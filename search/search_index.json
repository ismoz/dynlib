{"config":{"lang":["en","tr"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Dynlib","text":"<p>Dynlib is a simulation library developed for defining, simulating, and analyzing dynamical systems. Models are defined using a TOML-based DSL (Domain-Specific Language), so the same model definition can be used for both simulation and analysis. Dynlib currently supports discrete-time maps and ordinary differential equations (ODEs), and it comes with a growing set of analysis tools.</p> <p>Dynlib\u2019s goal is to make working with dynamical systems practical and repeatable. Implementation details do matter; however, once you learn how to wire together solvers, state arrays, parameter sweeps, plotting, and data management, rebuilding that scaffolding for every new model becomes a bottleneck. Dynlib abstracts the repetitive mechanical work so you can focus on the model, parameter regimes, and interpretation\u2014without losing control over numerical methods and configuration.</p> <p>Compared to simulations built with only \u201cNumPy + Matplotlib\u201d, dynlib makes the simulation and analysis workflow much more convenient. With dynlib, you can switch numerical solution methods without rewriting model code, and you can run simulations and analyses with very short scripts. This is especially useful in teaching dynamical systems courses. While students struggle with many implementation details\u2014writing loops, using NumPy and Matplotlib, implementing numerical integration methods\u2014trying to teach dynamical systems often drifts away from the real goal and turns the course into a Python class. With dynlib, you can quickly build a model and focus on simulation and analysis without wrestling with implementation details. With simplified plotting utilities, you can easily produce figures.</p> <p>In addition to simulation, dynlib includes built-in analysis tools such as bifurcation diagrams, basins of attraction, Lyapunov exponent estimation, manifold tracing, and fixed-point detection. It also provides JIT compilation (Just-In-Time Compilation) and disk caching for performance. It supports multiple families of numerical solvers (Euler, RK4, RK45, TR-BDF2A, etc.). With its model library, you can create new models and access them easily. You can stop and restart simulations (resume) and take a snapshot of the simulation state at any time. Dynlib also provides a simple CLI (command-line interface) so you can perform dynlib-related tasks from the terminal.</p> <p>Warning: Dynlib is currently under active development. APIs may change, and there may be bugs or numerical edge cases that affect results. If you use dynlib for research or critical decisions, validate results against reliable references (e.g., alternative solvers, smaller step sizes, analytical checks), and please report any issues you encounter.</p>"},{"location":"#terminology","title":"Terminology","text":"<p>To understand how dynlib works, you should be familiar with the following terms. Some of these are dynlib-specific.</p> <ul> <li>Map: Discrete-time dynamical systems (such as the logistic map).</li> <li>ODE: Ordinary Differential Equation system.</li> <li>DSL: Domain-Specific Language. A simple, readable language in TOML format for defining models.</li> <li>JIT: Abbreviation of just-in-time compilation. With the help of Numba, compiling Python code enables higher-performance simulation/analysis.</li> <li>Stepper: The program responsible for computing the next simulation step. ODE steppers implement numerical integration methods (such as Euler, RK4, RK45).</li> <li>Runner: If simulations are considered \u201cruns\u201d, a runner can be described as the program that executes a simulation run. Dynlib includes multiple specialized runner implementations. Since a runner + stepper combination can be JIT-compiled, you can think of it like a kernel.</li> <li>Wrapper: Since operations possible in JIT-compiled runners are limited, each runner is used under the control of a wrapper. If the runner is insufficient, the pure-Python wrapper takes over.</li> <li>API: Application Programming Interface. Defines how you should call a program/library.</li> <li>CLI: Command-Line Interface.</li> <li>URI: Represents the address of model TOML files (Uniform Resource Identifier).</li> <li>RHS: The right-hand side of an equation (Right-Hand Side).</li> <li>Snapshot: Saving the full state at a particular moment in a simulation, including state variables, parameter values, and simulation settings.</li> </ul>"},{"location":"#highlights","title":"Highlights","text":"<ul> <li> <p>Define the model once (TOML DSL): Write ODEs or discrete maps in a single TOML definition and use the same model across all simulations and analyses. Modeling</p> </li> <li> <p>Run simulations easily: Build simulations in a practical way without getting lost in details. Switch numerical methods easily by choosing a stepper. Use JIT acceleration if you want, and enable disk caching for fast builds. Save snapshots and resume simulations from where you left off. Simulation / Runtime</p> </li> <li> <p>Do the core analyses: Use built-in tools for bifurcation diagrams, basin mapping, Lyapunov exponent computation, fixed-point finding, manifold tracing, and parameter sweeps. Also plot results easily with Matplotlib-based helpers. Analysis / Plotting</p> </li> <li> <p>CLI: Use quick validation and inspection commands from the command line for common tasks. CLI</p> </li> </ul>"},{"location":"#start-here","title":"Start Here","text":"<ol> <li>Read Getting started overview to understand the project goals, recommended prerequisites, and how the documentation is organized.</li> <li>Follow Quickstart to install dynlib, validate it with the CLI, and run a built-in model from Python.</li> <li>See Your First Model to create and validate a model using the DSL.</li> </ol>"},{"location":"#go-deeper","title":"Go Deeper","text":"<p>You can get a more detailed view of how to use dynlib by browsing the other guides in the documentation:</p> <ul> <li>Home</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<ul> <li>Overview</li> <li>Quickstart</li> <li>Your First Model</li> </ul>"},{"location":"#guides","title":"Guides","text":""},{"location":"#cli","title":"CLI","text":"<ul> <li>CLI</li> </ul>"},{"location":"#modeling","title":"Modeling","text":"<ul> <li>Modeling guide</li> <li>DSL basics</li> <li>Equations</li> <li>Math and macros</li> <li>Ternary if</li> <li>Model registry</li> <li>Auxiliary variables</li> <li>DSL functions</li> <li>Events</li> <li>Lagging</li> <li>Inline models</li> <li>Configuration file</li> <li>Modes</li> <li>Presets</li> <li>Simulation defaults</li> </ul>"},{"location":"#simulation","title":"Simulation","text":"<ul> <li>Simulation guide</li> <li>Basics</li> <li>Configuration</li> <li>Just-In-Time compilation</li> <li>Presets</li> <li>Runner variants</li> <li>Session introspection</li> <li>Results</li> <li>Steppers</li> <li>Snapshots and resume</li> <li>Wrapper and runner</li> <li>Export sources</li> </ul>"},{"location":"#plotting","title":"Plotting","text":"<ul> <li>Plotting guide</li> <li>Plotting basics</li> <li>Decorations</li> <li>Export plots</li> <li>Cobweb plots</li> <li>Basin plots</li> <li>Vector fields</li> <li>Manifold plots</li> <li>Themes and facets</li> <li>Bifurcation diagrams</li> </ul>"},{"location":"#analysis","title":"Analysis","text":"<ul> <li>Analysis guide</li> <li>Runtime observers</li> <li>Lyapunov analysis</li> <li>Sweep tools</li> <li>Post analysis</li> <li>Fixed points</li> <li>Basin analysis</li> <li>Bifurcation diagrams</li> <li>Manifold analysis</li> </ul>"},{"location":"#examples","title":"Examples","text":"<ul> <li>Overview</li> <li>Analysis catalog</li> <li>Plotting catalog</li> <li>Runtime catalog</li> <li>State management</li> <li>Logistic map bifurcation</li> <li>Collatz conjecture</li> <li>Izhikevich neuron</li> </ul>"},{"location":"#reference","title":"Reference","text":"<ul> <li>Overview</li> <li>Built-in models</li> </ul>"},{"location":"#project","title":"Project","text":"<ul> <li>Changelog</li> <li>Issues</li> <li>TODO</li> </ul>"},{"location":"examples/","title":"Examples Overview","text":"<p>Use these curated pages to find the most relevant runnable scripts. Each page describes what the example does, highlights the dynlib features it exercises, and links to the actual script in <code>examples/</code>.</p>"},{"location":"examples/#catalog","title":"Catalog","text":"<ul> <li><code>analysis.md</code> \u2013 basin calculations, Lyapunov/spectrum analysis, manifold tracing, homoclinic/heteroclinic finders, and sweep helpers from <code>examples/analysis/</code>.</li> <li><code>plotting.md</code> \u2013 time-series/phase demos, plotting primitives, vector-field helpers, sweep/animation helpers, and theme previews.</li> <li><code>runtime.md</code> \u2013 runtime diagnostics for accuracy, early exits, transition detection, and printing compiled equations.</li> <li><code>state-management.md</code> \u2013 snapshots, source export, preset workflows, and URI resolution scripts that show how dynlib manages state/paths.</li> <li><code>bifurcation.md</code> \u2013 logistic-map bifurcation diagrams plus comparison scripts.</li> <li><code>integer-map.md</code> \u2013 Collatz iteration example with map steppers and integer arithmetic assertions.</li> <li><code>izhikevich.md</code> \u2013 Izhikevich neuron walkthrough and benchmark script links.</li> </ul>"},{"location":"examples/analysis/","title":"Analysis examples","text":""},{"location":"examples/analysis/#overview","title":"Overview","text":"<p>The <code>examples/analysis/</code> folder showcases how to apply dynlib's diagnostic and geometric toolkits. You will find scripts that (1) map basins of attraction with persistence or targeted classifiers, (2) compute Lyapunov exponents and spectra, (3) trace stable/unstable manifolds and homoclinic/heteroclinic orbits, and (4) sweep parameters while atomically analyzing every recorded trajectory.</p>"},{"location":"examples/analysis/#basin-mapping-and-classification","title":"Basin mapping and classification","text":""},{"location":"examples/analysis/#henon-map-basin-discovery","title":"Henon map basin discovery","text":"<p><pre><code>\"\"\"\nAuto basin of attraction calculation for the Henon Map.\n\nDemonstrates the basin_auto function (Persistent Cell-Recurrence Basin Mapping algorithm)\nto identify basins of attraction for the 2D Henon map.\n\nbasin_auto tries to automatically discover attractors and their basins. Its success highly\ndepends on the choice of parameters and the nature of the dynamical system. \n\"\"\"\n\nfrom __future__ import annotations\nimport numpy as np\nfrom dynlib import setup\nfrom dynlib.analysis import basin_auto, print_basin_summary\nfrom dynlib.plot import export, theme, fig, basin_plot\nfrom dynlib.utils import Timer\n\n# Setup Henon map model\nprint(\"Setting up Henon map model...\")\nsim = setup(\"builtin://map/henon\", stepper=\"map\", jit=True)\n\n# Set standard Henon parameters\na_param = 1.4\nb_param = 0.3\nsim.assign(a=a_param, b=b_param)\n\nprint(f\"  Parameters: a={a_param}, b={b_param}\")\nprint(f\"  State variables: x, y\")\n\n# Domain for basin calculation\n# Focusing on a region near the Henon attractor\nx_min, x_max = -2.5, 2.5\ny_min, y_max = -2.5, 2.5\n\n# Grid resolution (increase for higher detail)\ngrid_nx = 512\ngrid_ny = 512\n\nprint(f\"  Grid size: {grid_nx} \u00d7 {grid_ny} = {grid_nx * grid_ny} points\")\nprint(f\"  Domain: x \u2208 [{x_min}, {x_max}], y \u2208 [{y_min}, {y_max}]\")\n\n# Compute basin of attraction\nprint(\"\\nComputing basin of attraction...\")\nprint(\"  Algorithm: PCR-BM (Persistent Cell-Recurrence Basin Mapping)\")\nprint(f\"  Grid size: {grid_nx} \u00d7 {grid_ny} = {grid_nx * grid_ny} points\")\nprint(f\"  Domain: x \u2208 [{x_min}, {x_max}], y \u2208 [{y_min}, {y_max}]\")\n\nwith Timer(\"Basin computation time\"):\n    result = basin_auto(\n        sim,\n        ic_grid=[grid_nx, grid_ny],\n        ic_bounds=[(x_min, x_max), (y_min, y_max)],\n        observe_vars=[\"x\", \"y\"],  # Use both state variables\n        grid_res=[128, 128],  # Cell resolution for recurrence detection\n        merge_downsample=4,\n        post_detect_samples=512,\n        max_samples=2000,  # Number of iterations per initial condition\n        transient_samples=500,  # Skip initial transient\n        window=128,  # Recurrence detection window size\n        u_th=0.95,  # Uniqueness threshold\n        recur_windows=3,  # Required recurrence windows\n        s_merge=0.3,  # Similarity threshold for merging attractors\n        p_in=30,  # Persistence threshold\n        b_max=100.0,  # Blowup threshold (lower to catch diverging trajectories)\n        outside_limit=50,  # Maximum consecutive outside steps\n        parallel_mode=\"auto\",\n    )\n\nprint(\"Done!\")\n\n# Analyze results\nprint_basin_summary(result)\n\n# Visualization\nprint(\"\\nCreating visualization...\")\ntheme.use(\"notebook\")\ntheme.update(grid=False)\n\n# Create figure\nax = fig.single(size=(10, 8))\n\nbasin_plot(\n    result,\n    ax=ax,\n    xlabel=\"x\",\n    ylabel=\"y\",\n    ylabel_rot=0,\n    ypad=15,\n    title=f\"Basin of Attraction - Henon Map (a={a_param}, b={b_param})\",\n    titlepad=15,\n)\n\nexport.show()\nprint(\"\\nVisualization complete!\")\n</code></pre> Runs <code>basin_auto</code> on the built-in Henon map with a 512\u00d7512 grid, PCR-BM detection across both <code>x</code>/<code>y</code>, and timer instrumentation. The script prints attractor metadata, summarizes the result, and then hands the <code>BasinResult</code> to <code>basin_plot</code> so you can see how the automatic fingerprinting divides the plane.</p>"},{"location":"examples/analysis/#basin-of-known-attractors","title":"Basin of known attractors","text":"<p><pre><code>\"\"\"\nBasin of Attraction for Henon Map using Known Attractors.\n\nDemonstrates the simplified basin_known function to identify basins for the\n2D Henon map. basin_known requires reference(s) of the attractor(s) to be \nprovided beforehand.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport numpy as np\n\nfrom dynlib import setup\nfrom dynlib.analysis import basin_known, print_basin_summary, ReferenceRun\nfrom dynlib.plot import export, theme, fig, basin_plot\nfrom dynlib.utils import Timer\n\n# Setup Henon map model\nprint(\"Setting up Henon map model...\")\nsim = setup(\"builtin://map/henon\", stepper=\"map\", jit=True)\n\n# Set standard Henon parameters\na_param = 1.4\nb_param = 0.3\nsim.assign(a=a_param, b=b_param)\n\nprint(f\"  Parameters: a={a_param}, b={b_param}\")\nprint(f\"  State variables: x, y\")\n\n# Define grid of initial conditions\nprint(\"\\nGenerating initial condition grid...\")\n\n# Domain for basin calculation (region near Henon attractor)\nx_min, x_max = -2.5, 2.5\ny_min, y_max = -2.5, 2.5\n\n# Grid resolution\ngrid_nx = 512\ngrid_ny = 512\n\nprint(f\"  Grid size: {grid_nx} \u00d7 {grid_ny} = {grid_nx * grid_ny} points\")\nprint(f\"  Domain: x \u2208 [{x_min}, {x_max}], y \u2208 [{y_min}, {y_max}]\")\n\n# Compute basin of known attractors\nprint(\"\\nComputing basin of known attractors...\")\n\nwith Timer(\"basin_known computation\"):\n    result = basin_known(\n        sim,\n        attractors=[\n            ReferenceRun(name=\"Henon attractor\", ic=[0.1, 0.1]),\n        ],\n        ic_grid=[grid_nx, grid_ny],\n        ic_bounds=[(x_min, x_max), (y_min, y_max)],\n        max_samples=500,\n        transient_samples=200,\n        signature_samples=500,\n        tolerance=0.05,      # 5% of attractor range\n        min_match_ratio=0.8,  # 80% of points must match\n        escape_bounds=[(-5.0, 5.0), (-5.0, 5.0)],  # Wide bounds for escape detection\n        b_max=1e6, # Blowup threshold / None means literal NaN/Inf\n        parallel_mode=\"auto\",\n        refine=True, # refine is faster for high resolution grids\n    )\n\nprint(\"Done!\")\n\n# Analyze results\nprint_basin_summary(result)\n\n# Visualization\nprint(\"\\nCreating visualization...\")\ntheme.use(\"notebook\")\ntheme.update(grid=False)\n\nax = fig.single(size=(10, 8))\n\nbasin_plot(\n    result,\n    ax=ax,\n    xlabel=\"x\",\n    ylabel=\"y\",\n    ylabel_rot=0,\n    ypad=15,\n    title=f\"Basin of Attraction - Henon Map (a={a_param}, b={b_param})\",\n    titlepad=15,\n)\n\nexport.show()\n\nprint(\"\\nVisualization complete!\")\n</code></pre> Demonstrates <code>basin_known</code> + <code>ReferenceRun</code> to classify the Henon attractor during refinement. It feeds pre-computed attractor fingerprints into the known-attractor library, runs on a 512\u00d7512 grid, and shows how <code>signature_samples</code>, <code>tolerance</code>, and <code>min_match_ratio</code> influence the assignment.</p>"},{"location":"examples/analysis/#limit-cycle-basins","title":"Limit-cycle basins","text":"<pre><code>from dynlib import setup\nfrom dynlib.analysis import basin_auto\nfrom dynlib.plot import export, basin_plot, fig, phase\n\n# Energy Template Oscillator (ETO) with Circular L Curve\nsim = setup(\"builtin://ode/eto-circular\", jit=True, disk_cache=True, stepper=\"rk4\")\n# Globally stable limit cycle parameters\nsim.assign(mu=0.8, a=2.0)\n\nresults = basin_auto(\n    sim,\n    ic_grid=[128, 128],\n    ic_bounds=[(-3, 3), (-3, 3)],\n    dt_obs=0.01,\n    # run long enough to converge + see the cycle\n    max_samples=4000,          # 40 time units\n    transient_samples=2000,    # 20 time units of transient\n    # recurrence / evidence\n    window=512,                # ~5.12 time units &gt; 1 period\n    recur_windows=3,\n    u_th=0.8,                  # less strict; avoids missing clean periodic motion\n    post_detect_samples=1024,  # add extra evidence (aim: &gt;= 1\u20132 periods total)\n    # merging\n    merge_downsample=2,        # coarser fingerprint grid =&gt; more overlap\n    s_merge=0.4,               # easier merge for same attractor under phase shifts\n    # optional: make persistence assignment more stable\n    p_in=12,\n    online_max_cells=8192,     # avoid truncating the stored cell set for a large cycle\n)\n\n# Create an attractor\nsim.run(T=300, transient=100)\nattr = sim.results()\n\n# Plotting\nax = fig.single()\nphase.xy(x=attr[\"x\"], y=attr[\"y\"], ax=ax)\nbasin_plot(results, ax=ax)\n\nprint(\"Globally stable limit cycle.\")\nprint(\"Edges can go outside for high mu values but they should converge back.\")\n\nexport.show()\n</code></pre> <p><pre><code>from dynlib import setup\nfrom dynlib.analysis import basin_known, ReferenceRun\nfrom dynlib.plot import export, basin_plot, fig, phase\n\n# Energy Template Oscillator (ETO) with Circular L Curve\nsim = setup(\"builtin://ode/eto-circular\", jit=True, disk_cache=True, stepper=\"rk4\")\n# Globally stable limit cycle parameters\nsim.assign(mu=0.8, a=2.0)\n\nresults = basin_known(\n    sim,\n    attractors=[\n        ReferenceRun(name=\"Limit Cycle Attractor\", ic=[1.0, 0.0]),\n    ],\n    ic_grid=[128, 128],\n    ic_bounds=[(-3, 3), (-3, 3)],\n    dt_obs=0.01,\n    # run long enough to converge + see the cycle\n    signature_samples=8000, # samples are in steps not time\n    max_samples=4000,\n    transient_samples=2000, \n    tolerance=0.05,      # 5% of attractor range\n    min_match_ratio=0.8,  # 80% of points must match\n    escape_bounds=[(-5.0, 5.0), (-5.0, 5.0)],  # Wide bounds for escape detection\n    b_max=1e6, # Blowup threshold / None means literal NaN/Inf\n)\n\n# Create an attractor\nsim.run(T=300, transient=100)\nattr = sim.results()\n\n# Plotting\nax = fig.single()\nphase.xy(x=attr[\"x\"], y=attr[\"y\"], ax=ax)\nbasin_plot(results, ax=ax)\n\nexport.show()\n</code></pre> The first script uses <code>basin_auto</code> on the Energy Template Oscillator to capture a globally stable limit cycle via recurrence detection and post-detection persistence. The second repeats the experiment with <code>basin_known</code>/<code>ReferenceRun</code>, showcasing how to compare phase-space points with a reference trajectory while still refining the grid.</p>"},{"location":"examples/analysis/#refinement-benchmark","title":"Refinement benchmark","text":"<p><pre><code>\"\"\"\nBenchmark for basin_known with refine=False and refine=True.\n\nTests performance on different grid sizes: 64x64, 128x128, 256x256, 512x512.\nUses the same parameters and model as basin_henon_known.py.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport time\nimport numpy as np\n\nfrom dynlib import setup\nfrom dynlib.analysis import basin_known, ReferenceRun\n\n# Setup Henon map model\nprint(\"Setting up Henon map model...\")\nsim = setup(\"builtin://map/henon\", stepper=\"map\", jit=True)\n\n# Set standard Henon parameters\na_param = 1.4\nb_param = 0.3\nsim.assign(a=a_param, b=b_param)\n\nprint(f\"  Parameters: a={a_param}, b={b_param}\")\nprint(f\"  State variables: x, y\")\n\n# Domain for basin calculation (region near Henon attractor)\nx_min, x_max = -2.5, 2.5\ny_min, y_max = -2.5, 2.5\n\n# Common parameters for basin_known\nattractors = [\n    ReferenceRun(name=\"Henon attractor\", ic=[0.1, 0.1]),\n]\nic_bounds = [(x_min, x_max), (y_min, y_max)]\nmax_samples = 500\ntransient_samples = 200\nsignature_samples = 500\ntolerance = 0.05      # 5% of attractor range\nmin_match_ratio = 0.8  # 80% of points must match\nescape_bounds = [(-5.0, 5.0), (-5.0, 5.0)]  # Wide bounds for escape detection\nb_max = 1e6  # Blowup threshold / None means literal NaN/Inf\nparallel_mode = \"auto\"\n\n# Grid sizes to test\ngrid_sizes = [64, 128, 256, 512, 1024]\n\nprint(\"\\nBenchmarking basin_known with different grid sizes and refine options...\")\ngrid_width = 12\ntime_width = 12\nmatch_width = 10\nprint(f\"{'Grid Size':&lt;{grid_width}} | {'refine = False':&gt;{time_width}} | {'refine = True':&gt;{time_width}} | {'Match %':&gt;{match_width}}\")\nprint(\"-\" * (grid_width + time_width * 2 + match_width + 9))\n\n# Warm-up\nbasin_known(\n    sim,\n    attractors=attractors,\n    ic_grid=[grid_sizes[0], grid_sizes[0]],\n    ic_bounds=ic_bounds,\n    max_samples=max_samples,\n    transient_samples=transient_samples,\n    signature_samples=signature_samples,\n    tolerance=tolerance,\n    min_match_ratio=min_match_ratio,\n    escape_bounds=escape_bounds,\n    b_max=b_max,\n    parallel_mode=parallel_mode,\n    refine=False,\n)\n\nfor size in grid_sizes:\n    ic_grid = [size, size]\n\n    # Measure refine=False\n    start_time = time.perf_counter()\n    result_false = basin_known(\n        sim,\n        attractors=attractors,\n        ic_grid=ic_grid,\n        ic_bounds=ic_bounds,\n        max_samples=max_samples,\n        transient_samples=transient_samples,\n        signature_samples=signature_samples,\n        tolerance=tolerance,\n        min_match_ratio=min_match_ratio,\n        escape_bounds=escape_bounds,\n        b_max=b_max,\n        parallel_mode=parallel_mode,\n        refine=False,\n    )\n    false_time = time.perf_counter() - start_time\n\n    # Measure refine=True\n    start_time = time.perf_counter()\n    result_true = basin_known(\n        sim,\n        attractors=attractors,\n        ic_grid=ic_grid,\n        ic_bounds=ic_bounds,\n        max_samples=max_samples,\n        transient_samples=transient_samples,\n        signature_samples=signature_samples,\n        tolerance=tolerance,\n        min_match_ratio=min_match_ratio,\n        escape_bounds=escape_bounds,\n        b_max=b_max,\n        parallel_mode=parallel_mode,\n        refine=True,\n    )\n    true_time = time.perf_counter() - start_time\n\n    # Compute match percentage\n    match_percentage = np.sum(result_false.labels == result_true.labels) / result_false.labels.size * 100\n\n    print(f\"{f'{size}x{size}':&lt;{grid_width}} | {false_time:&gt;{time_width}.2f} | {true_time:&gt;{time_width}.2f} | {match_percentage:&gt;{match_width}.1f}\")\n\nprint(\"\\nBenchmark complete!\")\n</code></pre> Bi-directional benchmark toggles <code>refine</code> on <code>basin_known</code> across grid sizes from 64\u00d764 up to 1024\u00d71024, printing wall-clock time and label agreement so you can see the performance payoff before enabling coarse-to-fine passes.</p>"},{"location":"examples/analysis/#lyapunov-exponents-and-spectral-sweeps","title":"Lyapunov exponents and spectral sweeps","text":""},{"location":"examples/analysis/#logistic-map-lyapunov-demo","title":"Logistic-map Lyapunov demo","text":"<p><pre><code>\"\"\"\nLyapunov exponent calculation for the logistic map.\n\nDemonstrates the runtime analysis system for computing maximum Lyapunov exponents (MLE)\nand Lyapunov spectrum in discrete dynamical systems using the high-level Sim.run() API.\n\nThe Lyapunov exponent \u03bb characterizes divergence of nearby trajectories:\n    - \u03bb &gt; 0: Chaotic behavior \n    - \u03bb = 0: Periodic orbits\n    - \u03bb &lt; 0: Stable fixed points\n\nFor the logistic map at r=4: \u03bb = ln(2) \u2248 0.6931\n\"\"\"\n\nfrom __future__ import annotations\nimport numpy as np\nfrom dynlib import setup\nfrom dynlib.runtime.observers import lyapunov_mle_observer, lyapunov_spectrum_observer\nfrom dynlib.plot import series, export, theme, fig\n\n\n# Single run with multiple observers\nsim = setup(\"builtin://map/logistic\", jit=True, disk_cache=True)\nmodel = sim.model\n\nrecord_every = 1\n\n# Run simulation using the high-level Sim API with multiple observers\nprint(\"\\nComputing Lyapunov exponents with Sim.run()...\")\nprint(f\"  Parameter: r = 4.0\")\nprint(f\"  Iterations: 5000\")\nprint(f\"  Initial condition: x = 0.4\")\nprint(f\"  Observers: MLE and Spectrum\")\n\nsim.assign(x=0.4, r=4.0)\nsim.run(\n    N=5000,\n    dt=1.0,\n    record_interval=record_every,\n    observers=[\n        lyapunov_mle_observer(model=sim.model, record_interval=record_every),\n        lyapunov_spectrum_observer(model=sim.model, k=1, record_interval=record_every),\n    ],\n)\nresult = sim.results()\n\n# Extract runtime observer results\nprint(\"\\n\" + \"=\"*60)\nprint(\"RESULTS\")\nprint(\"=\"*60)\n\n# Get observer result with ergonomic named access\nlyap = result.observers[\"lyapunov_mle\"]\nspectrum = result.observers[\"lyapunov_spectrum\"]\n\n# Direct access to final MLE (auto-computed from trace)\nmle = lyap.mle  # Final converged value from trace\nlog_growth = lyap.log_growth\nn_steps = int(lyap.steps)\n\n# Get spectrum results (lyapunov_spectrum stores the final value in the trace)\nspectrum_steps = int(spectrum.steps)\n\ntheoretical_mle = np.log(2.0)\nx_trajectory = result[\"x\"]\nlyap_trace = lyap[\"mle\"]  # Full trace array (use bracket for arrays)\nspectrum_trace = spectrum[\"lyap0\"]  # Spectrum trace for first exponent\n\n# Note: trace may have one less point than trajectory if recording starts at t0\nn_points = min(len(x_trajectory), len(lyap_trace), len(spectrum_trace))\niterations = np.arange(n_points)\n\n# Get final spectrum value from trace (after data is loaded)\n# spectrum trace has alternating zeros, so find the last non-zero value\nnonzero_indices = np.nonzero(spectrum_trace)[0]\nspectrum_mle = spectrum_trace[nonzero_indices[-1]] if len(nonzero_indices) &gt; 0 else 0\n\nprint(\"\\nMaximum Lyapunov Exponent (MLE):\")\nprint(f\"  Computed MLE:      {mle:.10f}\")\nprint(f\"  Theoretical MLE:   {theoretical_mle:.10f} (ln(2))\")\nprint(f\"  Relative error:    {abs(mle - theoretical_mle)/theoretical_mle * 100:.4f}%\")\nprint(f\"  Total iterations:  {n_steps}\")\n\nprint(\"\\nLyapunov Spectrum:\")\nprint(f\"  Spectrum \u03bb\u2080:       {spectrum_mle:.10f}\")\nprint(f\"  Theoretical \u03bb\u2080:    {theoretical_mle:.10f} (ln(2))\")\nprint(f\"  Relative error:    {abs(spectrum_mle - theoretical_mle)/theoretical_mle * 100:.4f}%\")\nprint(f\"  Total iterations:  {spectrum_steps}\")\n\n# Visualize\ntheme.use(\"notebook\")\ntheme.update(grid=True)\n\nfig_obj = fig.grid(rows=3, cols=1, size=(10, 12))\n\n# Plot trajectory (first 500 iterations)\nseries.plot(\n    x=iterations[:500],\n    y=x_trajectory[:500],\n    style=\"line\",\n    ax=fig_obj[0, 0],\n    xlabel=\"Iteration (n)\",\n    ylabel=\"$x_n$\",\n    title=f\"Logistic Map Trajectory (r=4.0)\",\n    lw=1.0,\n    color=\"C0\",\n)\n\n# Plot Lyapunov exponent convergence\nseries.plot(\n    x=iterations,\n    y=lyap_trace[:n_points],\n    style=\"line\",\n    ax=fig_obj[1, 0],\n    xlabel=\"Iteration (n)\",\n    ylabel=\"$\\\\lambda$ (MLE)\",\n    title=\"Lyapunov Exponent Convergence\",\n    lw=1.5,\n    color=\"C1\",\n    hlines=[(theoretical_mle, f'Theoretical: \u03bb = ln(2) \u2248 {theoretical_mle:.4f}')],\n    hlines_kwargs={\"color\": \"gray\", \"linestyle\": \"--\", \"linewidth\": 2, \"label_pad\": 0.10},\n)\n\n# Annotate final value\nfig_obj[1, 0].text(\n    0.98, 0.05,\n    f'Computed: \u03bb = {mle:.6f}',\n    transform=fig_obj[1, 0].transAxes,\n    fontsize=11,\n    verticalalignment='bottom',\n    horizontalalignment='right',\n    bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.5)\n)\n\n# Plot Lyapunov spectrum convergence\nseries.plot(\n    x=iterations,\n    y=spectrum_trace[:n_points],\n    style=\"line\",\n    ax=fig_obj[2, 0],\n    xlabel=\"Iteration (n)\",\n    ylabel=\"$\\\\lambda$ (Spectrum)\",\n    title=\"Lyapunov Spectrum Convergence\",\n    lw=1.5,\n    color=\"C2\",\n    hlines=[(theoretical_mle, f'Theoretical: \u03bb = ln(2) \u2248 {theoretical_mle:.4f}')],\n    hlines_kwargs={\"color\": \"red\", \"linestyle\": \"--\", \"linewidth\": 2},\n)\n\n# Annotate final value from spectrum\nspectrum_final = spectrum_trace[n_points-1] if n_points &gt; 0 else 0\nfig_obj[2, 0].text(\n    0.98, 0.05,\n    f'Computed: \u03bb = {spectrum_final:.6f}',\n    transform=fig_obj[2, 0].transAxes,\n    fontsize=11,\n    verticalalignment='bottom',\n    horizontalalignment='right',\n    bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.5)\n)\n\nexport.show()\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Parameter Scan\")\nprint(\"=\"*60)\nprint(f\"{'r':&gt;6s} {'\u03bb (MLE)':&gt;12s} {'Regime':&gt;15s}\")\nprint(\"-\"*60)\n\ntest_r_values = [2.5, 3.2, 3.5, 3.83, 4.0]\nscan_sim = setup(\"builtin://map/logistic\", stepper=\"map\", jit=False)\n\nfor r_test in test_r_values:\n    params_test = np.array([r_test], dtype=model.dtype)\n    scan_sim.run(\n        N=2000,\n        dt=1.0,\n        record=False,\n        record_interval=1,\n        max_steps=2000,\n        cap_rec=1,\n        cap_evt=1,\n        ic=np.array([0.4], dtype=model.dtype),\n        params=params_test,\n        observers=lyapunov_mle_observer,  # Factory mode: Sim injects model\n    )\n\n    lyap_result = scan_sim.results().observers[\"lyapunov_mle\"]\n    mle_test = lyap_result.mle  # Direct final value access\n\n    if mle_test &lt; -0.01:\n        regime = \"Stable\"\n    elif abs(mle_test) &lt; 0.01:\n        regime = \"Periodic\"\n    else:\n        regime = \"Chaotic\"\n\n    print(f\"{r_test:6.2f} {mle_test:12.6f} {regime:&gt;15s}\")\n    scan_sim.reset()\n\nprint(\"=\"*60)\nprint(\"\\nThe logistic map exhibits the period-doubling route to chaos.\")\nprint(\"Chaos emerges around r \u2248 3.57, fully developed at r = 4.\")\n</code></pre> Runs the logistic map at <code>r=4</code>, attaches both the MLE and spectrum runtime observers, and plots the trajectory, Lyapunov convergence, and final spectrum trace while printing the error against <code>ln(2)</code>. The script also prints a quick scan over several <code>r</code> values to classify stability vs. chaos.</p>"},{"location":"examples/analysis/#lorenz-system-lyapunov-demo","title":"Lorenz-system Lyapunov demo","text":"<p><pre><code>\"\"\"\nLyapunov exponent calculation for the Lorenz system.\n\nDemonstrates the runtime analysis system for computing maximum Lyapunov exponents (MLE)\nand Lyapunov spectrum in continuous dynamical systems using the high-level Sim.run() API.\n\"\"\"\n\nfrom __future__ import annotations\nfrom dynlib import setup\nfrom dynlib.runtime.observers import lyapunov_mle_observer, lyapunov_spectrum_observer\nfrom dynlib.plot import fig, export, phase, series\n\n# 1. Setup simulation\n# -------------------\nsim = setup(\"builtin://ode/lorenz\", stepper=\"rk4\", jit=True)\n\n# Parameters for standard chaotic regime\nsigma, rho, beta = 10.0, 28.0, 8.0/3.0\ninitial_state = {\"x\": 1.0, \"y\": 1.0, \"z\": 1.0}\n\n# Simulation control\ndt = 0.001\ntotal_time = 400\ntransient = 20\nrecord_interval = 4\n\nprint(f\"Running Lorenz simulation (T={total_time}, dt={dt})...\")\n\n# 2. Run MLE Analysis\n# -------------------\nprint(\"Computing Maximum Lyapunov Exponent (MLE)...\")\nsim.assign(**initial_state, sigma=sigma, rho=rho, beta=beta)\nsim.run(\n    transient=transient,\n    T=total_time,\n    dt=dt,\n    record_interval=record_interval,\n    observers=lyapunov_mle_observer(record_interval=record_interval)\n)\nres_mle = sim.results()\nmle_analysis = res_mle.observers[\"lyapunov_mle\"]\n\n# 3. Run Spectrum Analysis\n# ------------------------\nprint(\"Computing Lyapunov Spectrum (3 exponents)...\")\nsim.reset()\nsim.assign(**initial_state, sigma=sigma, rho=rho, beta=beta)\nsim.run(\n    transient=transient,\n    T=total_time,\n    dt=dt,\n    record_interval=record_interval,\n    observers=lyapunov_spectrum_observer(k=3, record_interval=record_interval)\n)\nres_spec = sim.results()\nspec_analysis = res_spec.observers[\"lyapunov_spectrum\"]\n\n# 4. Results &amp; Validation\n# -----------------------\nprint(\"\\n\" + \"=\"*60)\nprint(\"RESULTS &amp; VALIDATION\")\nprint(\"=\"*60)\n\n# Theoretical values for Lorenz (standard parameters)\nref_lambda1 = 0.9056\nref_lambda2 = 0.0000\nref_lambda3 = -14.5723\n\n# MLE Results\nmle_calc = mle_analysis.mle\nmle_err = abs(mle_calc - ref_lambda1) / abs(ref_lambda1) * 100\nprint(f\"\\nMaximum Lyapunov Exponent (MLE):\")\nprint(f\"  Calculated:  {mle_calc:.4f}\")\nprint(f\"  Theoretical: {ref_lambda1:.4f}\")\nprint(f\"  Error:       {mle_err:.2f}%\")\n\n# Spectrum Results\n# Get final values from traces (using attribute access for final value)\nl1_calc = spec_analysis.lyap0\nl2_calc = spec_analysis.lyap1\nl3_calc = spec_analysis.lyap2\n\n# Calculate errors (handle division by zero for lambda2)\nl1_err = abs(l1_calc - ref_lambda1) / abs(ref_lambda1) * 100\nl3_err = abs(l3_calc - ref_lambda3) / abs(ref_lambda3) * 100\n\nprint(f\"\\nLyapunov Spectrum:\")\nprint(f\"  \u03bb\u2081: {l1_calc:.4f} (Ref: {ref_lambda1:.4f}, Err: {l1_err:.2f}%)\")\nprint(f\"  \u03bb\u2082: {l2_calc:.4f} (Ref: {ref_lambda2:.4f}, Err: N/A)\")\nprint(f\"  \u03bb\u2083: {l3_calc:.4f} (Ref: {ref_lambda3:.4f}, Err: {l3_err:.2f}%)\")\nprint(f\"  Sum: {l1_calc + l2_calc + l3_calc:.4f} (Ref: {ref_lambda1 + ref_lambda2 + ref_lambda3:.4f})\")\n\n# 5. Visualization\n# ----------------\nprint(\"\\nPlotting results...\")\n\n# Create a 3-row, 1-column grid\ngrid = fig.grid(rows=3, cols=1, size=(8, 12), title=\"Lorenz System Lyapunov Analysis\")\nax_phase, ax_mle, ax_spec = grid[0][0], grid[1][0], grid[2][0]\n\n# Plot 1: Phase Portrait (x vs z)\n# Use the trajectory from the spectrum run (it has the same parameters)\nx = res_spec[\"x\"]\nz = res_spec[\"z\"]\nphase.xy(\n    x=x,\n    y=z,\n    ax=ax_phase,\n    lw=0.5,\n    alpha=0.8,\n    title=\"Phase Portrait (Lorenz Attractor)\",\n    xlabel=\"x\",\n    ylabel=\"z\",\n)\n\n# Plot 2: MLE Convergence\n# Use explicit trace_time from analysis result\nt_mle = mle_analysis.trace_time\nmle_trace = mle_analysis[\"mle\"]\nseries.plot(\n    x=t_mle,\n    y=mle_trace,\n    ax=ax_mle,\n    label=f\"MLE (\u03bb\u2081) \u2248 {mle_analysis.mle:.3f}\",\n    title=\"Maximum Lyapunov Exponent Convergence\",\n    ylabel=\"MLE\",\n    legend=True,\n    hlines=[(ref_lambda1, f\"Theoretical \u03bb\u2081 \u2248 {ref_lambda1:.3f}\")],\n    hlines_kwargs={\"alpha\": 0.5},\n)\nax_mle.grid(True, alpha=0.3)\n\n# Plot 3: Lyapunov Spectrum Convergence\n# Use explicit trace_time from analysis result\nt_spec = spec_analysis.trace_time\n# Spectrum trace columns: lyap0, lyap1, lyap2\nl1 = spec_analysis[\"lyap0\"]\nl2 = spec_analysis[\"lyap1\"]\nl3 = spec_analysis[\"lyap2\"]\n\nseries.multi(\n    x=t_spec,\n    y=[l1, l2, l3],\n    names=[f\"\u03bb\u2081 \u2248 {l1[-1]:.3f}\", f\"\u03bb\u2082 \u2248 {l2[-1]:.3f}\", f\"\u03bb\u2083 \u2248 {l3[-1]:.3f}\"],\n    ax=ax_spec,\n    title=\"Lyapunov Spectrum Convergence\",\n    xlabel=\"Time\",\n    ylabel=\"Exponents\",\n    legend=True,\n    hlines=[ref_lambda1, ref_lambda2, ref_lambda3],\n    hlines_kwargs={\"alpha\": 0.3},\n)\n\nax_spec.grid(True, alpha=0.3)\n\n# Save figure\n# export.savefig(grid, \"lyapunov_lorenz_demo.png\")\nexport.show()\n</code></pre> Repeats the approach for the continuous Lorenz attractor. It computes an <code>rk4</code> run with <code>lyapunov_mle_observer</code> and another with <code>lyapunov_spectrum_observer</code>, prints the error to the reference <code>(0.9056, 0.0, -14.57)</code> spectrum, and draws the attractor plus convergence traces.</p>"},{"location":"examples/analysis/#parameter-sweeps-with-lyapunov-statistics","title":"Parameter sweeps with Lyapunov statistics","text":"<p><pre><code>\"\"\"\nLyapunov exponent parameter sweep for the logistic map.\n\nDemonstrates sweep.lyapunov_mle_sweep for computing maximum Lyapunov exponents (MLE)\nacross a range of parameter values. This reveals the transition from order to chaos\nas a continuous function of the control parameter.\n\nFor the logistic map x_{n+1} = r*x_n*(1-x_n):\n    - r &lt; 3.0: Stable fixed point (\u03bb &lt; 0)\n    - 3.0 &lt; r &lt; ~3.57: Periodic orbits (\u03bb = 0)\n    - r &gt; ~3.57: Chaotic regime (\u03bb &gt; 0)\n    - r = 4.0: Fully chaotic (\u03bb = ln(2) \u2248 0.6931)\n\"\"\"\n\nfrom __future__ import annotations\nimport numpy as np\nfrom dynlib import setup\nfrom dynlib.analysis import sweep\nfrom dynlib.plot import series, export, theme, fig, bifurcation_diagram\n\n\n# Setup simulation\nsim = setup(\"builtin://map/logistic\", jit=True, disk_cache=False)\n\n# Parameter sweep configuration (1000 points won't trigger parallelisation in auto mode)\nr_values = np.linspace(2.5, 4.0, 1000)  \nrecord_every = 1\n\nprint(f\"Computing bifurcation diagram and Lyapunov exponents for {len(r_values)} parameter values...\")\nprint(f\"  Parameter range: r \u2208 [{r_values[0]:.2f}, {r_values[-1]:.2f}]\")\nprint(f\"  Iterations per run: 3000\")\nprint(f\"  Transient: 500\")\nprint(f\"  Trace recording interval: {record_every}\")\n\n# First, compute bifurcation diagram\nprint(\"\\nComputing bifurcation diagram...\")\nsweep_bif = sweep.traj_sweep(\n    sim,\n    param=\"r\",\n    values=r_values,\n    record_vars=[\"x\"],\n    N=200,\n    transient=300,\n)\nresult_bif = sweep_bif.bifurcation(\"x\")\n\n# Then, run parameter sweep with MLE analysis\nprint(\"\\nComputing Lyapunov exponents...\")\nsim.assign(x=0.4)  # Initial condition\nres = sweep.lyapunov_mle_sweep(\n    sim,\n    param=\"r\",\n    values=r_values,\n    N=3000,\n    transient=500,\n    dt=1.0,\n    record_interval=record_every,\n    parallel_mode=\"auto\",  # Enable parallelization\n)\n\nprint(f\"\\nSweep completed!\")\nprint(f\"  Sweep kind: {res.kind}\")\nprint(f\"  MLE range: [{res.mle.min():.4f}, {res.mle.max():.4f}]\")\nprint(f\"  Chaos onset (\u03bb=0): r \u2248 {r_values[np.argmin(np.abs(res.mle))]:.4f}\")\nprint(f\"  MLE at r=4.0: {res.mle[-1]:.4f} (theoretical: {np.log(2):.4f})\")\n\n# Optional: inspect recorded trace per-parameter (list of arrays)\ntrace_runs = res.traces.get(\"mle\")\nif trace_runs:\n    print(f\"  Recorded {len(trace_runs)} convergence traces (first length={trace_runs[0].shape[0]})\")\n\n# ===== Visualization =====\ntheme.use(\"notebook\")\ntheme.update(grid=True, vline_label_placement_pad=0.16)\n\n# Create figure with 2 rows: bifurcation diagram (top) and MLE (bottom)\nax = fig.grid(rows=2, cols=1, size=(12, 10))\n\n# Top panel: Bifurcation diagram\nbifurcation_diagram(\n    result_bif,\n    alpha=0.8,\n    color=\"black\",\n    ax=ax[0, 0],\n    xlim=(2.5, 4.0),\n    ylim=(0, 1),\n    ylabel=\"x*\",\n    title=\"Bifurcation Diagram and Maximum Lyapunov Exponent\",\n    title_fs=14,\n    ylabel_fs=12,\n    vlines=[(3.0, 'r=3\\n(period-2)'), (3.57, 'r\u22483.57\\n(chaos)')],\n    vlines_kwargs={'color': 'darkred', \n                   'linestyle': '--', \n                   'alpha': 0.3, \n                   'linewidth': 1,\n                   'label_position': 'bottom',},\n)\n\n# Bottom panel: MLE vs parameter (sharing same x-axis)\nseries.plot(\n    x=res.values,\n    y=res.mle,\n    style=\"continuous\",\n    ax=ax[1, 0],\n    xlabel=\"r\",\n    ylabel=\"\u03bb (MLE)\",\n    lw=1.5,\n    color=\"darkred\",\n    xlabel_fs=12,\n    ylabel_fs=12,\n    vlines=[3.0, 3.57],\n    vlines_kwargs={'color': 'orange', 'linestyle': '--', 'alpha': 0.3, 'linewidth': 1},\n)\n\n# Add horizontal line at \u03bb=0 (chaos boundary)\nax[1, 0].axhline(0, color=\"gray\", ls=\"--\", lw=1, alpha=0.7)\nax[1, 0].text(2.6, 0.05, \"\u03bb = 0 (chaos boundary)\", fontsize=10, color=\"gray\")\n\n# Set x-limits to match\nax[1, 0].set_xlim(2.5, 4.0)\n\nexport.show()\n\n# ===== Analysis Summary =====\nprint(\"\\n\" + \"=\"*70)\nprint(\"ANALYSIS SUMMARY\")\nprint(\"=\"*70)\n\n# Find chaos onset (where \u03bb crosses zero from negative to positive)\nzero_crossings = np.where(np.diff(np.sign(res.mle)) &gt; 0)[0]\nif len(zero_crossings) &gt; 0:\n    chaos_onset_idx = zero_crossings[0]\n    print(f\"Chaos onset (first \u03bb=0 crossing): r \u2248 {res.values[chaos_onset_idx]:.4f}\")\n\n# Count negative, zero, and positive MLE regions\nn_negative = np.sum(res.mle &lt; -0.01)\nn_zero = np.sum(np.abs(res.mle) &lt;= 0.01)\nn_positive = np.sum(res.mle &gt; 0.01)\n\nprint(f\"\\nRegion distribution:\")\nprint(f\"  Stable (\u03bb &lt; 0):   {n_negative:3d} points ({n_negative/len(res.mle)*100:.1f}%)\")\nprint(f\"  Neutral (\u03bb \u2248 0):  {n_zero:3d} points ({n_zero/len(res.mle)*100:.1f}%)\")\nprint(f\"  Chaotic (\u03bb &gt; 0):  {n_positive:3d} points ({n_positive/len(res.mle)*100:.1f}%)\")\n\nprint(f\"\\nExtreme values:\")\nprint(f\"  Min MLE: {res.mle.min():.6f} at r={res.values[np.argmin(res.mle)]:.4f}\")\nprint(f\"  Max MLE: {res.mle.max():.6f} at r={res.values[np.argmax(res.mle)]:.4f}\")\n</code></pre> uses <code>sweep.lyapunov_mle_sweep</code> for the logistic map, pairing the bifurcation extraction with an MLE sweep over 1000 <code>r</code> values so you can see chaos onset from \u03bb crossing zero.</p> <p><pre><code>\"\"\"\nLyapunov spectrum parameter sweep for the Lorenz system.\n\nDemonstrates sweep.lyapunov_spectrum_sweep for computing the full Lyapunov spectrum\nacross a range of parameters, and overlays the results with a Lorenz\nbifurcation diagram.\n\nFor the Lorenz system (sigma=10, beta=8/3):\n    - rho &lt; ~24.74: stable fixed points\n    - rho &gt; ~24.74: chaotic regime\n\"\"\"\n\nfrom __future__ import annotations\n\nimport numpy as np\nfrom dynlib import setup\nfrom dynlib.analysis import sweep\nfrom dynlib.plot import series, export, theme, fig, bifurcation_diagram\n\n\n# Setup simulation\nsim = setup(\"builtin://ode/lorenz\", stepper=\"rk4\", jit=True)\n\nsigma, beta = 10.0, 8.0/3.0\ninitial_state = {\"x\": 1.0, \"y\": 1.0, \"z\": 1.0}\n\n# Sweep configuration\nrho_values = np.linspace(0.0, 200.0, 4000)\ndt = 0.01\ntotal_time = 50.0\ntransient = 50.0\nrecord_interval = 1\n\nprint(f\"Computing Lorenz bifurcation + spectrum for {len(rho_values)} values...\")\nprint(f\"  rho range: [{rho_values[0]:.2f}, {rho_values[-1]:.2f}]\")\nprint(f\"  T={total_time}, dt={dt}, transient={transient}\")\n\n# Bifurcation diagram (z vs rho)\nprint(\"\\nComputing bifurcation diagram...\")\nsim.assign(**initial_state, sigma=sigma, rho=rho_values[0], beta=beta)\nbif_sweep = sweep.traj_sweep(\n    sim,\n    param=\"rho\",\n    values=rho_values,\n    record_vars=[\"z\"],\n    T=total_time,\n    dt=dt,\n    transient=transient,\n    record_interval=record_interval,\n)\n# Local extrema give clean bifurcation diagrams for continuous systems\nbif_result = bif_sweep.bifurcation(\"z\").extrema(\n    max_points=50,  # Limit points in chaotic regime\n    min_peak_distance=8\n)\n\n# Lyapunov spectrum sweep\nprint(\"\\nComputing Lyapunov spectrum...\")\nsim.reset()\nsim.assign(**initial_state, sigma=sigma, rho=rho_values[0], beta=beta)\nres = sweep.lyapunov_spectrum_sweep(\n    sim,\n    param=\"rho\",\n    values=rho_values,\n    k=3,\n    T=total_time,\n    dt=dt,\n    transient=transient,\n    record_interval=record_interval,\n    parallel_mode=\"auto\",\n)\n\nprint(\"\\nSweep completed!\")\nprint(\n    \"  Spectrum min/max (lambda1): \"\n    f\"[{res.lyap0.min():.4f}, {res.lyap0.max():.4f}]\"\n)\n\n# ===== Visualization =====\ntheme.use(\"notebook\")\ntheme.update(grid=True)\n\nax = fig.grid(rows=2, cols=1, size=(12, 10), sharex=True)\n\n# Upper panel: Bifurcation diagram\nbifurcation_diagram(\n    bif_result,\n    alpha=0.6,\n    color=\"black\",\n    ax=ax[0, 0],\n    xlabel=\"rho\",\n    ylabel=\"z\",\n    title=\"Lorenz Bifurcation Diagram and Lyapunov Spectrum\",\n    title_fs=14,\n    ylabel_fs=12,\n)\n\n# Lower panel: Lyapunov spectrum vs parameter\nseries.multi(\n    x=res.values,\n    y=[res.lyap0, res.lyap1, res.lyap2],\n    names=[\"$\\\\lambda_1$\", \"$\\\\lambda_2$\", \"$\\\\lambda_3$\"],\n    ax=ax[1, 0],\n    xlabel=\"rho\",\n    ylabel=\"Lyapunov exponents\",\n    legend=True,\n    hlines=[0.0],\n    hlines_kwargs={\"color\": \"gray\", \"ls\": \"--\", \"lw\": 1, \"alpha\": 0.7},\n    xlim=(rho_values[0], rho_values[-1]),\n)\n\nexport.show()\n</code></pre> sweeps the Lorenz <code>rho</code> parameter with <code>sweep.lyapunov_spectrum_sweep</code>, overlays the z-plane bifurcation, and plots all three Lyapunov exponents across the range.</p>"},{"location":"examples/analysis/#manifolds-and-orbit-finders","title":"Manifolds and orbit finders","text":""},{"location":"examples/analysis/#manifold-tracing","title":"Manifold tracing","text":"<p><pre><code>from dynlib import setup\nfrom dynlib.analysis import trace_manifold_1d_map\nfrom dynlib.plot import manifold, theme, export, fig\n\n\na, b = 1.4, 0.3\nbounds = ((-2.5, 2.5), (-2.5, 2.5))\n\nsim = setup(\"builtin://map/henon2\", jit=True)\nsim.assign(a=1.4, b=0.3)\n\nfp = sim.model.fixed_points(seeds=[[0.8, 0.8]])\nstable_results = trace_manifold_1d_map( sim, \n                                        fp=fp.points[0],\n                                        bounds=bounds,\n                                        kind=\"stable\",\n                                        steps=80,\n                                        hmax=2e-3,\n                                        clip_margin=0.35,\n                                        max_points_per_segment=40000,\n                                        max_segments=300,\n                                    )\n\nunstable_results = trace_manifold_1d_map( sim, \n                                          fp=fp.points[0],\n                                          bounds=bounds,\n                                          kind=\"unstable\",\n                                          steps=80,\n                                          hmax=2e-3,\n                                          clip_margin=0.35,\n                                          max_points_per_segment=120000,\n                                          max_segments=400,\n                                        )\n\ntheme.use(\"paper\")\nax = fig.single(size=(5, 5))\nmanifold(\n    result=stable_results,\n    ax=ax,\n    color=\"blue\",\n    label=\"stable\",\n    xlim=bounds[0],\n    ylim=bounds[1],\n    xlabel=\"$x$\",\n    ylabel=\"$y$\",\n    title=\"Henon map manifolds\",\n    aspect=\"equal\",\n    lw=0.7,\n)\nmanifold(result=unstable_results, ax=ax, color=\"red\", label=\"unstable\", lw=0.7)\nax.plot(fp.points[0][0], fp.points[0][1], \"k+\", ms=12)\nexport.show()\n</code></pre> traces the 1D stable and unstable manifolds of the Henon map fixed point using <code>trace_manifold_1d_map</code>, shows both branches on a single plot, and overlays the fixed point.</p> <p><pre><code>\"\"\"\nExample: Tracing stable and unstable manifolds of a 2D saddle point.\n\nModel: x' = x, y' = -y + x^2\nEquilibrium at origin (0, 0) with:\n  - Unstable eigenvalue \u03bb=+1 (eigenvector along x-axis)\n  - Stable eigenvalue \u03bb=-1 (eigenvector along y-axis)\n\nKnown analytic solutions:\n  - Stable manifold: x = 0 (the y-axis)\n  - Unstable manifold: y = x^2/3\n\"\"\"\nfrom dynlib import setup\nfrom dynlib.analysis import trace_manifold_1d_ode\nfrom dynlib.plot import manifold, theme, export, fig\nimport numpy as np\n\n# Define the saddle model inline\nmodel_toml = \"\"\"\ninline:\n[model]\ntype = \"ode\"\nname = \"saddle2d\"\n\n[sim]\nt0 = 0.0\nT = 10.0\ndt = 0.01\n\n[states]\nx = 0.1\ny = 0.1\n\n[equations.rhs]\nx = \"x\"\ny = \"-y + x*x\"\n\"\"\"\n\n# Setup simulation\nsim = setup(model_toml, jit=True)\nbounds = ((-2.5, 2.5), (-2.5, 2.5))\n\n# Trace stable manifold (backward in time)\nstable_result = trace_manifold_1d_ode(\n    sim,\n    fp={\"x\": 0.0, \"y\": 0.0},\n    kind=\"stable\",\n    bounds=bounds,\n    dt=0.01,\n    max_time=50.0,\n    resample_h=0.01,\n)\n\n# Trace unstable manifold (forward in time)\nunstable_result = trace_manifold_1d_ode(\n    sim,\n    fp={\"x\": 0.0, \"y\": 0.0},\n    kind=\"unstable\",\n    bounds=bounds,\n    dt=0.01,\n    max_time=50.0,\n    resample_h=0.01,\n)\n\n# Validate against analytic solutions\nprint(f\"Stable eigenvalue: {stable_result.eigenvalue:.4f} (expected: -1)\")\nprint(f\"Unstable eigenvalue: {unstable_result.eigenvalue:.4f} (expected: +1)\")\n\n# Check stable manifold (should be x=0)\nstable_x_err = 0.0\nfor branch in stable_result.branches[0] + stable_result.branches[1]:\n    if branch.size &gt; 0:\n        stable_x_err = max(stable_x_err, np.max(np.abs(branch[:, 0])))\nprint(f\"Stable manifold max |x| error: {stable_x_err:.3e}\")\n\n# Check unstable manifold (should be y=x^2/3)\nunstable_err = 0.0\nfor branch in unstable_result.branches[0] + unstable_result.branches[1]:\n    if branch.shape[0] &gt;= 2:\n        x_vals = branch[:, 0]\n        y_vals = branch[:, 1]\n        y_analytic = x_vals**2 / 3.0\n        unstable_err = max(unstable_err, np.max(np.abs(y_vals - y_analytic)))\nprint(f\"Unstable manifold max |y - x\u00b2/3| error: {unstable_err:.3e}\")\n\n# Plot\ntheme.use(\"paper\")\nax = fig.single(size=(6, 6))\n\n# Stable manifold (blue)\nmanifold(\n    result=stable_result,\n    ax=ax,\n    color=\"C0\",\n    label=\"W^s (stable)\",\n    lw=1.5,\n)\n\n# Unstable manifold (red)\nmanifold(\n    result=unstable_result,\n    ax=ax,\n    color=\"C3\",\n    label=\"W^u (unstable)\",\n    lw=1.5,\n)\n\n# Analytic unstable manifold for comparison (dashed black)\nx_analytic = np.linspace(bounds[0][0], bounds[0][1], 500)\ny_analytic = x_analytic**2 / 3.0\nax.plot(x_analytic, y_analytic, \"k--\", lw=1.0, label=\"y = x\u00b2/3 (analytic)\")\n\n# Mark the equilibrium\nax.plot(0, 0, \"ko\", ms=8)\n\nax.set_xlim(bounds[0])\nax.set_ylim(bounds[1])\nax.set_aspect(\"equal\")\nax.set_xlabel(\"x\")\nax.set_ylabel(\"y\")\nax.set_title(\"Stable/Unstable Manifolds: x'=x, y'=-y+x\u00b2\")\nax.legend(loc=\"upper left\")\n\nexport.show()\n</code></pre> builds a simple saddle ODE, traces the manifolds via <code>trace_manifold_1d_ode</code>, compares against analytic formulas (<code>x=0</code>, <code>y=x\u00b2/3</code>), and reports eigenvalue errors.</p>"},{"location":"examples/analysis/#homoclinic-heteroclinic-finders","title":"Homoclinic &amp; heteroclinic finders","text":"<pre><code>\"\"\"\nExample: Homoclinic finder/tracer (manifold finder/tracer) on an inline model.\n\nWorkflow:\n1) Use homoclinic_finder to locate a parameter value with a homoclinic orbit.\n2) Use homoclinic_tracer to trace and plot the orbit at the found parameter.\n\nThis example demonstrates the simplified API with:\n- List inputs for equilibrium guess (no need for np.array)\n- window parameter as list of tuples\n- preset parameter for common configurations (\"fast\", \"default\", \"precise\")\n\nImportant: Matching Finder and Tracer Settings\n-----------------------------------------------\nThe tracer should use the same section/radius settings as the finder:\n- r_sec (section radius) and t_min_event (minimum event time) should match\n  the finder's configuration to ensure consistent return-section logic.\n- If tracing fails with status 'no_cross', try increasing t_max or loosening\n  the finder's gap_tol/x_tol tolerances.\n\nAdvanced Configuration\n----------------------\nFor fine-grained control, you can use the full configuration classes:\n\n    from dynlib.analysis import (\n        HomoclinicRK45Config,      # RK45 integrator settings (dt0, atol, rtol, etc.)\n        HomoclinicBranchConfig,    # Branch tracing settings (eps, t_max, r_sec, etc.)\n        HomoclinicFinderConfig,    # Finder config\n    )\n\n    # Example: Custom RK45 and branch configuration\n    rk_cfg = HomoclinicRK45Config(dt0=1e-4, atol=1e-12, rtol=1e-9, max_steps=5_000_000)\n    branch_cfg = HomoclinicBranchConfig(\n        t_max=2000.0,\n        r_blow=200.0,\n        r_sec=1e-2,\n        window_min=[-3.0, -3.0],\n        window_max=[3.0, 3.0],\n        rk=rk_cfg,\n    )\n    finder_cfg = HomoclinicFinderConfig(\n        trace=branch_cfg,\n        scan_n=81,\n        max_bisect=60,\n        gap_tol=1e-6,\n        x_tol=1e-4,\n    )\n\n    result = homoclinic_finder(sim, ..., cfg=finder_cfg)\n\nYou can also use `trace_cfg` for unified branch configuration:\n\n    result = homoclinic_finder(\n        sim, ...,\n        trace_cfg=branch_cfg,  # applies to the unstable branch\n        gap_tol=1e-6,\n    )\n\"\"\"\nfrom dynlib import setup\nfrom dynlib.analysis import (\n    homoclinic_finder,\n    homoclinic_tracer,\n)\nfrom dynlib.plot import theme, fig, export, manifold\n\n\nMODEL = \"\"\"\ninline:\n[model]\ntype = \"ode\"\nname = \"homoclinic-demo\"\n\n[sim]\nt0 = 0.0\nT = 10.0\ndt = 0.01\n\n[states]\nx = 0.0\ny = 0.0\n\n[params]\nmu = -0.86\n\n[equations.rhs]\nx = \"y\"\ny = \"mu*y + x - x*x + x*y\"\n\n[equations.jacobian]\nexpr = [\n    [\"0\", \"1\"],\n    [\"1 - 2*x + y\", \"mu + x\"]\n]\n\"\"\"\n\n\nsim = setup(MODEL, jit=True, disk_cache=False)\n\n# ============================================================================\n# SIMPLIFIED API: Using preset and flattened kwargs\n# ============================================================================\n\n# Simple case: just specify essential parameters, uses \"default\" preset\nresult = homoclinic_finder(\n    sim,\n    param=\"mu\",\n    param_min=-1.2,\n    param_max=-0.6,\n    param_init=-1.0,\n    eq_guess=[0.0, 0.0],  # Lists work! No need for np.array\n    # Simplified kwargs:\n    preset=\"default\",  # or \"fast\", \"precise\"\n    window=[(-3, 3), (-3, 3)],  # state-space bounds as (min, max) tuples\n    scan_n=61,\n    max_bisect=60,\n    gap_tol=1e-4,\n    x_tol=1e-4,\n    t_max=2000.0,\n    r_blow=200.0,\n)\n\nprint(\"success:\", result.success)\nprint(\"mu_found:\", result.param_found)\nprint(\"fail:\", result.info[\"fail\"])\nprint(\"best_by_abs_gap:\", result.info[\"best_by_abs_gap\"])\nprint(\"best_by_q:\", result.info[\"best_by_q\"])\nif result.success and result.miss is not None:\n    print(\n        \"gap_found:\",\n        result.info[\"gap_found\"],\n        \"q_found:\",\n        result.info[\"q_found\"],\n        \"t_cross:\",\n        result.info[\"t_cross\"],\n    )\n\nif (not result.success) or result.miss is None:\n    raise SystemExit(\"Homoclinic finder did not converge; see info above.\")\n\n# Trace the orbit using the simplified API\ntrace = homoclinic_tracer(\n    sim,\n    param=\"mu\",\n    param_value=result.param_found,\n    eq=result.miss.eq,          # Can also use lists: [0.0, 0.0]\n    sign_u=result.miss.sign_u,\n    preset=\"default\",  # Use same preset as finder for consistency\n    window=[(-3, 3), (-3, 3)],\n    t_max=2000.0,\n    r_blow=200.0,\n    r_sec=result.miss.r_sec,\n    t_min_event=result.miss.t_min,\n)\n\nprint(\"trace success: \", trace.success)\nprint(\"status: \", trace.meta.status)\nprint(\"event: \", None if trace.meta.event is None else trace.meta.event.kind)\n\nif not trace.success:\n    print(f\"\\nTracing failed with status '{trace.meta.status}'.\")\n    print(\"Consider increasing t_max or loosening gap_tol/x_tol.\")\n\n# Only plot if we have valid trajectory data\ntraj = trace.branch_pos[0] if trace.branch_pos and len(trace.branch_pos) &gt; 0 else None\nif traj is not None and len(traj) &gt; 1:\n    theme.use(\"paper\")\n    ax = fig.single()\n\n    title_suffix = \"\" if trace.success else \" (partial, no return-section hit)\"\n\n    manifold(\n        result=trace,\n        ax=ax,\n        color=\"C0\",\n        lw=1.2,\n        label=\"Homoclinic excursion\" + (\" (closed)\" if trace.success else \" (incomplete)\"),\n        xlim=(-1.6, 1.6),\n        ylim=(-1.0, 1.0),\n        xlabel=\"x\",\n        ylabel=\"y\",\n        title=f\"Homoclinic orbit at mu={result.param_found:.10f}{title_suffix}\",\n        aspect=\"equal\",\n    )\n    ax.scatter([result.miss.eq[0]], [result.miss.eq[1]], s=60, label=\"Equilibrium\")\n    ax.scatter([trace.meta.x_cross[0]], [trace.meta.x_cross[1]], s=30, label=\"Section cross\")\n    ax.legend(loc=\"best\")\n\n    \"\"\"\n    Section cross: This is the point where the unstable manifold trajectory\n    re-enters the return section defined by r_sec around the equilibrium.\n    When a homoclinic orbit exists, the crossing should align with the unstable\n    direction, making the signed return value g close to zero.\n    \"\"\"\n\n    export.show()\nelse:\n    print(\"\\nNo trajectory data to plot.\")\n</code></pre> <p><pre><code>\"\"\"\nExample: Heteroclinic finder/tracer (manifold finder/tracer) on an inline model.\n\nWorkflow:\n1) Use heteroclinic_finder to locate a parameter value with a heteroclinic orbit.\n2) Use heteroclinic_tracer to trace and plot the orbit at the found parameter.\n\nThis example demonstrates the simplified API with:\n- List inputs for fixed points (no need for np.array)\n- window parameter as list of tuples\n- preset parameter for common configurations (\"fast\", \"default\", \"precise\")\n\nImportant: Matching Finder and Tracer Settings\n-----------------------------------------------\nThe tracer's hit_radius should be chosen carefully based on the finder's accuracy:\n- If finder reports gap_found ~ 1e-4, use hit_radius ~ 0.01 to 0.05\n- If finder reports gap_found ~ 1e-6, use hit_radius ~ 0.001 to 0.01\n- Rule of thumb: hit_radius \u2248 5-50x the finder's gap_found value\n- Use the same preset for both finder and tracer for consistency\n\nThe finder and tracer may have slightly different numerical behavior, so the\ntracer might not achieve the exact same precision as the finder's gap measurement.\nIf the tracer fails with status 'window' or gets close but doesn't hit the target,\neither increase hit_radius or tighten the finder's gap_tol/x_tol tolerances.\n\nAdvanced Configuration\n----------------------\nFor fine-grained control, you can use the full configuration classes:\n\n    from dynlib.analysis import (\n        HeteroclinicRK45Config,      # RK45 integrator settings (dt0, atol, rtol, etc.)\n        HeteroclinicBranchConfig,    # Branch tracing settings (eps, t_max, window, etc.)\n        HeteroclinicFinderConfig2D,  # Finder config for 2D systems\n        HeteroclinicFinderConfigND,  # Finder config for N-dimensional systems\n    )\n\n    # Example: Custom RK45 and branch configuration\n    rk_cfg = HeteroclinicRK45Config(dt0=1e-4, atol=1e-12, rtol=1e-9, max_steps=5_000_000)\n    branch_cfg = HeteroclinicBranchConfig(\n        t_max=500.0,\n        r_blow=500.0,\n        window_min=[-20.0, -20.0],\n        window_max=[20.0, 20.0],\n        rk=rk_cfg,\n    )\n    finder_cfg = HeteroclinicFinderConfigND(\n        trace_u=branch_cfg,\n        trace_s=branch_cfg,\n        scan_n=121,\n        max_bisect=80,\n        gap_tol=1e-6,\n    )\n\n    result = heteroclinic_finder(sim, ..., cfg=finder_cfg)\n\nYou can also use `trace_cfg` for unified branch configuration:\n\n    result = heteroclinic_finder(\n        sim, ...,\n        trace_cfg=branch_cfg,  # applies to both unstable and stable branches\n        gap_tol=1e-6,\n    )\n\"\"\"\nimport numpy as np\n\nfrom dynlib import setup\nfrom dynlib.analysis import (\n    heteroclinic_finder,\n    heteroclinic_tracer,\n)\nfrom dynlib.plot import theme, fig, export, manifold\n\n\nMODEL = \"\"\"\ninline:\n[model]\ntype = \"ode\"\nname = \"heteroclinic-demo\"\n\n[sim]\nt0 = 0.0\nT = 10.0\ndt = 0.01\n\n[states]\nu = 0.0\nv = 0.0\n\n[params]\nc = 0.0\na = 0.3\n\n[equations.rhs]\nu = \"v\"\nv = \"-c*v - u*(1-u)*(u-a)\"\n\n[equations.jacobian]\nexpr = [\n    [\"0\", \"1\"],\n    [\"3*u*u - 2*(1+a)*u + a\", \"-c\"]\n]\n\"\"\"\n\n\nsim = setup(MODEL, jit=True, disk_cache=False)\n\n# NOTE: Stricter hit_radius requires stricter config values!\n#       With 0.02 you will see a gap near fixed points.\nhit_radius = 0.02\n\n# ============================================================================\n# SIMPLIFIED API: Using preset and flattened kwargs\n# ============================================================================\n\n# Simple case: just specify essential parameters, uses \"default\" preset\nresult = heteroclinic_finder(\n    sim,\n    param=\"c\",\n    param_min=-0.5,\n    param_max=1.0,\n    param_init=0.0,\n    source_eq_guess=[0.0, 0.0],  # Lists work! No need for np.array\n    target_eq_guess=[1.0, 0.0],\n    # Simplified kwargs:\n    preset=\"default\",  # or \"fast\", \"precise\"\n    window=[(-10, 10), (-10, 10)],  # state-space bounds as (min, max) tuples\n    scan_n=61,\n    max_bisect=60,\n    gap_tol=1e-4,\n    x_tol=1e-4,\n    t_max=200.0,\n    r_blow=200.0,\n)\n\nprint(\"success:\", result.success)\nprint(\"c_found:\", result.param_found)\nprint(\"fail:\", result.info[\"fail\"])\nprint(\"sign_u, sign_s:\", result.info[\"sign_u\"], result.info[\"sign_s\"])\nprint(\"best_by_abs_gap:\", result.info[\"best_by_abs_gap\"])\nprint(\"best_by_q:\", result.info[\"best_by_q\"])\nif result.success and result.miss is not None:\n    print(\n        \"gap_found:\",\n        result.info[\"gap_found\"],\n        \"gap_tol_eff_found:\",\n        result.info[\"gap_tol_eff_found\"],\n        \"q_found:\",\n        result.info[\"q_found\"],\n    )\n\nif (not result.success) or result.miss is None:\n    raise SystemExit(\"Heteroclinic finder did not converge; see info above.\")\n\n# Trace the orbit using the simplified API\n# Note: hit_radius should be adjusted based on the accuracy of the finder's gap (gap_found).\n# If the finder's gap is ~1e-4, a hit_radius of 1e-3 may be too strict for the tracer.\n# Reasonable values: 0.01 to 0.05 for typical cases, or 5-10x the finder's gap_found.\ntrace = heteroclinic_tracer(\n    sim,\n    param=\"c\",\n    param_value=result.param_found,\n    source_eq=result.miss.source_eq,  # Can also use lists: [0.0, 0.0]\n    target_eq=result.miss.target_eq,\n    sign_u=result.miss.sign_u,\n    preset=\"default\",  # Use same preset as finder for consistency\n    window=[(-10, 10), (-10, 10)],\n    t_max=200.0,\n    hit_radius=hit_radius,  # Adjusted to be more realistic given gap_found ~ 2e-4\n)\n\nprint(\"trace success: \", trace.success)\nprint(\"status: \", trace.meta.status)\nprint(\"event: \", None if trace.meta.event is None else trace.meta.event.kind)\n\nif not trace.success:\n    # Diagnose why tracing failed\n    if trace.branch_pos and len(trace.branch_pos) &gt; 0:\n        traj = trace.branch_pos[0]\n        dist_to_B = np.linalg.norm(traj[-1] - result.miss.target_eq)\n        print(f\"\\nTracing failed with status '{trace.meta.status}'.\")\n        print(f\"Trajectory reached distance {dist_to_B:.6f} from target_eq.\")\n        print(f\"This exceeds hit_radius={hit_radius}.\")\n        print(\"Consider increasing hit_radius or tightening finder tolerances.\")\n\nif not trace.success:\n    # Diagnose why tracing failed\n    if trace.branch_pos and len(trace.branch_pos) &gt; 0:\n        traj = trace.branch_pos[0]\n        dist_to_B = np.linalg.norm(traj[-1] - result.miss.target_eq)\n        print(f\"\\nTracing failed with status '{trace.meta.status}'.\")\n        print(f\"Trajectory reached distance {dist_to_B:.6f} from target_eq.\")\n        print(f\"This exceeds hit_radius={hit_radius}.\")\n        print(\"Consider increasing hit_radius or tightening finder tolerances.\")\n\n# Only plot if we have valid trajectory data\nif trace.branch_pos and len(trace.branch_pos) &gt; 0:\n    theme.use(\"paper\")\n    ax = fig.single()\n\n    # Add title indicating whether full heteroclinic connection was achieved\n    title_suffix = \"\" if trace.success else \" (partial, did not reach B within hit_radius)\"\n\n    manifold(\n        result=trace,\n        ax=ax,\n        color=\"C0\",\n        lw=1.2,\n        label=\"Wu(A)\" + (\" \u2192 B\" if trace.success else \" (incomplete)\"),\n        xlim=(-0.5, 1.5),\n        ylim=(-0.2, 0.4),\n        xlabel=\"u\",\n        ylabel=\"v\",\n        title=f\"Heteroclinic orbit at c={result.param_found:.10f}{title_suffix}\",\n        aspect=\"equal\",\n    )\n    ax.scatter([result.miss.source_eq[0]], [result.miss.source_eq[1]], s=60, label=\"A\")\n    ax.scatter([result.miss.target_eq[0]], [result.miss.target_eq[1]], s=60, label=\"B\")\n    ax.scatter([result.miss.x_u_cross[0]], [result.miss.x_u_cross[1]], s=30, label=\"cross (Wu)\")\n    ax.scatter([result.miss.x_s_cross[0]], [result.miss.x_s_cross[1]], s=30, label=\"cross (Ws)\")\n    ax.legend(loc=\"best\")\n\n    \"\"\"\n    cross (Wu) (or x_u_cross): This is the point where the unstable manifold (Wu) of\n    equilibrium point A crosses a section plane centered at equilibrium point B.\n\n    cross (Ws) (or x_s_cross): This is the point where the stable manifold (Ws) of\n    equilibrium point B crosses the same section plane.\n\n    When a heteroclinic orbit exists, these two crossing points should be very close\n    (ideally the same point), meaning the unstable manifold of A connects to the stable\n    manifold of B. The algorithm searches for parameter values where this \"miss distance\"\n    is minimized.\n    \"\"\"\n\n    export.show()\nelse:\n    print(\"\\nNo trajectory data to plot.\")\n</code></pre> Each script runs the corresponding finder/tracer pair on an inline 2D model. They demonstrate the simplified API (<code>preset</code>, tuple-style <code>window</code>, optional <code>x_tol</code>/<code>gap_tol</code>), print finder diagnostics (gap size, status), and plot the traced orbit in the return section so you can visualize whether the unstable manifold connects back.</p>"},{"location":"examples/analysis/#sweeps-and-trajectory-helpers","title":"Sweeps and trajectory helpers","text":""},{"location":"examples/analysis/#parameter-sweeps","title":"Parameter sweeps","text":"<p><pre><code>import numpy as np\nfrom dynlib import setup\nfrom dynlib.plot import series, export\nfrom dynlib.analysis import sweep\n\n\nDSL = \"\"\"\ninline:\n[model]\ntype=\"ode\"\n\n[states]\nx=10.0\n\n[params]\na=-1.0\n\n[equations.rhs]\nx = \"a * x\"\n\"\"\"\n\nsim = setup(DSL, \n            jit=True,\n            disk_cache=False)\n\nvalues = np.arange(-5.0, -1.0, 1.0)\nres=sweep.traj_sweep(sim, param=\"a\", record_vars=[\"x\"], values=values, T=5)\n\n# Plot all trajectories at once (stacked access)\nseries.multi(x=res.t, y=res[\"x\"], legend=False)\nexport.show()\n\n# Access individual runs for custom processing\nprint(f\"\\nSweep has {len(res.runs)} runs:\")\nfor run in res.runs:\n    final_x = run[\"x\"][-1]\n    print(f\"  a={run.param_value:.1f}: x(T)={final_x:.6f}\")\n\n# Access a specific run\nrun = res.runs[2]  # Third run (a=-3.0)\nprint(f\"\\nRun details for a={run.param_value}:\")\nprint(f\"  Time points: {len(run.t)}\")\nprint(f\"  Initial x: {run['x'][0]:.6f}\")\nprint(f\"  Final x: {run['x'][-1]:.6f}\")\n</code></pre> Uses <code>analysis.sweep.traj_sweep</code> to run the toy ODE <code>x' = a x</code> for several <code>a</code> values, stacks the trajectories with <code>series.multi</code>, and accesses each <code>SweepRun</code> to print the final state and step details.</p>"},{"location":"examples/analysis/#trajectory-analyzer","title":"Trajectory analyzer","text":"<p><pre><code>\"\"\"Demonstration of TrajectoryAnalyzer helpers on a damped oscillator.\"\"\"\n\nfrom __future__ import annotations\nimport numpy as np\nfrom dynlib import setup\n\n\nMODEL = \"\"\"\ninline:\n[model]\ntype=\"ode\"\nname=\"Damped oscillator with aux energy\"\n\n[states]\nx=1.0\nv=0.0\n\n[params]\nomega=2.0\nzeta=0.15\n\n[equations.rhs]\nx = \"v\"\nv = \"-2*zeta*omega*v - omega**2 * x\"\n\n[aux]\nenergy = \"0.5 * (v**2 + (omega * x)**2)\"\n\"\"\"\n\n\ndef _round_dict(values: dict[str, float], digits: int = 3) -&gt; dict[str, float]:\n    return {k: round(float(v), digits) for k, v in values.items()}\n\n\ndef main() -&gt; None:\n    sim = setup(MODEL, stepper=\"rk4\", jit=False, disk_cache=False)\n    sim.config(dt=0.01, max_steps=150_000)\n    sim.run(T=15.0, record_vars=[\"x\", \"v\", \"aux.energy\"])\n    res = sim.results()\n\n    print(\"\\n--- Single-variable analysis (x) ---\")\n    x = res.analyze(\"x\")\n    print(\"summary:\", _round_dict(x.summary()))\n    t_peak, peak = x.argmax()\n    print(f\"peak x at t={t_peak:.3f}: {peak:.3f}\")\n    crossings = x.zero_crossings(direction=\"up\")\n    print(\"first three zero up-crossings (s):\", np.round(crossings[:3], 3))\n    print(f\"time with x &gt;= 0.5: {x.time_above(0.5):.3f}s\")\n    print(f\"time with x &lt; -0.5: {x.time_below(-0.5):.3f}s\")\n\n    print(\"\\n--- Multi-variable analysis (x, v) ---\")\n    mv = res.analyze([\"x\", \"v\"])\n    print(\"argmax by var:\", {k: (round(t, 3), round(v, 3)) for k, (t, v) in mv.argmax().items()})\n    print(\"range by var:\", _round_dict(mv.range()))\n    print(\"mean by var:\", _round_dict(mv.mean()))\n\n    print(\"\\n--- Aux variable analysis (energy) ---\")\n    energy = res.analyze(\"energy\")  # auto-detected aux without explicit prefix\n    print(\"energy min/max:\", (round(energy.min(), 3), round(energy.max(), 3)))\n    print(\"energy range:\", round(energy.range(), 3))\n    below_times = energy.crossing_times(threshold=0.1, direction=\"down\")\n    print(\"first drop below 0.1:\", round(below_times[0], 3) if len(below_times) else \"never\")\n\n    print(\"\\n--- Automatic variable selection ---\")\n    auto = res.analyze()\n    print(\"recorded vars picked by res.analyze():\", auto.vars)\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> Runs a damped oscillator with an auxiliary energy variable, then calls <code>res.analyze()</code> to show <code>summary()</code>, <code>argmax()</code>, <code>zero_crossings()</code>, and <code>time_above/Below</code> for single- and multi-variable selections. It also inspects the automatically selected auxiliary variables to demonstrate how <code>TrajectoryAnalyzer</code> finds recorded names.</p>"},{"location":"examples/bifurcation/","title":"Bifurcation Diagram: Logistic Map","text":""},{"location":"examples/bifurcation/#overview","title":"Overview","text":"<p>This example demonstrates how to create bifurcation diagrams using dynlib's parameter sweep and plotting tools. Bifurcation diagrams visualize how the long-term behavior of a dynamical system changes as a parameter varies, revealing transitions between fixed points, periodic orbits, and chaotic dynamics.</p> <p>The logistic map <code>x_{n+1} = r\u00b7x_n\u00b7(1-x_n)</code> is a classic example exhibiting the period-doubling route to chaos as the parameter <code>r</code> increases from 2.5 to 4.0.</p>"},{"location":"examples/bifurcation/#key-concepts","title":"Key Concepts","text":"<ul> <li>Parameter sweeps: Computing trajectories across a range of parameter values</li> <li>Bifurcation extraction: Post-processing trajectories into scatter data for visualization</li> <li>Extraction modes: Different strategies for capturing system behavior (<code>all</code>, <code>tail</code>, <code>final</code>, <code>extrema</code>)</li> <li>Period-doubling cascade: The Feigenbaum scenario leading to chaos</li> </ul>"},{"location":"examples/bifurcation/#the-logistic-map-model","title":"The Logistic Map Model","text":"<p>The logistic map is defined as:</p> \\[ x_{n+1} = r \\cdot x_n \\cdot (1 - x_n) \\] <p>Key bifurcation points: - r &lt; 3.0: Stable fixed point - r = 3.0: First period-doubling (period-2 orbit emerges) - r \u2248 3.449: Period-4 orbit - r \u2248 3.57: Onset of chaos (Feigenbaum point r\u221e \u2248 3.5699) - r = 4.0: Fully developed chaos</p>"},{"location":"examples/bifurcation/#basic-example","title":"Basic Example","text":"<p>The simplest bifurcation diagram uses the built-in logistic map model:</p> <pre><code>from dynlib import setup\nfrom dynlib.analysis import sweep\nfrom dynlib.plot import bifurcation_diagram, theme, fig, export\nimport numpy as np\n\n# Setup model\nsim = setup(\"builtin://map/logistic\", stepper=\"map\", jit=True)\n\n# Parameter range\nr_values = np.linspace(2.8, 4.0, 5000)\n\n# Run parameter sweep\nsweep_result = sweep.traj_sweep(\n    sim,\n    param=\"r\",\n    values=r_values,\n    record_vars=[\"x\"],\n    N=100,           # iterations per parameter value\n    transient=500,   # discard initial transient\n)\n\n# Extract bifurcation data\nresult = sweep_result.bifurcation(\"x\")\n\n# Plot\ntheme.use(\"notebook\")\nax = fig.single(size=(10, 6))\n\nbifurcation_diagram(\n    result,\n    xlabel=\"r\",\n    ylabel=\"x*\",\n    title=\"Bifurcation Diagram: Logistic Map\",\n    ax=ax\n)\n\nexport.show()\n</code></pre>"},{"location":"examples/bifurcation/#complete-examples-in-repository","title":"Complete Examples in Repository","text":""},{"location":"examples/bifurcation/#1-basic-bifurcation","title":"1. Basic Bifurcation","text":"<pre><code>\"\"\"\nBifurcation diagram demonstration for the logistic map.\n\n\"\"\"\n\nfrom __future__ import annotations\nimport numpy as np\nfrom dynlib import setup\nfrom dynlib.analysis import sweep\nfrom dynlib.plot import export, theme, fig, bifurcation_diagram\n\nr0 = 2.8\nrend = 4.0\n\nsim = setup(\"builtin://map/logistic\", stepper=\"map\", jit=True, disk_cache=True)\n\nr_values = np.linspace(r0, rend, 20000)\n\nprint(\"Computing bifurcation diagram...\")\nprint(f\"  Parameter: r \u2208 [{r0}, {rend}]\")\nprint(f\"  Grid points: {len(r_values)}\")\n\nsweep_result = sweep.traj_sweep(\n    sim,\n    param=\"r\",\n    values=r_values,\n    record_vars=[\"x\"],\n    N=100,  \n    transient=500,  \n    record_interval=1,  \n    parallel_mode=\"auto\",\n)\n# Extract bifurcation data (defaults to .all() mode - all recorded points)\nresult = sweep_result.bifurcation(\"x\")\n# Alternatively: result = sweep_result.bifurcation(\"x\").tail(50)  # for tail mode\n\nprint(f\"  Total points plotted: {len(result.p)}\")\nprint(\"Done!\")\n\ntheme.use(\"notebook\")\ntheme.update(grid=True)\n\nax = fig.single(size=(10, 8))\n\nbifurcation_diagram(\n    result,\n    color=\"blue\",\n    xlim=(r0, rend),\n    ylim=(0, 1),\n    xlabel=\"r\",\n    ylabel=\"x*\",\n    title=\"Bifurcation Diagram: Logistic Map\",\n    xlabel_fs=12,\n    ylabel_fs=12,\n    title_fs=14,\n    ax=ax,\n)\n\nexport.show()\n# Save figure with high dpi will be more smooth\n# export.savefig(ax, \"bifurcation_logistic_map.png\", dpi=600)\n</code></pre> <p>Demonstrates the standard workflow: - High-resolution parameter sweep (20,000 points) - Default extraction mode (all recorded points) - Simple plotting with minimal customization</p>"},{"location":"examples/bifurcation/#2-mode-comparison","title":"2. Mode Comparison","text":"<pre><code>\"\"\"\nBifurcation diagram comparison for the logistic map showing different modes.\n\nThis example demonstrates the three different bifurcation analysis modes:\n1. \"final\": Shows only the final state (good for fixed points)\n2. \"tail\": Shows multiple samples from the attractor (reveals periodic orbits)\n3. \"extrema\": Shows local extrema (emphasizes periodic structure)\n\"\"\"\n\nfrom __future__ import annotations\nimport numpy as np\nfrom dynlib import setup\nfrom dynlib.analysis import sweep\nfrom dynlib.plot import export, theme, fig\n\n# Setup the builtin logistic map model\nsim = setup(\"builtin://map/logistic\", stepper=\"map\", jit=True, disk_cache=True)\n\n# Focus on the interesting region where bifurcations occur\nr_values = np.linspace(2.8, 4.0, 1500)\n\nprint(\"Computing bifurcation diagrams in different modes...\")\n\n# Runtime sweep (do once)\nsweep_result = sweep.traj_sweep(\n    sim,\n    param=\"r\",\n    values=r_values,\n    record_vars=[\"x\"],\n    N=500,\n    transient=200,\n)\n\nextractor = sweep_result.bifurcation(\"x\")\n\n# Mode 1: \"final\" - just the final value (good for convergent behavior)\nresult_final = extractor.final()\n\n# Mode 2: \"tail\" - multiple samples from attractor\nresult_tail = extractor.tail(50)\n\n# Mode 3: \"extrema\" - local extrema (maxima + minima)\nresult_extrema = extractor.extrema(tail=100, max_points=30, min_peak_distance=1)\n\nprint(\"Done! Creating comparison plot...\")\n\n# Configure plot theme\ntheme.use(\"notebook\")\ntheme.update(grid=True)\n\n# Create 3-panel comparison\nfrom dynlib.plot import bifurcation_diagram\n\nax = fig.grid(rows=3, cols=1, size=(10, 10))\n\n# Panel 1: Final mode\nbifurcation_diagram(\n    result_final,\n    marker=\".\",\n    ms=0.5,\n    alpha=0.7,\n    color=\"blue\",\n    ax=ax[0, 0],\n    xlim=(2.8, 4.0),\n    ylim=(0, 1),\n    ylabel=\"x*\",\n    title='Mode: \"final\" (last recorded value)',\n    title_fs=12,\n)\n\n# Panel 2: Tail mode\nbifurcation_diagram(\n    result_tail,\n    marker=\".\",\n    ms=0.3,\n    alpha=0.5,\n    color=\"black\",\n    ax=ax[1, 0],\n    xlim=(2.8, 4.0),\n    ylim=(0, 1),\n    ylabel=\"x*\",\n    title='Mode: \"tail\" (attractor cloud)',\n    title_fs=12,\n)\n\n# Panel 3: Extrema mode\nbifurcation_diagram(\n    result_extrema,\n    marker=\".\",\n    ms=0.5,\n    alpha=0.6,\n    color=\"red\",\n    ax=ax[2, 0],\n    xlim=(2.8, 4.0),\n    ylim=(0, 1),\n    xlabel=\"r\",\n    ylabel=\"x*\",\n    title='Mode: \"extrema\" (local maxima and minima)',\n    title_fs=12,\n)\n\nexport.show()\n</code></pre> <p>Compares three extraction modes side-by-side:</p> <pre><code>extractor = sweep_result.bifurcation(\"x\")\n\n# Mode 1: Final value only\nresult_final = extractor.final()\n\n# Mode 2: Last 50 points (attractor cloud)\nresult_tail = extractor.tail(50)\n\n# Mode 3: Local extrema (maxima + minima)\nresult_extrema = extractor.extrema(tail=100, max_points=30)\n</code></pre>"},{"location":"examples/integer-map/","title":"Integer Map Example: Collatz Sequence","text":""},{"location":"examples/integer-map/#overview","title":"Overview","text":"<p>This example shows how to build a map-type simulation that uses an integer state variable. In contrast to the floating-point logistic map used elsewhere in the docs, this model keeps the Collatz iteration in the integer domain, letting you inspect integer arithmetic.</p>"},{"location":"examples/integer-map/#key-concepts","title":"Key Concepts","text":"<ul> <li><code>map</code> stepper: A discrete-time map that updates the state once per step with no notion of continuous time.</li> <li>Integer dtype (<code>int64</code>): Ensures every iterated value remains precise so the Collatz sequence can be compared exactly to a pre-computed reference.</li> <li>Assertion-based validation: <code>numpy.testing.assert_array_equal</code> checks the full trajectory against the expected 1-4-2-1 cycle.</li> <li>Series plotting: Visualizes the integer trajectory to highlight when it converges to the 4-2-1 cycle.</li> </ul>"},{"location":"examples/integer-map/#collatz-map-definition","title":"Collatz Map Definition","text":"<p>The inline Toml definition uses a single integer state <code>n</code> initialized to 27 and an <code>int64</code> right-hand side that branches on parity:</p> <pre><code>[model]\ntype = \"map\"\ndtype = \"int64\"\nname = \"Collatz Conjecture\"\n\n[states]\nn = 27\n\n[equations.rhs]\nn = \"n//2 if n % 2 == 0 else 3*n + 1\"\n</code></pre>"},{"location":"examples/integer-map/#running-the-simulation","title":"Running the Simulation","text":"<p>The script instantiates the model with <code>setup(..., stepper=\"map\")</code>, runs <code>len(expected) - 1</code> iterations, and reads the results table via <code>sim.results()</code>. The plot uses <code>series.plot</code> to show <code>n</code> vs. iteration and checks that the recorded values match the prepared <code>expected</code> array (the known sequence starting at 27 and terminating in the 1-4-2-1 loop). The example also prints the tail of the trajectory and the state dtype so you can confirm that the cycle and datatype are preserved.</p>"},{"location":"examples/integer-map/#plotting-and-export","title":"Plotting and Export","text":"<p><code>theme.use(\"paper\")</code> configures matplotlib for publication-ready styles, and <code>export.show()</code> displays the figure. The plot's axis labels (<code>iteration</code> and <code>n</code>) and title (<code>Collatz Conjecture</code>) make it easy to see how the iterates descend before settling into the familiar cycle.</p>"},{"location":"examples/integer-map/#reference-script","title":"Reference Script","text":"<p><pre><code>from dynlib import setup\nfrom dynlib.plot import series, export, theme\nimport numpy as np\nfrom numpy.testing import assert_array_equal\n\nmodel = '''\ninline:\n[model]\ntype = \"map\"\ndtype = \"int64\"\nname = \"Collatz Conjecture\"\n\n[states]\nn = 27\n\n[equations.rhs]\nn = \"n//2 if n % 2 == 0 else 3*n + 1\"\n\n'''\n\nexpected = np.array([\n    27, 82, 41, 124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121,\n    364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175,\n    526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502,\n    251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438,\n    719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367,\n    4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300,\n    650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160,\n    80, 40, 20, 10, 5, 16, 8, 4, 2, 1\n], dtype=np.int64)\n\n\nsim = setup(model, stepper=\"map\")\nsim.run(N=len(expected)-1)\nres = sim.results()\n\ntheme.use(\"paper\")\n\nseries.plot(x=res.step, y=res[\"n\"], xlabel=\"iteration\", ylabel=\"n\", ylabel_rot=0, title=\"Collatz Conjecture\")\nprint(\"1-4-2-1 cycle: \", res[\"n\"][-6:])\nprint(\"dtype for n  : \", res[\"n\"].dtype)\n\nif res[\"n\"][0] == 27:\n    assert_array_equal(res[\"n\"], expected)\n    print(\"\u2705 Collatz sequence matches exactly!\")\n\nexport.show()\n</code></pre> for the full implementation, including the <code>sequence</code> validation and plotting logic. The script doubles as a regression test by asserting that every integer in the run matches the <code>expected</code> NumPy array.</p>"},{"location":"examples/izhikevich/","title":"Izhikevich Neuron Example","text":""},{"location":"examples/izhikevich/#overview","title":"Overview","text":"<p>This example walks through simulating the Izhikevich spiking neuron and visualizing its membrane potential as we step through different input currents, including a burst-inducing preset. It highlights dynlib's ability to resume simulations, toggle presets, and annotate plots so that you can clearly see how changing drive currents alters the firing pattern.</p>"},{"location":"examples/izhikevich/#key-concepts","title":"Key Concepts","text":"<ul> <li>Current stepping: run a single simulation while updating the injected current and resuming state, capturing both transients and new attractors.</li> <li>Apply presets: call <code>sim.apply_preset(\"bursting\")</code> to switch the intrinsic parameters (<code>c</code>, <code>d</code>, etc.) that reshape the neuron's excitability.</li> <li>Snapshot tooling: use <code>sim.list_snapshots()</code> plus <code>sim.param_vector</code>/<code>param_dict</code> with <code>source=\"snapshot\"</code> to inspect the stored configuration after running through different regimes.</li> <li>Annotated time series: <code>series.plot</code> supports <code>vbands</code> and <code>vlines</code> so you can label regimes where the injected current changes.</li> </ul>"},{"location":"examples/izhikevich/#the-izhikevich-model","title":"The Izhikevich Model","text":"<p>The builtin model packages the canonical 2D system:</p> \\[ dv = 0.04\\,v^2 + 5.0\\,v + 140.0 - u + I $$ $$ du = a\\,(b\\,v - u) \\] <p>with a hard reset event when <code>v &gt;= v_th</code> (default <code>30.0</code>), setting <code>v = c</code> and <code>u = u + d</code>. The default parameters (<code>a=0.02</code>, <code>b=0.2</code>, <code>c=-65</code>, <code>d=8</code>, <code>I=10</code>) reproduce regular spiking; the <code>bursting</code> preset reduces <code>c</code>/<code>d</code> to produce fast bursts that emerge as the current ramps up.</p>"},{"location":"examples/izhikevich/#basic-example","title":"Basic Example","text":"<pre><code>from dynlib import setup\nfrom dynlib.plot import series, fig, export\n\nsim = setup(\"builtin://ode/izhikevich\", stepper=\"rk4\", jit=True, dtype=\"float32\")\n\nI0, T0 = 0.0, 300.0\nI1, T1 = 5.0, 600.0\nI2, T2 = 10.0, 900.0\nI3, T3 = 15.0, 1200.0\nI4, T4 = 10.0, 1500.0\n\nsim.config(dt=0.01)\nsim.assign(I=I0)\nsim.run(T=T0, transient=50.0)\nsim.assign(I=I1)\nsim.run(T=T1, resume=True)\nsim.assign(I=I2)\nsim.run(T=T2, resume=True)\nsim.assign(I=I3)\nsim.run(T=T3, resume=True)\nsim.apply_preset(\"bursting\")\nsim.assign(I=I4)\nsim.run(T=T4, resume=True)\n\nres = sim.results()\n\nax = fig.single(size=(8, 4))\nseries.plot(\n    x=res.t,\n    y=res[\"v\"],\n    ax=ax,\n    ylim=(-80, 50),\n    title=\"Membrane Potential (v)\",\n    vbands=[(0, T0, \"b\"), (T0, T1, \"m\"), (T1, T2, \"g\"), (T2, T3, \"r\"), (T3, T4, \"c\")],\n    vlines=[(0, \"I=0\"), (T0, \"I=5\"), (T1, \"I=10\"), (T2, \"I=15\"), (T3, \"I=10\")],\n    vlines_color=\"red\",\n)\nexport.show()\n\nprint(\"SNAPSHOTS: \", sim.list_snapshots())\nprint(\"Snapshot Parameter Vector: \", sim.param_vector(source=\"snapshot\"))\nprint(\"Snapshot Parameter Dictionary: \", sim.param_dict(source=\"snapshot\"))\n</code></pre> <p><code>series.plot</code> overlays vertical bands/lines to flag each current step, while the run/profile calls demonstrate how <code>resume=True</code> keeps the stateful simulation continuous as current changes. After plotting the membrane potential, the snapshot helpers summarize the stored parameter sets for later analysis.</p>"},{"location":"examples/izhikevich/#complete-examples-in-repository","title":"Complete Examples in Repository","text":""},{"location":"examples/izhikevich/#1-izhikevich-neuron","title":"1. Izhikevich Neuron","text":"<pre><code>from dynlib import setup\nfrom dynlib.plot import series, export, fig\n\n\nsim = setup(\"builtin://ode/izhikevich\", \n            stepper=\"rk4\", \n            jit=True, \n            dtype=\"float32\")\n\nI0, T0 = 0.0, 300.0\nI1, T1 = 5.0, 600.0\nI2, T2 = 10.0, 900.0\nI3, T3 = 15.0, 1200.0\nI4, T4 = 10.0, 1500.0\n\nsim.config(dt=0.01)\nsim.assign(I=I0)\nsim.run(T=T0, transient=50.0)\nsim.assign(I=I1)\nsim.run(T=T1, resume=True)\nsim.assign(I=I2)\nsim.run(T=T2, resume=True)\nsim.assign(I=I3)\nsim.run(T=T3, resume=True)\nsim.apply_preset(\"bursting\")\nsim.assign(I=I4)\nsim.run(T=T4, resume=True)\n\nres = sim.results()\n\nax = fig.single(size=(8, 4))\nseries.plot(x=res.t, y=res[\"v\"],\n            ax=ax,\n            ylim=(-80, 50),\n            title=\"Membrane Potential (v)\",\n            vbands=[(0,T0,\"b\"), (T0,T1,\"m\"), (T1,T2,\"g\"), (T2,T3,\"r\"), (T3,T4,\"c\")],\n            vlines=[(0, \"I=0\"), (T0, \"I=5\"), (T1, \"I=10\"), (T2, \"I=15\"), (T3, \"I=10\")],\n            vlines_color=\"red\")    \nexport.show()\n\nprint(\"SNAPSHOTS: \", sim.list_snapshots())\nprint(\"Snapshot Parameter Vector: \", sim.param_vector(source=\"snapshot\"))\nprint(\"Snapshot Parameter Dictionary: \", sim.param_dict(source=\"snapshot\"))\n</code></pre> <ul> <li>Full driving-current sequence with five regimes and the <code>bursting</code> preset applied just before the largest steps.</li> <li>Demonstrates how to configure <code>vbands</code>/<code>vlines</code> on a <code>series.plot</code> trace.</li> <li>Prints the snapshots, parameter vector, and dictionary so you can audit the recorded presets.</li> </ul>"},{"location":"examples/izhikevich/#2-izhikevich-benchmark","title":"2. Izhikevich Benchmark","text":"<pre><code>from dynlib import build, Sim\nfrom dynlib.plot import series, export\nfrom dynlib.utils import Timer\n\n\nDSL = '''\ninline:\n[model]\ntype = \"ode\"\n\n[states]\nv = -65.0\nu = -13.0\n\n[params]\na = 0.02\nb = 0.2\nc = -65.0\nd = 8.0\nI = 10.0\n\n[equations]\nexpr = \"\"\"\ndv = 0.04 * v * v + 5.0 * v + 140.0 - u + I\ndu = a * (b * v - u)\n\"\"\"\n\n[events.reset]\ncond = \"v &gt;= 30.0\"\nphase = \"post\"\naction = \"\"\"\nv = c\nu = u + d\n\"\"\"\n'''\n\nT = 1000\n\nwith Timer(\"build model\"):\n    model = build(DSL, stepper=\"euler\", jit=False, dtype=\"float32\")\n\nwith Timer(\"build model jit\"):\n    model_jit = build(DSL, stepper=\"euler\", jit=True, dtype=\"float32\")\n\nsim = Sim(model)\nsim_jit = Sim(model_jit)\n\nwith Timer(\"jit False\"):\n    sim.run(T=T, dt=0.01, cap_rec=10000, record=False)\n\nwith Timer(\"jit True\"):\n    sim_jit.run(T=T, dt=0.01, cap_rec=10000, record=False)\n</code></pre> <ul> <li>Uses <code>dynlib.build</code>/<code>Sim</code> with inline DSL to recreate the same ODE and reset event.</li> <li>Measures runtime differences between JIT and non-JIT builds using <code>dynlib.utils.Timer</code>.</li> <li>Runs <code>sim.run</code> with <code>cap_rec=10000</code> and <code>record=False</code> to isolate performance rather than memory usage.</li> </ul>"},{"location":"examples/plotting/","title":"Plotting examples","text":""},{"location":"examples/plotting/#overview","title":"Overview","text":"<p>These demos capture the plotting helpers that sit on top of dynlib's simulation stack. They show how to build time series, phase portraits, return maps, vector fields, histograms, and animations with consistent styling and the <code>dynlib.plot</code> API.</p>"},{"location":"examples/plotting/#time-series-and-phase-portraits","title":"Time series and phase portraits","text":""},{"location":"examples/plotting/#logistic-map-diagnostics","title":"Logistic map diagnostics","text":"<p><pre><code>from dynlib import setup\nfrom dynlib.plot import series, export, theme, fig, return_map, cobweb\n\nmodel = '''\ninline:\n[model]\ntype=\"map\"\nname=\"Logistic Map\"\n\n[states]\nx=0.1\n\n[params]\nr=4.0\n\n[equations.rhs]\nx = \"r * x * (1 - x)\"\n'''\n\n# stepper=\"map\" is default and can be omitted for map models\nsim = setup(model, stepper=\"map\", jit=True, disk_cache=True)\nsim.run(N=192, transient=40)\nsim.run(resume=True, N=400)\nres=sim.results()\n\nseeds = [[0.1], [0.7], [0.9]]\nfps = sim.model.fixed_points(seeds=seeds)\nprint(fps.points)\n\ntheme.use(\"notebook\")\ntheme.update(grid=False)\n\n# Create 1x2 grid for time series and return map\nax = fig.grid(rows=1, cols=2, size=(12, 5))\n\n# Time series plot\nseries.plot(\n    x=res.t,\n    y=res[\"x\"],\n    style=\"line\",\n    ax=ax[0, 0],\n    xlabel=\"n\",\n    ylabel=\"$x_n$\",\n    ylabel_rot=0,\n    title=\"Logistic Map (r=4)\",\n    ypad=10,\n    xlabel_fs=13,\n    ylabel_fs=13,\n    title_fs=14,\n    xtick_fs=9,\n    ytick_fs=11,\n    lw=1.0\n)\n\n# Return map: x[n] vs x[n+1]\nreturn_map(\n    x=res[\"x\"],\n    step=1,\n    style=\"scatter\",\n    ax=ax[0, 1],\n    ms=2,\n    color=\"C1\",\n    title=\"Return Map: $x[n]$ vs $x[n+1]$\",\n    xlabel_fs=13,\n    ylabel_fs=13,\n    title_fs=14,\n    xtick_fs=9,\n    ytick_fs=11,\n)\n\ncobweb(\n    f=sim.model,\n    x0=0.1,\n    xlim=(0, 1),\n    steps=50,\n    color=\"green\",\n    stair_color=\"orange\",\n    identity_color=\"red\",\n)\n\nexport.show()\n</code></pre> Builds the builtin logistic map, runs with a transient, and then plots the time series, return map, and cobweb diagram. The script also prints the fixed points found by <code>sim.model.fixed_points(seeds=...)</code> so you can compare analytic predictions with the numerically discovered attractors.</p>"},{"location":"examples/plotting/#van-der-pol-oscillator","title":"Van der Pol oscillator","text":"<p><pre><code>from dynlib import setup\nfrom dynlib.plot import series, export, fig, phase\nfrom dynlib.utils import Timer\n\nstepper = \"tr-bdf2a\"\nmu = 1000.0\n\nsim = setup(\"builtin://ode/vanderpol\", \n            stepper=stepper, \n            jit=True,\n            disk_cache=False)\n\nsim.assign(mu=mu)\nsim.config(dt=5e-4, max_steps=6_500_000)\nwith Timer(\"run simulation\"):\n    sim.run(T=3000.0)\nres = sim.results()\n\nseries.plot(x=res.t, y=res[\"x\"],\n            title=f\"Van der Pol Oscillator (\u03bc={mu})\",\n            xlabel=\"Time\",\n            ylabel=\"x\",\n            ylim=(-3, 3),\n            )\n\nphase.xy(x=res[\"x\"], y=res[\"y\"])\nexport.show()\n</code></pre> Runs the stiff <code>builtin://ode/vanderpol</code> model with the <code>tr-bdf2a</code> stepper, times the run with <code>dynlib.utils.Timer</code>, and plots both the time series and phase portrait. It demonstrates how to tune <code>dt</code>/<code>max_steps</code> for long runs while keeping the figure creation simple.</p>"},{"location":"examples/plotting/#plot-helper-gallery","title":"Plot helper gallery","text":""},{"location":"examples/plotting/#basic-plotting-primitives","title":"Basic plotting primitives","text":"<p><pre><code>from __future__ import annotations\n\"\"\"\nDemonstration of various plotting functions from dynlib.plot module.\nOnly the ones not used in other examples are shown here.\n\"\"\"\n\nimport numpy as np\nfrom dynlib.plot import fig, series, phase, utils, export, theme\n\n\ndef main() -&gt; None:\n    theme.use(\"notebook\")\n\n    # ----- Time data -----\n    t = np.linspace(0, 10, 101)\n    y = np.sin(2 * np.pi * 0.5 * t)\n    y2 = np.cos(2 * np.pi * 0.5 * t)\n    # step-like signal\n    y_step = np.floor(t) % 2\n    # noisy distribution for histogram\n    y_hist = y + 0.3 * np.random.randn(len(t))\n\n    # ----- Discrete (map) data -----\n    r = 3.7\n    x0 = 0.2\n    n_iter = 30\n    xs = [x0]\n    x = x0\n    for k in range(n_iter):\n        x = r * x * (1 - x)\n        xs.append(x)\n    ks = np.arange(len(xs))\n    xs = np.array(xs)\n\n    # Layout: 3 rows x 2 cols\n    ax = fig.grid(rows=3, cols=2, size=(10, 12), sharex=False)\n\n    # Row 0, Col 0: series.stem\n    series.stem(\n        x=t,\n        y=y,\n        ax=ax[0, 0],\n        label=\"sin(t) stems\",\n        color=\"C0\",\n        xlabel=\"$t$\",\n        ylabel=\"$y$\",\n        title=\"series.stem: stem plot\",\n    )\n\n    # Row 0, Col 1: series.step\n    series.step(\n        x=t,\n        y=y_step,\n        ax=ax[0, 1],\n        label=\"step(t)\",\n        color=\"C1\",\n        xlabel=\"$t$\",\n        ylabel=\"$y$\",\n        title=\"series.step: step plot\",\n    )\n\n    # Row 1, Col 0: utils.hist\n    utils.hist(\n        y=y_hist,\n        bins=30,\n        density=False,\n        ax=ax[1, 0],\n        color=\"C2\",\n        title=\"utils.hist: histogram\",\n        xlabel=\"$y$\",\n        ylabel=\"count\",\n    )\n\n    # Row 1, Col 1: phase.xy with scatter style (for discrete maps)\n    phase.xy(\n        x=y,\n        y=y2,\n        style=\"scatter\",\n        ax=ax[1, 1],\n        ms=6,\n        color=\"C3\",\n        title=\"phase.xy: sin vs cos (scatter)\",\n        xlabel=r\"$\\sin$\",\n        ylabel=r\"$\\cos$\",\n    )\n\n    # Row 2, Col 0: series with discrete/map style (stem-like effect)\n    series.plot(\n        x=ks,\n        y=xs,\n        style=\"map\",\n        ax=ax[2, 0],\n        color=\"C4\",\n        title=\"series.plot: logistic iterations (map style)\",\n        xlabel=\"n\",\n        ylabel=\"$x_n$\",\n    )\n\n    # Row 2, Col 1: series with mixed style (line + markers)\n    series.plot(\n        x=ks,\n        y=xs,\n        style=\"mixed\",\n        ax=ax[2, 1],\n        color=\"C5\",\n        title=\"series.plot: logistic iterations (mixed style)\",\n        xlabel=\"n\",\n        ylabel=\"$x_n$\",\n    )\n\n    # Tighten layout and show\n    export.show()\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> Presents one figure with six subplots to showcase <code>series.stem</code>, <code>series.step</code>, <code>utils.hist</code>, <code>phase.xy</code>, and the <code>series.plot</code> styles <code>map</code> and <code>mixed</code>. This is a quick reference for how each helper handles line, stem, histogram, and map-style data.</p>"},{"location":"examples/plotting/#theme-presets","title":"Theme presets","text":"<p><pre><code>#!/usr/bin/env python3\n\"\"\"\nDemonstration of all theme presets available in dynlib.plot.theme.\n\nThis script creates a sample figure for each preset and saves it as an image.\n\"\"\"\n\nimport numpy as np\nfrom dynlib.plot import fig, series, theme, export, utils\n\n\ndef create_sample_figure():\n    \"\"\"Create a sample figure with various plot elements.\"\"\"\n    # Generate sample data\n    t = np.linspace(0, 10, 100)\n    y1 = np.sin(t)\n    y2 = np.cos(t)\n    y3 = np.sin(t) * np.exp(-t / 10)\n\n    # Create figure with subplots\n    ax = fig.grid(rows=2, cols=2, size=(8, 6))\n\n    # Line plot\n    series.plot(x=t, y=y1, ax=ax[0, 0], label=\"sin(t)\", xlabel=\"Time\", ylabel=\"Amplitude\", title=\"Line Plot\")\n\n    # Scatter plot\n    series.plot(x=t[::5], y=y2[::5], ax=ax[0, 1], style=\"scatter\", label=\"cos(t) samples\", xlabel=\"Time\", ylabel=\"Amplitude\", title=\"Scatter Plot\")\n\n    # Multiple lines\n    series.plot(x=t, y=y1, ax=ax[1, 0], label=\"sin(t)\", color=\"C0\")\n    series.plot(x=t, y=y2, ax=ax[1, 0], label=\"cos(t)\", color=\"C1\")\n    series.plot(x=t, y=y3, ax=ax[1, 0], label=\"damped sin(t)\", color=\"C2\")\n    ax[1, 0].set_xlabel(\"Time\")\n    ax[1, 0].set_ylabel(\"Amplitude\")\n    ax[1, 0].set_title(\"Multiple Lines\")\n    ax[1, 0].legend()\n\n    # Histogram\n    data = np.random.normal(0, 1, 1000)\n    utils.hist(y=data, ax=ax[1, 1], bins=30, xlabel=\"Value\", ylabel=\"Frequency\", title=\"Histogram\")\n\n    return ax[0, 0].figure\n\n\ndef main():\n    \"\"\"Demonstrate each theme preset.\"\"\"\n    presets = [\"notebook\", \"paper\", \"talk\", \"dark\", \"mono\"]\n\n    for preset in presets:\n        print(f\"Creating figure with '{preset}' preset...\")\n\n        # Apply theme\n        theme.use(preset)\n\n        # Create sample figure\n        fig = create_sample_figure()\n\n        # Save figure\n        export.savefig(fig, f\"theme_{preset}\", fmts=(\"png\",), dpi=150)\n\n        print(f\"Saved theme_{preset}.png\")\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> Iterates through the <code>notebook</code>, <code>paper</code>, <code>talk</code>, <code>dark</code>, and <code>mono</code> themes, renders a sample figure, and saves PNGs so you can inspect how each preset affects colors, gridlines, and typography.</p>"},{"location":"examples/plotting/#faceted-histograms","title":"Faceted histograms","text":"<p><pre><code>import dynlib.plot as plot\nimport numpy as np\n\n# Sample data: a dictionary where keys are categories and values are data arrays\ndata = {\n    'Category A': np.random.randn(100),\n    'Category B': np.random.randn(100) + 1,\n    'Category C': np.random.randn(100) - 1,\n}\n\n# Create facets: 2 columns, with a title\nfor ax, key in plot.facet.wrap(data.keys(), cols=2, title='Data by Category'):\n    values = data[key]\n    ax.hist(values, bins=20, alpha=0.7)\n    ax.set_title(f'Histogram for {key}')\n    ax.set_xlabel('Value')\n    ax.set_ylabel('Frequency')\n\n# Display the plot\nplot.export.show()\n</code></pre> Uses <code>plot.facet.wrap</code> to build a grid of histogram panels for multiple categories. Each axis receives its own data slice plus titles/labels so you can explore the data-distribution helper without manually creating <code>plt.subplots</code>.</p>"},{"location":"examples/plotting/#vector-field-helper","title":"Vector field helper","text":"<p><pre><code>from __future__ import annotations\n\n\"\"\"\nDemonstration of the dynlib.plot.vectorfield helper.\n\"\"\"\n\nimport numpy as np\n\nfrom dynlib import build, plot\n\n\ndef _make_model():\n    # Simple spiral system with tunable linear terms\n    model_uri = \"\"\"\ninline:\n[model]\ntype = \"ode\"\nname = \"spiral\"\n\n[sim]\nt0 = 0.0\ndt = 0.1\n\n[states]\nx = 0.0\ny = 0.0\n\n[params]\na = 0.8\nb = 0.2\n\n[equations.rhs]\nx = \"a * x - y\"\ny = \"x + b * y\"\n\"\"\"\n    return build(model_uri, jit=False, disk_cache=False)\n\n\ndef main() -&gt; None:\n    plot.theme.use(\"notebook\")\n    model = _make_model()\n\n    ax = plot.fig.single(title=\"Vector field demo\")\n\n    handle = plot.vectorfield(\n        model,\n        ax=ax,\n        xlim=(-2, 2),\n        ylim=(-2, 2),\n        grid=(25, 25),\n        normalize=True,\n        speed_color=True,\n        speed_cmap=\"plasma\",\n        nullclines=True,\n        nullcline_style={\"colors\": [\"#333333\"], \"linewidths\": 1.2, \"alpha\": 0.6},\n    )\n\n    # Update parameters and redraw to illustrate handle.update()\n    handle.update(params={\"a\": 1.2, \"b\": -0.1})\n\n    plot.export.show()\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> Shows <code>plot.vectorfield</code> with a spiral model, getter handles that update parameters (<code>a</code>, <code>b</code>), nullclines, and a custom color mapping for speed. It demonstrates how the returned handle can redraw the vector field when you tweak parameters interactively.</p>"},{"location":"examples/plotting/#animated-swept-vector-fields","title":"Animated &amp; swept vector fields","text":""},{"location":"examples/plotting/#vector-field-animation-demo","title":"Vector field animation demo","text":"<p><pre><code>from __future__ import annotations\n\n\"\"\"Demonstration of plot.vectorfield_animate for a simple spiral system.\"\"\"\n\nfrom dynlib import build, plot\n\n\ndef _make_model():\n    model_uri = \"\"\"\ninline:\n[model]\ntype = \"ode\"\nname = \"spiral\"\n\n[sim]\nt0 = 0.0\ndt = 0.05\n\n[states]\nx = 0.0\ny = 0.0\n\n[params]\na = -0.4\nb = 0.25\n\n[equations.rhs]\nx = \"a * x - y\"\ny = \"x + b * y\"\n\"\"\"\n    return build(model_uri, jit=False, disk_cache=False)\n\n\ndef main() -&gt; None:\n    plot.theme.use(\"notebook\")\n    model = _make_model()\n\n    values = [v for v in (-1.0, -0.4, 0.0, 0.6, 1.0, 1.4)]\n    # You have to define anim (or any other name) even if you don't use it. \n    # Otherwise it gets garbage collected.\n    anim = plot.vectorfield_animate(\n        model,\n        param=\"a\",\n        values=values,\n        xlim=(-2.5, 2.5),\n        ylim=(-2.5, 2.5),\n        grid=(24, 24),\n        normalize=True,\n        speed_color=True,\n        speed_cmap=\"plasma\",\n        title_func=lambda v, idx: f\"Vector field: a={float(v):.2f}\",\n        nullclines=True,\n        nullcline_style={\"colors\": [\"#333333\"], \"linewidths\": 1.0, \"alpha\": 0.6},\n        interactive=False,\n        fps=3,\n        blit=False,\n    )\n\n    # Preview the animation in notebook/backends that support it, or save via anim.animation.save(...)\n    plot.export.show()\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> Uses <code>plot.vectorfield_animate</code> to step the <code>a</code> parameter through several profiles while normalizing and color-mapping the speed. The animation can preview in notebooks or be saved later with Matplotlib writers.</p>"},{"location":"examples/plotting/#dense-vector-field-animation","title":"Dense vector field animation","text":"<p><pre><code># An interesting animation that I like.\n\nimport numpy as np\nfrom dynlib.plot import export, vectorfield_animate\n\n\nDSL = \"\"\"\ninline:\n[model]\ntype=\"ode\"\n\n[states]\nx=0.0\ny=0.0\n\n[params]\nk=0.0\n\n[equations.rhs]\nx = \"sin(k*y)\"\ny = \"sin(k*x)\"\n\"\"\"\n\n# You have to define anim (or any other name) even if you don't use it. \n# Otherwise it gets garbage collected.\nanim=vectorfield_animate(DSL, \n                    param=\"k\", \n                    values=np.linspace(0.1,10,300), \n                    xlim=(-10, 10), \n                    ylim=(-10, 10), \n                    grid=(24, 24), \n                    interval=130,\n                    normalize=True,\n                    title_func=lambda v, idx: f\"Vector field: k={float(v):.2f}\",\n                    )\n\n# Save using writer of your choice, e.g., \"ffmpeg\", \"pillow\", etc.\n# anim.save(\"vectorfield_animation.gif\", writer=\"pillow\", dpi=150)\n\nexport.show()\n</code></pre> Builds a sin/cos-based vector field and sweeps the frequency <code>k</code> across 300 frames, giving you an extensive example of how to keep the <code>anim</code> handle alive so it doesn't get garbage-collected before you save.</p>"},{"location":"examples/plotting/#high-dimensional-slices","title":"High-dimensional slices","text":"<p><pre><code>from __future__ import annotations\n\n\"\"\"\nDemonstration of projecting a higher-dimensional vector field onto chosen 2D planes.\n\nWe use the 3D Lorenz system and visualize two slices:\n- x/y plane with z fixed (and then updated to a new z to show handle.update)\n- y/z plane with x fixed\n\nClick on either panel to launch a short trajectory through that slice.\n\"\"\"\n\nfrom dynlib import build, plot\n\n\ndef _lorenz_model():\n    model_uri = \"\"\"\ninline:\n[model]\ntype = \"ode\"\nname = \"lorenz-3d\"\nstepper = \"rk4\"\n\n[sim]\nt0 = 0.0\ndt = 0.01\nt_end = 8.0\n\n[states]\nx = 1.0\ny = 1.0\nz = 1.0\n\n[params]\nsigma = 10.0\nrho = 28.0\nbeta = 2.6666666666666665\n\n[equations.rhs]\nx = \"sigma * (y - x)\"\ny = \"x * (rho - z) - y\"\nz = \"x * y - beta * z\"\n\"\"\"\n    return build(model_uri, jit=False, disk_cache=False)\n\n\ndef main() -&gt; None:\n    plot.theme.use(\"notebook\")\n    model = _lorenz_model()\n\n    ax = plot.fig.grid(rows=1, cols=2, size=(12, 5), sharex=False, sharey=False)\n\n    handle_xy = plot.vectorfield(\n        model,\n        ax=ax[0, 0],\n        vars=(\"x\", \"y\"),\n        fixed={\"z\": 5.0},\n        xlim=(-20, 20),\n        ylim=(-30, 30),\n        grid=(25, 25),\n        normalize=False,\n        nullclines=False,\n        T=6.0,\n        dt=0.01,\n        trajectory_style={\"color\": \"C0\"},\n    )\n    ax[0, 0].set_title(\"x-y slice with z fixed (click to trace)\", fontsize=11)\n\n    handle_yz = plot.vectorfield(\n        model,\n        ax=ax[0, 1],\n        vars=(\"y\", \"z\"),\n        fixed={\"x\": 0.0},\n        xlim=(-30, 30),\n        ylim=(0, 50),\n        grid=(25, 25),\n        normalize=False,\n        nullclines=False,\n        T=6.0,\n        dt=0.01,\n        trajectory_style={\"color\": \"C1\"},\n    )\n    ax[0, 1].set_title(\"y-z slice with x fixed (click to trace)\", fontsize=11)\n\n    # Show that fixed values can be updated without rebuilding the figure.\n    handle_xy.update(fixed={\"z\": 15.0}, redraw=True)\n    handle_xy.ax.set_title(\"x-y slice with z updated to 15.0\", fontsize=11)\n\n    plot.export.show()\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> Projects the 3D Lorenz vector field onto two different 2D slices (<code>x/y</code> and <code>y/z</code>) with adjustable fixed-state values. The demo lets you click either panel to trigger a trajectory trace and shows how to reuse the returned handle to update the slice without recreating axes.</p>"},{"location":"examples/plotting/#vector-field-sweeps","title":"Vector field sweeps","text":"<p><pre><code>from __future__ import annotations\n\n\"\"\"Demonstration of plot.vectorfield_sweep for a simple 2D system.\"\"\"\n\nfrom dynlib import build, plot\n\n\ndef _make_model():\n    model_uri = \"\"\"\ninline:\n[model]\ntype = \"ode\"\nname = \"spiral\"\n\n[sim]\nt0 = 0.0\ndt = 0.05\n\n[states]\nx = 0.0\ny = 0.0\n\n[params]\na = 0.5\nb = -0.2\n\n[equations.rhs]\nx = \"a * x - y\"\ny = \"x + b * y\"\n\"\"\"\n    return build(model_uri, jit=False, disk_cache=False)\n\n\ndef main() -&gt; None:\n    plot.theme.use(\"notebook\")\n    model = _make_model()\n\n    plot.vectorfield_sweep(\n        model,\n        param=\"a\",\n        values=[-0.6, 0.0, 0.6, 1.2],\n        xlim=(-2.5, 2.5),\n        ylim=(-2.5, 2.5),\n        grid=(22, 22),\n        normalize=True,\n        speed_color=True,\n        speed_cmap=\"plasma\",\n        cols=2,\n        facet_titles=\"a={value:.2f}\",\n        title=\"Vector field sweep over parameter 'a'\",\n        nullclines=True,\n        nullcline_style={\"colors\": [\"#333333\"], \"linewidths\": 1.0, \"alpha\": 0.6},\n        interactive=False,\n        size=(8,6)\n    )\n\n    plot.export.show()\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> Sweeps the spiral model over a list of <code>a</code> values, arranges the resulting fields in a grid, and shows how <code>plot.vectorfield_sweep</code> automatically handles layout, nullclines, and annotations so you can compare parameter regimes at a glance.</p>"},{"location":"examples/runtime/","title":"Runtime utilities and diagnostics","text":""},{"location":"examples/runtime/#overview","title":"Overview","text":"<p>The runtime utilities in this suite exercise dynlib's low-level control hooks: <code>setup()</code> can drive a broad range of steppers, stop conditions, and event observers, while helper APIs reveal what the compiler built or what a trajectory is doing in real time. These scripts demonstrate how to sanity-check numerical accuracy, cancel simulations early, detect interesting transitions, and print the DSL equations so you can audit what is actually running inside <code>Sim</code>.</p>"},{"location":"examples/runtime/#example-scripts","title":"Example scripts","text":""},{"location":"examples/runtime/#stepper-accuracy-ranking","title":"Stepper accuracy ranking","text":"<p><pre><code>import numpy as np\nimport warnings\nfrom dynlib import setup, list_steppers, get_stepper\n\n# Suppress RuntimeWarnings to avoid cluttering output with solver convergence messages\nwarnings.simplefilter(\"ignore\", RuntimeWarning)\n\n# Define models and their exact solutions\nmodels = [\n    {\n        \"name\": \"Exponential Decay\",\n        \"model\": '''\ninline:\n[model]\ntype=\"ode\"\n\n[states]\nx=1.0\n\n[params]\na=1.0\n\n[equations]\nexpr = \"\"\"\ndx = -a * x\n\"\"\"\n''',\n        \"exact\": lambda t: np.exp(-t)\n    },\n    {\n        \"name\": \"Harmonic Oscillator\",\n        \"model\": '''\ninline:\n[model]\ntype=\"ode\"\n\n[states]\nx=1.0\nv=0.0\n\n[params]\nomega=100.0\n\n[equations]\nexpr = \"\"\"\ndx = v\ndv = -omega**2 * x\n\"\"\"\n''',\n        \"exact\": lambda t: (np.cos(100.0 * t), -100.0 * np.sin(100.0 * t))\n    }\n]\n\n# Simulation parameters\nT = 10  # total time\ndt = 1e-4  # time step\nN = int(T / dt)  # number of steps\n\node_steppers = list_steppers(kind=\"ode\")\n\nfor model_info in models:\n    model_name = model_info[\"name\"]\n    model_str = model_info[\"model\"]\n    exact_func = model_info[\"exact\"]\n\n    print(f\"\\n=== {model_name} ===\")\n\n    # Dictionary to store errors\n    errors = {}\n    failed_steppers = {}\n\n    for name in ode_steppers:\n        spec = get_stepper(name)\n        try:        \n            print(f\"Running simulation with stepper: {name}\")\n\n            # Setup simulation\n            sim = setup(model_str, stepper=name, jit=False)\n            sim.config(dt=dt, max_steps=N*10)  # allow more steps if needed\n\n            # Run simulation\n            sim.run(T=T)\n            res = sim.results()\n\n            # Compute relative error on x\n            if model_name == \"Exponential Decay\":\n                x_exact = exact_func(res.t)\n                rel_error = np.abs((res[\"x\"] - x_exact) / x_exact)\n            else:  # Harmonic Oscillator\n                x_exact, v_exact = exact_func(res.t)\n                rel_error = np.abs((res[\"x\"] - x_exact) / x_exact)\n\n            rms_rel_error = np.sqrt(np.mean(rel_error**2))\n\n            errors[name] = rms_rel_error\n            print(f\"RMS relative error for {name}: {rms_rel_error:.2e}\")\n\n        except Exception as e:\n            print(f\"Error with stepper {name}: {e}\")\n            failed_steppers[name] = str(e)\n            continue\n\n    # Sort steppers by accuracy (lowest error first)\n    sorted_steppers = sorted(errors.items(), key=lambda x: x[1])\n\n    print(f\"\\n{model_name} - Stepper accuracy ranking (lowest RMS relative error = most accurate):\")\n    for rank, (name, error) in enumerate(sorted_steppers, 1):\n        print(f\"{rank}. {name}: {error:.2e}\")\n\n    if failed_steppers:\n        print(f\"\\n{model_name} - Failed steppers:\")\n        for name, error_msg in failed_steppers.items():\n            print(f\"- {name}: {error_msg}\")\n</code></pre> Runs every registered ODE stepper against two analytic solutions (exponential decay and the harmonic oscillator) with a tiny constant <code>dt</code>. Each run computes an RMS relative error so you can sort steppers by accuracy, log failures, and compare how each integrator behaves when your time step is near its stability limit.</p>"},{"location":"examples/runtime/#early-exit-macros","title":"Early exit macros","text":"<p><pre><code>\"\"\"\nEarly Exit Demo\n===============\n\nThis example demonstrates the early exit feature using the `stop` condition\nwith built-in DSL macros. The simulation will terminate early when a specified\ncondition is met.\n\nAvailable macros for stop conditions:\n- cross_up(state, threshold): detects upward threshold crossing\n- cross_down(state, threshold): detects downward threshold crossing  \n- in_interval(state, lower, upper): checks if state is in range\n- enters_interval(state, lower, upper): detects entering a range\n- leaves_interval(state, lower, upper): detects leaving a range\n- increasing(state): detects if state is increasing\n- decreasing(state): detects if state is decreasing\n- changed(state): detects any change in state\n\nNote: Event macros that use lagged values (like cross_up) require the\nsimulation to have at least one prior step, so they won't trigger at t0.\n\"\"\"\n\nfrom dynlib import setup\n\n\ndef get_exit_reason(res):\n    \"\"\"Return a user-friendly description of why the simulation ended.\"\"\"\n    if res.exited_early:\n        return \"Early exit (stop condition met)\"\n    elif res.ok:\n        return \"Completed normally (max steps reached)\"\n    else:\n        return \"Failed or interrupted\"\n\n\ndef demo_simple_threshold():\n    \"\"\"Example 1: Stop using a simple threshold condition\"\"\"\n    print(\"\\n\" + \"=\" * 70)\n    print(\"Example 1: Simple Threshold (x &gt; 0.8)\")\n    print(\"=\" * 70)\n\n    model = '''\ninline:\n[model]\ntype = \"map\"\nname = \"Logistic Map - Simple Threshold\"\n\n[states]\nx = 0.1\n\n[params]\nr = 3.5\n\n[equations.rhs]\nx = \"r * x * (1 - x)\"\n\n[sim]\nt0 = 0.0\ndt = 1.0\nstepper = \"map\"\nrecord = true\nstop = \"x &gt; 0.8\"\n'''\n\n    sim = setup(model, jit=False)\n    sim.run(N=100)\n    res = sim.results()\n\n    print(f\"Exit reason: {get_exit_reason(res)}\")\n    print(f\"Steps executed: {res.step_count_final}\")\n    print(f\"Final state: x = {res['x'][-1]:.6f}\")\n    print(f\"Interpretation: Stopped when x first exceeded 0.8\")\n\n\ndef demo_interval_check():\n    \"\"\"Example 2: Stop using in_interval macro\"\"\"\n    print(\"\\n\" + \"=\" * 70)\n    print(\"Example 2: Interval Check with in_interval()\")\n    print(\"=\" * 70)\n\n    model = '''\ninline:\n[model]\ntype = \"map\"\nname = \"Logistic Map - Interval Check\"\n\n[states]\nx = 0.1\n\n[params]\nr = 3.5\n\n[equations.rhs]\nx = \"r * x * (1 - x)\"\n\n[sim]\nt0 = 0.0\ndt = 1.0\nstepper = \"map\"\nrecord = true\nstop = \"in_interval(x, 0.82, 0.86)\"\n'''\n\n    sim = setup(model, jit=False)\n    sim.run(N=100)\n    res = sim.results()\n\n    print(f\"Exit reason: {get_exit_reason(res)}\")\n    print(f\"Steps executed: {res.step_count_final}\")\n    print(f\"Final state: x = {res['x'][-1]:.6f}\")\n    print(f\"Interpretation: Stopped when x entered the interval [0.82, 0.86]\")\n\n\ndef demo_cross_up():\n    \"\"\"Example 3: Stop using cross_up macro (requires lag)\"\"\"\n    print(\"\\n\" + \"=\" * 70)\n    print(\"Example 3: Threshold Crossing with cross_up()\")\n    print(\"=\" * 70)\n\n    model = '''\ninline:\n[model]\ntype = \"map\"\nname = \"Logistic Map - Cross Up Detection\"\n\n[states]\nx = 0.1\n\n[params]\nr = 3.5\n\n[equations.rhs]\nx = \"r * x * (1 - x)\"\n\n[sim]\nt0 = 0.0\ndt = 1.0\nstepper = \"map\"\nrecord = true\nstop = \"cross_up(x, 0.8)\"\n'''\n\n    sim = setup(model, jit=False)\n    sim.run(N=100)\n    res = sim.results()\n\n    print(f\"Exit reason: {get_exit_reason(res)}\")\n    print(f\"Steps executed: {res.step_count_final}\")\n    print(f\"Final state: x = {res['x'][-1]:.6f}\")\n    if res.n &gt;= 2:\n        print(f\"Previous state: x = {res['x'][-2]:.6f}\")\n        print(f\"Interpretation: Stopped when x crossed 0.8 from below\")\n        print(f\"  (previous: {res['x'][-2]:.6f} &lt;= 0.8, current: {res['x'][-1]:.6f} &gt; 0.8)\")\n\n\ndef demo_decreasing():\n    \"\"\"Example 4: Stop when state starts decreasing\"\"\"\n    print(\"\\n\" + \"=\" * 70)\n    print(\"Example 4: Detect Decreasing Trend with decreasing()\")\n    print(\"=\" * 70)\n\n    model = '''\ninline:\n[model]\ntype = \"map\"\nname = \"Logistic Map - Detect Decrease\"\n\n[states]\nx = 0.1\n\n[params]\nr = 3.5\n\n[equations.rhs]\nx = \"r * x * (1 - x)\"\n\n[sim]\nt0 = 0.0\ndt = 1.0\nstepper = \"map\"\nrecord = true\nstop = \"decreasing(x)\"\n'''\n\n    sim = setup(model, jit=False)\n    sim.run(N=100)\n    res = sim.results()\n\n    print(f\"Exit reason: {get_exit_reason(res)}\")\n    print(f\"Steps executed: {res.step_count_final}\")\n    print(f\"Final state: x = {res['x'][-1]:.6f}\")\n    if res.n &gt;= 2:\n        print(f\"Previous state: x = {res['x'][-2]:.6f}\")\n        print(f\"Interpretation: Stopped when x started decreasing\")\n        print(f\"  (previous: {res['x'][-2]:.6f}, current: {res['x'][-1]:.6f})\")\n\n\nif __name__ == \"__main__\":\n    print(\"\\n\" + \"=\" * 70)\n    print(\"EARLY EXIT FEATURE DEMONSTRATION\")\n    print(\"Using Built-in DSL Macros for Stop Conditions\")\n    print(\"=\" * 70)\n\n    demo_simple_threshold()\n    demo_interval_check()\n    demo_cross_up()\n    demo_decreasing()\n\n    print(\"\\n\" + \"=\" * 70)\n    print(\"Demo Complete!\")\n    print(\"=\" * 70)\n    print(\"\\nKey Takeaways:\")\n    print(\"  \u2022 Use res.exited_early to check if stop condition was triggered\")\n    print(\"  \u2022 res.ok is True for both normal completion and early exit\")\n    print(\"  \u2022 Simple conditions (x &gt; 0.8) work at any step\")\n    print(\"  \u2022 in_interval() checks current state without lag\")\n    print(\"  \u2022 cross_up(), decreasing(), etc. use lag and require prior steps\")\n    print(\"  \u2022 All conditions are evaluated after each simulation step\")\n    print(\"=\" * 70 + \"\\n\")\n</code></pre> Explores the DSL <code>stop</code> macros such as <code>cross_up</code>, <code>in_interval</code>, and <code>decreasing</code>. For several logistic-map variants the script runs up to 100 steps but halts as soon as the condition becomes true, printing the exit reason, executed steps, and the values just before/after the trigger. It highlights how stopping early keeps the run deterministic while saving time.</p>"},{"location":"examples/runtime/#transition-detection-via-events","title":"Transition detection via events","text":"<p><pre><code>from dynlib import setup\nfrom dynlib.plot import series, export, theme\n\n\"\"\"\nThis example demonstrate lagging mechanism to detect trasition \nfrom negative to positive value in one of the state variables \nof a chaotic system.\n\"\"\"\n\ndetect_mod = '''\ninline:\n[mod]\nname = \"detect_transition\"\n\n[mod.add.events.detect]\ncond = \"cross_up(x, 0)\"\nphase = \"post\"\nlog = [\"t\"]\n'''\n\nsim = setup(\"builtin://ode/lorenz\", stepper=\"rk4\", jit=False, mods=[detect_mod])\nsim.config(dt=0.01)\nsim.run(T=50.0, transient=10.0)\n\nres = sim.results()\nev = res.event(\"detect\")\n\ntheme.use(\"paper\")\n\nseries.plot(x=res.t,\n            y=res[\"x\"],\n            vlines=ev.t,\n            xlabel='Time',\n            xlabel_fs=11, # Theme override\n            ylabel='x',\n            title='Lorenz system: x variable with transition detection')\n\nexport.show()\n</code></pre> Adds an event that fires when the Lorenz <code>x</code> variable crosses zero from below. The run records the timestamp of each <code>detect</code> event, draws vertical lines on the <code>x(t)</code> series plot, and demonstrates how to inspect <code>res.event(\"detect\")</code> to drive annotations or downstream logic in chaotic regimes.</p>"},{"location":"examples/runtime/#printing-compiled-equations","title":"Printing compiled equations","text":"<p><pre><code># examples/print_equations_demo.py\n\"\"\"\nDemonstrate printing model equations from the DSL spec.\n\nPrints the equations for the built-in Henon map and Lorenz system.\n\"\"\"\n\nfrom dynlib import setup\n\n\ndef main() -&gt; None:\n    print(\"Henon map equations:\")\n    sim_henon = setup(\"builtin://map/henon\", stepper=\"map\", jit=False)\n    sim_henon.model.print_equations()\n\n    print(\"\\nLorenz system equations:\")\n    sim_lorenz = setup(\"builtin://ode/lorenz\", stepper=\"rk4\", jit=False)\n    sim_lorenz.model.print_equations(tables=(\"equations\", \"equations.jacobian\"))\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> Builds the Henon map and Lorenz system with <code>jit=False</code> and simply prints the RHS and Jacobian tables that the compiler derives from Toml or builtin specs. This is handy when you need to confirm that <code>dynlib</code> sees the model you expect before running expensive simulations.</p>"},{"location":"examples/state-management/","title":"State, URI, and source-management demos","text":""},{"location":"examples/state-management/#overview","title":"Overview","text":"<p>These scripts highlight the ways dynlib exposes the compiled artifacts, externalizes simulation state, and resolves models from different URI schemes. Use them when you want to checkpoint a run, save or reload presets, export generated Python source for inspection, or understand how <code>setup()</code> picks a model from inline text, files, or config-based tags.</p>"},{"location":"examples/state-management/#example-scripts","title":"Example scripts","text":""},{"location":"examples/state-management/#snapshots-exportimport","title":"Snapshots &amp; export/import","text":"<p><pre><code># examples/snapshot_demo.py\n\"\"\"\nDemonstration of snapshot export/import functionality in dynlib.\n\nThis example shows how to:\n1. Export current simulation state to disk (including workspaces)\n2. Export named snapshots to disk\n3. Import snapshots from disk\n4. Inspect snapshot metadata\n5. Demonstrate workspace persistence across sessions\n\"\"\"\n\nfrom pathlib import Path\nimport tempfile\nimport tomllib\nfrom dynlib import setup\n\n\ndef create_model():\n    \"\"\"Create a simple exponential decay model for demonstration.\"\"\"\n    model_uri = \"\"\"\ninline:\n[model]\ntype = \"ode\"\nname = \"Demo Exponential Decay\"\ndtype = \"float64\"\n\n[states]\nx = 1.0\n\n[params]\ndecay_rate = 0.1\n\n[equations.rhs]\nx = \"-decay_rate * x\"\n\n[sim]\nstepper = \"euler\"\ndt = 0.01\nt0 = 0.0\nt_end = 10.0\nrecord = true\n\"\"\"\n\n    return setup(model_uri, jit=True)\ndef main():\n    print(\"=== Dynlib Snapshot Export/Import Demo ===\\n\")\n\n    # Create simulation\n    sim = create_model()\n    print(\"\u2713 Created simulation with exponential decay model\")\n\n    # Run to some intermediate state\n    sim.run(T=2.0)\n    print(f\"\u2713 Ran simulation to t=2.0, current state: x={sim.state_vector()[0]:.4f}\")\n\n    # Create an in-memory snapshot\n    sim.create_snapshot(\"checkpoint_1\", \"After running to t=2.0\")\n    print(\"\u2713 Created in-memory snapshot 'checkpoint_1'\")\n\n    # Continue running\n    sim.run(T=5.0, resume=True)\n    print(f\"\u2713 Continued to t=5.0, current state: x={sim.state_vector()[0]:.4f}\")\n\n    with tempfile.TemporaryDirectory() as tmp_dir:\n        tmp_path = Path(tmp_dir)\n\n        # Export current state\n        current_snap_path = tmp_path / \"current_state.npz\"\n        sim.export_snapshot(current_snap_path, source=\"current\")\n        print(f\"\u2713 Exported current state to {current_snap_path.name}\")\n\n        # Export the named snapshot\n        named_snap_path = tmp_path / \"checkpoint_1.npz\"\n        sim.export_snapshot(named_snap_path, source=\"snapshot\", name=\"checkpoint_1\")\n        print(f\"\u2713 Exported named snapshot to {named_snap_path.name}\")\n\n        # Inspect the snapshots without loading them\n        print(\"\\n--- Snapshot Inspection ---\")\n        for path in [current_snap_path, named_snap_path]:\n            meta = sim.inspect_snapshot(path)\n            print(f\"{path.name}:\")\n            print(f\"  Schema: {meta['schema']}\")\n            print(f\"  Name: {meta['name']}\")\n            print(f\"  Time: {meta['t_curr']:.3f}\")\n            print(f\"  State: x={meta['state_names'][0]}\")\n            print(f\"  Workspace signature: {meta['pins']['workspace_sig']}\")\n            print(f\"  Created: {meta['created_at']}\")\n            print()\n\n        # Continue simulation further\n        sim.run(T=8.0, resume=True)\n        current_x = sim.state_vector()[0]\n        print(f\"\u2713 Continued to t=8.0, current state: x={current_x:.4f}\")\n\n        # Import the earlier snapshot\n        print(\"\\n--- Importing Snapshot ---\")\n        sim.import_snapshot(named_snap_path)\n        restored_x = sim.state_vector()[0]\n        restored_t = sim.session_state_summary()[\"t\"]\n        print(f\"\u2713 Imported snapshot from t=2.0\")\n        print(f\"  Restored state: t={restored_t:.3f}, x={restored_x:.4f}\")\n\n        # Verify results are cleared\n        try:\n            results = sim.raw_results()\n            print(\"\u2717 ERROR: Results should be cleared after import!\")\n        except RuntimeError as e:\n            print(f\"\u2713 Results correctly cleared: {e}\")\n\n        # Can continue from restored state\n        sim.run(T=3.0, resume=True)\n        final_x = sim.state_vector()[0]\n        print(f\"\u2713 Resumed from restored state to t=3.0, x={final_x:.4f}\")\n\n        # Demonstrate workspace persistence\n        print(\"\\n--- Workspace Persistence ---\")\n        # Create a new simulation to show workspace restoration\n        sim2 = create_model()\n        sim2.run(T=1.0)  # Run to different state\n\n        # Export current state with workspace\n        ws_snap_path = tmp_path / \"workspace_demo.npz\"\n        sim.export_snapshot(ws_snap_path, source=\"current\")\n        print(\"\u2713 Exported simulation state with workspace\")\n\n        # Import into new simulation\n        sim2.import_snapshot(ws_snap_path)\n        print(\"\u2713 Imported state with workspace into new simulation\")\n\n        # Verify state was restored\n        restored_state = sim2.session_state_summary()\n        print(f\"  Restored time: {restored_state['t']:.3f}\")\n        print(f\"  Restored state: x={sim2.state_vector()[0]:.4f}\")\n        print(f\"  Can resume: {restored_state['can_resume']}\")\n\n    print(\"\\n=== Demo Complete ===\")\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> Builds a simple exponential-decay model, runs to a few time points, and then demonstrates <code>sim.create_snapshot</code>, <code>sim.export_snapshot</code>, and <code>sim.import_snapshot</code>. The script prints snapshot metadata, shows how workspaces survive across exports, and verifies that <code>sim.results()</code> is cleared after restoring a snapshot so you can safely resume from arbitrary points.</p>"},{"location":"examples/state-management/#exporting-the-compiled-sources","title":"Exporting the compiled sources","text":"<p><pre><code># examples/export_sources_demo.py\n\"\"\"\nDemonstration of compiled model source code export functionality.\n\nThis example shows how to:\n1. Build a compiled model using setup()\n2. Export the generated Python source code for inspection\n3. Verify the compilation is correct\n\"\"\"\n\nfrom pathlib import Path\nimport tempfile\nfrom dynlib import setup\n\ndef main():\n    # Use an existing test model\n    model_path = Path(__file__).parent.parent / \"tests\" / \"data\" / \"models\" / \"decay.toml\"\n\n    # Setup simulation with JIT compilation\n    print(f\"Building model from: {model_path.name}\")\n    sim = setup(str(model_path), stepper=\"euler\", jit=True, disk_cache=False)\n\n    # Check if source code is available\n    print(f\"\\nSource code availability:\")\n    print(f\"  RHS source: {'\u2713' if sim.model.rhs_source else '\u2717'}\")\n    print(f\"  Events pre source: {'\u2713' if sim.model.events_pre_source else '\u2717'}\")\n    print(f\"  Events post source: {'\u2713' if sim.model.events_post_source else '\u2717'}\")\n    print(f\"  Stepper source: {'\u2713' if sim.model.stepper_source else '\u2717'}\")\n\n    # Export sources to a temporary directory\n    with tempfile.TemporaryDirectory() as tmpdir:\n        export_dir = Path(tmpdir) / \"compiled_model\"\n        print(f\"\\nExporting sources to: {export_dir}\")\n\n        exported_files = sim.model.export_sources(export_dir)\n\n        print(f\"\\nExported files:\")\n        for component, filepath in exported_files.items():\n            size = filepath.stat().st_size if filepath.exists() else 0\n            print(f\"  {component}: {filepath.name} ({size} bytes)\")\n\n        # Display the RHS source code\n        if \"rhs\" in exported_files:\n            print(f\"\\n{'='*60}\")\n            print(\"RHS Function Source Code:\")\n            print('='*60)\n            rhs_content = exported_files[\"rhs\"].read_text()\n            print(rhs_content)\n            print('='*60)\n\n        # Display the stepper source code if available\n        if \"stepper\" in exported_files:\n            print(f\"\\n{'='*60}\")\n            print(\"Stepper Function Source Code:\")\n            print('='*60)\n            stepper_content = exported_files[\"stepper\"].read_text()\n            print(stepper_content)\n            print('='*60)\n\n    print(\"\\n\u2713 Export demo completed successfully!\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> Builds a JIT-enabled simulation from <code>tests/data/models/decay.toml</code>, toggles <code>disk_cache=False</code>, and calls <code>sim.model.export_sources()</code> into a temporary directory. The demo checks that the RHS, events, and stepper sources exist, prints their sizes, and shows the contents so you can review what dynlib emitted for debugging or compliance.</p>"},{"location":"examples/state-management/#preset-workflows","title":"Preset workflows","text":"<p><pre><code>#!/usr/bin/env python3\n\"\"\"\nDemo of the presets feature in dynlib v2.\n\nShows:\n- Inline presets defined in the model DSL\n- Listing and applying presets\n- Loading presets from external files\n- Saving presets to files\n- Capturing runtime presets with add_preset\n- Round-trip preservation\n\"\"\"\n\nimport tempfile\nfrom pathlib import Path\nimport tomllib\n\n\nfrom dynlib.dsl.parser import parse_model_v2\nfrom dynlib.dsl.spec import build_spec\nfrom dynlib.compiler.build import build\nfrom dynlib.runtime.sim import Sim\n\n\n# Model with inline presets\nMODEL_TOML = \"\"\"\n[model]\ntype = \"ode\"\nname = \"Izhikevich Neuron (Simple)\"\n\n[states]\nv = -65.0\nu = -13.0\n\n[params]\na = 0.02\nb = 0.2\nc = -65.0\nd = 8.0\nI = 10.0\n\n[equations.rhs]\nv = \"0.04*v*v + 5*v + 140 - u + I\"\nu = \"a*(b*v - u)\"\n\n[events.spike]\nphase = \"post\"\ncond = \"v &gt;= 30\"\nlog = [\"t\"]\n\n[events.spike.action]\nv = \"c\"\nu = \"u + d\"\n\n[sim]\nt0 = 0.0\nt_end = 200.0\ndt = 0.25\nstepper = \"euler\"\nrecord = true\n\n# Inline presets for different neuron behaviors\n[presets.regular_spiking.params]\na = 0.02\nb = 0.2\nc = -65.0\nd = 8.0\nI = 10.0\n\n[presets.fast_spiking.params]\na = 0.1\nb = 0.2\nc = -65.0\nd = 2.0\nI = 10.0\n\n[presets.bursting.params]\na = 0.02\nb = 0.2\nc = -50.0\nd = 2.0\nI = 15.0\n\n[presets.bursting.states]\nv = -70.0\nu = -14.0\n\"\"\"\n\n\ndef main():\n    # Load model\n    print(\"=== Loading model ===\")\n    doc = tomllib.loads(MODEL_TOML)\n    spec = build_spec(parse_model_v2(doc))\n    model = build(spec, stepper=spec.sim.stepper, jit=True)\n    sim = Sim(model)\n\n    # List inline presets\n    print(\"\\n=== Inline presets ===\")\n    presets = sim.list_presets()\n    print(f\"Available presets: {presets}\")\n\n    # Apply a preset and run\n    print(\"\\n=== Applying 'regular_spiking' preset ===\")\n    sim.apply_preset(\"regular_spiking\")\n    sim.run(T=100.0)\n    results = sim.results()\n    event_counts = results.event.summary()\n    n_spikes = event_counts.get('spike', 0)\n    print(f\"Regular spiking: {n_spikes} spikes in 100ms\")\n\n    # Apply different preset\n    print(\"\\n=== Applying 'fast_spiking' preset ===\")\n    sim.reset()  # Reset to initial state\n    sim.apply_preset(\"fast_spiking\")\n    sim.run(T=100.0)\n    results = sim.results()\n    event_counts = results.event.summary()\n    n_spikes = event_counts.get('spike', 0)\n    print(f\"Fast spiking: {n_spikes} spikes in 100ms\")\n\n    # Save presets to file\n    with tempfile.TemporaryDirectory() as tmpdir:\n        preset_file = Path(tmpdir) / \"neuron_presets.toml\"\n\n        print(f\"\\n=== Saving presets to {preset_file.name} ===\")\n        sim.reset()\n        sim.apply_preset(\"regular_spiking\")\n        sim.add_preset(\"regular_spiking\", overwrite=True)\n        sim.save_preset(\"regular_spiking\", preset_file)\n\n        sim.apply_preset(\"fast_spiking\")\n        sim.add_preset(\"fast_spiking\", overwrite=True)\n        sim.save_preset(\"fast_spiking\", preset_file)\n\n        # Check file contents\n        with open(preset_file, \"rb\") as f:\n            doc = tomllib.load(f)\n        print(f\"File contains: {list(doc['presets'].keys())}\")\n\n        # Create a new sim and load from file\n        print(\"\\n=== Loading presets from file ===\")\n        sim2 = Sim(model)\n        count = sim2.load_preset(\"*\", preset_file, on_conflict=\"replace\") # warning should be raised\n        print(f\"Loaded {count} presets\")\n        print(f\"Available: {sim2.list_presets()}\")\n\n        # Verify they work\n        sim2.apply_preset(\"regular_spiking\")\n        sim2.run(T=100.0)\n        results2 = sim2.results()\n        event_counts2 = results2.event.summary()\n        n_spikes2 = event_counts2.get('spike', 0)\n        print(f\"Loaded preset produces {n_spikes2} spikes (should match original)\")\n\n    # Demonstrate glob patterns\n    print(\"\\n=== Glob pattern matching ===\")\n    print(f\"All presets: {sim.list_presets('*')}\")\n    print(f\"Presets starting with 'fast': {sim.list_presets('fast_*')}\")\n    print(f\"Presets ending with 'spiking': {sim.list_presets('*_spiking')}\")\n\n    print(\"\\n=== Demo complete ===\")\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> Builds an inline Izhikevich neuron and then lists/apply the inline <code>regular_spiking</code>, <code>fast_spiking</code>, and <code>bursting</code> presets. It saves the presets to a temporary file, loads them back into a second <code>Sim</code>, and proves that the loaded presets reproduce the spike counts while showcasing glob-style preset matching.</p>"},{"location":"examples/state-management/#uri-and-path-resolution","title":"URI and path resolution","text":"<p><pre><code>#!/usr/bin/env python3\n\"\"\"\nThis script demonstrates the new path resolution and URI system,\nshowing various ways to load and run models.\n\"\"\"\nfrom dynlib import setup\n\n\ndef demo_inline_model():\n    \"\"\"Demo 1: Load a model from inline TOML.\"\"\"\n    print(\"=\" * 60)\n    print(\"Demo 1: Inline Model Definition\")\n    print(\"=\" * 60)\n\n    inline_model = \"\"\"\n    inline:\n    [model]\n    type = \"ode\"\n\n    [states]\n    x = 1.0\n\n    [params]\n    a = 1.0\n\n    [equations.rhs]\n    x = \"-a * x\"\n\n    [sim]\n    t0 = 0.0\n    t_end = 2.0\n    dt = 0.1\n    stepper = \"euler\"\n    \"\"\"\n\n    uri = inline_model\n    sim = setup(uri, stepper=\"euler\", jit=False)\n\n    print(f\"Model kind: {sim.model.spec.kind}\")\n    print(f\"States: {sim.model.spec.states}\")\n    print(f\"Stepper: {sim.model.stepper_name}\")\n\n    # Run simulation\n    sim.run(T=2.0)\n    results = sim.results()\n\n    print(f\"Simulation ran {len(results)} steps\")\n    print(f\"Initial x: {results['x'][0]:.6f}\")\n    print(f\"Final x: {results['x'][-1]:.6f}\")\n    print()\n\n\ndef demo_file_loading():\n    \"\"\"Demo 2: Load a model from existing test file.\"\"\"\n    print(\"=\" * 60)\n    print(\"Demo 2: File-based Model Loading\")\n    print(\"=\" * 60)\n\n    from pathlib import Path\n    data_dir = Path(__file__).parent.parent / \"tests\" / \"data\" / \"models\"\n    model_path = data_dir / \"decay.toml\"\n\n    if not model_path.exists():\n        print(f\"Test data not found: {model_path}\")\n        return\n\n    # Load using absolute path\n    sim = setup(str(model_path), stepper=\"euler\", jit=False)\n\n    print(f\"Loaded from: {model_path}\")\n    print(f\"Model kind: {sim.model.spec.kind}\")\n    print(f\"States: {sim.model.spec.states}\")\n    print(f\"Default stepper: {sim.model.stepper_name}\")\n    print()\n\n\ndef demo_uri_schemes():\n    \"\"\"Demo 3: Show different URI schemes.\"\"\"\n    print(\"=\" * 60)\n    print(\"Demo 3: URI Scheme Examples\")\n    print(\"=\" * 60)\n\n    examples = [\n        (\"inline: [model]\\\\ntype='ode'\", \"Inline TOML definition\"),\n        (\"/abs/path/model.toml\", \"Absolute file path\"),\n        (\"relative/model.toml\", \"Relative path from cwd\"),\n        (\"model\", \"Extensionless (tries model.toml)\"),\n        (\"proj://model.toml\", \"TAG resolution from config\"),\n        (\"model.toml#mod=fast\", \"Fragment selector for mods\"),\n        (\"TAG://path/to/model.toml#mod=variant\", \"Combined TAG + fragment\"),\n    ]\n\n    print(\"Supported URI schemes:\")\n    for uri, description in examples:\n        print(f\"  {uri:40s} - {description}\")\n    print()\n\n    print(\"Configuration:\")\n    print(\"  Config file: ~/.config/dynlib/config.toml (Linux)\")\n    print(\"  Or: ~/Library/Application Support/dynlib/config.toml (macOS)\")\n    print(\"  Or: %APPDATA%\\\\dynlib\\\\config.toml (Windows)\")\n    print()\n    print(\"  Environment overrides:\")\n    print(\"    DYNLIB_CONFIG=/custom/config.toml\")\n    print(\"    DYN_MODEL_PATH=proj=/extra/path,/another\")\n    print()\n\n\ndef main():\n    \"\"\"Run all demos.\"\"\"\n    print(\"\\n\")\n    print(\"\u2554\" + \"\u2550\" * 58 + \"\u2557\")\n    print(\"\u2551\" + \" \" * 10 + \"DYNLIB URI System Demo\" + \" \" * 26 + \"\u2551\")\n    print(\"\u255a\" + \"\u2550\" * 58 + \"\u255d\")\n    print()\n\n    demo_inline_model()\n    demo_file_loading()\n    demo_uri_schemes()\n\n    print(\"=\" * 60)\n    print(\"Demo Complete!\")\n    print(\"=\" * 60)\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> Covers the URI resolver itself by:  - running inline TOML via the <code>inline:</code> scheme,  - loading from absolute and relative filesystem paths,  - showing how to use extensionless names, fragments (<code>#mod=</code>), and <code>proj://</code>/<code>TAG://</code> references,  - and reminding you where config files live (<code>~/.config/dynlib/config.toml</code>, <code>%APPDATA%</code> on Windows, etc.). The script prints what each invocation loaded to make debug easier when a model path is ambiguous.</p>"},{"location":"getting-started/","title":"Getting started with dynlib","text":"<p>These pages walk you through the first steps of using dynlib: from the high-level goals to a working model in just a few commands.</p>"},{"location":"getting-started/#getting-oriented","title":"Getting oriented","text":"<ul> <li>Overview \u2014 explains the philosophy behind dynlib, the core components (DSL, runtime, analysis helpers), and what the project bundles for dynamical-systems exploration.</li> <li>Quickstart \u2014 installs dynlib, validates a builtin model, and runs the first simulation so you can confirm the toolchain works before writing your own models.</li> <li>Your First Model \u2014 builds a self-contained TOML model, wires it into <code>setup(...)</code>, steps it with a named stepper, and inspects the results with the simulation helpers.</li> </ul>"},{"location":"getting-started/first-model/","title":"Your First Model","text":"<p>This guide walks through defining a simple model both as a standalone TOML file and as an inline string that Dynlib can consume without ever touching disk. Refer to the Modeling guides for deeper DSL coverage (DSL basics for the TOML structure, inline models for the inline keyword, and config file if you want to register the file in the model registry).</p>"},{"location":"getting-started/first-model/#1-create-a-toml-spec","title":"1. Create a TOML spec","text":"<p>Pick <code>type = \"map\"</code> or <code>type = \"ode\"</code> depending on the dynamics you need. At minimum supply <code>[model]</code>, <code>[states]</code>, and an equations table.</p> <p>Save this as <code>first-model.toml</code> (or any path you prefer) inside your project:</p> <pre><code>[model]\ntype = \"map\"\nname = \"Simple Logistic Map\"\ndtype = \"float64\"\n\n[params]\nr = 3.9\n\n[states]\nx = 0.2\n\n[equations.rhs]\nx = \"r * x * (1 - x)\"\n</code></pre> <p>The <code>[dsl-basics](../guides/modeling/dsl-basics.md)</code> reference shows every table you can add (constants, aux, events, matrix-style Jacobians, etc.) and how Dynlib interprets expressions.</p> <p>Run <code>dynlib model validate first-model.toml</code> (or <code>python -m dynlib.cli model validate ...</code>) to make sure the parser accepts your spec and the state ordering matches what you expect.</p>"},{"location":"getting-started/first-model/#2-inline-models-for-quick-experimentation","title":"2. Inline models for quick experimentation","text":"<p>When you just want to prototype without saving a file, define the TOML string in place and point <code>setup()</code> (or any resolver) at an <code>inline:</code> URI. The inline document follows the same structure as the DSL file:</p> <pre><code>from dynlib import setup\n\nspec = '''\ninline:\n[model]\ntype = \"map\"\nname = \"Inline Logistic\"\ndtype = \"float64\"\n\n[params]\nr = 3.9\n\n[states]\nx = 0.3\n\n[equations.rhs]\nx = \"r * x * (1 - x)\"\n'''\n\nsim = setup(spec)\nsim.run(N=30)\n</code></pre> <p>The inline helpers document lists the acceptable URI formats and the multiline <code>inline:</code> workflow (<code>docs/guides/modeling/inline-models.md</code>), so grab that page when you need macros, functions, or inline macros embedded in the string.</p>"},{"location":"getting-started/first-model/#3-minimal-ode-reference","title":"3. Minimal ODE reference","text":"<p>Need a continuous-time example? Switch <code>type = \"ode\"</code> and describe the time derivatives via <code>[equations.rhs]</code>. A tiny, self-contained spec is a good way to verify the DSL still parses when you add vectors, Jacobians, or helper functions later:</p> <pre><code>[model]\ntype = \"ode\"\nname = \"Simple Harmonic Oscillator\"\ndtype = \"float64\"\n\n[params]\nomega = 1.0\n\n[states]\nx = 1.0\nv = 0.0\n\n[equations.rhs]\nx = \"v\"\nv = \"-omega ** 2 * x\"\n</code></pre> <p>Feed this through <code>dynlib model validate harmonic.toml</code> or inline it like above, then run the below code to check the trajectories. Because the DSL treats states as a <code>dict</code>, you can sprinkle additional aux states or helpers in the same document without changing the core structure.</p> <pre><code>sim = setup(\"path/to/harmonic.toml\")\nsim.run(T=30)\n</code></pre>"},{"location":"getting-started/first-model/#4-next-steps","title":"4. Next steps","text":"<p>Once the TOML file validates, point Dynlib at it via <code>setup(\"first-model.toml\", ...)</code>, wire it into a runner, or register the directory using the config file so you can call it with a tag (<code>proj://first-model.toml</code>). For more options, see:</p> <ul> <li>Customizing the tag map and cache roots</li> <li>Runtime settings (steppers, recorders, persistence)</li> </ul>"},{"location":"getting-started/overview/","title":"Overview","text":"<p>If you are new to dynlib, make sure to check the main page for the fundamentals.</p>"},{"location":"getting-started/overview/#requirements","title":"Requirements","text":"<ul> <li>A working Python environment (3.10+ is recommended).</li> <li>A virtual environment (virtualenv) or a similar isolation layer for installation, although it is not mandatory.</li> <li>The NumPy package for numerical computations (<code>python -m pip install numpy</code>).</li> <li>The Matplotlib package for plotting (<code>python -m pip install matplotlib</code>).</li> <li>The package itself (<code>python -m pip install dynlib</code>). For installation details, see the Quickstart guide.</li> </ul> <p>Numba is strongly recommended for high-performance simulation and analysis (<code>python -m pip install numba</code>).</p>"},{"location":"getting-started/overview/#how-to-use-this-section","title":"How to use this section","text":"<ol> <li>Follow the Quickstart guide to install dynlib, verify the CLI (<code>dynlib --version</code>, <code>dynlib model validate</code>, etc.), and run one of the built-in models from Python.</li> <li>Move on to Your First Model to write a TOML model, validate it (<code>dynlib model validate first-model.toml</code>), and experiment with inline text definitions.</li> <li>When you need to work with steppers, recorders, and other DSL features, explore the Modeling guide and the Simulation guide.</li> <li>To use simulation outputs and create plots, see the Simulation Results and Plotting guides.</li> <li>For end-to-end workflows\u2014from bifurcation diagrams to neuron models\u2014check the Examples and the Analysis guide sections.</li> </ol>"},{"location":"getting-started/quickstart/","title":"Quickstart","text":"<p>This page walks you through the first three things every dynlib user does: install the package, sanity-check the CLI, and run a bundled model from Python. After that we point you toward configuring your own model catalog so you can dive into DSL editing or analysis.</p>"},{"location":"getting-started/quickstart/#installation","title":"Installation","text":"<p>Use your favorite virtual environment and then install the released wheel. The <code>dynlib</code> console script and the <code>python -m dynlib.cli</code> entry point both become available.</p> <pre><code>python -m pip install dynlib\n</code></pre> <p>For active development, install from source so you can tweak the code, run tests, and immediately see your changes in the CLI:</p> <pre><code>git clone https://github.com/ismoz/dynlib.git\ncd dynlib\npython -m pip install -e .\n</code></pre> <p>Make sure you activate the virtual environment afterward so both <code>dynlib</code> and its dependencies stay isolated from other projects.</p>"},{"location":"getting-started/quickstart/#validate-the-cli","title":"Validate the CLI","text":"<p>The bundled CLI mirrors the Python API and is the fastest way to confirm that the environment works.</p> <ul> <li><code>dynlib --version</code> or <code>python -m dynlib.cli --version</code> shows the installed package version and proves that the entry point scripts are registered.</li> <li><code>dynlib model validate builtin://ode/lorenz.toml</code> parses a built-in ODE spec and prints the validated stepper, dtype, and state count. Replace the path with any <code>builtin://</code> model under <code>ode/</code> or <code>map/</code> to try something else.</li> <li><code>dynlib steppers list --kind ode --jit_capable</code> lists all available ODE steppers that support JIT, with more filters available (<code>--stiff</code>, <code>--jacobian optional</code>, etc.) so you can scope the runtime behavior before wiring it into your DSL.</li> <li><code>dynlib cache path</code> shows where compiled runners and JIT artifacts live; <code>dynlib cache list</code> or <code>dynlib cache clear --dry_run</code> helps you inspect or clean the cache if you switch steppers or dtypes.</li> </ul> <p>Each command accepts <code>--help</code> for more flags (e.g., <code>dynlib steppers list --help</code>), which lets you explore runtime knobs without reading the source.</p>"},{"location":"getting-started/quickstart/#run-a-built-in-model-from-python","title":"Run a built-in model from Python","text":"<p>Use <code>dynlib.setup</code> to compile a model, choose a stepper, and get back the <code>Sim</code> facade in a single call. The example below loads the bundled Lorenz system, enables JIT, caches the compiled runner, runs for 15 time units, and then plots the <code>x</code> and <code>z</code> states using built-in plot utilities.</p> <pre><code>from dynlib import setup\nfrom dynlib.plot import fig, series, export\n\nsim = setup(\n    \"builtin://ode/lorenz.toml\",\n    stepper=\"rk4\",\n)\n\nsim.run(T=15.0, dt=0.01)\nres = sim.results()\n\nprint(\"Recorded states:\", res.state_names)\nprint(\"Recorded steps:\", len(res))\nprint(\"Final z value:\", res[\"z\"][-1])\n\nax = fig.single()\nseries.plot(x=res.t, y=res[\"x\"], ax=ax, label=\"x\")\nseries.plot(x=res.t, y=res[\"z\"], ax=ax, label=\"z\", xlabel=\"time\")\nexport.show()\n</code></pre> <p><code>res</code> is a <code>ResultsView</code>, so <code>res.t</code>, <code>res[\"state_name\"]</code>, <code>res.event_names()</code>, and helpers like <code>res.to_pandas()</code> (requires <code>pandas</code>) work without copying the underlying buffers. Call <code>sim.run(...)</code> again with <code>resume=True</code>, new <code>params</code>, or <code>record_vars</code> lists to continue or record subsets of the state vector, and use <code>sim.model.spec</code> or <code>res.state_names</code> to inspect the DSL metadata.</p>"},{"location":"getting-started/quickstart/#point-dynlib-at-your-own-models","title":"Point dynlib at your own models","text":"<p><code>builtin://</code> URIs make it trivial to explore the bundled ODEs (<code>lorenz</code>, <code>vanderpol</code>, <code>izhikevich</code>, etc.) and maps (<code>logistic</code>, <code>henon</code>, <code>standard</code>, \u2026). Once you have your own TOML files, dynlib offers flexible URI resolution:</p> <ul> <li>Inline TOML strings or <code>inline:</code> URIs (see <code>examples/uri_demo.py</code>) are parsed immediately and can coexist with file-based models.</li> <li>Absolute or relative paths are accepted (<code>/path/model.toml</code> or <code>my_model.toml</code>), and <code>model</code> resolves to <code>model.toml</code> in the current directory.</li> <li>Tag-based URIs such as <code>proj://my_model.toml</code> look up the <code>proj</code> tag in <code>~/.config/dynlib/config.toml</code> (Linux), <code>~/Library/Application Support/dynlib/config.toml</code> (macOS), or <code>%APPDATA%\\dynlib\\config.toml</code> (Windows). You can override that default location with <code>DYNLIB_CONFIG=/custom/config.toml</code>.</li> <li>To add directories without editing the config file, set <code>DYN_MODEL_PATH=proj=/extra/models:/more</code> (Windows uses <code>;</code> between tags). The string before <code>=</code> becomes the tag name and the comma-separated paths become search roots.</li> </ul> <p>Your config file can look like this:</p> <pre><code>[tags]\nproj = [\"/Users/you/dynlib-models\", \"~/projects/other-models\"]\ntests = [\"~/src/dynlib/tests/data/models\"]\n\n[cache]\ncache_root = \"/tmp/dynlib-cache\"\n</code></pre> <p>With the <code>proj</code> tag registered you can now <code>setup(\"proj://decay.toml\")</code>, <code>dynlib model validate proj://decay.toml</code>, or refer to that URI inside other specs.</p>"},{"location":"getting-started/quickstart/#next-steps","title":"Next steps","text":"<p>After the quickstart, continue with Your First Model to write DSL files, explore Guides \u2192 Modeling/Simulation for steppers and recording best practices, and read the Examples or Analysis guides when you need plotting, fixed-point analysis, or Lyapunov observers. If you hit issues, the CLI <code>dynlib cache list</code> helps you debug caching, and <code>dynlib model validate</code> shows DSL parsing errors with line/column hints.</p>"},{"location":"guides/","title":"Guides","text":"<p>Dynlib\u2019s guides go deeper than the quick-start material: each section untangles a core subsystem so you can customize models, steppers, analysis helpers, or the plotting stack without hunting for scattered notes.</p>"},{"location":"guides/#guides-at-a-glance","title":"Guides at a glance","text":"<ul> <li>Command-line guide \u2014 explains the <code>dynlib</code> (and <code>python -m dynlib.cli</code>) commands for model validation, stepper inspection, and cache management.</li> <li>Modeling guide \u2014 covers the TOML DSL, auxiliary helpers, mods, presets, and other authoring conveniences you need to keep specs readable and reusable.</li> <li>Simulation guide \u2014 surveys runtime concepts such as steppers, wrappers, snapshots, results, and configuration knobs that control the solver behavior.</li> <li>Plotting guide \u2014 surveys the Matplotlib-based helpers (<code>plot.series</code>, <code>plot.phase</code>, <code>plot.manifold</code>, decorations, exports, themes) tuned for dynamical systems.</li> <li>Analysis guide \u2014 explains the runtime observers, sweep utilities, basins, Lyapunov diagnostics, and manifold finders that turn results into scientific insights.</li> </ul>"},{"location":"guides/analysis/","title":"Analysis guide","text":"<p>Dynlib\u2019s analysis subsystem translates raw simulation data into scientific insights. The guides below describe the runtime observers, sweep helpers, fixed-point/manifold tools, basins, and post-processing utilities that turn <code>Sim</code> runs into bifurcation diagrams, Lyapunov spectra, or attractor families.</p>"},{"location":"guides/analysis/#topics","title":"Topics","text":"<ul> <li>Basins \u2014 automatic or known-attractor basin calculators (<code>basin_auto</code>, <code>basin_known</code>) with grid configuration, detection thresholds, and plotting tips.</li> <li>Fixed points \u2014 Newton solvers exposed via <code>find_fixed_points</code> and <code>FullModel.fixed_points</code>, complete with seed handling, classification, and metadata.</li> <li>Runtime observers \u2014 the observer framework, pre/post-step hooks, trace buffers, and the <code>lyapunov_*</code> factories that plug directly into <code>Sim.run</code>.</li> <li>Lyapunov analysis \u2014 how to use the MLE and spectrum observers to quantify chaos, request traces, and read the emitted <code>Results</code> entries.</li> <li>Sweep utilities \u2014 scalar, trajectory, and Lyapunov sweeps that vary parameters, return <code>SweepResult</code> objects, and support fast-path or parallel execution before plotting.</li> <li>Bifurcation diagrams \u2014 build tracers from sweep outputs, use <code>BifurcationExtractor</code> helpers, and render scatter plots with <code>dynlib.plot.bifurcation_diagram</code>.</li> <li>Post-analysis \u2014 the <code>TrajectoryAnalyzer</code>/<code>MultiVarAnalyzer</code> helpers that summarize runs, compute crossings/extrema, and slice sweeps for further plotting.</li> <li>Manifold analysis \u2014 1D manifold tracing, heteroclinic/homoclinic searchers, and the metadata you feed straight into <code>plot.manifold</code> or the plotting guide\u2019s manifold pages.</li> </ul>"},{"location":"guides/analysis/basin/","title":"Basin analysis","text":"<p>Basin-of-attraction analysis can be performed after setting up a simulation with a <code>Sim</code> object (see the simulation guide for the basics of building models, steppers, and parameter assignments). Dynlib currently exposes two complementary basin calculators:</p> <ul> <li><code>dynlib.analysis.basin_auto</code> automatically discovers attractors by watching how trajectories revisit quantized cells (PCR-BM).</li> <li><code>dynlib.analysis.basin_known</code> matches initial conditions against fixed-point or reference-run attractors you already know, optionally via the reusable <code>build_known_attractors_psc</code> helper.</li> </ul> <p>Both functions return a <code>BasinResult</code> (<code>labels</code>, <code>registry</code>, <code>meta</code>) plus the special label constants <code>BLOWUP</code>, <code>OUTSIDE</code>, and <code>UNRESOLVED</code> from <code>dynlib.analysis.basin</code>. The <code>labels</code> array preserves the order of the initial conditions you provided (grid flattening, parameter batches, or explicit <code>ic</code>), so you can reshape it back to the original layout before plotting.</p>"},{"location":"guides/analysis/basin/#automatic-basin-mapping-basin_auto","title":"Automatic basin mapping (<code>basin_auto</code>)","text":"<p><code>basin_auto</code> runs Persistent Cell-Recurrence Basin Mapping (PCR-BM). It quantizes the observation space, watches how often each trajectory revisits the same cell window, fingerprints newly discovered attractors, merges similar fingerprints (<code>s_merge</code>), and assigns the remaining trajectories via persistence (<code>p_in</code>).</p> <p>Key knobs:</p> <ul> <li>Initial conditions: supply <code>ic</code> as a <code>(n_points, n_states)</code> array or ask <code>basin_auto</code> to build a uniform grid via <code>ic_grid</code> + <code>ic_bounds</code>.</li> <li>Observation space: <code>observe_vars</code> picks the variables to quantize, while <code>obs_min</code>/<code>obs_max</code> or the grid bounds define the detection region; <code>grid_res</code> controls spatial resolution.</li> <li>Dynamics mode: use <code>mode=\"map\"</code> for discrete maps, <code>mode=\"ode\"</code> for flows (or <code>auto</code> to infer); ODE mode requires a fixed-step stepper and an explicit <code>dt_obs</code> sampling interval.</li> <li>Detection parameters: <code>max_samples</code>, <code>window</code>, <code>u_th</code>, <code>recur_windows</code>, <code>post_detect_samples</code>, and <code>merge_downsample</code> tune the persistence scan and fingerprint merging. <code>transient_samples</code> lets you skip early transients, <code>b_max</code>/<code>blowup_vars</code> flag diverging trajectories, and <code>outside_limit</code> detects escapes from the observation region.</li> <li>Execution controls: <code>online=True</code> (default) streams analysis to keep memory in check; set <code>online=False</code> for offline debugging, but watch the <code>max_memory_bytes</code> guard. <code>parallel_mode</code>, <code>max_workers</code>, <code>batch_size</code>, <code>online_max_attr</code>, and <code>online_max_cells</code> trade off throughput vs. memory.</li> </ul> <p>The returned <code>BasinResult.meta</code> records everything a plotting helper needs (<code>mode</code>, <code>observe_vars</code>, <code>grid_res</code>, <code>ic_grid</code>, <code>ic_bounds</code>, <code>dt_obs</code>, etc.), so you can pass the result straight to <code>dynlib.plot.basin_plot</code> (see the basin plotting guide).</p> <p>Example (Henon map):</p> <pre><code>from dynlib import setup\nfrom dynlib.analysis import basin_auto\n\nsim = setup(\"builtin://map/henon\", stepper=\"map\", jit=True)\nsim.assign(a=1.4, b=0.3)\n\nresult = basin_auto(\n    sim,\n    ic_grid=[200, 200],\n    ic_bounds=[(-2.5, 2.5), (-2.5, 2.5)],\n    grid_res=64,\n    max_samples=600,\n    window=64,\n    u_th=0.5,\n    mode=\"map\",\n)\n\nlabels = result.labels.reshape(200, 200)\n</code></pre>"},{"location":"guides/analysis/basin/#targeted-classification-basin_known-build_known_attractors_psc","title":"Targeted classification (<code>basin_known</code> + <code>build_known_attractors_psc</code>)","text":"<p>Use <code>basin_known</code> when you already understand the attractors in the basin (fixed points, limit cycles, strange attractors captured as reference runs). <code>basin_known</code> compares each trajectory against a <code>KnownAttractorLibrary</code> built from <code>FixedPoint</code> or <code>ReferenceRun</code> specs, so classification boils down to distance/tolerance checks plus optional escape/blowup detection.</p> <p>Workflow notes:</p> <ul> <li>Attractor specs:</li> <li><code>FixedPoint(name, loc, radius)</code> fast-path: trajectories that stay within <code>radius</code> for <code>fixed_point_settle_steps</code> steps are immediately classified.</li> <li><code>ReferenceRun(name, ic, params)</code> captures a trajectory via <code>build_known_attractors_psc</code>, so matching is a similarity test (use <code>signature_samples</code>, <code>tolerance</code>, <code>min_match_ratio</code> to adjust strictness).</li> <li>Grid handling: as with <code>basin_auto</code>, pass <code>ic</code> or <code>ic_grid</code> + <code>ic_bounds</code>. With grids you can enable <code>refine=True</code> to do a coarse-to-fine pass (controls <code>coarse_factor</code>, <code>boundary_dilation</code>). The refinement benchmark in <code>examples/analysis/basin_refine_benchmark.py</code> shows how refine can speed up large grids.</li> <li>Dynamics mode: same <code>mode</code>/<code>dt_obs</code> rules apply (ODE mode requires fixed-step). <code>escape_bounds</code> guard against leaving the region, and <code>b_max</code>/<code>blowup_vars</code> detect blowups.</li> <li>Parallel/execution: <code>parallel_mode</code>, <code>max_workers</code>, and <code>batch_size</code> control concurrency. The <code>refine</code> path may spawn process pools or shared classifiers depending on your configuration.</li> </ul> <p>If you prefer to reuse the attractor fingerprints, call <code>build_known_attractors_psc(sim, attractor_specs, ...)</code> once (the helper also runs <code>ReferenceRun</code> specs) and feed the returned <code>KnownAttractorLibrary</code> to downstream utilities that live outside <code>dynlib.analysis</code>.</p> <p>Example (Duffing ODE fixed points):</p> <pre><code>from dynlib import setup\nfrom dynlib.analysis import basin_known, FixedPoint\n\nsim = setup(\"builtin://ode/duffing\", stepper=\"rk2\", jit=True)\nsim.assign(delta=0.02, alpha=-0.5, beta=0.5)\n\nresult = basin_known(\n    sim,\n    attractors=[\n        FixedPoint(name=\"+1\", loc=[1.0, 0.0], radius=0.3),\n        FixedPoint(name=\"-1\", loc=[-1.0, 0.0], radius=0.3),\n    ],\n    ic_grid=[300, 300],\n    ic_bounds=[(-1.5, 1.5), (-1.5, 1.5)],\n    dt_obs=0.01,\n    max_samples=60000,\n    signature_samples=0,\n    escape_bounds=[(-2.0, 2.0), (-2.0, 2.0)],\n    b_max=1e6,\n)\n</code></pre>"},{"location":"guides/analysis/basin/#inspecting-basin-results","title":"Inspecting basin results","text":"<p><code>BasinResult.labels</code> carries the assignment for every initial condition, so you can reshape it and feed it to contour/<code>pcolormesh</code> helpers. The <code>registry</code> list holds <code>Attractor(id, fingerprint, cells)</code> entries and captures the discovered attractor metadata (useful for persistence debugging). <code>meta</code> includes algorithm parameters, grid metadata (<code>ic_grid</code>, <code>ic_bounds</code>), and the attractor names (for <code>basin_known</code>).</p> <p>Use <code>dynlib.analysis.basin_stats(result)</code> or <code>basin_summary(result)</code> to get counts/percentages for each label and an attractor-by-attractor report. The plotting guide shows how <code>dynlib.plot.basin_plot(result)</code> combines labels, <code>result.meta</code>, and the color legend to reveal basins, escaping sets, and unresolved pockets in one figure.</p>"},{"location":"guides/analysis/basin/#quick-summaries-with-print_basin_summary","title":"Quick summaries with <code>print_basin_summary</code>","text":"<p>When you need a fast console dump, <code>dynlib.analysis.print_basin_summary(result)</code> (see <code>examples/analysis/basin_henon_auto.py</code> and <code>examples/analysis/basin_henon_known.py</code>) prints attractor counts, the percentage of grid points assigned to each attractor, and the current label mix. It mirrors the structured <code>basin_summary</code> output but skips the data objects, making it ideal for iterating on grid resolutions or detection thresholds.</p> <p>Because both calculators rely on Numba, there is no pure-Python <code>jit=False</code> fallback path for these helpers. Each entry point (via <code>dynlib.analysis.basin._require_numba</code>) raises <code>JITUnavailableError</code> whenever the soft dependency probe reports NumPy/Numba is missing, so install Numba and rebuild the extension before running large batches.</p>"},{"location":"guides/analysis/bifurcation/","title":"Bifurcation diagrams","text":"<p>Bifurcation diagrams are produced as a post-processing workflow after you sweep a parameter: the sweep helpers in <code>dynlib.analysis.sweep</code> (e.g., <code>traj_sweep</code>, <code>lyapunov_mle_sweep</code>, <code>lyapunov_spectrum_sweep</code>) record trajectories or diagnostics for each grid value, and <code>SweepResult.bifurcation(var)</code> converts those trajectories into the scatter points that form the diagram.</p>"},{"location":"guides/analysis/bifurcation/#workflow","title":"Workflow","text":"<ol> <li>Run a sweep with <code>dynlib.analysis.sweep.traj_sweep</code> (or another sweep helper) over the parameter you're interested in. Record the variables you want to plot and keep any transients you want to discard via the <code>transient</code>, <code>tail</code>, or extractor arguments.</li> <li>Extract bifurcation points with <code>result.bifurcation(\"x\")</code>, <code>result.bifurcation(\"z\").extrema(...)</code>, etc. The <code>BifurcationExtractor</code> provides helpers such as <code>extrema(...)</code>, <code>tail(...)</code>, <code>final()</code>, and <code>poincare(...)</code> so you can build steady-state envelopes, maxima/minima, or return-section crossings.</li> <li>Plot the result with <code>dynlib.plot.bifurcation_diagram(extractor)</code> or feed the extractor\u2019s <code>p</code>/<code>y</code> arrays into your own figure routines. The extractor carries metadata (<code>param_name</code>, <code>values</code>, <code>meta</code>) that keeps axis labels and parameter grids consistent.</li> </ol> <p>The <code>dynlib.plot.bifurcation_diagram</code> helper is demonstrated in <code>examples/bifurcation_logistic_map.py</code>, and bifurcation extraction is shown alongside Lyapunov sweeps in <code>examples/analysis/lyapunov_sweep_mle_demo.py</code> and <code>examples/analysis/lyapunov_sweep_spectrum_demo.py</code>.</p>"},{"location":"guides/analysis/bifurcation/#notes","title":"Notes","text":"<ul> <li>The extractor works with trajectories of different lengths\u2014the helper normalizes the data so you can stack or iterate over runs safely.</li> <li>Many sweep helpers fill <code>meta</code> with stepper settings, so you can see whether each point used the same <code>dt</code>, <code>record_interval</code>, etc.</li> <li>When building publication figures, combine bifurcation extractors with <code>series.plot</code>, <code>phase.xy</code>, or <code>fig.grid</code> for custom layouts.</li> </ul>"},{"location":"guides/analysis/fixed-points/","title":"Fixed points and equilibria","text":"<p>Fixed points (for maps) or equilibria (for ODE models) are the state vectors where the right-hand-side of the model vanishes. Dynlib exposes two entry points for exploring them:</p> <ul> <li>the standalone <code>find_fixed_points(...)</code> helper inside <code>dynlib.analysis.fixed_points</code>, which operates on any callable RHS/jacobian pair, and</li> <li>the <code>FullModel.fixed_points(...)</code> convenience method that bridges the solver with a compiled model (parameter defaults, runtime workspace, timestep handling, and an optional analytic Jacobian).</li> </ul> <p>Both routes drive the same Newton solver with configurable convergence criteria, deduplication, and stability diagnostics, but <code>FullModel.fixed_points(...)</code> is the preferred API for most users because it automatically wires up parameters, seeds, and Jacobians from the compiled model. They work both for maps and ODE models. To keep the API simple, the term fixed-point is used for the helpers.</p>"},{"location":"guides/analysis/fixed-points/#quick-start","title":"Quick Start","text":"<p>To find fixed points, you need: - A model (for <code>FullModel.fixed_points</code>) or RHS function (for <code>find_fixed_points</code>). - Initial guesses (seeds) near the expected fixed points. - Optional parameters and configuration.</p> <p>For a compiled model, use:</p> <pre><code>from dynlib.analysis import FixedPointConfig\n\n# Create or load your model\nmodel = ...  # e.g., from dynlib import compile_model; model = compile_model('your_model.toml')\n\n# Configure the solver\ncfg = FixedPointConfig(tol=1e-10, classify=True)\n\n# Find fixed points\nresult = model.fixed_points(\n    params={\"param_name\": value},  # Optional: parameter values\n    seeds=[[x1, y1], [x2, y2]],    # Initial guesses\n    cfg=cfg\n)\n\n# Check results\nprint(\"Fixed points:\", result.points)\nprint(\"Stability:\", result.stability)\n</code></pre> <p>This returns a <code>FixedPointResult</code> with the solutions and diagnostics.</p>"},{"location":"guides/analysis/fixed-points/#find_fixed_points","title":"<code>find_fixed_points(...)</code>","text":"<p>This helper solves <code>f(x, params) = 0</code> starting from one or more user-supplied seeds.</p> <ul> <li>Function signature: <code>f(x, params)</code> takes NumPy arrays and must return a vector with the same shape as <code>x</code>. If you provide <code>jac(x, params)</code>, its output is validated against <code>(n_state, n_state)</code> before solving.</li> <li>Seed/pattern handling: <code>seeds</code> accepts a single vector or a batch of shape <code>(n_seeds, n_state)</code>. The helper raises if the shape does not match. <code>params</code> must be a 1-D array; pass <code>None</code> to keep the default zero-length vector.</li> <li>Newton settings: <code>cfg</code> (see below) tunes tolerance, maximum iterations, finite-difference epsilon, and whether to perform eigenvalue-based classification. The solver returns as soon as the residual norm falls below <code>cfg.tol</code>.</li> <li>Deduplication: after solving every seed, the helper reports unique solutions. If <code>cfg.unique_tol</code> is positive, it merges nearby points (within the tolerance) and keeps the copy with the smallest residual. Setting <code>unique_tol</code> to <code>None</code> or a non-positive value disables deduplication.</li> <li>Classification: when classification is enabled via <code>cfg.classify</code>, the solver computes eigenvalues for each unique root (for maps it adds the identity to the Jacobian before eigendecomposition), then labels each point as <code>stable</code>, <code>unstable</code>, <code>neutral</code>, or <code>saddle</code> based on <code>cfg.stability_tol</code>.</li> <li>Meta information: every run records per-seed residuals, iteration counts, convergence flags, and mapping from seeds to unique points. <code>FixedPointResult.meta</code> exposes this data alongside the evaluated parameter vector and the <code>FixedPointConfig</code> used.</li> </ul>"},{"location":"guides/analysis/fixed-points/#fixedpointconfig","title":"<code>FixedPointConfig</code>","text":"Field Description <code>method</code> Solver method name (<code>\"newton\"</code> only for now). <code>tol</code> Residual tolerance for convergence (default <code>1e-10</code>). <code>max_iter</code> Maximum Newton iterations per seed (default <code>50</code>). <code>unique_tol</code> Distance for merging duplicates (default <code>1e-6</code>). Set to <code>None</code>/\u22640 to keep every converged seed. <code>jac</code> Jacobian mode: <code>\"auto\"</code> (use analytic if provided, otherwise finite diff), <code>\"fd\"</code>, or <code>\"provided\"</code> (requires a <code>jac</code> callable). <code>fd_eps</code> Step size for finite-difference Jacobians (default <code>1e-6</code>). <code>classify</code> Enable eigenvalue computation and stability labels (default <code>True</code>). <code>kind</code> Either <code>\"ode\"</code> or <code>\"map\"</code>\u2014<code>find_fixed_points</code> enforces this value and uses it for classification. <code>stability_tol</code> Margin around the unit circle/imaginary axis where eigenvalues are considered neutral (default <code>1e-6</code>)."},{"location":"guides/analysis/fixed-points/#interpreting-fixedpointresult","title":"Interpreting <code>FixedPointResult</code>","text":"<p>The <code>FixedPointResult</code> object contains all the information about the found fixed points. Here's what each field means:</p> <ul> <li><code>points</code>: A list of NumPy arrays, each representing a unique fixed point (state vector where the model RHS is zero). These are deduplicated based on <code>unique_tol</code>.</li> <li><code>residuals</code>: The Euclidean norm of the RHS function at each point (should be very small, e.g., &lt; 1e-10, for converged solutions).</li> <li><code>jacobians</code>: The Jacobian matrices evaluated at each point (used for stability analysis). For maps, this includes the identity added (J + I).</li> <li><code>eigvals</code>: Complex eigenvalues of the Jacobian (only if <code>classify=True</code>). Used to determine stability.</li> <li><code>stability</code>: A list of strings labeling each point as 'stable', 'unstable', 'neutral', or 'saddle'. For ODEs, based on eigenvalue real parts; for maps, based on eigenvalue magnitudes relative to 1.</li> <li><code>meta</code>: A dictionary with detailed diagnostics:</li> <li><code>seed_points</code>: The original seeds provided.</li> <li><code>seed_residuals</code>: Residuals after solving each seed.</li> <li><code>seed_converged</code>: Boolean flags indicating if each seed converged.</li> <li><code>seed_iterations</code>: Number of Newton iterations per seed.</li> <li><code>seed_to_unique</code>: Mapping from seed indices to unique point indices.</li> <li><code>unique_seed_indices</code>: Indices of seeds that produced unique points.</li> <li><code>params</code>: The parameter vector used.</li> <li><code>cfg</code>: The <code>FixedPointConfig</code> used.</li> </ul> <p>If a seed doesn't converge (e.g., due to bad initial guess or model issues), check <code>meta['seed_converged']</code> and adjust seeds or tolerances.</p>"},{"location":"guides/analysis/fixed-points/#fullmodelfixed_points","title":"<code>FullModel.fixed_points(...)</code>","text":"<p>Calling this method on a compiled <code>FullModel</code> routes the solver through the model runtime so you get consistent defaults and Jacobians:</p> <ul> <li><code>params</code>/<code>seeds</code> accept either sequences (applied directly) or mappings from names to overrides (which update the default parameter or state vectors).</li> <li><code>method</code>, <code>tol</code>, <code>max_iter</code>, <code>unique_tol</code>, and <code>classify</code> mirror <code>FixedPointConfig</code> fields; pass a <code>cfg</code> object if you need multiple overrides at once.</li> <li><code>jac</code> lets you request finite differences (<code>\"fd\"</code>), force analytic mode (<code>\"analytic\"</code>), or leave it <code>\"auto\"</code> (the default). When <code>jac='analytic'</code> the model must expose a Jacobian.</li> <li><code>t</code> controls the evaluation time for non-autonomous problems; it defaults to <code>spec.sim.t0</code> so steady-state solutions match the simulation start.</li> <li>Internally the method builds a runtime workspace, evaluates the RHS (and Jacobian if available), subtracts the identity for maps, and then delegates to <code>find_fixed_points(...)</code>. It also updates <code>cfg.kind</code> from <code>spec.kind</code> before calling the helper so ODE vs. map behavior stays correct.</li> </ul>"},{"location":"guides/analysis/fixed-points/#example","title":"Example","text":"<p>Here's a complete example using the logistic map model. Assume you have a compiled model for the logistic map equation: <code>x_{n+1} = r * x_n * (1 - x_n)</code>.</p> <pre><code>from dynlib.analysis import FixedPointConfig\n\n# Assuming 'model' is a compiled FullModel for the logistic map\n# For r=3.8, expected fixed points are around 0.0 and 0.7368\n\ntop_cfg = FixedPointConfig(unique_tol=1e-8, classify=True)\nresult = model.fixed_points(\n    params={\"r\": 3.8},  # Set parameter r\n    seeds=[[-0.5, 0.2], [0.4, 0.4]],  # Initial guesses near expected points\n    cfg=top_cfg,\n)\n\n# Inspect results\nprint(\"Number of fixed points found:\", len(result.points))\nprint(\"Fixed points:\")\nfor i, point in enumerate(result.points):\n    print(f\"  Point {i}: {point}\")\nprint(\"Stability labels:\", result.stability)\nprint(\"Residuals (should be near 0):\", result.residuals)\n\n# Example output (approximate):\n# Number of fixed points found: 2\n# Fixed points:\n#   Point 0: [0.0]\n#   Point 1: [0.73684211]\n# Stability labels: ['unstable', 'stable']\n# Residuals (should be near 0): [0.0, 1.11022302e-16]\n</code></pre> <p>This example shows how seeds converge to unique fixed points, with stability determined by eigenvalues. For maps, stability depends on whether the eigenvalue magnitude is less than 1. Use <code>result.meta</code> to trace convergence details per seed.</p>"},{"location":"guides/analysis/fixed-points/#tips-and-common-issues","title":"Tips and Common Issues","text":"<ul> <li>Choosing seeds: Start with educated guesses based on model behavior or prior simulations. For example, plot the vector field or run short trajectories to estimate where fixed points might be.</li> <li>Convergence problems: If seeds don't converge, try increasing <code>max_iter</code>, lowering <code>tol</code>, or using better initial guesses. Check <code>result.meta['seed_converged']</code> for failures.</li> <li>Deduplication: Set <code>unique_tol</code> to merge nearby points; set to <code>None</code> to keep all converged solutions.</li> <li>Stability analysis: Enable <code>classify=True</code> to get stability labels. For ODEs, stable points have all eigenvalues with negative real parts; for maps, magnitudes &lt; 1.</li> <li>Performance: Providing an analytic Jacobian speeds up convergence and improves accuracy over finite differences.</li> <li>Errors: Ensure seeds match the state vector shape <code>(n_state,)</code>. For models, verify parameters are correctly named.</li> </ul> <p>For more examples, see the analysis examples in the repository.</p>"},{"location":"guides/analysis/lyapunov/","title":"Lyapunov analysis","text":"<p>Dynlib exposes dedicated analysis helpers for computing maximum Lyapunov exponents (MLE) and full Lyapunov spectra. These helpers are implemented as observer factories, so the bulk of the runtime wiring is already documented in the observers guide, but this page focuses on using <code>lyapunov_mle_observer</code> and <code>lyapunov_spectrum_observer</code> as standalone analysis tools (with or without additional observers).</p>"},{"location":"guides/analysis/lyapunov/#when-to-use-lyapunov-diagnostics","title":"When to use Lyapunov diagnostics","text":"<p>Lyapunov exponents quantify how infinitesimal perturbations grow or contract along trajectories:</p> <ul> <li>Positive MLE signals sensitive dependence on initial conditions and chaotic regimes.</li> <li>Zero or near-zero MLE often indicates periodic or quasiperiodic motion.</li> <li>Negative MLE implies stable fixed points or sinks.</li> </ul> <p>The spectrum generalizes the MLE by tracking every exponent, so it is useful whenever you want a fuller picture of stability (e.g., flows with multiple contracting/expanding directions or low-dimensional maps).</p>"},{"location":"guides/analysis/lyapunov/#observer-factories","title":"Observer factories","text":"<p>Both factories live in <code>dynlib.runtime.observers</code> and share a consistent signature:</p> <pre><code>from dynlib.runtime.observers import lyapunov_mle_observer, lyapunov_spectrum_observer\n\nfactory = lyapunov_mle_observer(model=sim.model, record_interval=record_every)\n</code></pre> <p>Common arguments:</p> <ul> <li><code>model</code>: the active <code>Model</code> (can be passed explicitly or injected when using the factory directly).</li> <li><code>record_interval</code> / <code>trace_plan</code>: determines how often convergence traces are stored; omit to only track the final outputs.</li> <li><code>mode</code>: <code>\"flow\"</code>, <code>\"map\"</code>, or <code>\"auto\"</code> to control whether time or iteration counts appear in denominators (auto derives from <code>model.spec.kind</code>).</li> <li><code>prefer_variational_combined</code>: reuse the stepper\u2019s combined variational integrator when available; bypass this to fall back to the tangent-only path.</li> <li><code>analysis_kind</code>: integer tag that flows through metadata builders and caches (set it to distinguish multiple analyses in the same run).</li> <li><code>k</code> (spectrum only): how many leading exponents to compute; the first exponent is the MLE.</li> </ul> <p>These factories declare their requirements (<code>need_jvp</code>, variational stepping, trace alignment) so the runner enforces compatible steppers just as described in the observers guide.</p>"},{"location":"guides/analysis/lyapunov/#common-workflow","title":"Common workflow","text":"<ol> <li>Register the observers when calling <code>Sim.run(...)</code>.</li> <li>Request trace sampling (set <code>record_interval</code> or a <code>FixedTracePlan</code>) if you want convergence data.</li> <li>Inspect <code>sim.results().observers[...]</code> after the run for per-observer outputs/traces.</li> </ol>"},{"location":"guides/analysis/lyapunov/#example-snippet-logistic-map","title":"Example snippet (logistic map)","text":"<p>The logistic map demo (<code>examples/analysis/lyapunov_logistic_map_demo.py</code>) ties everything together:</p> <pre><code>sim.assign(x=0.4, r=4.0)\nsim.run(\n    N=5000,\n    dt=1.0,\n    record_interval=1,\n    observers=[\n        lyapunov_mle_observer(model=sim.model, record_interval=1),\n        lyapunov_spectrum_observer(model=sim.model, k=1, record_interval=1),\n    ],\n)\nresult = sim.results()\n</code></pre> <p>Afterwards, the <code>ResultView</code> exposes ergonomic helpers such as <code>result.observers[\"lyapunov_mle\"].mle</code> for the converged exponent and <code>result.observers[\"lyapunov_spectrum\"][\"lyap0\"]</code> for the trace values.</p>"},{"location":"guides/analysis/lyapunov/#reading-outputs","title":"Reading outputs","text":"<p>Each Lyapunov observer writes: - Output slots (<code>output_names</code>) for final statistics such as <code>mle</code>, <code>log_growth</code>, or <code>lyap0</code>. - Traces (<code>trace_names</code>) when a trace plan is active.</p> <p>Use the <code>ResultView.observers</code> dictionary to iterate over observers, and rely on <code>trace_steps</code>, <code>trace_time</code>, and direct indexing (<code>result[\"mle\"]</code>) to align diagnostics with the recorded trajectory.</p>"},{"location":"guides/analysis/lyapunov/#tips","title":"Tips","text":"<ul> <li>Combine <code>lyapunov_mle_observer</code> with other diagnostics (e.g., convergence tracers or event logs) as long as they share the same <code>TracePlan</code>.</li> <li>The <code>lyapunov_spectrum_observer</code> stores its exponents in alternating trace buffers, so filter out the zero entries when reading the last non-zero exponent. See the logistic map demo for a working extraction example.</li> <li>If you only need the final value (no trace), set <code>record=False</code> on <code>Sim.run</code> and skip the trace plan; the observers still deposit output buffers and metadata. ```</li> </ul>"},{"location":"guides/analysis/manifold/","title":"Manifold analysis","text":"<p>Dynlib currently supports 1D manifold tracing for both discrete maps and ODEs, plus search/trace utilities for heteroclinic and homoclinic orbits of ODE models. Once you extract the manifolds (stable/unstable branches or connecting orbits) you can feed the results directly into <code>dynlib.plot.manifold</code> or the plotting guide in manifold plots.</p>"},{"location":"guides/analysis/manifold/#1d-manifold-tracing","title":"1D manifold tracing","text":"<p>Two helpers live in <code>dynlib.analysis.manifold</code>:</p> <ul> <li><code>trace_manifold_1d_map(...)</code> for autonomous maps whose stable or unstable subspace is 1D. Stable branches require the model to expose an analytic inverse map (<code>model.inv_rhs</code>), while unstable branches only need the forward map (<code>model.rhs</code>).</li> <li><code>trace_manifold_1d_ode(...)</code> for ODE systems; it always uses an internal RK4 integrator (independent of the Sim stepper) and traces forward (unstable) or backward (stable) in time from an equilibrium point.</li> </ul>"},{"location":"guides/analysis/manifold/#map-manifolds-trace_manifold_1d_map","title":"Map manifolds (<code>trace_manifold_1d_map</code>)","text":"<p>Key arguments and workflow:</p> <ul> <li><code>sim</code>, <code>fp</code>: supply a <code>Sim</code> whose compiled model is a map plus the equilibrium you want to expand (dict or array is accepted).</li> <li><code>kind=\"stable\"</code> or <code>\"unstable\"</code> picks the branch. Stable mode additionally requires <code>model.inv_rhs</code>.</li> <li><code>params</code> override extra parameters, and <code>bounds</code> defines an <code>(n_state, 2)</code> observation box so tracing stops once the branch leaves it.</li> <li><code>clip_margin</code> adds a fractional buffer when integrating; <code>seed_delta</code> perturbs the fixed point along the chosen eigenvector.</li> <li><code>steps</code>, <code>hmax</code>, <code>max_points_per_segment</code>, and <code>max_segments</code> control how far the sampler walks and how many segments it stores.</li> <li><code>eig_rank</code>, <code>strict_1d</code>, <code>eig_unit_tol</code>, and <code>eig_imag_tol</code> tune the eigenvalue selection so you can force a particular root or relax the strict-1D assumption.</li> <li><code>jac=\"auto\" | \"fd\" | \"analytic\"</code> picks the Jacobian strategy; <code>fd_eps</code> sets the finite-difference step.</li> <li><code>fp_check_tol</code> optionally verifies that <code>fp</code> is still a fixed point at the provided parameters.</li> </ul> <p>If Numba/JIT is available and the model was compiled with <code>jit=True</code>, the helper employs fast batch evaluation or preallocated fastpaths; otherwise it falls back to safe Python loops with a warning.</p>"},{"location":"guides/analysis/manifold/#ode-manifolds-trace_manifold_1d_ode","title":"ODE manifolds (<code>trace_manifold_1d_ode</code>)","text":"<p>Key knobs:</p> <ul> <li><code>sim</code>, <code>fp</code>, <code>params</code>, and <code>bounds</code> work as above. The <code>bounds</code> box is respected during integration, and you can set <code>clip_margin</code> to buffer it while <code>strict_1d</code> ensures the selected eigenvector really spans a 1D manifold.</li> <li><code>dt</code>, <code>max_time</code>, and <code>max_points</code> cap the internal RK4 integration. <code>resample_h</code> (if non-<code>None</code>) re-samples each branch to roughly equal arc-length spacing for cleaner plotting.</li> <li><code>seed_delta</code> seeds the branch along the normalized eigenvector (both positive and negative directions are traced unless the branch leaves early).</li> <li>Jacobian handling mirrors the map helper (<code>jac</code>, <code>fd_eps</code>, <code>eig_real_tol</code>, <code>eig_imag_tol</code>). Use <code>eig_rank</code> when multiple stable/unstable eigenvalues exist.</li> <li><code>fp_check_tol</code> lets you refuse to trace if <code>fp</code> is no longer a steady state (e.g., due to parameter overrides).</li> </ul> <p>Like the map helper, the ODE tracer prefers a JIT-compiled model but runs even without Numba (with a warning about fallback).</p>"},{"location":"guides/analysis/manifold/#manifoldtraceresult","title":"<code>ManifoldTraceResult</code>","text":"<p>Both tracing utilities return a <code>ManifoldTraceResult</code> with these attributes:</p> <ul> <li><code>kind</code>: <code>\"stable\"</code> or <code>\"unstable\"</code>.</li> <li><code>fixed_point</code>: the equilibrium that seeded the branches.</li> <li><code>branches</code>: a tuple <code>(positive_side, negative_side)</code> where each side is a list of point sequences (<code>np.ndarray</code> of shape <code>(n_points, n_state)</code>).</li> <li><code>branch_pos</code> / <code>branch_neg</code>: convenient views of the tuple above.</li> <li><code>eigenvalue</code>, <code>eigenvector</code>, <code>eig_index</code>, <code>step_mul</code>: spectral information used during the trace.</li> <li><code>meta</code>: dictionary recording the configuration that produced the result (bounds, params, dt, clip margins, etc.).</li> </ul> <p>These results are directly consumable by <code>dynlib.plot.manifold</code> and expose <code>branches</code>, so you can overlay them with heteroclinic traces, time series, or other decorations (see the plotting guide).</p> <p>Concrete examples:</p> <ul> <li><code>examples/analysis/manifold_henon.py</code> traces the Henon map stable/unstable manifolds and renders them with <code>plot.manifold</code>.</li> <li><code>examples/analysis/manifold_ode_saddle.py</code> walks through an analytic saddle, showing how to seed both sides, check the traced curve against closed-form expressions, and plot the result.</li> </ul>"},{"location":"guides/analysis/manifold/#heteroclinic-and-homoclinic-findertracer","title":"Heteroclinic and homoclinic finder/tracer","text":"<p>For ODE models you can search for or trace connecting orbits without manually tweaking shooting segments. The workflow typically is:</p> <ol> <li>Call a finder to locate a parameter value (and equilibrium pair) that yields a connection.</li> <li>Use a tracer at the confirmed parameter to record the orbit.</li> <li>Plot the resulting trace alongside the source/target manifolds using <code>dynlib.plot.manifold</code>.</li> </ol>"},{"location":"guides/analysis/manifold/#heteroclinic-utilities","title":"Heteroclinic utilities","text":"<ul> <li><code>heteroclinic_finder(...)</code> searches for a parameter <code>param</code> in <code>[param_min, param_max]</code> whose unstable manifold from <code>source_eq_guess</code> lands near the stable manifold of <code>target_eq_guess</code>. The simplified API accepts the <code>preset</code> (<code>\"fast\"</code>, <code>\"default\"</code>, <code>\"precise\"</code>), a <code>window</code> to constrain search, and convergence tolerances such as <code>gap_tol</code> (miss distance) and <code>x_tol</code> (parameter refinement). The return value, <code>HeteroclinicFinderResult</code>, contains:</li> <li><code>success</code>: whether a valid orbit was found.</li> <li><code>param_found</code>: the parameter value that minimized the miss distance.</li> <li><code>miss</code>: diagnostic struct (<code>HeteroclinicMissResult2D</code> or <code>HeteroclinicMissResultND</code>) with crossing points, gap metrics, and solver status.</li> <li><code>info</code>: auxiliary diagnostics (preset name, number of scans, etc.).</li> <li>After the finder succeeds, <code>heteroclinic_tracer(...)</code> records the actual connection at <code>param_value</code>. You must specify both equilibria (<code>source_eq</code>, <code>target_eq</code>) and an unstable direction sign (<code>sign_u</code>). The tracer exposes:</li> <li><code>HeteroclinicTraceResult</code> with fields <code>t</code>, <code>X</code>, <code>meta</code>, <code>branches</code>, and a boolean <code>success</code> property.</li> <li><code>hit_radius</code>: controls how close the unstable segment must get to the target before stopping (default <code>1e-2</code>).</li> <li>The same <code>preset</code>/<code>window</code>/<code>t_max</code>/<code>r_blow</code> shortcuts plus the full <code>HeteroclinicBranchConfig</code> if you need finer control.</li> </ul>"},{"location":"guides/analysis/manifold/#configuration-dataclasses","title":"Configuration dataclasses","text":"<p>The finder/tracer pairs also accept structured dataclasses from <code>dynlib.analysis.manifold</code> when you need deterministic control. <code>heteroclinic_finder</code> can take a <code>cfg</code> (<code>HeteroclinicFinderConfig2D</code> or <code>HeteroclinicFinderConfigND</code>) while <code>heteroclinic_tracer</code> accepts <code>cfg_u</code>, and both can be overridden with the simplified <code>preset</code>, <code>trace_cfg</code>, and keyword arguments described above.</p> <ul> <li><code>HeteroclinicRK45Config</code> tunes the internal RK45 integrator (<code>dt0</code>, <code>min_step</code>, <code>dt_max</code>, <code>atol</code>, <code>rtol</code>, <code>safety</code>, <code>max_steps</code>), which is stored on each branch config.</li> <li><code>HeteroclinicBranchConfig</code> bundles the settings for a single manifold trace: equilibrium refinement (<code>eq_tol</code>, <code>eq_max_iter</code>, optional <code>eq_track_max_dist</code>), the leave radius (<code>eps_mode</code>, <code>eps</code>, <code>eps_min</code>, <code>eps_max</code>, <code>r_leave</code>, <code>t_leave_target</code>), integration caps (<code>t_max</code>, <code>s_max</code>, <code>r_blow</code>), optional sections/windowed exit conditions (<code>window_min</code>, <code>window_max</code>, <code>t_min_event</code>, <code>require_leave_before_event</code>), spectral tolerances (<code>eig_real_tol</code>, <code>eig_imag_tol</code>, <code>strict_1d</code>), Jacobian handling (<code>jac</code>, <code>fd_eps</code>), and the <code>rk</code> field that points to a <code>HeteroclinicRK45Config</code>.</li> <li><code>HeteroclinicFinderConfig2D</code>/<code>HeteroclinicFinderConfigND</code> pair two branch configs (<code>trace_u</code>, <code>trace_s</code>) with search behavior (<code>scan_n</code>, <code>max_bisect</code>, <code>x_tol</code>, <code>gap_tol</code>, <code>gap_fac</code>, <code>branch_mode</code>, <code>sign_u</code>, <code>sign_s</code>, <code>r_sec</code>, <code>r_sec_mult</code>, <code>r_sec_min_mult</code>, plus <code>tau_min</code> for ND) and optionally <code>eq_tol</code>/<code>eq_max_iter</code> overrides. This full config is passed through <code>cfg</code> and bypasses the simplified kwargs when present.</li> <li><code>HeteroclinicPreset</code> packages a branch config, RK settings, and scan parameters so you can request <code>\"fast\"</code>, <code>\"default\"</code>, or <code>\"precise\"</code> (or create a custom preset by instantiating the dataclass yourself) instead of manually setting every field.</li> </ul> <p>See <code>examples/analysis/heteroclinic_finder_tracer.py</code> for a complete heteroclinic hunt + plotting routine.</p>"},{"location":"guides/analysis/manifold/#homoclinic-utilities","title":"Homoclinic utilities","text":"<ul> <li><code>homoclinic_finder(...)</code> searches for a parameter such that the unstable and stable manifolds of the same saddle equilibrium reconnect. It accepts the same <code>preset</code> names and simplified overrides (<code>window</code>, <code>scan_n</code>, <code>max_bisect</code>, <code>gap_tol</code>, <code>x_tol</code>, <code>t_max</code>, <code>r_blow</code>, <code>r_sec</code>, <code>t_min_event</code>) or a full <code>HomoclinicFinderConfig</code>. The returned <code>HomoclinicFinderResult</code> mirrors the heteroclinic finder (with a <code>HomoclinicMissResult</code> describing the closest hit).</li> <li><code>homoclinic_tracer(...)</code> follows a single sign-defined unstable branch until it lands back on the saddle; it returns a <code>HomoclinicTraceResult</code> whose <code>branches</code> attribute can be sent to <code>plot.manifold</code>. The tracer uses <code>HomoclinicBranchConfig</code>, allowing you to tweak RK45 tolerances, leave/return radii, and event detection guards.</li> </ul>"},{"location":"guides/analysis/manifold/#configuration-dataclasses_1","title":"Configuration dataclasses","text":"<p>The finder/tracer pair exposes structured configuration dataclasses for advanced tuning. <code>homoclinic_finder</code> accepts a <code>cfg: HomoclinicFinderConfig</code> while <code>homoclinic_tracer</code> can take <code>cfg_u: HomoclinicBranchConfig</code>; supplying these objects bypasses the simplified <code>preset</code>, <code>trace_cfg</code>, and keyword arguments.</p> <ul> <li><code>HomoclinicRK45Config</code> owns the RK45 parameters (<code>dt0</code>, <code>min_step</code>, <code>dt_max</code>, <code>atol</code>, <code>rtol</code>, <code>safety</code>, <code>max_steps</code>).</li> <li><code>HomoclinicBranchConfig</code> layers equilibrium refinement (<code>eq_tol</code>, <code>eq_max_iter</code>, <code>eq_track_max_dist</code>), leave-event control (<code>eps_mode</code>, <code>eps</code>, <code>eps_min</code>, <code>eps_max</code>, <code>r_leave</code>, <code>t_leave_target</code>, <code>r_sec</code>, <code>t_min_event</code>, <code>require_leave_before_event</code>), integration caps (<code>t_max</code>, <code>s_max</code>, <code>r_blow</code>), optional window constraints, spectral thresholds (<code>eig_real_tol</code>, <code>eig_imag_tol</code>, <code>strict_1d</code>), Jacobian handling (<code>jac</code>, <code>fd_eps</code>), and an <code>rk</code> field referencing a <code>HomoclinicRK45Config</code>.</li> <li><code>HomoclinicFinderConfig</code> wraps a <code>trace</code> branch config with search-specific knobs (<code>scan_n</code>, <code>max_bisect</code>, <code>gap_tol</code>, <code>x_tol</code>, <code>branch_mode</code>, <code>sign_u</code>) so you can control both the tracing and parameter bisection behavior.</li> <li><code>HomoclinicPreset</code> bundles a branch config, RK settings, and scan tolerances so <code>\"fast\"</code>, <code>\"default\"</code>, or <code>\"precise\"</code> can be passed directly as the <code>preset</code> argument; you can also instantiate your own preset if those defaults are not aggressive enough.</li> </ul> <p>Preset Summary:</p> Name Description <code>fast</code> Quick scan with looser tolerances for exploration. <code>default</code> Balance of speed and robustness for standard use cases. <code>precise</code> Tight tolerances, smaller steps, and longer integrations for demanding orbits. <p>Both finders/tracers log <code>diag</code> metadata in their result <code>meta</code> objects so you can inspect ODE step counts, RK adjustments, and event triggers if a run fails or only barely succeeds.</p>"},{"location":"guides/analysis/manifold/#next-steps","title":"Next steps","text":"<ul> <li>Use <code>trace_manifold_1d_map</code> or <code>trace_manifold_1d_ode</code> once you know the target equilibrium and want to visualize its stable/unstable branches. Combine their <code>ManifoldTraceResult</code> with reference plots in manifold plots.</li> <li>Run the heteroclinic/homoclinic finder scripts from <code>examples/analysis/{heteroclinic_,homoclinic_}finder_tracer.py</code> to hunt for parameter values, then trace the orbit at the discovered parameter to create publication-ready visuals.</li> </ul>"},{"location":"guides/analysis/observers/","title":"Runtime observers","text":"<p>Dynlib ships a small analysis subsystem that runs alongside each <code>Sim.run()</code> invocation. Observer modules inject pre/post step hooks, carry workspace buffers, and optionally log traces into a shared <code>Results</code> object so you can compute diagnostics (Lyapunov exponents, spectra, convergence traces, etc.) without post-processing recorded trajectories.</p>"},{"location":"guides/analysis/observers/#registering-observers-with-simrun","title":"Registering observers with <code>Sim.run</code>","text":"<ul> <li><code>Sim.run(..., observers=\u2026)</code> accepts:</li> <li>An <code>ObserverModule</code> instance.</li> <li>An Observer factory (callable with the signature <code>(model, sim, record_interval)</code> and the <code>__observer_factory__</code> flag). Dynlib-built factories such as <code>lyapunov_mle_observer</code> set that flag so <code>Sim</code> can inject the compiled model automatically.</li> <li>A sequence of <code>ObserverModule</code>s. <code>Sim</code> wraps multiple modules into a <code>CombinedObserver</code> so they execute in a single pass.</li> <li><code>record_interval</code> is forwarded to factories; provide it at the <code>Sim.run</code> call if you want to sample traces at a coarser cadence than the step size.</li> <li>All observers are validated against the current stepper (<code>ObserverModule.validate_stepper</code>) before the run begins; incompatible combinations (e.g., a fixed-step observer on an adaptive stepper) raise immediately.</li> <li><code>CombinedObserver</code> enforces unique keys, rejects observers that mutate state, and allows at most one variational integrator per step, so pick either a single module or a carefully constructed combination.</li> <li>Because the runner can only emit one variational stepper per pass and observers share the same trace buffers/counters, you cannot mix multiple variational observers or let more than one observer mutate the model state in a single run. Each observer must also agree on the trace plan (same <code>TracePlan</code> or <code>record_interval</code>) so recorded traces stay aligned, and any observer requiring fast-path-incompatible features (event logs, accept/reject hooks, fixed-step enforcement) can force the run back to the wrapper path even if you requested the fast runner.</li> </ul>"},{"location":"guides/analysis/observers/#core-observer-building-blocks","title":"Core observer building blocks","text":"<ul> <li><code>ObserverModule</code> carries:</li> <li><code>requirements</code> (<code>ObserverRequirements</code>) that declare needs such as fixed-step execution, Jacobian-vector products (<code>need_jvp</code>), dense Jacobians, event logs, or variational stepping hooks.</li> <li><code>workspace_size</code>, <code>output_size</code>, <code>output_names</code>, and optional <code>trace</code> metadata (<code>TraceSpec</code>), which together determine how much runtime storage the runner allocates.</li> <li><code>hooks</code> (<code>ObserverHooks</code>) whose <code>pre_step</code>/<code>post_step</code> callbacks run each integration step; these hooks receive the current <code>t</code>, <code>dt</code>, states, params, runtime workspace, analysis workspace, output buffers, and trace buffers.</li> <li><code>TraceSpec</code> describes recorded trace layout and requires a <code>TracePlan</code> when width &gt; 0. For most observers you can pass a <code>FixedTracePlan(record_interval=K)</code> or simply rely on the <code>record_interval</code> you supplied to the factory.</li> <li>Observers expose helper methods such as <code>needs_trace</code>, <code>trace_stride</code>, and <code>trace_capacity(total_steps=...)</code> so <code>Sim</code> can tune buffer sizes and detect overflow; <code>build_observer_metadata(...)</code> collects this information into the final <code>Results</code> payload.</li> <li>If you intend to compile per-step hooks with Numba (fast-path runners), <code>ObserverModule.resolve_hooks(jit=True, dtype=...)</code> compiles them on demand, while <code>observer_noop_hook()</code> keeps runtimes type-stable when no hook is installed.</li> </ul>"},{"location":"guides/analysis/observers/#reference-lyapunov-observers","title":"Reference Lyapunov observers","text":"<p>The builtin <code>dynlib.runtime.observers</code> package provides two observer factories:</p> <ol> <li><code>lyapunov_mle_observer(...)</code></li> <li><code>lyapunov_spectrum_observer(...)</code></li> </ol> <p>Both factories auto-detect the required <code>jvp</code> and <code>n_state</code> from the provided model (or require you to pass them explicitly). They build variational hooks that either rely on the stepper\u2019s combined variational step or manually call the tangent integrator, so:</p> <ul> <li>Flow vs map mode: <code>mode=\"flow\"</code> keeps denominators in time units, <code>mode=\"map\"</code> sums iteration counts, and <code>mode=\"auto\"</code> infers the right behavior from <code>model.spec.kind</code>.</li> <li>Trace sampling: Specify <code>record_interval</code> (or <code>trace_plan=FixedTracePlan(record_interval=K)</code>) to capture convergence traces; without a trace plan the observer only updates its output registers.</li> <li>Variational stepping: Flow-mode observers require a stepper whose <code>caps.variational_stepping</code> is enabled. <code>prefer_variational_combined=True</code> tries to reuse the stepper\u2019s combined state+tangent integrator; otherwise the observer falls back to the tangent-only callback generated by <code>stepper_spec.emit_tangent_step(...)</code>.</li> <li>Analysis kind: Pass <code>analysis_kind=1</code> or another integer to tag the module for downstream metadata or caching; the value migrates through <code>build_observer_metadata</code> and runner caches.</li> </ul> <p>Factory usage is idiomatic:</p> <pre><code>from dynlib.runtime.observers import lyapunov_mle_observer, lyapunov_spectrum_observer\n\nsim.run(\n    N=5000,\n    dt=1.0,\n    record_interval=1,\n    observers=[\n        lyapunov_mle_observer(model=sim.model, record_interval=1),\n        lyapunov_spectrum_observer(model=sim.model, k=1, record_interval=1),\n    ],\n)\nres = sim.results()\n</code></pre> <p>The logistic-map demo in <code>examples/analysis/lyapunov_logistic_map_demo.py</code> shows this exact pattern, including how to read <code>res.observers</code> afterward.</p>"},{"location":"guides/analysis/observers/#inspecting-observer-outputs","title":"Inspecting observer outputs","text":"<ul> <li><code>ResultsView.observers</code> returns a dictionary of <code>ObserverResult</code> objects keyed by each observer\u2019s <code>key</code>. Each <code>ObserverResult</code> exposes:</li> <li>Mapping access (<code>result[\"out\"]</code>, <code>result[\"trace\"]</code>) for backwards compatibility.</li> <li>Auto-generated attribute access (<code>result.log_growth</code>, <code>result.steps</code>, etc.) derived from <code>output_names</code> and <code>trace_names</code>.</li> <li>Discovery helpers (<code>result.output_names</code>, <code>result.trace_names</code>, <code>list(result)</code>).</li> <li>Trace helpers (<code>result.trace</code>, <code>result.trace_steps</code>, <code>result.trace_time</code>) that align trace rows with step/time indices whenever the runner recorded them.</li> <li>Example:</li> </ul> <pre><code>lyap = res.observers[\"lyapunov_mle\"]\nmle = lyap.mle          # final converged exponent\nlog_growth = lyap.log_growth\nn_steps = int(lyap.steps)\ntrace = lyap[\"mle\"]     # full convergence trace (record_interval spacing)\n</code></pre> <ul> <li>Runtime metadata survives post-processing via <code>res.observer_metadata</code> (or the raw <code>Results.observer_metadata</code>) so you can inspect workspace sizes, trace strides, or whether a trace overflowed.</li> </ul>"},{"location":"guides/analysis/observers/#fast-path-and-practical-notes","title":"Fast-path and practical notes","text":"<ul> <li>When observers are present, the runner switches to the analysis-aware variants (<code>RunnerVariant.ANALYSIS</code> / <code>FASTPATH_ANALYSIS</code>). <code>CombinedObserver.supports_fastpath(...)</code> gates whether a fast-path runner is compatible; for instance, observers requiring event logs, accept/reject hooks, or state mutation disable fast-path execution.</li> <li>Observers without <code>trace</code> data still contribute output slots, so <code>Sim.results().observers</code> will return <code>ObserverResult</code>s even if <code>trace_plan</code> was <code>None</code>.</li> <li>If you craft custom observers, follow the same pattern: declare requirements, return an <code>ObserverModule</code>, and set <code>workspace_size</code>/<code>output_names</code>/<code>trace_names</code> so downstream code (runner caches, metadata builders) can align buffers automatically.</li> </ul> <p>Use the observer infrastructure to monitor runtime diagnostics (Lyapunov exponents, spectra, growth rates) without extra post-processing and rely on <code>ResultsView.observers</code> to keep the diagnostics keyed and time-aligned with your simulation run.</p>"},{"location":"guides/analysis/post-analysis/","title":"Post-analysis","text":"<p>Post-processing is how you turn raw simulation or sweep results into the insights you care about: summary statistics, rise/fall times, threshold crossings, and bifurcation scatter clouds. Dynlib keeps the recorded trajectories in place, so you can line up analysis helpers with the same time axis you already plotted or exported.</p>"},{"location":"guides/analysis/post-analysis/#from-resultsview-to-trajectory-analyzers","title":"From <code>ResultsView</code> to trajectory analyzers","text":"<p>After a run you normally call <code>res = sim.results()</code> (see the Simulation results guide for the full API). <code>res.analyze(...)</code> builds the analyzer you need:</p> <ul> <li><code>res.analyze(\"x\")</code> returns a <code>TrajectoryAnalyzer</code> for a single variable.</li> <li><code>res.analyze([\"x\", \"y\"])</code> or any explicit tuple returns a <code>MultiVarAnalyzer</code> for the requested columns.</li> <li><code>res.analyze()</code> with no arguments prefers the recorded states (falls back to recorded aux variables if no states were recorded) and returns <code>MultiVarAnalyzer</code>.</li> </ul> <p>Both analyzers wrap the recorded NumPy views, so all statistics and temporal helpers operate on the same grid you see in <code>res.t</code>.</p> <pre><code>res = sim.results()\nxa = res.analyze(\"x\")\npeak_time, peak_value = xa.argmax()\nsummary = res.analyze().summary()  # dict of per-variable stats\n</code></pre> <p><code>TrajectoryAnalyzer</code> exposes:</p> <ul> <li>basic stats: <code>min()</code>, <code>max()</code>, <code>mean()</code>, <code>std()</code>, <code>variance()</code>, <code>median()</code>, <code>percentile(q)</code>, <code>summary()</code>.</li> <li>extrema timing: <code>argmin()</code>, <code>argmax()</code>, <code>range()</code>.</li> <li>temporal helpers: <code>initial()</code>, <code>final()</code>, <code>crossing_times(threshold, direction)</code>, <code>zero_crossings(direction)</code>, <code>time_above(threshold)</code>, <code>time_below(threshold)</code>.</li> </ul> <p><code>MultiVarAnalyzer</code> mirrors the same methods but returns dictionaries keyed by variable name (and lazy-caches per-variable <code>TrajectoryAnalyzer</code> instances to avoid rebuilding). Use it whenever you want side-by-side stats for multiple recorded variables.</p>"},{"location":"guides/analysis/post-analysis/#parameter-sweeps-bifurcation-data","title":"Parameter sweeps \u2192 bifurcation data","text":"<p>When you run a sweep via <code>dynlib.analysis.sweep.traj_sweep(...)</code>, the returned <code>SweepResult</code> bundles the grid, per-run payload, and any recorded stats. Call <code>sweep_result.bifurcation(\"x\")</code> to get a <code>BifurcationExtractor</code> for that variable; this helper lazily converts the trajectories into the scatter points needed for bifurcation diagrams.</p> <pre><code>from dynlib.analysis import sweep\nfrom dynlib.plot import bifurcation_diagram\n\nsweep_result = sweep.traj_sweep(sim, param=\"r\", values=r_values, record_vars=[\"x\",\"y\"], N=2000)\nextrema = sweep_result.bifurcation(\"x\").extrema(kind=\"max\", tail=500, max_points=80)\nbifurcation_diagram(extrema)\n</code></pre> <p><code>BifurcationExtractor</code> behaves like a thin <code>BifurcationResult</code> plus some helpers:</p> <ul> <li><code>.all()</code> (default mode if you pass the extractor straight to a plot helper) concatenates every recorded point so you can inspect the transient and steady-state data together.</li> <li><code>.tail(n)</code> keeps the last <code>n</code> samples per parameter (useful when the limit cycle has stabilized).</li> <li><code>.final()</code> only keeps the final sample for each sweep value, helping you spot equilibria and slow drifts.</li> <li><code>.extrema(...)</code> detects maxima/minima (or both) within the (optional) tail, with parameters for <code>max_points</code> and <code>min_peak_distance</code> to avoid dense clusters.</li> <li><code>.poincare(section_var=..., level=..., direction=..., tail=..., max_points=..., min_section_distance=...)</code> builds section crossings while interpolating crossing times and the corresponding value of the target variable.</li> </ul> <p>Each method returns a <code>BifurcationResult</code> dataclass with:</p> <ul> <li><code>param_name</code>: the swept parameter (used for automatic axis labeling).</li> <li><code>values</code>: the full sweep grid (shape <code>(M,)</code>).</li> <li><code>p</code>, <code>y</code>: flattened arrays of parameter/value pairs suitable for scatter plots.</li> <li><code>mode</code>: which extraction strategy produced the data.</li> <li><code>meta</code>: copy of <code>SweepResult.meta</code> plus the analyzer settings that generated the result.</li> </ul> <p>Pass the result or extractor directly to <code>dynlib.plot.bifurcation_diagram()</code> to reuse axis labels and metadata, or feed the <code>.p</code>/<code>.y</code> arrays into your own plot utilities.</p>"},{"location":"guides/analysis/post-analysis/#tips-for-reliable-post-analysis","title":"Tips for reliable post-analysis","text":"<ul> <li>Verify the variable name you analyze actually appears in <code>res.state_names</code>/<code>res.aux_names</code> or <code>SweepResult.record_vars</code>; otherwise <code>res.analyze(...)</code> or <code>sweep_result.bifurcation(...)</code> raises immediately.</li> <li>When you only care about the long-term behavior, trim transients with <code>.tail(n)</code> or slice <code>res.segment[...]</code> before analyzing.</li> <li>Use <code>MultiVarAnalyzer</code> summaries to compare variables (<code>mean()</code> returns <code>{\"x\": ..., \"y\": ...}</code>) and drill into individual components with <code>.crossing_times(...)</code> if a specific variable is oscillating.</li> <li>Combine the analyzer metadata with plot helpers to annotate findings (e.g., label the time of the global maximum using <code>xa.argmax()</code> and <code>res.t</code>).</li> </ul>"},{"location":"guides/analysis/sweep/","title":"Sweep analysis utilities","text":"<p>Dynlib keeps a dedicated <code>dynlib.analysis.sweep</code> module so you can explore how system behavior changes across a parameter grid without duplicating bootstrapping logic or manually iterating runs. Each helper reads the current simulation session (<code>sim.state_vector(source=\"session\")</code> and <code>sim.param_vector(source=\"session\")</code>) as the baseline, varies one parameter, and returns a <code>SweepResult</code> whose contents match what you recorded.</p>"},{"location":"guides/analysis/sweep/#core-result-helpers","title":"Core result helpers","text":""},{"location":"guides/analysis/sweep/#sweepresult","title":"<code>SweepResult</code>","text":"<p><code>SweepResult</code> normalizes the metadata you expect (<code>param_name</code>, <code>values</code>, <code>kind</code>, <code>meta</code>) and exposes the actual data through mapping and attribute access. Scalar sweeps populate <code>outputs</code>, Lyapunov sweeps add <code>traces</code>, and trajectory sweeps attach a <code>TrajectoryPayload</code> in <code>payload</code>. The helper re-exports recorded variable names (<code>record_vars</code>), provides <code>t</code>/<code>t_all</code>, and gives you convenience helpers such as <code>.runs</code> (per-value <code>SweepRun</code> objects) or <code>.stack()</code> when all trajectories share the same length. Asking for a missing key raises immediately and lists the available fields so typos fail fast.</p>"},{"location":"guides/analysis/sweep/#trajectorypayload-sweeprun-and-sweeprunsview","title":"<code>TrajectoryPayload</code>, <code>SweepRun</code>, and <code>SweepRunsView</code>","text":"<p><code>TrajectoryPayload</code> keeps the tuple of recorded names, every run\u2019s <code>t_runs</code>/<code>data</code> arrays, and the sweep grid <code>values</code>. It also builds an internal <code>_var_index</code>, which powers named access (<code>payload[\"x\"]</code>, <code>payload.series([...])</code>) and the ability to stack (<code>payload.stack()</code>) or grab the default time axis (<code>payload.t</code>). When different runs log different lengths (adaptive steppers, <code>record_interval</code>, etc.), <code>t_all</code> and <code>data</code> remain aligned so you can handle each run manually.</p> <p><code>SweepRunsView</code> is a list-like wrapper over the run values; iterating it yields <code>SweepRun</code> instances. Each <code>SweepRun</code> stores <code>param_value</code>, the per-run <code>t</code>, and a variable lookup table so <code>run[\"x\"]</code> or <code>run[[\"x\",\"y\"]]</code> returns the recorded trace for that parameter value.</p>"},{"location":"guides/analysis/sweep/#sweep-helpers","title":"Sweep helpers","text":""},{"location":"guides/analysis/sweep/#scalar_sweep","title":"<code>scalar_sweep</code>","text":"<p>Use <code>scalar_sweep</code> for one-number summaries per parameter value (equilibria, mean trends, min/max envelopes). You record a single <code>var</code> and pick a reduction <code>mode</code>:</p> <ul> <li><code>\"final\"</code> (default): the last recorded sample</li> <li><code>\"mean\"</code>: arithmetic average over the logged window</li> <li><code>\"max\"</code>/<code>\"min\"</code>: extreme values</li> </ul> <p>The helper tries a fast-path batch run (<code>fastpath_batch_for_sim</code>) for eligible configurations. If the fast path is unavailable it warns (<code>_warn_fastpath_fallback</code>) and falls back to normal <code>Sim.run()</code> calls. Result is a <code>SweepResult(kind=\"scalar\")</code> where <code>outputs['y']</code> holds the reduced array (shape <code>(M,)</code>) and <code>meta</code> records the integration settings, stepper kind, and reduction mode.</p> <pre><code>from dynlib.plot import series\n\nres = sweep.scalar_sweep(\n    sim,\n    param=\"r\",\n    values=np.linspace(2.5, 4.0, 4000),\n    var=\"x\",\n    mode=\"final\",\n    N=2000,\n    transient=1000,\n)\nseries.plot(x=res.values, y=res.y, xlabel=\"r\", ylabel=\"x*\")\n</code></pre>"},{"location":"guides/analysis/sweep/#traj_sweep","title":"<code>traj_sweep</code>","text":"<p><code>traj_sweep</code> records full trajectories for any combination of <code>record_vars</code> (e.g., <code>\"x\"</code>, <code>\"y\"</code>, <code>\"z\"</code>). Each run\u2019s time series lives in a <code>TrajectoryPayload</code>, so you can call <code>res[\"x\"]</code>, <code>res.series([\"x\",\"y\"])</code>, <code>res.stack()</code>, or iterate <code>res.runs</code> for per-parameter plotting. The sweep supports both fast-path batch execution and a <code>ProcessPoolExecutor</code> when <code>values</code> &gt; 1000. The <code>parallel_mode</code> argument controls how that batch run is executed (<code>\"auto\"</code>, <code>\"threads\"</code>, <code>\"process\"</code>, <code>\"none\"</code>); <code>max_workers</code> tunes the worker pool size. When number of workers resolves to one or <code>process</code> mode isn\u2019t efficient the helper transparently downgrades to sequential execution.</p> <p><code>record_interval</code> allows you to decimate logging for memory savings, and the sweep remembers that interval in <code>meta</code>. You can also request a fixed <code>dt</code>, <code>t0</code>, <code>T</code>, or discrete iteration count <code>N</code> (useful for maps).</p> <pre><code>from dynlib.plot import phase\n\nres = sweep.traj_sweep(\n    sim,\n    param=\"A\",\n    values=[0.5, 1.0, 1.5],\n    record_vars=[\"x\", \"y\"],\n    dt=0.01,\n    T=20.0,\n    record_interval=5,\n)\nfor run in res.runs:\n    phase.xy(x=run[\"x\"], y=run[\"y\"], label=f\"A={run.param_value}\")\n</code></pre>"},{"location":"guides/analysis/sweep/#lyapunov_mle_sweep","title":"<code>lyapunov_mle_sweep</code>","text":"<p>This helper couples a parameter sweep with the maximum Lyapunov exponent (MLE) observer. For the fast-path batch execution (and the Lyapunov observers themselves) you should use a JIT-compiled sim with a fixed-step stepper and an explicit <code>dt</code>, but the helper gracefully falls back to sequential <code>Sim.run()</code> with observers attached if fast path support is unavailable. The function returns <code>outputs</code> for <code>mle</code>, <code>log_growth</code>, and <code>steps</code>, and if you provided <code>record_interval</code> it also returns <code>traces['mle']</code> (list of convergence arrays) so you can inspect how each exponent converged. <code>analysis_kind</code> lets you choose between algorithm variants.</p> <p>The sweep attempts fast-path batch runs with optional <code>ProcessPoolExecutor</code> acceleration (chunks of the values list). If the fast path or fast parallel worker initialization fails it warns and falls back to sequential <code>Sim.run()</code> calls with the Lyapunov observer attached.</p> <pre><code>from dynlib.plot import series\n\nres = sweep.lyapunov_mle_sweep(\n    sim,\n    param=\"r\",\n    values=np.linspace(3.0, 4.0, 400),\n    N=5000,\n    transient=1000,\n    record_interval=10,\n)\nseries.plot(x=res.values, y=res.mle, xlabel=\"r\", ylabel=\"\u03bb_max\")\n</code></pre>"},{"location":"guides/analysis/sweep/#lyapunov_spectrum_sweep","title":"<code>lyapunov_spectrum_sweep</code>","text":"<p>Compute the first <code>k</code> Lyapunov exponents across a parameter grid. Like the MLE sweep, it is tuned for JIT + fixed <code>dt</code> fast-path execution (and accepts an optional <code>init_basis</code> for the tangent space), but it also falls back to sequential <code>Sim.run()</code> with the observer attached whenever the batch fast path or process parallelism is unavailable. The <code>outputs</code> dictionary always contains:</p> <ul> <li><code>spectrum</code>: array of shape <code>(M, k)</code> with the normalized exponents</li> <li><code>log_r</code>: the raw logarithmic growth values (shape <code>(M, k)</code>)</li> <li><code>steps</code>: final number of algorithm steps per value</li> <li><code>lyap0</code>, <code>lyap1</code>, \u2026 <code>lyap{k-1}</code>: convenient aliases for each exponent column</li> </ul> <p>There are no <code>traces</code>, because the underlying observer only emits the latest spectrum. Use <code>parallel_mode</code>/<code>max_workers</code> and <code>record_interval</code> just like the MLE sweep; the helper also falls back to sequential execution when necessary.</p>"},{"location":"guides/analysis/sweep/#practical-notes","title":"Practical notes","text":"<ul> <li>If the fast path is closed (<code>fastpath_batch_for_sim</code> returns <code>None</code>) you\u2019ll see a warning that the sweep is falling back to <code>Sim.run()</code>. Providing <code>jit=True</code>, using fixed-step steppers, and recording explicit <code>dt</code>/<code>N</code> values keeps the fast path healthy.</li> <li>For trajectory sweeps, <code>record_interval</code> and <code>max_steps</code> let you trade resolution for memory/cpu. Trajectories are stored exactly as produced, so you can re-use them with <code>dynlib.analysis.post.bifurcation.BifurcationExtractor</code> via <code>res.bifurcation(\"x\")</code> to generate scatter clouds, extrema, or trimmed sample sets.</li> <li>Lyapunov helpers accept <code>analysis_kind</code> (default <code>1</code>) so you can pick the variant that best matches your system. <code>max_workers</code> defaults to machine cores (capped at 8) via <code>_resolve_process_workers</code>.</li> <li>See <code>examples/bifurcation_logistic_map.py</code> for an end-to-end script that runs <code>traj_sweep</code>, extracts <code>res.bifurcation(\"x\")</code>, and feeds the result into <code>dynlib.plot.bifurcation_diagram</code>.</li> <li>All sweeps return <code>meta</code> metadata that includes stepper settings, timestamps, and any parallel-run configuration so you can trace how the data was generated.</li> </ul>"},{"location":"guides/cli/cli/","title":"Command-line guide","text":"<p>Dynlib exposes a lightweight command-line interface as two entry points: the <code>dynlib</code> console script that is installed with the package and <code>python -m dynlib.cli</code>. The CLI mirrors a handful of runtime utilities so you can validate models, introspect the stepper registry, and manage the on-disk JIT cache without writing a Python script. Each verb/noun parser layer supports <code>--help</code>, so run <code>dynlib &lt;command&gt; --help</code> or <code>python -m dynlib.cli &lt;command&gt; --help</code> whenever you need a reminder about the available options.</p>"},{"location":"guides/cli/cli/#global-flags","title":"Global flags","text":"<ul> <li><code>--version</code>   Prints the currently installed dynlib version. The CLI discovers the version first via <code>importlib.metadata</code> and, when that fails (editable installs, source checkouts, etc.), falls back to reading <code>pyproject.toml</code>.</li> </ul>"},{"location":"guides/cli/cli/#model-tooling","title":"Model tooling","text":"<p><code>dynlib model validate &lt;uri&gt;</code></p> <ul> <li>Purpose: Parse and validate a model defined in dynlib's TOML-based DSL. The CLI delegates to <code>load_model_from_uri</code>, so it supports the same <code>builtin://</code> URIs used in the rest of the project as well as filesystem paths and other registered loaders.</li> <li>Success message: When the DSL is valid, the command prints <code>Model OK</code> along with the model kind (<code>ode</code> or <code>map</code>), dtype, state count, and the default stepper recorded in <code>spec.sim.stepper</code>.</li> <li>Error handling: Syntax violations, missing fields, or runtime validation problems are surfaced via <code>DynlibError</code> with a descriptive message on <code>stderr</code> and a non-zero exit code.</li> </ul> <p>Use this command as a quick sanity check before running a simulation, sharing a model, or bundling the spec into another toolchain.</p>"},{"location":"guides/cli/cli/#steppers-registry","title":"Steppers registry","text":"<p><code>dynlib steppers list [--kind &lt;kind&gt;] [--&lt;cap&gt;] [--jacobian &lt;policy&gt;]</code></p> <ul> <li>Purpose: Inspect every registered <code>StepperMeta</code>/<code>StepperCaps</code> pair. Because the CLI imports <code>dynlib.steppers</code> as a side effect, all built-in and registered third-party steppers appear in the listing.</li> <li>Displayed columns: Each line shows the stepper name, <code>kind</code>, <code>scheme</code>, <code>order</code>, <code>stiff</code> hint, and every <code>StepperCaps</code> field so you can quickly compare features without reading source code.</li> <li>Kind filter: Use <code>--kind ode</code> or <code>--kind map</code> to restrict the list to ODE solvers or discrete maps (the same <code>Kind</code> enum used by the runtime).</li> <li>Capability filters: The CLI dynamically exposes one flag per <code>StepperCaps</code> field.</li> <li>Boolean flags (<code>--dense_output</code>, <code>--jit_capable</code>, <code>--requires_scipy</code>, <code>--variational_stepping</code>) are requirements. When provided, only steppers whose <code>StepperCaps</code> set that field to <code>True</code> remain in the output.</li> <li>Value flags currently include <code>--jacobian</code> (matching the <code>JacobianPolicy</code> literal: <code>none</code>, <code>internal</code>, <code>optional</code>, <code>required</code>). Provide the exact policy string to filter steppers that declare that Jacobian behavior.</li> <li>Use cases: This command is handy for confirming which steppers support dense output (e.g., being the basis for animation or variable-step interpolation), identifying the subset that can be JIT-compiled, or quickly checking that a third-party stepper registered the capabilities you expect.</li> </ul>"},{"location":"guides/cli/cli/#cache-management","title":"Cache management","text":"<p>All cache commands delegate to <code>resolve_cache_root()</code> so they respect your <code>[cache]</code> overrides, <code>DYN_MODEL_PATH</code> tag map extensions, or <code>DYNLIB_CONFIG</code> environment variable described in the config file.</p>"},{"location":"guides/cli/cli/#dynlib-cache-path","title":"<code>dynlib cache path</code>","text":"<ul> <li>Prints the cache root directory. Useful when you want to inspect the files on disk, mount the directory into a container, or troubleshoot permission issues.</li> </ul>"},{"location":"guides/cli/cli/#dynlib-cache-list-stepper-name-dtype-token-hash-prefix","title":"<code>dynlib cache list [--stepper &lt;name&gt;] [--dtype &lt;token&gt;] [--hash &lt;prefix&gt;]</code>","text":"<ul> <li>Purpose: Enumerate every entry under <code>cache_root/jit/{triplets,steppers,runners}</code>.</li> <li>Output format: Each entry prints the family (<code>triplets</code>, <code>steppers</code>, or <code>runners</code>), stepper name, dtype, spec hash, digest, size (human-readable), and filesystem path. Entries that recorded compile-time components also add <code>components=...</code>.</li> <li>Filters:</li> <li><code>--stepper</code> matches the stepper name (case-insensitive).</li> <li><code>--dtype</code> matches the dtype token (also case-insensitive).</li> <li><code>--hash</code> matches a prefix of the model spec hash to pull the artifacts associated with a particular spec.</li> <li>Ordering: Results are sorted by family, stepper, dtype, and digest so related artifacts appear together.</li> <li>Use cases: Run this after you switch dtypes/steppers to confirm whether cached kernels exist, or to verify which runners the <code>disk_cache</code> flag left behind. Filtering by <code>--hash</code> is the fastest way to find the compiled artifact for a model hash, and <code>--dtype</code> is helpful when you use mixed precision.</li> </ul>"},{"location":"guides/cli/cli/#dynlib-cache-clear-all-stepper-name-dtype-token-hash-prefix-dry_run","title":"<code>dynlib cache clear (--all | --stepper &lt;name&gt; | --dtype &lt;token&gt; | --hash &lt;prefix&gt;) [--dry_run]</code>","text":"<ul> <li>Purpose: Delete cached JIT artifacts you no longer need or to recover from cache corruption after code changes.</li> <li>Safety guard: You must specify <code>--all</code> or at least one of the filter flags. Without a filter the CLI exits with a message and error code <code>2</code>.</li> <li><code>--all</code>: Removes the entire cache root via <code>shutil.rmtree</code>. Use this when you want a clean slate (for example, after upgrading dynlib or changing <code>cache_root</code>). The command does nothing if the directory is missing.</li> <li>Selective deletion: Combine <code>--stepper</code>, <code>--dtype</code>, and/or <code>--hash</code> to delete only the matching cache entries. Matching is case-insensitive, and <code>--hash</code> works on prefix matches so you can target a commit or spec version even if you only remember part of the hash.</li> <li><code>--dry_run</code>: Prints the files and directories that would be removed without touching disk. Run this before a destructive operation to double-check the target list.</li> <li>Feedback: Each deleted cache prints a confirmation line and the command returns a non-zero exit code if any deletion fails.</li> </ul>"},{"location":"guides/cli/cli/#examples","title":"Examples","text":"<pre><code>dynlib model validate docs/models/lorenz.toml\ndynlib steppers list --kind ode --jit_capable --variational_stepping\ndynlib cache list --hash 9c8a --dtype float64\ndynlib cache clear --stepper rk4 --dry_run\n</code></pre>"},{"location":"guides/cli/cli/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>When stepping into cache issues, pair <code>dynlib cache list</code> with <code>dynlib cache path</code> to know which directory you are inspecting.</li> <li>If the CLI cannot find a stepper you expect, make sure the module defining it has been imported (the runtime automatically imports <code>dynlib.steppers</code> on startup, but third-party steppers must register themselves before running the CLI).</li> <li>The <code>model validate</code> command raises <code>DynlibError</code> for any DSL parsing issue; run it in a shell pipeline (<code>dynlib model validate ... || true</code>) when you want to process error output via another tool.</li> </ul>"},{"location":"guides/modeling/","title":"Modeling guide","text":"<p>This guide explains how to declare, extend, and tune dynlib models using the TOML DSL and the helper utilities that keep specs structured, readable, and reproducible. Start with the DSL overview, then explore the reusable components and the workflow helpers that tie a spec to the runtime.</p>"},{"location":"guides/modeling/#model-structure-essentials","title":"Model structure essentials","text":"<ul> <li>DSL basics \u2014 the canonical TOML template that lists every table you can write (<code>[model]</code>, <code>[states]</code>, <code>[params]</code>, <code>[constants]</code>, <code>[equations]</code>, <code>[aux]</code>, <code>[functions]</code>, <code>[events]</code>, <code>[sim]</code>, etc.).</li> <li>Equations \u2014 compares the <code>rhs</code>, block, inverse, and Jacobian forms, explains which contexts accept each one, and outlines best practices for keeping your right-hand sides tidy.</li> <li>Math &amp; macros \u2014 catalogs the built-in math functions, scalar macros (<code>clip</code>, <code>approx</code>, <code>relu</code>, etc.), generator comprehensions, and event utilities available inside every expression.</li> <li>Ternary <code>if</code> \u2014 shows how the Python-style ternary expression streamlines small branches without pulling you into full <code>if</code>/<code>else</code> blocks.</li> <li>Model registry \u2014 describes tag URIs (<code>builtin://</code>, custom tags, inline models), the <code>DYNLIB_CONFIG</code>/<code>DYN_MODEL_PATH</code> behavior, and the CLI helpers that validate or override registry paths.</li> </ul>"},{"location":"guides/modeling/#reusable-building-blocks","title":"Reusable building blocks","text":"<ul> <li>Auxiliary variables \u2014 name derived expressions so you can share them between equations, events, or Jacobians without repeating the math.</li> <li>DSL functions \u2014 define reusable functions with arguments, expression bodies, and clean callsites that keep the DSL declarative.</li> <li>Events \u2014 wire <code>cond</code>, <code>action</code>, and logging metadata to <code>pre</code>/<code>post</code> phases, use the event macros, and manage event logs without destabilizing fast-path runners.</li> <li>Lagging \u2014 enable <code>lag_&lt;state&gt;(k)</code> helpers, control the buffer depth, and understand how lagged states interact with ODEs, maps, and NumPy-friendly runtimes.</li> <li>Inline models \u2014 embed a TOML snippet in a Python string so you can prototype models entirely inside tests or notebooks.</li> </ul>"},{"location":"guides/modeling/#workflow-helpers","title":"Workflow helpers","text":"<ul> <li>Config file \u2014 customize registry paths, cache roots, and plugin behavior through <code>~/.config/dynlib/config.toml</code> or the <code>DYNLIB_CONFIG</code> environment variable.</li> <li>Mods \u2014 patch models dynamically with <code>remove</code>, <code>replace</code>, <code>add</code>, and <code>set</code> verbs so you can build variants, override parameters, or inject new events without cloning the base spec.</li> <li>Presets \u2014 capture reusable state/parameter snapshots, load/save them from disk, and replay them via the simulation bank.</li> <li>Simulation defaults \u2014 document the <code>[sim]</code> table, explain how it merges with <code>Sim.run</code> overrides, and highlight early-exit, recording, and tolerancing knobs.</li> </ul>"},{"location":"guides/modeling/aux/","title":"Auxiliary Variables","text":"<p>Auxiliary variables (<code>[aux]</code> in DSL files) let you name intermediate or derived expressions so you can reuse them throughout equations, events, and functions without repeating their logic. They are evaluated after the state updates for each step, and every expression is compiled to Python before the model runs.</p>"},{"location":"guides/modeling/aux/#syntax","title":"Syntax","text":"<pre><code>[aux]\nenergy = \"0.5 * mass * velocity^2\"\ngain = \"baseline_gain * exp(-t / tau)\"\n# You can reference any previously defined aux as long as there is no cycle.\n</code></pre> <ul> <li>Every value must be a string literal because it is parsed and type-checked as an expression. When the expression includes <code>^</code>, the compiler rewrites it to <code>**</code> for Python compatibility.</li> <li>Aux expressions can refer to states, parameters, time (<code>t</code>), other aux (no cycles), user-defined functions, math macros, and generator comprehensions. They cannot use event macros because they do not execute in event contexts.</li> <li><code>t</code> is available just like in equations, so time-dependent aux are easy to write.</li> </ul>"},{"location":"guides/modeling/aux/#expression-context","title":"Expression Context","text":"<ul> <li>States: current values only (lag notation must reference states explicitly).</li> <li>Parameters: the numerical constants defined in <code>[params]</code>.</li> <li>Auxiliary variables: you may use another aux defined earlier in the file.</li> <li>Built-in math functions &amp; scalar macros: everything from <code>dynlib</code>\u2019s DSL library (<code>sin</code>, <code>cos</code>, <code>clip</code>, <code>approx</code>, generator comprehensions, etc.).</li> <li>User-defined functions: call them by name once they are declared in <code>[functions]</code> (no recursion).</li> <li>Time (<code>t</code>): always present in expressions just like in equations.</li> <li>Lag notation: only available if the referenced symbol is a state; aux variables cannot be lagged directly.</li> </ul>"},{"location":"guides/modeling/aux/#example-usage","title":"Example Usage","text":"<ul> <li>Use aux to compute shared expressions such as energy, forces, or logging helpers so you do not repeat long calculations.</li> <li>Pair aux with events by referencing them in <code>cond</code>, <code>action</code>, or <code>log</code> lists rather than retyping the expressions.</li> <li>Aux can simplify Jacobian entries or generator comprehensions when the same subexpression appears in multiple equations.</li> </ul>"},{"location":"guides/modeling/aux/#interaction-with-mods","title":"Interaction with Mods","text":"<p>Mods can manipulate auxiliary variables using the <code>remove</code>, <code>replace</code>, <code>add</code>, and <code>set</code> verbs.</p> <ul> <li><code>mod.remove.aux</code> requires the aux to exist and simply drops it from the model.</li> <li><code>mod.replace.aux</code> lets you change the definition while keeping the same name.</li> <li><code>mod.add.aux</code> inserts a new auxiliary (errors if the name already exists).</li> <li><code>mod.set.aux</code> upserts the expression (creates it if missing, updates if present).</li> </ul> <p>These verbs respect the mod verb order (<code>remove \u2192 replace \u2192 add \u2192 set</code>), so you can remove an aux and add a new definition with the same name later in the same mod.</p>"},{"location":"guides/modeling/aux/#best-practices","title":"Best Practices","text":"<ol> <li>Prioritize readability: Give aux names that describe the quantity (<code>kinetic_energy</code>, <code>normalized_voltage</code>) so they help rather than hide complexity.</li> <li>Avoid cycles: Do not create mutual dependencies between aux variables; the compiler enforces a DAG.</li> <li>Keep expressions focused: If you start requiring lagged values or differential behavior, consider promoting the quantity to a state instead of overloading aux logic.</li> <li>Document intent: A short TOML comment next to the aux definition is enough to remind future readers why the derived quantity exists.</li> <li>Reuse judiciously: Aux are great for repeated math, but do not over-index the model with trivial aliases that only obfuscate the math.</li> </ol>"},{"location":"guides/modeling/config-file/","title":"Model registry configuration","text":"<p>Dynlib keeps its model registry details in a small TOML file so you can assign tags to directories, override builtin models, and control where the JIT cache lives. <code>load_config()</code> merges the file with <code>DYN_MODEL_PATH</code> entries before handing the final <code>PathConfig</code> (tag map + optional cache root) to every resolver.</p>"},{"location":"guides/modeling/config-file/#where-the-config-lives","title":"Where the config lives","text":"<ul> <li>Default path (when <code>DYNLIB_CONFIG</code> is not set):</li> <li>Linux/Unix: <code>${XDG_CONFIG_HOME:-~/.config}/dynlib/config.toml</code></li> <li>macOS: <code>~/Library/Application Support/dynlib/config.toml</code></li> <li>Windows: <code>%APPDATA%/dynlib/config.toml</code></li> <li>Override: set <code>DYNLIB_CONFIG</code> to a custom TOML file and dynlib loads that instead.</li> <li>Missing file: <code>load_config()</code> quietly returns an empty config so dynlib still works with <code>DYNLIB_CONFIG</code> or <code>DYN_MODEL_PATH</code> overrides.</li> </ul>"},{"location":"guides/modeling/config-file/#file-format","title":"File format","text":"<pre><code>[paths]\ncustom = [\"~/repos/dynlib-models\", \"/opt/dynlib/models\"]\nbuiltin = [\"~/custom/builtin\"] # This extends the built-in model path, does not replace it.\n\ncache_root = \"~/Library/Caches/dynlib\"\n# or the alternate form\n[cache]\nroot = \"~/Library/Caches/dynlib\"\n</code></pre> <ul> <li><code>[paths]</code> maps a tag name (like <code>builtin</code> or <code>custom</code>) to one or more directory roots. Each entry can be a string or a list of strings. Dynlib resolves a URI such as <code>custom://circuit/srn</code> by searching each root in order.</li> <li>The <code>[cache]</code> table (or top-level <code>cache_root</code>) lets you pin the JIT cache location passed to <code>resolve_cache_root()</code>. Provide an absolute or <code>~/</code>-expanded path, and dynlib validates writability before using it.</li> <li>The file is guarded by <code>ConfigError</code> if the TOML is malformed, <code>[paths]</code> contains non-string entries, or a required value is missing.</li> </ul>"},{"location":"guides/modeling/config-file/#environment-overrides","title":"Environment overrides","text":"<ul> <li><code>DYN_MODEL_PATH</code> lets you prepend tag roots without editing the file. Its syntax is <code>TAG=/path/one:/path/two</code> on POSIX and <code>TAG=C:\\path1;TAG2=C:\\path2</code> on Windows.</li> <li>Entries are parsed into a map and inserted before the ones declared in the config file, so environment paths win when multiple directories share a tag.</li> <li>Dynlib keeps the builtin models folder appended to the <code>builtin</code> tag list after all overrides so <code>builtin://</code> always resolves even if you override it.</li> </ul>"},{"location":"guides/modeling/config-file/#resolution-order-and-behavior","title":"Resolution order and behavior","text":"<ol> <li><code>load_config()</code> loads the TOML file (if present) and builds the tag map.</li> <li><code>DYN_MODEL_PATH</code> entries are prepended to each tag, letting temporary overrides shadow the file-backed roots.</li> <li>The builtin models directory is appended to the <code>builtin</code> tag to guarantee <code>builtin://</code> URIs exist even when you redefine the tag.</li> <li>The resulting <code>PathConfig</code> is cached by resolver helpers, so restarting the CLI or process re-reads any on-disk changes.</li> </ol> <p>When dynlib can\u2019t find a tag or the requested model path, it raises a <code>ConfigError</code> (unknown tag) or <code>ModelNotFoundError</code> (file search failed), listing the candidates it tried.</p>"},{"location":"guides/modeling/config-file/#troubleshooting-tips","title":"Troubleshooting tips","text":"<ul> <li>Run <code>dynlib model validate &lt;uri&gt;</code> to confirm the registry resolves a model before you run a simulation.</li> <li>Inspect <code>DYNLIB_CONFIG</code> and <code>DYN_MODEL_PATH</code> to ensure they point to writable directories.</li> <li>If the cache root in the config is unwritable, dynlib falls back to a platform default (Linux: <code>~/.cache/dynlib</code>, macOS: <code>~/Library/Caches/dynlib</code>, Windows: <code>%LOCALAPPDATA%/dynlib/Cache</code>). It emits a <code>RuntimeWarning</code> when this happens.</li> </ul>"},{"location":"guides/modeling/dsl-basics/","title":"DSL Model File Template","text":"<p>This is a quick reference template for creating DSL model files in TOML format.  It lists all available tables and their keys.</p>"},{"location":"guides/modeling/dsl-basics/#required-tables","title":"Required Tables","text":""},{"location":"guides/modeling/dsl-basics/#model","title":"[model]","text":"<ul> <li><code>type</code> (required): \"ode\" | \"map\"</li> <li><code>name</code> (optional): string</li> <li><code>dtype</code> (optional): data type, default \"float64\"</li> </ul>"},{"location":"guides/modeling/dsl-basics/#states","title":"[states]","text":"<ul> <li><code>state_name = initial_value</code> (order defines the authoritative state vector order)</li> <li>For value expressions like 8/3 use quotes: \"8/3\".</li> </ul>"},{"location":"guides/modeling/dsl-basics/#optional-tables","title":"Optional Tables","text":""},{"location":"guides/modeling/dsl-basics/#constants","title":"[constants]","text":"<ul> <li><code>constant_name = value</code> (scalars, numeric expressions allowed, can reference prior constants)</li> <li>Constants cannot be assigned and they are read-only literals.</li> </ul>"},{"location":"guides/modeling/dsl-basics/#params","title":"[params]","text":"<ul> <li><code>param_name = value</code> (scalars or arrays, cast to model dtype)</li> </ul>"},{"location":"guides/modeling/dsl-basics/#equations-choose-one-form-or-mix","title":"Equations (choose one form or mix)","text":""},{"location":"guides/modeling/dsl-basics/#equationsrhs-per-state-form","title":"[equations.rhs] (per-state form)","text":"<ul> <li><code>state_name = \"expression\"</code></li> </ul>"},{"location":"guides/modeling/dsl-basics/#equations-block-form","title":"[equations] (block form)","text":"<ul> <li>`expr = \"\"\"dx = expression   dy = expression\"\"\"</li> </ul>"},{"location":"guides/modeling/dsl-basics/#equationsjacobian-optional-dense-jacobian","title":"[equations.jacobian] (optional dense Jacobian)","text":"<ul> <li><code>expr = [[ \"...\", \"...\", ... ], [...], ...]</code> (n \u00d7 n matrix of expressions)</li> <li>State vector order is the [states] declaration order (after mods). For <code>state_names = (s0, s1, ...)</code>, <code>expr[i][j]</code> is \u2202f_state_names[i]/\u2202state_names[j]. Reordering [states] is a semantic change and changes how matrix literals are interpreted.</li> </ul>"},{"location":"guides/modeling/dsl-basics/#aux","title":"[aux]","text":"<ul> <li><code>aux_name = \"expression\"</code></li> </ul>"},{"location":"guides/modeling/dsl-basics/#functionsfunction_name","title":"[functions.function_name]","text":"<ul> <li><code>args = [\"arg1\", \"arg2\", ...]</code></li> <li>`expr = \"expression\"</li> </ul>"},{"location":"guides/modeling/dsl-basics/#eventsevent_name","title":"[events.event_name]","text":"<ul> <li><code>phase</code> (optional): \"pre\" | \"post\" | \"both\" (default \"post\")</li> <li>`cond = \"expression\"</li> <li><code>action = \"expression\"</code> or `action.state_name = \"expression\"</li> <li><code>tags</code> (optional): [\"tag1\", \"tag2\", ...]</li> <li><code>log</code> (optional): [\"var1\", \"var2\", ...]</li> </ul>"},{"location":"guides/modeling/dsl-basics/#sim","title":"[sim]","text":"<ul> <li><code>t0 = value</code></li> <li><code>t_end = value</code></li> <li><code>dt = value</code></li> <li><code>stepper = \"euler\" | \"rk4\" | ...</code></li> <li><code>record = true/false</code></li> <li><code>stepper_config = value (stepper-specific config values)</code></li> </ul>"},{"location":"guides/modeling/dsl-basics/#meta","title":"[meta]","text":"<ul> <li>`title = \"string\"</li> <li>Meta table is currently ignored. Anything can be written into [meta].</li> </ul>"},{"location":"guides/modeling/dsl-basics/#special-variables","title":"Special Variables","text":"<ul> <li><code>t</code> - Current time (available in all expressions)</li> </ul>"},{"location":"guides/modeling/equations/","title":"Equations","text":"<p>The <code>[equations]</code> table is where you describe how states change every step. It accepts several interchangeable sub-forms so you can pick the style that fits your model.</p>"},{"location":"guides/modeling/equations/#basic-forms","title":"Basic forms","text":"<ul> <li><code>[equations.rhs]</code> (per-state) \u2013 a TOML table of <code>state = \"expr\"</code> entries. Each expression must be a string so the DSL can parse macros before evaluating the right-hand side for that state.</li> <li><code>[equations].expr</code> (block) \u2013 a single multi-line string where each line assigns to a state (<code>x = ...</code>) or, for ODE models, uses derivative notation (<code>dx = ...</code> or <code>d(x) = ...</code>). Use whichever style keeps your algebra tidy, but do not define the same state in both places (the loader enforces this).</li> <li><code>[equations.inverse]</code> \u2013 available only for <code>map</code> models; it mirrors the main equation form and provides a callable inverse update. You may define <code>rhs</code> or <code>expr</code> inside this table, but not both for the same state.</li> <li><code>[equations.jacobian]</code> \u2013 optional metadata containing a single <code>expr</code> key with a square list-of-list literal describing the dense Jacobian (each entry may be a string or numeric literal). This table is only used when you supply custom derivatives for the compiler (e.g., for stiff solvers or implicit steppers).</li> </ul>"},{"location":"guides/modeling/equations/#example","title":"Example","text":"<pre><code>[equations.rhs]\nx = \"speed * cos(theta)\"\ntheta = \"speed * sin(theta)\"\n\n[equations.inverse]\nexpr = \"\"\"\nx = x - speed * cos(theta)\ntheta = theta - speed * sin(theta)\n\"\"\"\n\n[equations.jacobian]\nexpr = [\n  [\"0\", \"-speed * sin(theta)\"],\n  [\"speed * cos(theta)\", \"0\"]\n]\n</code></pre>"},{"location":"guides/modeling/equations/#expression-context","title":"Expression context","text":"<p>Equation expressions share the same identifiers available elsewhere: states, parameters, constants, aux, functions, macros (<code>sin</code>, <code>clip</code>, <code>approx</code>, generator comprehensions) and <code>t</code>. ODE blocks also accept derivative targets (<code>dx</code>, <code>d(x)</code>), but map models must stick to <code>state = expr</code> assignments.</p>"},{"location":"guides/modeling/equations/#inverse-equations","title":"Inverse equations","text":"<ul> <li>The <code>inverse</code> table only exists for map models and supplies an <code>inv_rhs</code> callable used by inversion utilities and diagnostics.</li> <li>You can write it as a per-state table (<code>[equations.inverse.rhs]</code>) or a block string (<code>[equations.inverse].expr</code>), mirroring the primary equation form.</li> <li>Each state may appear only once across inverse forms; mixing <code>rhs</code> and <code>expr</code> for the same state raises an error.</li> <li>The inverse update must also resolve the same identifier sets as forward equations (states, params, aux, etc).</li> </ul>"},{"location":"guides/modeling/equations/#jacobian-table","title":"Jacobian table","text":"<ul> <li><code>[equations.jacobian].expr</code> is a list of rows; the number of rows and columns must match the number of declared states (square matrix).</li> <li>Each matrix entry can be a string expression or a numeric literal (integers/floats). The compiler flattens this into the explicit Jacobian used for solver support.</li> <li>If you need a dense Jacobian but prefer to keep it organized, you may precompute shared expressions with aux variables and reference them inside the matrix entries.</li> </ul>"},{"location":"guides/modeling/equations/#validation-hints","title":"Validation hints","text":"<ul> <li>The parser forbids unknown keys inside <code>[equations]</code>, <code>[equations.inverse]</code>, and <code>[equations.jacobian]</code> so typos are caught early.</li> <li>States can only be defined once across <code>[equations.rhs]</code> and <code>[equations].expr</code>, and similarly for the inverse table.</li> <li>Map models cannot use derivative notation (the loader explicitly rejects <code>d(x)</code> inside <code>[equations].expr</code> for maps).</li> <li><code>[equations.jacobian].expr</code> must be provided as a list of rows; using the plural <code>exprs</code> or omitting the table will raise an error.</li> </ul>"},{"location":"guides/modeling/equations/#best-practices","title":"Best practices","text":"<ol> <li>Stick to one style per state (either <code>rhs</code> or block) to avoid redundant logic.</li> <li>Use aux/functions to factor complex right-hand sides so the equation tables stay readable.</li> <li>Document inverse tables clearly\u2014mention why they exist (e.g., for stepping backwards or diagnostics) since they execute outside the normal solver path.</li> <li>Only supply a Jacobian when necessary (implicit solvers, stiffness); otherwise, let the compiler numerically estimate derivatives.</li> </ol>"},{"location":"guides/modeling/events/","title":"Event Handling","text":"<p>Events let you react to model conditions during simulation by executing actions and logging whenever the <code>cond</code> expression becomes true. They run either before the step (<code>phase = \"pre\"</code>), after (<code>phase = \"post\"</code>), or both, and you can attach logging to capture diagnostics for debugging or analysis. </p> <p>NOTE: Some fast-path runners for analysis prefer models without events.</p>"},{"location":"guides/modeling/events/#basic-template","title":"Basic Template","text":"<pre><code>[events.reset_on_threshold]\nphase = \"post\"\ncond = \"x &gt; threshold\"\naction = \"x = 0; spike_count = spike_count + 1\"\nlog = [\"t\", \"x\", \"spike_count\"]\n</code></pre> <ul> <li><code>phase</code> controls when the condition is evaluated (default is <code>post</code>).</li> <li><code>cond</code> must be a string returning a boolean. It is re-evaluated every timestep.</li> <li><code>action</code> is a string of assignment statements; you can also scope assignments as <code>action.var = \"expr\"</code> for clarity.</li> <li><code>log</code> is optional and lists variables whose values are recorded when the event fires.</li> </ul>"},{"location":"guides/modeling/events/#condition-context","title":"Condition Context","text":"<ul> <li>States/parameters: Reference any declared state or parameter.</li> <li>Aux variables: Reuse derived expressions from <code>[aux]</code> to keep conditions readable.</li> <li>Time (<code>t</code>): Always available for time-based triggers.</li> <li>User-defined functions: Call them just like in equations or aux definitions.</li> <li>Built-in math &amp; scalar macros: <code>sin</code>, <code>cos</code>, <code>clip</code>, <code>approx</code>, etc.</li> <li>Generator comprehensions: Use <code>sum(...)</code> or <code>prod(...)</code> when you need reductions.</li> <li>Event macros: <code>cross_up</code>, <code>cross_down</code>, <code>changed</code>, <code>in_interval</code>, <code>enters_interval</code>, <code>leaves_interval</code>, <code>increasing</code>, <code>decreasing</code>, and <code>cross_either</code> automatically compare lagged state values so you do not need to write manual <code>lag_</code> expressions.</li> <li>Lag notation: You can call <code>lag_state(k)</code> within conditions, but only for real state variables, never aux.</li> </ul>"},{"location":"guides/modeling/events/#event-macros-example","title":"Event Macros Example","text":"<pre><code>[events.detect_spike]\nphase = \"pre\"\ncond = \"cross_up(v, 1.0)\"\naction = \"spike_count += 1\"\n</code></pre> <p>The macro handles the lagged access for you, so the condition fires the instant <code>v</code> crosses the threshold from below without extra bookkeeping.</p>"},{"location":"guides/modeling/events/#action-details","title":"Action Details","text":"<ul> <li>Actions can modify states, parameters (if allowed), aux, or tracker variables by assigning new expressions.</li> <li>Use semicolons to separate multiple statements or define individual assignments with <code>action.var = \"expr\"</code> syntax.</li> <li>Actions execute atomically after the condition is evaluated; side effects become part of the model state for the next timestep.</li> <li>Keep actions short; heavy computations belong in aux variables or helper functions.</li> </ul>"},{"location":"guides/modeling/events/#logging","title":"Logging","text":"<ul> <li><code>log</code> captures the listed expressions whenever the event is triggered.</li> <li>Logs can include states, aux, or computed expressions (<code>log = [\"t\", \"energy\", \"debug_flag\"]</code>).</li> <li>Use logging to inspect event timing, detect spurious triggers, or record counters for analysis.</li> </ul>"},{"location":"guides/modeling/events/#event-lifecycle-with-mods","title":"Event Lifecycle with Mods","text":"<p>Mods can manipulate events using the same verbs available elsewhere:</p> <ul> <li><code>mod.remove.events</code> deletes existing events by name.</li> <li><code>mod.replace.events.name</code> redefines the phase/cond/action/log for an event that already exists.</li> <li><code>mod.add.events.new_name</code> inserts a new event (errors if the name already exists).</li> <li><code>mod.set.events</code> is not supported; use <code>add</code> or <code>replace</code> instead.</li> </ul> <p>Always remember the global verb order: remove \u2192 replace \u2192 add \u2192 set, so you can remove or replace an event before adding another with the same identifier.</p>"},{"location":"guides/modeling/events/#best-practices","title":"Best Practices","text":"<ol> <li>Name events descriptively (<code>events.detect_refractory_start</code>) so their intent is clear.</li> <li>Extract complex predicates into aux variables or functions to keep conditions readable.</li> <li>Keep actions small and deterministic, and prefer updating derived quantities via aux rather than inlined expressions.</li> <li>Use event macros when tracking crossings or changes to avoid manual lag bookkeeping.</li> <li>Log intentionally\u2014too many log entries can degrade performance, so record only what you need for debugging or analysis contexts.</li> </ol>"},{"location":"guides/modeling/functions/","title":"DSL Functions","text":"<p>User-defined functions let you encapsulate reusable logic once and call it from equations, aux, events, and other functions (no recursion). They keep expressions manageable and allow you to parameterize common computations.</p>"},{"location":"guides/modeling/functions/#syntax","title":"Syntax","text":"<pre><code>[functions.sigmoid]\nargs = [\"x\", \"gain\", \"offset\"]\nexpr = \"gain / (1 + exp(-x)) + offset\"\n</code></pre> <ul> <li><code>args</code> is an array of parameter names; use only simple identifiers.</li> <li><code>expr</code> is a string expression evaluated using the same macro-expanded DSL/ Python rules as other expressions (<code>^</code> \u2192 <code>**</code>, generator comprehensions compiled to loops, etc.).</li> <li>Functions do not declare a return type; the expression value is the return value.</li> </ul>"},{"location":"guides/modeling/functions/#context-inside-functions","title":"Context Inside Functions","text":"<ul> <li>Arguments: Functions can use their own parameters as variables (<code>x</code>, <code>gain</code>).</li> <li>Time (<code>t</code>): Available only when the surrounding context provides time (e.g., calling from an equation or aux, not from a pure math helper).</li> <li>States &amp; parameters: Referenced by name if they exist in the model.</li> <li>Aux variables: Can call aux defined in <code>[aux]</code>, but ensure you avoid dependency cycles.</li> <li>Other user-defined functions: Call them like normal, but prevent recursion.</li> <li>Built-in math &amp; macros: Use <code>sin</code>, <code>cos</code>, <code>clip</code>, <code>approx</code>, generator comprehensions, etc.</li> <li>Lag notation: Allowed if the function is invoked where <code>lag_</code> access is valid (states only).</li> <li>Event macros: Not accessible inside functions directly; use them in event conditions instead.</li> </ul>"},{"location":"guides/modeling/functions/#calling-functions","title":"Calling Functions","text":"<ul> <li>Reference functions by name just like built-ins: <code>sigmoid(x, gain, offset)</code>.</li> <li>You can pass expressions, states, aux, or literals as arguments.</li> <li>Functions can simplify repeated math, conditional logic, or complex transformations used across equations or events.</li> <li>Use helper functions to factor out tooling for Jacobians, logging expressions, or custom activation shapes.</li> </ul>"},{"location":"guides/modeling/functions/#mods-functions","title":"Mods &amp; Functions","text":"<p>Function definitions can be modified via mods:</p> <ul> <li><code>mod.remove.functions</code> deletes named functions (component must already exist).</li> <li><code>mod.replace.functions.name</code> overwrites the body while keeping the identifier.</li> <li><code>mod.add.functions.name</code> inserts a new function (fails if already present).</li> <li><code>mod.set.functions.name</code> upserts the function definition (create or update).</li> </ul> <p>These verbs obey the global rem/replace/add/set order, so you can remove or replace before adding another version.</p>"},{"location":"guides/modeling/functions/#best-practices","title":"Best Practices","text":"<ol> <li>Name helpers descriptively (<code>functions.normalize_input</code>) so downstream equations clarify intent.</li> <li>Keep argument lists short; overly many args suggest the function should operate on aux or state bundles instead.</li> <li>Avoid side effects\u2014functions should only return values and not mutate states or aux.</li> <li>Document assumptions (e.g., expected ranges) in nearby comments or docs to keep integrators aware of constraints.</li> <li>Reuse judiciously: don\u2019t wrap trivial expressions unless they help readability or hide complex math.</li> </ol>"},{"location":"guides/modeling/inline-models/","title":"Inline Models","text":"<p>Models don't have to be defined in a separate toml file. You can define models in the same python file using the <code>inline:</code> keyword.</p>"},{"location":"guides/modeling/inline-models/#example","title":"Example","text":"<pre><code>model = '''\ninline:\n[model]\ntype = \"map\"\ndtype = \"int64\"\nname = \"Collatz Conjecture\"\n\n[states]\nn = 27\n\n[equations.rhs]\nn = \"n//2 if n % 2 == 0 else 3*n + 1\"\n\n'''\n</code></pre>"},{"location":"guides/modeling/lagging/","title":"Lag System Design &amp; Implementation","text":""},{"location":"guides/modeling/lagging/#overview","title":"Overview","text":"<p>The lag system provides access to historical state values in dynlib models using the notation: - <code>lag_&lt;name&gt;()</code> - Access state <code>&lt;name&gt;</code> from one step ago - <code>lag_&lt;name&gt;(k)</code> - Access state <code>&lt;name&gt;</code> from k steps ago</p> <p>Key Features: - On-demand activation (only lagged states consume memory) - O(1) circular buffer access (Numba-compatible) - Counted after successful committed steps (immune to buffer growth, early breaks, resume) - Works with both ODE and map models - Dedicated runtime workspace (stepper ABI extended with runtime_ws parameter)</p>"},{"location":"guides/modeling/lagging/#dsl-syntax","title":"DSL Syntax","text":""},{"location":"guides/modeling/lagging/#supported-usage","title":"Supported Usage","text":"<pre><code>[model]\ntype = \"map\"\n\n[states]\nx = 0.1\n\n[params]\nr = 3.5\nalpha = 0.3\n\n[equations.rhs]\n# Mix current and lagged states\nx = \"r * (alpha * x + (1 - alpha) * lag_x(1)) * (1 - x)\"\n\n# Use zero-arg shorthand for one step back\nx = \"r * (alpha * x + (1 - alpha) * lag_x()) * (1 - x)\"\n</code></pre>"},{"location":"guides/modeling/lagging/#lag-depths","title":"Lag Depths","text":"<pre><code>[aux]\n# Use multiple lag depths - max is automatically detected\ndelayed_diff = \"x - lag_x(5)\"\n\n[equations.rhs]\nx = \"v + 0.1 * lag_x(2)\"  # Max lag for x = 5 (from aux)\nv = \"-x - lag_v(3)\"       # Max lag for v = 3\n</code></pre>"},{"location":"guides/modeling/lagging/#restrictions","title":"Restrictions","text":"<p>Only for state variables: <pre><code>[states]\nx = 0.1\n\n[params]\na = 2.0\n\n[equations.rhs]\nx = \"lag_x(1)\"   # Valid - x is a state\nx = \"lag_a(1)\"   # Error - a is a parameter, not a state\n</code></pre></p> <p>Lag argument must be integer literal: <pre><code> x = \"lag_x(2)\"       # Valid\n x = \"lag_x(k)\"       # Error - k is not a literal\n x = \"lag_x(2 + 1)\"   # Error - expression not allowed\n</code></pre></p> <p>Sanity limit: <pre><code>x = \"lag_x(1000)\"    # Error - exceeds sanity limit (1000)\n</code></pre></p>"},{"location":"guides/modeling/lagging/#lagging-auxiliary-variables","title":"Lagging Auxiliary Variables","text":"<p>Auxiliary variables CANNOT be lagged directly. Instead, use lagged states in expressions:</p>"},{"location":"guides/modeling/lagging/#not-supported","title":"Not Supported:","text":"<pre><code>[aux]\nenergy = \"0.5 * v^2 + 0.5 * k * x^2\"\n\n[equations.rhs]\nv = \"-x - 0.1 * lag_energy(1)\"  # ERROR: energy is aux, not state\n</code></pre>"},{"location":"guides/modeling/lagging/#correct-approach","title":"Correct Approach:","text":"<pre><code>[aux]\nenergy = \"0.5 * v^2 + 0.5 * k * x^2\"  # Current energy (optional)\n\n[equations.rhs]\n# Compute lagged energy from lagged states\nv = \"-x - 0.1 * (0.5 * lag_v(1)^2 + 0.5 * k * lag_x(1)^2)\"\n</code></pre> <p>Rationale: Auxiliaries are ephemeral derived quantities. Lagging <code>energy</code> is mathematically equivalent to computing <code>energy</code> from lagged states.</p>"},{"location":"guides/modeling/lagging/#alternative-promote-aux-to-state","title":"Alternative: Promote Aux to State","text":"<p>If a derived quantity is frequently lagged:</p> <pre><code>[states]\nx = 0.1\nv = 0.0\nenergy = 0.005  # Promoted from aux\n\n[params]\nk = 2.0\n\n[equations.rhs]\nx = \"v\"\nv = \"-k * x - 0.1 * lag_energy(1)\"  # Clean access\nenergy = \"0.5 * v^2 + 0.5 * k * x^2\"  # Track as ODE\n</code></pre> <p>Trade-off: Increases system dimension by 1.</p>"},{"location":"guides/modeling/lagging/#storage-architecture","title":"Storage Architecture","text":""},{"location":"guides/modeling/lagging/#runtimeworkspace-structure","title":"RuntimeWorkspace Structure","text":"<p>Lag buffers are stored in a dedicated <code>RuntimeWorkspace</code> NamedTuple:</p> <pre><code>RuntimeWorkspace = namedtuple(\n    \"RuntimeWorkspace\",\n    [\"lag_ring\", \"lag_head\", \"lag_info\"],\n)\n</code></pre> <p>Components: - <code>lag_ring</code>: Contiguous array storing all circular buffers (dtype matches model) - <code>lag_head</code>: Array of current head indices for each lagged state (int32) - <code>lag_info</code>: Metadata array with shape (n_lagged_states, 3) containing (state_idx, depth, offset)</p>"},{"location":"guides/modeling/lagging/#circular-buffer-layout","title":"Circular Buffer Layout","text":"<p>Each lagged state gets a contiguous segment in <code>lag_ring</code>:</p> <pre><code>lag_ring layout (contiguous):\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 lag buffer for x \u2502 lag buffer for y \u2502 (unused)    \u2502\n\u2502  (depth 5)       \u2502  (depth 3)       \u2502             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n   offset=0           offset=5          end\n</code></pre> <p>Allocation: - Each lagged state with depth <code>k</code> gets <code>k</code> consecutive elements in <code>lag_ring</code> - Total <code>lag_ring</code> size = sum of all lag depths - <code>lag_head</code> has one entry per lagged state - <code>lag_info[j] = (state_idx, depth, offset)</code> for lagged state <code>j</code></p>"},{"location":"guides/modeling/lagging/#circular-buffer-mechanics","title":"Circular Buffer Mechanics","text":""},{"location":"guides/modeling/lagging/#access-pattern","title":"Access Pattern","text":"<p>For <code>lag_x(k)</code> where state <code>x</code> has: - <code>depth = 5</code> (max lag) - <code>offset = 0</code> (starts at lag_ring[0]) - <code>head_index = 0</code> (head at lag_head[0])</p> <p>Lowered expression: <pre><code>runtime_ws.lag_ring[offset + ((runtime_ws.lag_head[head_index] - k) % depth)]\n#  runtime_ws.lag_ring[0 + ((runtime_ws.lag_head[0] - k) % 5)]\n</code></pre></p>"},{"location":"guides/modeling/lagging/#initialization-at-tt0","title":"Initialization (at t=t0)","text":"<pre><code># Fill with IC for each lagged state\nfor j, (state_idx, depth, offset) in enumerate(lag_info):\n    value = y_curr[state_idx]\n    runtime_ws.lag_ring[offset : offset + depth] = value\n    runtime_ws.lag_head[j] = depth - 1  # head at last position\n</code></pre> <p>Why depth-1? So that after first step commit, head wraps to 0.</p>"},{"location":"guides/modeling/lagging/#update-after-committed-step","title":"Update After Committed Step","text":"<p>CRITICAL: Updates happen ONLY after successful step commits, not after rejected steps or buffer growths.</p> <pre><code># In runner.py, after commit:\nfor j in range(n_lagged_states):\n    state_idx, depth, offset = lag_info[j]\n    head = int(lag_head[j]) + 1\n    if head &gt;= depth:\n        head = 0\n    lag_head[j] = head\n    lag_ring[offset + head] = y_curr[state_idx]\n</code></pre> <p>Example trace for x with depth=3:</p> <pre><code>Step 0 (IC=0.1):\nlag_ring = [0.1, 0.1, 0.1], head=2\n\nStep 1 (y_curr=0.2):\nhead = (2+1) % 3 = 0\nlag_ring[0] = 0.2 \u2192 lag_ring = [0.2, 0.1, 0.1], head=0\n\nStep 2 (y_curr=0.3):\nhead = (0+1) % 3 = 1\nlag_ring[1] = 0.3 \u2192 lag_ring = [0.2, 0.3, 0.1], head=1\n\nStep 3 (y_curr=0.4):\nhead = (1+1) % 3 = 2\nlag_ring[2] = 0.4 \u2192 lag_ring = [0.2, 0.3, 0.4], head=2\n\nAccess lag_x(1) at step 3:\nlag_ring[0 + ((2 - 1) % 3)] = lag_ring[1] = 0.3 \u2713 (step 2 value)\n\nAccess lag_x(2) at step 3:\nlag_ring[0 + ((2 - 2) % 3)] = lag_ring[0] = 0.2 \u2713 (step 1 value)\n</code></pre>"},{"location":"guides/modeling/lagging/#safety-correctness","title":"Safety &amp; Correctness","text":""},{"location":"guides/modeling/lagging/#buffer-growth-grow_rec-grow_evt","title":"Buffer Growth (GROW_REC, GROW_EVT)","text":"<p>Lag buffers are NOT reallocated during recording/event buffer growth: - Runtime workspace sizes are determined by lag depths (model-specific, not trajectory-dependent) - Wrapper doubles <code>rec</code>/<code>ev</code> buffers, but leaves runtime workspace unchanged - Lag state preserved across re-entry</p>"},{"location":"guides/modeling/lagging/#early-breaks-stepfail-nan_detected-user_break","title":"Early Breaks (STEPFAIL, NAN_DETECTED, USER_BREAK)","text":"<ul> <li>Runner commits state before break</li> <li>Lag buffers contain values up to last successful commit</li> <li>Resume uses <code>workspace_seed</code> to restore exact lag state</li> </ul>"},{"location":"guides/modeling/lagging/#resume-snapshots","title":"Resume &amp; Snapshots","text":"<ul> <li><code>RuntimeWorkspace</code> supports <code>snapshot_workspace()</code> and <code>restore_workspace()</code></li> <li>Lag buffers automatically included in workspace snapshots</li> <li>No special handling needed</li> </ul> <p>Correctness guarantee: Lags are counted after committed steps only.</p>"},{"location":"guides/modeling/lagging/#example-logistic-map-with-delay","title":"Example: Logistic Map with Delay","text":"<pre><code>[model]\ntype = \"map\"\nname = \"Delayed Logistic Map\"\n\n[states]\nx = 0.1\n\n[params]\nr = 3.8\nalpha = 0.7  # Mix of current and delayed feedback\n\n[equations.rhs]\n# Delay-coupled logistic map\nx = \"r * (alpha * x + (1 - alpha) * lag_x()) * (1 - x)\"\n\n[sim]\nt0 = 0.0\ndt = 1.0\nstepper = \"map\"\n</code></pre> <p>Execution trace: <pre><code>n=0: x=0.1, lag_x(1)=0.1 (IC)\nn=1: x = 3.8*(0.7*0.1 + 0.3*0.1)*(1-0.1) = 0.342\n     lag_x(1)=0.1\nn=2: x = 3.8*(0.7*0.342 + 0.3*0.1)*(1-0.342) = 0.627\n     lag_x(1)=0.342\nn=3: x = 3.8*(0.7*0.627 + 0.3*0.342)*(1-0.627) = 0.788\n     lag_x(1)=0.627\n...\n</code></pre></p>"},{"location":"guides/modeling/lagging/#performance","title":"Performance","text":""},{"location":"guides/modeling/lagging/#memory-overhead","title":"Memory Overhead","text":"<p>Per lagged state with depth <code>k</code>: - Storage: <code>k * sizeof(dtype)</code> bytes in <code>RuntimeWorkspace.lag_ring</code> - Head indices: 1 int32 per lagged state in <code>RuntimeWorkspace.lag_head</code> - Metadata: 3 int32 per lagged state in <code>RuntimeWorkspace.lag_info</code> - Example: 3 states, depth 10, float64 \u2192 3 * 10 * 8 = 240 bytes + overhead</p>"},{"location":"guides/modeling/lagging/#computational-cost","title":"Computational Cost","text":"<ul> <li>Per step: O(n_lagged_states) writes to circular buffer</li> <li>Lag access: O(1) modulo + array index</li> <li>Numba optimizes <code>(x - k) % depth</code> to bitwise AND if depth is power-of-2</li> </ul>"},{"location":"guides/modeling/lagging/#references","title":"References","text":"<ul> <li>Runtime Workspace: <code>runtime/workspace.py</code></li> <li>DSL Spec: <code>dsl/spec.py</code></li> <li>Expression Lowering: <code>compiler/codegen/rewrite.py</code></li> <li>Runner ABI: <code>runtime/runner_api.py</code></li> <li>Stepper Base: <code>steppers/base.py</code></li> </ul>"},{"location":"guides/modeling/math-and-macros/","title":"Math Functions, Scalar Macros, and Generator Comprehensions","text":""},{"location":"guides/modeling/math-and-macros/#built-in-math-functions","title":"Built-in Math Functions","text":"<p>The following mathematical functions are available and map directly to Python's <code>math</code> module or built-in functions:</p>"},{"location":"guides/modeling/math-and-macros/#basic-functions","title":"Basic Functions","text":"<ul> <li><code>abs(x)</code> - Absolute value</li> <li><code>min(x, y, ...)</code> - Minimum of arguments</li> <li><code>max(x, y, ...)</code> - Maximum of arguments</li> <li><code>round(x)</code> - Round to nearest integer</li> </ul>"},{"location":"guides/modeling/math-and-macros/#exponential-and-logarithmic-functions","title":"Exponential and Logarithmic Functions","text":"<ul> <li><code>exp(x)</code> - Exponential function (e^x)</li> <li><code>expm1(x)</code> - exp(x) - 1 (more accurate for small x)</li> <li><code>log(x)</code> - Natural logarithm</li> <li><code>log10(x)</code> - Base-10 logarithm</li> <li><code>log2(x)</code> - Base-2 logarithm</li> <li><code>log1p(x)</code> - log(1 + x) (more accurate for small x)</li> <li><code>sqrt(x)</code> - Square root</li> </ul>"},{"location":"guides/modeling/math-and-macros/#trigonometric-functions","title":"Trigonometric Functions","text":"<ul> <li><code>sin(x)</code> - Sine</li> <li><code>cos(x)</code> - Cosine</li> <li><code>tan(x)</code> - Tangent</li> <li><code>asin(x)</code> - Inverse sine</li> <li><code>acos(x)</code> - Inverse cosine</li> <li><code>atan(x)</code> - Inverse tangent</li> <li><code>atan2(y, x)</code> - Two-argument inverse tangent</li> </ul>"},{"location":"guides/modeling/math-and-macros/#hyperbolic-functions","title":"Hyperbolic Functions","text":"<ul> <li><code>sinh(x)</code> - Hyperbolic sine</li> <li><code>cosh(x)</code> - Hyperbolic cosine</li> <li><code>tanh(x)</code> - Hyperbolic tangent</li> <li><code>asinh(x)</code> - Inverse hyperbolic sine</li> <li><code>acosh(x)</code> - Inverse hyperbolic cosine</li> <li><code>atanh(x)</code> - Inverse hyperbolic tangent</li> </ul>"},{"location":"guides/modeling/math-and-macros/#rounding-functions","title":"Rounding Functions","text":"<ul> <li><code>floor(x)</code> - Floor (round down to integer)</li> <li><code>ceil(x)</code> - Ceiling (round up to integer)</li> <li><code>trunc(x)</code> - Truncate (remove fractional part)</li> </ul>"},{"location":"guides/modeling/math-and-macros/#special-functions","title":"Special Functions","text":"<ul> <li><code>hypot(x, y)</code> - Euclidean distance (sqrt(x^2 + y^2))</li> <li><code>copysign(x, y)</code> - Copy sign of y to magnitude of x</li> <li><code>erf(x)</code> - Error function</li> <li><code>erfc(x)</code> - Complementary error function</li> </ul>"},{"location":"guides/modeling/math-and-macros/#scalar-macros","title":"Scalar Macros","text":"<p>Scalar macros are special functions that perform common mathematical operations:</p> <ul> <li><code>sign(x)</code> - Sign function: returns -1 for negative, 0 for zero, 1 for positive</li> <li><code>heaviside(x)</code> - Heaviside step function: returns 0 for x &lt; 0, 1 for x &gt;= 0</li> <li><code>step(x)</code> - Same as heaviside (alias)</li> <li><code>relu(x)</code> - Rectified Linear Unit: returns max(0, x)</li> <li><code>clip(x, min, max)</code> - Clamp x to the range [min, max]</li> <li><code>approx(x, y, tol)</code> - Check if |x - y| &lt;= tol (returns boolean)</li> </ul>"},{"location":"guides/modeling/math-and-macros/#generator-comprehensions","title":"Generator Comprehensions","text":"<p>The DSL supports generator comprehensions for efficient sum and product operations over ranges:</p> <ul> <li><code>sum(expr for var in range(start, stop[, step]) [if condition])</code> - Sum of expressions over a range</li> <li><code>prod(expr for var in range(start, stop[, step]) [if condition])</code> - Product of expressions over a range</li> </ul> <p>These constructs are compiled into optimized for-loops. Only <code>range()</code> is supported as the iterator, and only a single generator is allowed. Conditional filters with <code>if</code> are supported.</p> <p>Examples: - <code>sum(i*i for i in range(10))</code> - Sum of squares from 0 to 9 (0+1+4+...+81) - <code>prod((i+1) for i in range(1, 5))</code> - Product 2\u00d73\u00d74\u00d75 = 120 - <code>sum(x[i] for i in range(N) if i % 2 == 0)</code> - Sum of even-indexed elements (assuming x is an array)</p>"},{"location":"guides/modeling/math-and-macros/#event-macros","title":"Event Macros","text":"<p>Event macros are used in event conditions to detect state changes and transitions. These macros automatically use lagged state values for comparison:</p> <ul> <li><code>cross_up(state, threshold)</code> - True when state crosses threshold from below to above</li> <li><code>cross_down(state, threshold)</code> - True when state crosses threshold from above to below</li> <li><code>cross_either(state, threshold)</code> - True when state crosses threshold in either direction</li> <li><code>changed(state)</code> - True when state value changed from previous step</li> <li><code>in_interval(state, lower, upper)</code> - True when state is currently in [lower, upper]</li> <li><code>enters_interval(state, lower, upper)</code> - True when state enters [lower, upper] interval</li> <li><code>leaves_interval(state, lower, upper)</code> - True when state leaves [lower, upper] interval</li> <li><code>increasing(state)</code> - True when state is increasing (current &gt; previous)</li> <li><code>decreasing(state)</code> - True when state is decreasing (current &lt; previous)</li> </ul>"},{"location":"guides/modeling/model-registry/","title":"Model registry","text":"<p>Model files live on disk, but dynlib exposes them through a small registry that lets you refer to any model with a stable URI instead of juggling absolute paths. The registry handles the builtin models that ship with dynlib, lets you define your own tags, and transparently resolves relative paths, fragments, and inline models.</p>"},{"location":"guides/modeling/model-registry/#built-in-models","title":"Built-in models","text":"<p>Dynlib preloads the <code>src/dynlib/models</code> package so that a <code>builtin://</code> tag always exists. That means you can drop any of the models below into <code>setup(...)</code>, <code>dynlib model validate</code>, or any other entry point without writing a config file.</p>"},{"location":"guides/modeling/model-registry/#map-models","title":"Map models","text":"<ul> <li><code>builtin://map/logistic</code></li> <li><code>builtin://map/henon</code></li> <li><code>builtin://map/henon2</code></li> <li><code>builtin://map/ikeda</code></li> <li><code>builtin://map/lozi</code></li> <li><code>builtin://map/sine</code></li> <li><code>builtin://map/standard</code></li> </ul>"},{"location":"guides/modeling/model-registry/#ode-models","title":"ODE models","text":"<ul> <li><code>builtin://ode/duffing</code></li> <li><code>builtin://ode/eto-circular</code></li> <li><code>builtin://ode/expdecay</code></li> <li><code>builtin://ode/exp-if</code></li> <li><code>builtin://ode/fitzhugh-nagumo</code></li> <li><code>builtin://ode/hodgkin-huxley</code></li> <li><code>builtin://ode/izhikevich</code></li> <li><code>builtin://ode/leaky-if</code></li> <li><code>builtin://ode/lorenz</code></li> <li><code>builtin://ode/quadratic-if</code></li> <li><code>builtin://ode/resonate-if</code></li> <li><code>builtin://ode/vanderpol</code></li> </ul> <p>The registry adds that builtin directory automatically (see <code>dynlib/compiler/paths.py</code> for the exact logic) so you rarely need to worry about paths under <code>builtin://</code> \u2014 just write <code>builtin://ode/vanderpol</code> (without <code>.toml</code>) and dynlib checks for the file and throws a helpful <code>ModelNotFoundError</code> if it cannot be located.</p> <p>Use the CLI when you need to inspect or validate a builtin model:</p> <pre><code>dynlib model validate builtin://ode/expdecay\n</code></pre> <p>This command parses the URI, resolves the file, validates the DSL, and reports any parsing errors before you run a simulation.</p>"},{"location":"guides/modeling/model-registry/#uri-usage","title":"URI usage","text":"<p><code>resolve_uri</code> (the same logic behind the CLI and <code>setup(...)</code>) understands several URI forms:</p> <ol> <li>Inline declarations: Start a string with <code>inline:</code> and dynlib keeps the DSL snippet in memory. Handy for throwaway models in notebooks or tests.</li> <li>Tag URIs: <code>TAG://relative/path</code> looks for the model under any root registered for <code>TAG</code>. The builtin models use <code>TAG=builtin</code>, but you can add your own tags with custom directories (see the next section).</li> <li>Absolute or relative paths: A literal file path works too, and dynlib normalizes it (expands <code>~</code>, environment variables, <code>.toml</code> extension, and resolves the absolute path relative to <code>cwd</code>).</li> </ol> <p>Tag URIs can also carry fragments to select mods or sections inside a file:</p> <pre><code>builtin://ode/duffing#mod=odd\n</code></pre> <p>The parser strips the <code>#mod=...</code> before resolving the file and hands the fragment back so the compiler can use it when calling <code>build(..., mods=[...])</code>.</p> <p><code>resolve_uri</code> also tries to append <code>.toml</code> when the provided path has no suffix, so both <code>builtin://ode/vanderpol</code> and <code>builtin://ode/vanderpol.toml</code> are accepted. Security checks prevent traversal outside the registered root, so <code>TAG://../foo.toml</code> raises a <code>PathTraversalError</code> before any file is read.</p>"},{"location":"guides/modeling/model-registry/#configuring-tag-roots","title":"Configuring tag roots","text":"<p>Dynlib keeps the registry configuration in a tiny TOML file and supplements it with environment variables:</p> <ul> <li><code>DYNLIB_CONFIG</code> overrides the config path (default: <code>~/.config/dynlib/config.toml</code> on Linux, <code>~/Library/Application Support/dynlib/config.toml</code> on macOS, <code>%APPDATA%/dynlib/config.toml</code> on Windows).</li> <li><code>DYN_MODEL_PATH</code> lets you prepend tag roots on the fly with a shell-friendly syntax. On POSIX systems use <code>TAG=/path/one,/path/two:OTHER=/path/three</code>, and on Windows use <code>;</code> between tags.</li> </ul> <p>A <code>config.toml</code> looks like this:</p> <pre><code>[paths]\nmyproj = [\"~/repos/dynlib-models\", \"/opt/models\"]\nbuiltin = [\"/custom/builtin/overrides\"]  # keep dynlib builtins accessible\n\ncache_root = \"~/Library/Caches/dynlib\"\n</code></pre> <p><code>load_config()</code> parses that file, then prepends any <code>DYN_MODEL_PATH</code> entries so environment roots win when multiple directories share the same tag. After that, the builtin models folder is appended to the <code>builtin</code> tag list to guarantee <code>builtin://</code> URIs resolve even if you override the tag elsewhere.</p>"},{"location":"guides/modeling/model-registry/#adding-your-own-paths","title":"Adding your own paths","text":"<ol> <li>Choose a tag (e.g., <code>myproj</code>) and create a directory tree that mirrors the tag URI structure. For example, <code>myproj://circuit/srn.toml</code> resolves to <code>.../&lt;root&gt;/circuit/srn.toml</code>.</li> <li>Add the root to <code>DYNLIB_CONFIG</code>\u2019s <code>[paths]</code> table, or set <code>DYN_MODEL_PATH=\"myproj=~/models/myproj\"</code> in your shell for temporary overrides.</li> <li>Validate the setup with <code>dynlib model validate myproj://circuit/srn</code>.</li> <li>Use the URI inside scripts, <code>setup(...)</code>, or your own tooling \u2014 dynlib resolves tags, tries <code>.toml</code>, and reports missing files with a list of candidates.</li> </ol> <p>If you maintain multiple registries, remember that <code>DYN_MODEL_PATH</code> entries take precedence over config file entries, and both of those are searched before the builtin folder. This ordering lets you override <code>builtin://</code> models by putting a directory with the same structure earlier in the <code>builtin</code> tag list.</p>"},{"location":"guides/modeling/model-registry/#tips","title":"Tips","text":"<ul> <li>Run <code>dynlib model validate &lt;uri&gt;</code> before running a simulation to ensure the registry actually resolves the file.</li> <li>Use <code>mytag://path/to/model#mod=variant</code> when composing models with variants stored in separate <code>[[mods]]</code> tables.</li> <li>Keep reusable models under a well-known tag directory so collaborators can rely on the same URIs without editing their local config.</li> </ul> <p>With this registry in place, you can freely mix builtin models, shared libraries, and project-specific files while letting dynlib handle the lookup semantics for you.</p>"},{"location":"guides/modeling/mods/","title":"Mods: Model Modifications in Dynlib","text":"<p>Mods (modifications) in Dynlib allow you to dynamically alter model specifications without changing the original model files. This is useful for:</p> <ul> <li>Creating model variants (e.g., different parameter sets, added events)</li> <li>A/B testing different model configurations</li> <li>Applying patches or fixes to existing models</li> <li>Building complex models from simpler base models</li> </ul>"},{"location":"guides/modeling/mods/#overview","title":"Overview","text":"<p>Mods are defined using TOML table syntax. A basic mod looks like:</p> <pre><code>[mod]\nname = \"my_modification\"\ngroup = \"optional_group\"\nexclusive = false\n\n[mod.remove.events]\nnames = [\"event_to_remove\"]\n\n[mod.add.events.new_event]\nphase = \"post\"\ncond = \"x &gt; threshold\"\naction = \"x = 0\"\n\n[mod.set.params]\nalpha = 0.5\nbeta = 2.0\n</code></pre>"},{"location":"guides/modeling/mods/#verb-operations","title":"Verb Operations","text":"<p>Mods support four main operations (verbs) that are applied in this order: remove \u2192 replace \u2192 add \u2192 set.</p>"},{"location":"guides/modeling/mods/#1-remove","title":"1. Remove","text":"<p>Removes existing components from the model. Only works on components that already exist.</p> <p>Supported targets: <code>events</code>, <code>params</code>, <code>aux</code>, <code>functions</code></p> <pre><code>[mod]\nname = \"cleanup\"\n\n# Remove specific events\n[mod.remove.events]\nnames = [\"debug_event\", \"temporary_trigger\"]\n\n# Remove parameters\n[mod.remove.params]\nnames = [\"unused_param\", \"legacy_constant\"]\n\n# Remove auxiliary variables\n[mod.remove.aux]\nnames = [\"temp_var\", \"debug_output\"]\n\n# Remove functions\n[mod.remove.functions]\nnames = [\"helper_func\", \"unused_util\"]\n</code></pre> <p>Note: Attempting to remove <code>states</code> or other unsupported targets will raise an error.</p>"},{"location":"guides/modeling/mods/#2-replace","title":"2. Replace","text":"<p>Replaces existing components with new definitions. The component must already exist.</p> <p>Supported targets: <code>events</code>, <code>aux</code>, <code>functions</code></p> <p>Note: Use <code>set.params</code> to update parameter values. Use <code>remove</code> + <code>add</code> to replace parameters entirely.</p> <pre><code>[mod]\nname = \"update_logic\"\n\n# Replace an event\n[mod.replace.events.existing_event]\nphase = \"post\"\ncond = \"x &gt; new_threshold\"\naction = \"x = 0; counter = counter + 1\"\n\n# Replace auxiliary variables\n[mod.replace.aux]\nenergy = \"0.5 * m * v^2\"  # New expression\npower = \"force * velocity\"  # New expression\n\n# Replace functions\n[mod.replace.functions.activation]\nargs = [\"x\", \"gain\", \"offset\"]\nexpr = \"gain * tanh(x) + offset\"\n</code></pre>"},{"location":"guides/modeling/mods/#3-add","title":"3. Add","text":"<p>Adds new components to the model. The component must not already exist.</p> <p>Supported targets: <code>events</code>, <code>params</code>, <code>aux</code>, <code>functions</code></p> <pre><code>[mod]\nname = \"add_features\"\n\n# Add new events\n[mod.add.events.reset_mechanism]\nphase = \"post\"\ncond = \"x &gt; 10\"\naction = \"x = 0\"\n\n[mod.add.events.spike_detector]\nphase = \"pre\"\ncond = \"v &gt; threshold\"\naction = \"spike_count = spike_count + 1\"\nlog = [\"t\"]  # Log spike times\n\n# Add new parameters\n[mod.add.params]\ngain = 2.5\noffset = 0.1\n\n# Add auxiliary variables\n[mod.add.aux]\ntotal_energy = \"kinetic + potential\"\nefficiency = \"output_power / input_power\"\n\n# Add functions\n[mod.add.functions.sigmoid]\nargs = [\"x\"]\nexpr = \"1 / (1 + exp(-x))\"\n\n[mod.add.functions.relu]\nargs = [\"x\"]\nexpr = \"max(0, x)\"\n</code></pre> <p>Note: Attempting to add <code>states</code> or other unsupported targets will raise an error.</p>"},{"location":"guides/modeling/mods/#4-set","title":"4. Set","text":"<p>Sets or updates component values. This is an \"upsert\" operation - it can create new components or update existing ones.</p> <p>Supported targets: <code>states</code>, <code>params</code>, <code>aux</code>, <code>functions</code></p> <pre><code>[mod]\nname = \"configure\"\n\n# Set state initial values\n[mod.set.states]\nx = 5.0\ny = -2.5\n\n# Set parameter values (must already exist)\n[mod.set.params]\nalpha = 0.1\nbeta = 2.5\n\n# Set auxiliary variables (upsert - create or update)\n[mod.set.aux]\ndebug = \"t\"  # Create new\nenergy = \"0.5 * k * x^2\"  # Update existing\n\n# Set functions (upsert - create or update)\n[mod.set.functions.activation]\nargs = [\"x\"]\nexpr = \"tanh(x)\"  # Update existing\n\n[mod.set.functions.new_func]\nargs = [\"a\", \"b\"]\nexpr = \"a + b\"  # Create new\n</code></pre> <p>Note: For <code>states</code> and <code>params</code>, <code>set</code> only updates existing values and will raise an error if the component doesn't exist. Use <code>add</code> to create new parameters.</p>"},{"location":"guides/modeling/mods/#event-definition-format","title":"Event Definition Format","text":"<p>Events in mods use the same TOML table format as model definitions:</p> <pre><code>[mod.add.events.event_name]\nphase = \"pre\" | \"post\"        # When to check condition\ncond = \"expression\"           # Condition to trigger\naction = \"code\"               # Action to perform (string)\nlog = [\"var1\", \"var2\"]        # Variables to log when triggered (optional)\n\n# Alternative: keyed action assignments\n[mod.add.events.event_name]\nphase = \"post\"\ncond = \"x &gt; 5\"\naction.dx = 1.0\naction.dy = -0.5\nlog = [\"t\"]\n</code></pre>"},{"location":"guides/modeling/mods/#function-definition-format","title":"Function Definition Format","text":"<p>Functions are defined with args and expr:</p> <pre><code>[mod.add.functions.function_name]\nargs = [\"arg1\", \"arg2\", \"arg3\"]  # Array of argument names\nexpr = \"expression\"              # Function body expression\n</code></pre>"},{"location":"guides/modeling/mods/#group-and-exclusivity","title":"Group and Exclusivity","text":"<p>Mods can be grouped to prevent conflicting modifications:</p> <pre><code># Exclusive mods in the same group\n[mods.fast]\nname = \"fast\"\ngroup = \"speed\"\nexclusive = true\n\n[mods.fast.set.params]\ndt = 0.01\n\n[mods.slow]\nname = \"slow\"\ngroup = \"speed\"\nexclusive = true\n\n[mods.slow.set.params]\ndt = 0.1\n\n# Only one mod from the \"speed\" group can be active at a time\n</code></pre>"},{"location":"guides/modeling/mods/#using-mods","title":"Using Mods","text":""},{"location":"guides/modeling/mods/#loading-mods-from-files","title":"Loading Mods from Files","text":"<p>Mods are typically stored in TOML files and loaded via URI:</p> <pre><code>from dynlib import build\n\n# Load model with mods\nmodel = build(\"model.toml\", mods=[\"mods.toml#mod=variant1\"])\n</code></pre>"},{"location":"guides/modeling/mods/#single-mod-file","title":"Single Mod File","text":"<pre><code>[mod]\nname = \"parameter_tune\"\ngroup = \"tuning\"\n\n[mod.set.params]\nalpha = 0.5\nbeta = 2.0\n\n[mod.add.events.monitor]\nphase = \"post\"\ncond = \"t % 1.0 == 0\"\naction = \"\"\nlog = [\"x\", \"y\"]\n</code></pre>"},{"location":"guides/modeling/mods/#multiple-mods-in-one-file","title":"Multiple Mods in One File","text":"<pre><code>[mods.variant1]\nname = \"variant1\"\n\n[mods.variant1.set.params]\ngain = 1.0\n\n[mods.variant2]\nname = \"variant2\"\n\n[mods.variant2.set.params]\ngain = 2.0\n\n[mods.variant2.add.events.noise]\nphase = \"pre\"\ncond = \"true\"\naction = \"x = x + 0.1 * randn()\"\n</code></pre>"},{"location":"guides/modeling/mods/#uri-patterns-for-mods","title":"URI Patterns for Mods","text":"<ul> <li><code>\"mods.toml\"</code> - Load single mod from file</li> <li><code>\"mods.toml#mod=variant1\"</code> - Load specific mod from collection</li> <li><code>\"inline: [mod]\\nname='patch'\\n...\"</code> - Inline mod definition</li> </ul>"},{"location":"guides/modeling/mods/#programmatic-usage","title":"Programmatic Usage","text":"<p>For advanced use cases, you can create mods programmatically:</p> <pre><code>from dynlib.compiler.mods import ModSpec, apply_mods_v2\nfrom dynlib.dsl.parser import parse_model_v2\n\n# Define mod as Python dict (equivalent to TOML above)\nmod = ModSpec(\n    name=\"programmatic_mod\",\n    set={\n        \"params\": {\"alpha\": 0.5},\n        \"aux\": {\"debug\": \"t\"}\n    }\n)\n\n# Apply to parsed model\nnormal = parse_model_v2(model_toml_string)\nmodified = apply_mods_v2(normal, [mod])\n</code></pre>"},{"location":"guides/modeling/mods/#error-handling","title":"Error Handling","text":"<p>Mods validate operations and raise <code>ModelLoadError</code> for:</p> <ul> <li>Unsupported targets: Attempting to use operations on unsupported targets (e.g., <code>add.states</code>, <code>remove.states</code>, <code>replace.params</code>)</li> <li>Non-existent components: Attempting to remove or replace components that don't exist</li> <li>Duplicate components: Attempting to add components that already exist</li> <li>Unknown components: Attempting to set values for non-existent states or params</li> <li>Invalid data types: Using non-string values for aux variables</li> <li>Malformed definitions: Invalid function definitions (missing args, expr, etc.)</li> <li>Group exclusivity violations: Activating multiple exclusive mods from the same group</li> </ul>"},{"location":"guides/modeling/mods/#supported-targets-by-verb","title":"Supported Targets by Verb","text":"Verb Supported Targets Notes <code>remove</code> <code>events</code>, <code>params</code>, <code>aux</code>, <code>functions</code> Component must exist <code>replace</code> <code>events</code>, <code>aux</code>, <code>functions</code> Component must exist <code>add</code> <code>events</code>, <code>params</code>, <code>aux</code>, <code>functions</code> Component must not exist <code>set</code> <code>states</code>, <code>params</code>, <code>aux</code>, <code>functions</code> States/params must exist; aux/functions are upsert"},{"location":"guides/modeling/mods/#common-errors-and-solutions","title":"Common Errors and Solutions","text":"<p>Error: <code>add.states: unsupported target</code> - Cause: Trying to add new state variables via mods - Solution: States cannot be added dynamically. Define them in the base model.</p> <p>Error: <code>remove.states: unsupported target</code> - Cause: Trying to remove state variables via mods - Solution: States cannot be removed. They are fundamental to the model structure.</p> <p>Error: <code>replace.params: unsupported target</code> - Cause: Trying to replace parameters using <code>replace</code> verb - Solution: Use <code>set.params</code> to update values, or use <code>remove.params</code> + <code>add.params</code> sequence.</p> <p>Error: <code>add.params.x: param already exists</code> - Cause: Trying to add a parameter that already exists - Solution: Use <code>set.params</code> to update the value, or <code>remove.params</code> first if you need to replace it.</p>"},{"location":"guides/modeling/mods/#validation-prevents-silent-failures","title":"Validation Prevents Silent Failures","text":"<p>Prior to validation improvements, unsupported operations would silently fail, leaving users confused about why their mods weren't working. Now, any attempt to use unsupported targets will immediately raise a clear error with a list of supported targets.</p>"},{"location":"guides/modeling/mods/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Use descriptive names: Give mods clear, descriptive names that indicate their purpose.</p> </li> <li> <p>Group related mods: Use groups for mutually exclusive options (e.g., different parameter sets).</p> </li> <li> <p>Test thoroughly: Mods can significantly change model behavior - validate results carefully.</p> </li> <li> <p>Document mods: Include comments explaining what each mod does and why.</p> </li> <li> <p>Version control: Keep mod files under version control alongside your models.</p> </li> <li> <p>Start simple: Begin with basic set operations, then progress to more complex add/replace/remove combinations.</p> </li> </ol>"},{"location":"guides/modeling/mods/#examples","title":"Examples","text":""},{"location":"guides/modeling/mods/#parameter-study-mods","title":"Parameter Study Mods","text":"<pre><code>[mods.low_gain]\nname = \"low_gain\"\ngroup = \"gain_study\"\nexclusive = true\n\n[mods.low_gain.set.params]\nk = 0.1\n\n[mods.high_gain]\nname = \"high_gain\"\ngroup = \"gain_study\"\nexclusive = true\n\n[mods.high_gain.set.params]\nk = 10.0\n</code></pre>"},{"location":"guides/modeling/mods/#replacing-parameters-with-time-varying-expressions","title":"Replacing Parameters with Time-Varying Expressions","text":"<p>This example shows how to convert a constant parameter into a time-dependent auxiliary variable:</p> <pre><code>[mods.sine_drive]\nname = \"sine_drive\"\n\n# Note: Cannot add states via mods (would raise error)\n# Instead, add auxiliary noise variables\n\n[mods.sine_drive.add.params]\nfreq = 1000.0\nVmax = 4.0\n\n# Add V as a time-varying auxiliary variable\n[mods.sine_drive.add.aux]\nV = \"Vmax*sin(2*pi*freq*t)\"\n</code></pre>"},{"location":"guides/modeling/mods/#model-variants","title":"Model Variants","text":"<pre><code>[mod.stochastic]\nname = \"stochastic\"\n\n# Note: Cannot add states via mods (would raise error)\n# Instead, add auxiliary noise variables\n\n[mod.stochastic.add.params]\nsigma = 0.1\n\n[mod.stochastic.add.aux]\nnoise = \"sigma * randn()\"\nnoisy_x = \"x + noise\"\n</code></pre>"},{"location":"guides/modeling/mods/#debugging-aids","title":"Debugging Aids","text":"<pre><code>[mod.debug]\nname = \"debug\"\n\n[mod.debug.add.aux]\ndebug_t = \"t\"\ndebug_x = \"x\"\ndebug_dx = \"dx_dt\"\n\n[mod.debug.add.events.log_state]\nphase = \"post\"\ncond = \"t % 1.0 == 0\"  # Log every second\naction = \"\"  # No action, just logging\nlog = [\"debug_t\", \"debug_x\", \"debug_dx\"]\n</code></pre>"},{"location":"guides/modeling/mods/#function-variants","title":"Function Variants","text":"<p>In the below example h(phi,N) function has two variants. One can be chosen as follows:</p> <pre><code>sim = setup(\"memristive_chua#mod=odd\")\n</code></pre> <pre><code>[model]\ntype=\"ode\"\nname=\"Flux Controlled Memristor\"\n\n[states]\nphi=0.1\n\n[params]\na=0.08\nb=1\nc=0.83\nd=1.8\nN=0\nfreq=1.0\nVmax=4.0\n\n[functions.W]\nargs=[\"phi\"]\nexpr=\"a+b*tanh(phi)**2\"\n\n[aux]\nV = \"Vmax*sin(2*pi*freq*t)\"\nI = \"W(phi)*V\"\n\n[equations.rhs]\nphi=\"c*V-d*h(phi,N)\"\n\n### MODS:\n\n[mods.odd.add.functions]\nh = {args = [\"phi\",\"N\"], expr=\"\"\"\nphi if N==0 else phi-sum(sign(phi+(2*j-1))+sign(phi-(2*j-1)) for j in range(1,N+1))\n\"\"\"}\n\n[mods.even.add.functions]\nh = {args = [\"phi\",\"N\"], expr = \"\"\"\nphi-sign(phi) if N==0 else phi-sign(phi)-sum(sign(phi+2*j)+sign(phi-2*j) for j in range(1,N+1))\n\"\"\"}\n</code></pre>"},{"location":"guides/modeling/mods/#verb-order-matters","title":"Verb Order Matters","text":"<p>Remember that verbs are applied in this fixed order:</p> <ol> <li>Remove - Remove components first</li> <li>Replace - Replace existing components  </li> <li>Add - Add new components</li> <li>Set - Set/update values</li> </ol> <p>This allows complex transformations like: remove old component \u2192 add new one with different name, or replace component \u2192 then modify its parameters.</p>"},{"location":"guides/modeling/presets/","title":"Presets","text":"<p>Presets let you capture reusable sets of state and parameter values so you can quickly switch between \"modes\" of a model (e.g., fast vs. slow dynamics, resting vs. activated). Once defined, presets live in a Sim's in\u2011memory bank and can be applied, listed, saved, loaded, or created at runtime.</p>"},{"location":"guides/modeling/presets/#defining-presets-in-the-dsl","title":"Defining presets in the DSL","text":"<p>Inline presets are declared inside the model TOML using <code>[presets.&lt;name&gt;]</code> tables. Each preset may provide:</p> <ul> <li><code>[presets.&lt;name&gt;.params]</code> for parameter overrides</li> <li><code>[presets.&lt;name&gt;.states]</code> for state initial values</li> </ul> <p>At least one of the two sections must exist, and every value must be a number (integers and floats are both accepted). A preset can omit states (parameter-only), omit params (state-only), or supply both. The declared names must match the model's <code>states</code> and <code>params</code>; invalid names are caught when the DSL is validated.</p> <pre><code>[presets.fast.params]\nalpha = 2.5\nbeta = 0.1\n\n[presets.fast.states]\nx = 5.0\ny = -1.0\n\n[presets.rest.params]\nalpha = 0.2\nbeta = 0.01\n</code></pre> <p>Inline presets are automatically loaded into each <code>Sim</code> instance during initialization. If a preset name appears more than once, the first definition wins and a warning is emitted.</p>"},{"location":"guides/modeling/presets/#working-with-the-preset-bank","title":"Working with the preset bank","text":"<p>Every <code>Sim</code> instance keeps a bank of presets, populated from inline definitions plus any added/loaded at runtime.</p> <ul> <li><code>list_presets(pattern=\"*\")</code> returns all matching names (supports <code>*</code>, <code>?</code>, <code>[]</code>) sorted alphabetically.</li> <li><code>apply_preset(name)</code> updates only the params/states listed in the preset; time, dt, stepper workspace, step count, and recorded history remain untouched. Before applying, Dynlib validates that each key exists and casts the numeric values to the model dtype (warning if precision might be lost).</li> </ul>"},{"location":"guides/modeling/presets/#adding-new-presets-on-the-fly","title":"Adding new presets on the fly","text":"<p>Use <code>add_preset(name, *, states=None, params=None, overwrite=False)</code> to snapshot the current session or to register custom values:</p> <ul> <li>If both <code>states</code> and <code>params</code> are <code>None</code>, the preset captures the current session's values.</li> <li>Each argument may be a mapping (<code>{\"x\": 1.0}</code>) or a 1\u2011D NumPy array (interpreted in declaration order), and may be partial (e.g., only a subset of states).</li> <li>The method raises <code>ValueError</code> if the name already exists unless <code>overwrite=True</code>, or if there is nothing to store.</li> </ul>"},{"location":"guides/modeling/presets/#persisting-presets-to-disk","title":"Persisting presets to disk","text":"<p>Dynlib can read/write presets using TOML files that follow <code>dynlib-presets-v1</code>. The file must contain:</p> <pre><code>[__presets__]\nschema = \"dynlib-presets-v1\"\n\n[presets.example.params]\na = 1.0\nb = 2.0\n\n[presets.example.states]\nx = 0.0\n</code></pre> <ul> <li><code>load_preset(name_or_pattern, path, *, on_conflict=\"error\")</code> imports presets from the file into the bank. You can pass an exact name or a glob pattern (e.g., <code>\"fast_*\"</code>). By default a conflict with an existing bank entry raises, but <code>\"keep\"</code>/<code>\"replace\"</code> let you skip or overwrite the bank entry (warnings highlight the action). The loader validates the schema header, enforces numeric tables, and ensures all referenced names exist in the active model.</li> <li><code>save_preset(name, path, *, overwrite=False)</code> appends or writes a preset from the bank to disk. It creates or updates the <code>[__presets__]</code> header, leaves existing unrelated presets intact, and respects <code>overwrite</code> for name collisions inside the file.</li> </ul> <p>Together these helpers make it easy to build curriculums of parameter/state sets, share them across projects, or export the state of a numerical experiment for later reuse.</p>"},{"location":"guides/modeling/presets/#example","title":"Example","text":"<pre><code>[model]\ntype = \"ode\"\n\n[states]\nv = -65.0\nu = -13.0\n\n[params]\na = 0.02\nb = 0.2\nc = -65.0\nd = 8.0\nI = 10.0\nv_th = 30.0\n\n[equations]\nexpr = \"\"\"\ndv = 0.04 * v * v + 5.0 * v + 140.0 - u + I\ndu = a * (b * v - u)\n\"\"\"\n\n[events.reset]\ncond = \"v &gt;= v_th\"\nphase = \"post\"\naction = \"\"\"\nv = c\nu = u + d\n\"\"\"\n\n# PRESETS:\n[presets.regular_spiking.params]\na = 0.02\nb = 0.2\nc = -65.0\nd = 8.0\n\n[presets.intrinsic_bursting.params]\na = 0.02\nb = 0.2\nc = -55.0\nd = 4.0\n\n[presets.bursting.params]\na = 0.02\nb = 0.2\nc = -50\nd = 2\n\n[presets.fast_spiking.params]\na = 0.1\nb = 0.2\nc = -65\nd = 2\n\n[presets.low_threshold.params]\na = 0.02\nb = 0.25\nc = -65\nd = 2\n\n[presets.resonator.params]\na = 0.1\nb = 0.26\nc = -65\nd = 2\n</code></pre> <p>In the simulation file you can choose one of the existing presets. TOML presets are added to the presets bank automatically.</p> <p>See simulation for runtime usage of presets.</p>"},{"location":"guides/modeling/sim/","title":"Simulation ([sim])","text":"<p>The <code>[sim]</code> table specifies default runtime knobs for any model. Most fields feed into the <code>Sim</code> facade (<code>Sim.run</code>) and the runner that executes integrations or maps. Think of this table as the \u201crecommended defaults\u201d for users and tools that load your model.</p>"},{"location":"guides/modeling/sim/#known-keys","title":"Known keys","text":"<ul> <li><code>t0</code> \u2013 Initial time. Defaults to <code>0.0</code>. It seeds both the runtime clock and the derived <code>Nominal dt / T</code> arithmetic.</li> <li><code>t_end</code> \u2013 End time for continuous (ODE-like) models. Defaults to <code>1.0</code>. The <code>Sim.run</code> fa\u00e7ade uses it when you do not override <code>T</code>.</li> <li><code>dt</code> \u2013 Nominal time step (or discrete map spacing). Defaults to <code>1e-2</code>. The runner caches this as the \u201cnominal dt\u201d used for both stepping and as the fallback when you omit <code>dt</code> in <code>Sim.run</code>.</li> <li><code>stepper</code> \u2013 Name of the default stepper (e.g., <code>\"rk4\"</code> for ODEs, <code>\"map\"</code> for maps). The compiler chooses a sane default based on the model kind but you can override it here to pin a specific integrator.</li> <li><code>record</code> \u2013 Boolean controlling the default recording behavior. Defaults to <code>true</code>. When <code>Sim.run</code> is called without <code>record</code>, this value decides whether state/aux samples are accumulated.</li> <li><code>atol</code>, <code>rtol</code> \u2013 Adaptive-stepper tolerances (default <code>1e-8</code>/<code>1e-5</code>). They only apply when the configured stepper exposes adaptive control via its <code>Config</code> dataclass.</li> <li><code>max_steps</code> \u2013 Maximum number of steps before the runner stops (default <code>1_000_000</code>). For discrete models it also serves as the default iteration count (<code>N</code>) when you do not supply <code>N</code> or <code>T</code>.</li> <li><code>stop</code> \u2013 Early exit condition evaluated every step, usually in the <code>post</code> phase. You can write a simple string <code>stop = \"x &gt; threshold\"</code> or a table:   <pre><code>[sim.stop]\ncond = \"max_energy &gt; threshold\"\nphase = \"post\"  # only \"post\" is currently supported\n</code></pre>   When the condition is true the runner raises <code>EARLY_EXIT</code> and <code>Results.status</code> reflects that fact.</li> <li>Extra keys \u2013 Any other entries (anything besides the keys listed above) are forwarded into <code>SimDefaults._stepper_defaults</code> and automatically mapped onto the active stepper\u2019s <code>Config</code> fields. This lets you pass <code>stepper-specific</code> defaults such as <code>tol</code>, <code>max_iter</code>, or any enum-typed option without duplicating the stepper name in code.</li> </ul>"},{"location":"guides/modeling/sim/#interaction-with-runs","title":"Interaction with runs","text":"<ol> <li>Run-time overrides win \u2013 Every public <code>Sim.run</code> argument (<code>t0</code>, <code>T</code>/<code>N</code>, <code>dt</code>, <code>max_steps</code>, <code>record</code>, etc.) overrides the values in <code>[sim]</code>. This includes stepper kwargs passed via <code>**stepper_kwargs</code>, which take precedence over <code>[sim]</code> extras.</li> <li>Precedence chain \u2013 Stepper config defaults come from: stepper class default &lt; <code>[sim]</code> extra fields &lt; <code>Sim.run(... stepper_kwargs...)</code>. This merging happens automatically through <code>ConfigMixin.default_config</code>, so you only need to declare the keys once.</li> <li>Discrete vs. continuous \u2013 <code>Sim.run</code> interprets <code>[sim].t_end</code>/<code>dt</code> differently depending on the model kind (<code>map</code> vs <code>ode</code>). For maps, <code>[sim].max_steps</code> becomes the default iteration count when <code>N</code>/<code>T</code> are omitted; for ODEs, <code>t_end</code> is the default integration horizon.</li> <li>Stop condition evaluation \u2013 When <code>[sim].stop</code> is present, the compiler wires it into the appropriate runner (pre/post according to <code>phase</code>). The condition shares the usual expression context (states, params, aux, functions, built-in macros) and is checked every committed step.</li> <li>Recording defaults \u2013 <code>[sim].record</code> only sets the default; <code>Sim.run(record=False)</code> still disables logging for that specific invocation. If you use selective recording (<code>record_vars</code>), the <code>[sim]</code> table remains unchanged because selection is runtime-specific.</li> </ol>"},{"location":"guides/modeling/sim/#examples","title":"Examples","text":"<pre><code>[sim]\nt0 = 0.0\nt_end = 5.0\ndt = 0.01\nstepper = \"rk4\"\nrecord = true\natol = 1e-9\nrtol = 1e-6\nmax_steps = 500_000\ntol = 1e-8        # extra field forwarded to the stepper config\nstop = \"energy &gt; 100\"  # triggers early exit\n</code></pre> <p>If the stepper exposes a <code>Config</code> with a field named <code>tol</code>, that value overrides its default but can still be overridden later via <code>Sim.run(t, dt, tol=explicit_value)</code>.</p>"},{"location":"guides/modeling/sim/#best-practices","title":"Best practices","text":"<ol> <li>Only add stepper-specific keys you need so the list of extras stays focused.</li> <li>Document your early-exit condition when you use <code>[sim].stop</code>\u2014readers should know when and why the simulation aborts.</li> <li>Keep defaults consistent with physical time units (seconds, iterations) so scripts using your model do not need to repeatedly override <code>t0</code>, <code>dt</code>, or <code>t_end</code>.</li> <li>Use <code>[sim]</code> mostly for safe defaults; rely on <code>Sim.run</code> arguments when reproducing experiments or steering explorers.</li> </ol>"},{"location":"guides/modeling/ternary-if/","title":"Ternary if","text":""},{"location":"guides/modeling/ternary-if/#ternary-if-expressions","title":"Ternary <code>if</code> expressions","text":"<p>The DSL lets you keep short, two-way branches inline because every right-hand expression is parsed as a Python expression. That means you can write the familiar Python ternary form:</p> <pre><code>&lt;value when true&gt; if &lt;condition&gt; else &lt;value when false&gt;\n</code></pre> <p>This form is ideal when the condition simply selects between two calculations without needing side effects or additional statements. Use a full <code>if</code>/<code>else</code> block when you need multiple assignments, logging, or other imperative steps before producing the final value.</p>"},{"location":"guides/modeling/ternary-if/#examples-from-the-repository","title":"Examples from the repository","text":"<p>The mods guide itself shows a ternary expression inside an added helper function, using it to substitute one formula when <code>N == 0</code> and another when <code>N</code> is positive (see <code>docs/guides/modeling/mods.md:483-491</code>):</p> <pre><code>h = {args = [\"phi\",\"N\"], expr=\"\"\"\nphi if N==0 else phi-sum(sign(phi+(2*j-1))+sign(phi-(2*j-1)) for j in range(1,N+1))\n\"\"\"}\n</code></pre> <p>The unit tests also rely on a ternary branch inside an inline model to make the RHS depend on time; <code>tests/unit/test_sum_generator_lowering.py:27-110</code> defines the model with</p> <pre><code>[equations.rhs]\nx = \"1.0 if t &lt; 0 else sum(i for i in range(N))\"\n</code></pre> <p>and verifies both sides of the branch against the Python and JIT backends.</p> <p>Those examples show how ternary expressions keep expressions concise while still feeding the compiler two distinct paths to choose from.</p>"},{"location":"guides/modeling/ternary-if/#nested-if-expressions","title":"Nested <code>if</code> expressions","text":"<p>You can nest ternary <code>if</code> expressions to handle multiple conditions in a single expression. This allows for more complex branching without resorting to full <code>if</code>/<code>else</code> blocks, as long as the logic remains purely functional.</p>"},{"location":"guides/modeling/ternary-if/#syntax","title":"Syntax","text":"<pre><code>&lt;value1&gt; if &lt;condition1&gt; else &lt;value2&gt; if &lt;condition2&gt; else &lt;value3&gt; if ... else &lt;default_value&gt;\n</code></pre> <p>Note that nesting can reduce readability, so use it sparingly and consider parentheses for clarity if needed.</p>"},{"location":"guides/modeling/ternary-if/#example","title":"Example","text":"<p>Suppose you need to select a value based on multiple thresholds. In a model equation, you might write:</p> <pre><code>result = \"0 if x &lt; 0 else 1 if x &lt; 10 else 2\"\n</code></pre> <p>This evaluates to: - <code>0</code> if <code>x &lt; 0</code> - <code>1</code> if <code>0 &lt;= x &lt; 10</code> - <code>2</code> otherwise</p>"},{"location":"guides/plotting/","title":"Plotting guide","text":""},{"location":"guides/plotting/#plotting-guide","title":"Plotting guide","text":"<ul> <li>Plotting Basics: quick tour of the <code>plot.series</code>, <code>plot.phase</code>, <code>plot.utils</code>, and <code>plot.manifold</code> helpers with their common options.</li> <li>Exporting Plots: how to render or persist figures using <code>dynlib.plot.export</code>.</li> <li>Cobweb Plots: visualizing iteration trajectories and dynamics of 1D discrete maps.</li> <li>Basin Plots: rendering basin-of-attraction classifications from analysis results.</li> <li>Vector Fields: plotting direction fields and flow visualizations for ODEs.</li> <li>Themes &amp; Facets: how to control global styling via <code>plot.theme</code>, set palettes/presets, and build reused multi-panel layouts with <code>plot.fig</code>/<code>plot.facet</code>.</li> </ul>"},{"location":"guides/plotting/basics/","title":"Plotting Basics","text":"<p>Dynlib's plotting module (<code>dynlib.plot</code>) provides a set of high-level helpers that wrap Matplotlib to align with dynlib's analysis workflows. These tools handle common plotting tasks for dynamical systems, such as time series, phase portraits, and manifolds, while ensuring consistent styling and layout. All helpers accept NumPy arrays, lists, pandas Series, or slices from <code>Results</code> objects, automatically converting them as needed.</p> <p>This guide covers the basics of using these plotting helpers, from creating figures to customizing plots.</p>"},{"location":"guides/plotting/basics/#getting-started","title":"Getting Started","text":"<p>To use dynlib's plotting tools, import the necessary modules:</p> <pre><code>from dynlib.plot import fig, series, phase, utils\n</code></pre> <p>Here's a quick example that demonstrates creating a grid of subplots and plotting different types of data:</p> <pre><code># Create a 2x2 grid of subplots\naxes = fig.grid(rows=2, cols=2, size=(10, 8))\n\n# Plot a time series\nseries.plot(x=t, y=x_traj, label=\"x(t)\", ax=axes[0, 0])\n\n# Plot discrete data as stems\nseries.stem(x=k, y=impulse_response, ax=axes[0, 1])\n\n# Plot a phase portrait with equilibrium points\nphase.xy(x=x_traj, y=y_traj, equil=[(x_eq, y_eq)], ax=axes[1, 0])\n\n# Display a 2D image with a colorbar\nutils.image(Z, extent=[0, 10, 0, 1], colorbar=True, ax=axes[1, 1])\n</code></pre> <p>Dynlib's <code>fig</code> helpers manage figure creation and layout automatically, so you can focus on the data rather than Matplotlib's boilerplate.</p>"},{"location":"guides/plotting/basics/#creating-figures-and-subplots","title":"Creating Figures and Subplots","text":"<p>Dynlib provides convenient functions to create figures and subplots with consistent styling:</p> <ul> <li><code>fig.single()</code>: Creates a single subplot.</li> <li><code>fig.grid(rows=2, cols=2)</code>: Creates a grid of subplots.</li> <li><code>fig.wrap(n=5, cols=3)</code>: Creates a grid that wraps a specified number of subplots into columns, hiding any unused axes.</li> <li><code>fig.single3D()</code>: Creates a single 3D subplot.</li> </ul> <p>These functions accept parameters like <code>title</code>, <code>size</code>, <code>scale</code>, <code>sharex</code>, and <code>sharey</code> for customization. They return Matplotlib axes objects that you can pass to plotting helpers.</p> <p>For faceting plots over data categories, use <code>plot.facet.wrap(keys, cols=3)</code>, which yields axes and keys for iteration.</p> <p>Example:</p> <pre><code># Create a single subplot\nax = fig.single(size=(8, 6))\nseries.plot(x=t, y=data, ax=ax)\n\n# Create a grid for multiple plots\naxes = fig.grid(rows=1, cols=3)\nfor i, dataset in enumerate(datasets):\n    series.plot(x=t, y=dataset, ax=axes[i])\n</code></pre>"},{"location":"guides/plotting/basics/#styling-and-decorations","title":"Styling and Decorations","text":"<p>Dynlib's plotting helpers support consistent styling through presets and decorations.</p>"},{"location":"guides/plotting/basics/#style-presets","title":"Style Presets","text":"<p>Style presets define how data is visualized (e.g., lines, markers, or both). Available presets include <code>\"continuous\"</code>, <code>\"discrete\"</code>, <code>\"line\"</code>, <code>\"scatter\"</code>, and others. You can pass a preset name or a custom style dictionary.</p> <p>Example:</p> <pre><code># Use a preset\nseries.plot(x=t, y=data, style=\"continuous\", ax=ax)\n\n# Customize with overrides\nseries.plot(x=t, y=data, style={\"ls\": \"--\", \"marker\": \"x\"}, color=\"red\", ax=ax)\n</code></pre>"},{"location":"guides/plotting/basics/#decorations","title":"Decorations","text":"<p>Add vertical or horizontal lines and bands to highlight features:</p> <ul> <li><code>vlines</code>: Vertical lines (e.g., <code>vlines=[5, (10, \"threshold\")]</code>)</li> <li><code>hlines</code>: Horizontal lines</li> <li><code>vbands</code>: Vertical bands</li> <li><code>hbands</code>: Horizontal bands</li> </ul> <p>Labels are positioned automatically and respect axis limits.</p> <p>Example:</p> <pre><code>series.plot(x=t, y=data, vlines=[(5, \"start\"), 10], hbands=[(0, 1, \"region\")], ax=ax)\n</code></pre>"},{"location":"guides/plotting/basics/#axis-control","title":"Axis Control","text":"<p>Control axis limits with <code>xlim</code>, <code>ylim</code>, and <code>zlim</code> (for 3D). Helpers automatically apply consistent labels, fonts, and rotations.</p>"},{"location":"guides/plotting/basics/#plotting-time-series","title":"Plotting Time Series","text":"<p>Use <code>series</code> helpers for time-based plots:</p> <ul> <li><code>series.plot(x, y, ...)</code>: Standard line plot for continuous or discrete data.</li> <li><code>series.stem(x, y, ...)</code>: Stem plot for discrete samples.</li> <li><code>series.step(x, y, ...)</code>: Step plot for piecewise-constant data.</li> <li><code>series.multi(data, ...)</code>: Plot multiple series at once.</li> </ul> <p>These helpers support all styling and decoration options.</p> <p>Examples:</p> <pre><code># Simple time series\nseries.plot(x=t, y=x_traj, label=\"Position\", ax=ax)\n\n# Multiple series\ndata = {\"x\": x_traj, \"y\": y_traj}\nseries.multi(data, styles={\"x\": \"continuous\", \"y\": \"discrete\"}, ax=ax)\n\n# Stem plot for impulses\nseries.stem(x=k, y=impulse, ax=ax)\n</code></pre>"},{"location":"guides/plotting/basics/#plotting-phase-portraits","title":"Plotting Phase Portraits","text":"<p>Phase-space plots visualize relationships between state variables:</p> <ul> <li><code>phase.xy(x, y, ...)</code>: 2D phase portrait.</li> <li><code>phase.xyz(x, y, z, ...)</code>: 3D phase portrait.</li> <li><code>phase.multi(x_list, y_list, ...)</code>: Multiple trajectories on one plot.</li> <li><code>phase.return_map(x, step, ...)</code>: Return map for maps.</li> </ul> <p>Mark equilibria with <code>equil</code> and customize labels.</p> <p>Examples:</p> <pre><code># 2D phase portrait\nphase.xy(x=x_traj, y=y_traj, equil=[(0, 0)], ax=ax)\n\n# Return map\nphase.return_map(x=trajectory, step=1, equil=[(fixed_point,)], ax=ax)\n</code></pre>"},{"location":"guides/plotting/basics/#utility-plots","title":"Utility Plots","text":"<p>Additional helpers for common visualizations:</p> <ul> <li><code>utils.hist(data, ...)</code>: Histogram of 1D data.</li> <li><code>utils.image(data, ...)</code>: 2D image plot.</li> </ul> <p>Both support styling and can include colorbars.</p> <p>Example:</p> <pre><code># Histogram\nutils.hist(data, bins=50, density=True, ax=ax)\n\n# Image with colorbar\nutils.image(matrix, extent=[0, 1, 0, 1], colorbar=True, ax=ax)\n</code></pre>"},{"location":"guides/plotting/basics/#exporting-and-displaying-figures","title":"Exporting and displaying figures","text":"<p>Import <code>export</code> from <code>dynlib.plot</code> whenever you need to present or save a figure. It re-exports Matplotlib's <code>savefig</code> helpers with dynlib-aware defaults, so you can pass entire axes grids or figure handles without extra boilerplate. Call <code>export.show()</code> once your plotting script is complete (handy in notebooks or scripts) or <code>export.savefig(fig_or_ax, \"plots/my-fig\", fmts=(\"png\", \"pdf\"))</code> to write multiple formats. See the dedicated Exporting plots guide for details on format selection, metadata, and working with grid containers.</p>"},{"location":"guides/plotting/basics/#plotting-manifolds","title":"Plotting Manifolds","text":"<p>For 1D manifolds, use <code>plot.manifold(segments, ...)</code> or pass <code>result</code> objects with branches. Specify components and styles for different groups.</p> <p>Example:</p> <pre><code>plot.manifold(result.branches, components=(0, 1), ax=ax)\n</code></pre>"},{"location":"guides/plotting/basics/#tips-and-best-practices","title":"Tips and Best Practices","text":"<ul> <li>Always use <code>ax=</code> when creating multi-panel figures to control where plots appear.</li> <li>Leverage style presets for quick styling, then override as needed.</li> <li>Decorations like lines and bands work across most helpers for consistent annotations.</li> <li>Helpers automatically handle data conversion, so mix NumPy arrays, lists, and dynlib results freely.</li> <li>For images with colorbars, access the colorbar via <code>ax._last_colorbar</code> for further customization.</li> </ul> <p>This should get you started with dynlib's plotting tools. For more advanced features, check the API reference.</p>"},{"location":"guides/plotting/basin-plot/","title":"Basin Plots","text":"<p>Basin plots expose which attractor each initial condition settles toward by coloring a 2D grid of parameter space. <code>plot.basin_plot()</code> turns the categorical labels produced by the basin-of-attraction analysis utilities into a <code>pcolormesh</code> so you can instantly see the structure of the basins, the special outcomes, and how the color legend relates to each attractor.</p>"},{"location":"guides/plotting/basin-plot/#what-the-plot-shows","title":"What the plot shows","text":"<p>Each grid cell corresponds to one initial condition defined during the analysis. The value stored for that cell is an integer label:</p> <ul> <li>Attractor IDs (0, 1, \u2026) mark trajectories that converged onto a known attractor.</li> <li>Special values (<code>BLOWUP</code>, <code>OUTSIDE</code>, <code>UNRESOLVED</code>) flag diverging trajectories, escapes from the region of interest, or initial conditions that did not reach a decision within the computation budget.</li> </ul> <p><code>basin_plot()</code> maps those integers to colors and emits a colorbar that labels the special outcomes first and then the attractors in index order.</p>"},{"location":"guides/plotting/basin-plot/#preparing-your-data","title":"Preparing your data","text":"<p>Pass the <code>BasinResult</code> returned by <code>analysis.basin_auto()</code> (or <code>analysis.basin_known()</code>) directly to <code>basin_plot()</code>. The helper reads <code>res.labels</code> for the categorical grid and uses <code>res.meta</code> to infer grid dimensions (<code>ic_grid</code>), bounds (<code>ic_bounds</code>), observed variables (<code>observe_vars</code>), and attractor metadata (<code>attractor_labels</code>/<code>attractor_names</code>).</p> <p>If you computed the labels yourself, pass them with <code>labels=</code>; 1D arrays require a <code>grid=(nx, ny)</code> shape so the helper can reshape to 2D, whereas pre-shaped 2D arrays can be supplied directly. Alternatively, provide explicit <code>x</code> and <code>y</code> coordinates that match the label array.</p> <pre><code>from dynlib import setup\nfrom dynlib.analysis import basin_auto\nfrom dynlib.plot import basin_plot\n\nsim = setup(\"models/henon.map\", stepper=\"map\")\nres = basin_auto(sim, ic_grid=[256, 256], ic_bounds=[(-2, 2), (-2, 2)])\nbasin_plot(res)\n</code></pre>"},{"location":"guides/plotting/basin-plot/#controlling-the-colormap","title":"Controlling the colormap","text":"<p><code>basin_plot()</code> builds a single colormap that starts with the special outcomes (default order <code>[BLOWUP, OUTSIDE, UNRESOLVED]</code>) followed by the attractor IDs. Override the defaults with:</p> <ul> <li><code>special_order</code>: swap or drop the special IDs.</li> <li><code>special_colors</code>: supply one color per special label; defaults fall back to grayscale pairs derived from the current Matplotlib palette if you request more entries.</li> <li><code>special_labels</code>: rename the special entries that appear on the colorbar (e.g., <code>{\"blowup\": \"Diverged\"}</code>).</li> <li><code>attractor_cmap</code>: switch from <code>\"hsv\"</code> to any Matplotlib colormap (or pass a <code>Colormap</code> instance) for the attractors.</li> <li><code>attractor_colors</code>: give explicit colors instead of sampling a colormap.</li> <li><code>attractor_labels</code>: customize the attractor names on the colorbar; they default to <code>meta[\"attractor_labels\"]</code>, <code>meta[\"attractor_names\"]</code>, or <code>A0</code>, <code>A1</code>, \u2026.</li> </ul> <pre><code>basin_plot(\n    res,\n    special_colors=[\"#1a1a1a\", \"#444444\", \"#777777\"],\n    attractor_cmap=\"viridis\",\n    attractor_labels=[\"Period-1\", \"Period-2\"],\n    colorbar_label=\"Outcome\",\n)\n</code></pre> <p><code>basin_plot()</code> raises if you ask for fewer colors than there are labels, so make sure your palette matches the number of special outcomes and attractors in the result.</p>"},{"location":"guides/plotting/basin-plot/#axis-bounds-and-annotations","title":"Axis, bounds, and annotations","text":"<p>Axis limits, labels, and tick styling are handled by the usual <code>plot</code> helpers:</p> <ul> <li><code>bounds</code> or <code>res.meta[\"ic_bounds\"]</code> specify the <code>(x_min, x_max)</code>/<code>(y_min, y_max)</code> ranges used when generating the initial conditions. If you supply <code>x</code> and <code>y</code> arrays instead, <code>bounds</code> is ignored.</li> <li><code>xlabel</code>, <code>ylabel</code>, and <code>title</code> behave like <code>matplotlib.axes.Axes</code> labels. When the result metadata contains <code>observe_vars</code>, those names automatically populate <code>xlabel</code>/<code>ylabel</code> unless you override them.</li> <li><code>xlim</code>, <code>ylim</code>, <code>aspect</code>, <code>xlabel_fs</code>, <code>ylabel_fs</code>, <code>xtick_fs</code>, <code>ytick_fs</code>, <code>xlabel_rot</code>, <code>ylabel_rot</code>, <code>title_fs</code>, <code>titlepad</code>, <code>xpad</code>, and <code>ypad</code> let you fine-tune the appearance.</li> <li>The helper accepts an existing <code>ax=</code> so you can place the basin map into a multi-panel figure produced by <code>plot.fig()</code>/<code>plot.theme()</code> or Matplotlib directly.</li> </ul> <p>Because the plot uses <code>pcolormesh</code>, <code>shading</code> defaults to <code>\"auto\"</code> and <code>alpha</code> can be used to fade the grid if you intend to overlay contours or basins from another dataset.</p>"},{"location":"guides/plotting/basin-plot/#colorbar-tuning","title":"Colorbar tuning","text":"<p>Set <code>colorbar=False</code> to omit it. Otherwise, the helper automatically hooks up ticks for the special entries followed by the attractor IDs. Use:</p> <ul> <li><code>colorbar_label</code>, <code>colorbar_label_rotation</code>, and <code>colorbar_labelpad</code> to adjust the axis title.</li> <li><code>colorbar_kwargs</code> to forward extra settings (e.g. <code>{\"fraction\": 0.05}</code>) to <code>plt.colorbar()</code>.</li> </ul> <p><code>plot.basin_plot()</code> stores the created <code>Colorbar</code> on <code>ax._last_colorbar</code>, mirroring other plotting helpers.</p>"},{"location":"guides/plotting/basin-plot/#tips","title":"Tips","text":"<ul> <li>Provide <code>grid</code> when passing only flattened labels; the helper must know how to reshape them into <code>(ny, nx)</code> for <code>pcolormesh</code>.</li> <li><code>res.meta[\"ic_grid\"]</code> and <code>res.meta[\"ic_bounds\"]</code> are frequently populated by the analysis routines, so you rarely need to repeat them when plotting.</li> <li>To visualize a different slice of a multi-parameter result, slice the labels array before calling <code>basin_plot()</code> and update <code>bounds</code> accordingly (the helper does not automatically reshape multidimensional slices).</li> <li>If you want to highlight attractor names instead of IDs, always supply <code>attractor_labels</code> so the colorbar ticks read clearly regardless of the order of your attractor registry.</li> </ul> <p><code>basin_plot()</code> always returns the <code>Axes</code> object so you can continue annotating the figure with Matplotlib commands or the shared decoration arguments (<code>vlines</code>, <code>hlines</code>, <code>vbands</code>, <code>hbands</code>) described in Plot Decorations.</p>"},{"location":"guides/plotting/bifurcation-diagrams/","title":"Bifurcation Diagrams","text":"<p>Bifurcation diagrams visualize how the long-term behavior of a dynamical system changes as a parameter is varied. Dynlib provides the <code>bifurcation_diagram()</code> function to create scatter-style plots of bifurcation data, optimized for the dense point clouds typical of bifurcation analysis.</p>"},{"location":"guides/plotting/bifurcation-diagrams/#basic-usage","title":"Basic Usage","text":"<p>The <code>bifurcation_diagram()</code> function accepts bifurcation data in two formats:</p> <ol> <li>A <code>BifurcationExtractor</code>/<code>BifurcationResult</code> (usually returned by <code>SweepResult.bifurcation()</code>)</li> <li>A tuple of <code>(parameter_values, state_values)</code> arrays</li> </ol> <p>See the Input Data Formats section below for more on extractor helpers and raw arrays.</p> <pre><code>from dynlib.plot import bifurcation_diagram, theme, fig, export\n\n# Assuming you have bifurcation data from analysis\n# result = sweep_result.bifurcation(\"x\")  # returns an extractor (defaults to .all())\n\n# Create the plot\nax = fig.single(size=(10, 6))\nbifurcation_diagram(\n    result,  # BifurcationResult or (p, y) tuple\n    xlabel=\"r\",\n    ylabel=\"x*\",\n    title=\"Bifurcation Diagram\",\n    ax=ax\n)\n\nexport.show()\n</code></pre>"},{"location":"guides/plotting/bifurcation-diagrams/#input-data-formats","title":"Input Data Formats","text":""},{"location":"guides/plotting/bifurcation-diagrams/#bifurcation-extractors-and-results","title":"Bifurcation extractors and results","text":"<p><code>SweepResult.bifurcation(\"x\")</code> returns a <code>BifurcationExtractor</code>, which implements the same thin interface as <code>BifurcationResult</code> (exposing <code>.p</code>, <code>.y</code>, <code>.param_name</code>, <code>.meta</code>, and <code>.mode</code>). You can pass the extractor directly to <code>bifurcation_diagram()</code> or call helper methods such as <code>.all()</code>, <code>.tail()</code>, <code>.extrema()</code>, or <code>.final()</code> to get a concrete <code>BifurcationResult</code>.</p> <pre><code>from dynlib.analysis.sweep import traj_sweep\n\nsweep_result = traj_sweep(sim, param=\"r\", values=r_values, record_vars=[\"x\"], ...)\nresult = sweep_result.bifurcation(\"x\")             # extractor defaults to the \"all\" mode\n# result = result.tail(50)                          # optional: focus on the last 50 points\n\nbifurcation_diagram(result)  # xlabel=\"r\", ylabel=\"x\", title based on mode\n</code></pre> <p><code>bifurcation_diagram()</code> automatically pulls: - Parameter values from <code>result.p</code> - State values from <code>result.y</code> - Axis labels from <code>result.param_name</code> and <code>result.meta[\"var\"]</code> (when metadata is available) - Title from <code>result.mode</code> (e.g., <code>\"all\"</code>, <code>\"tail\"</code>, <code>\"extrema\"</code>)</p>"},{"location":"guides/plotting/bifurcation-diagrams/#raw-arrays","title":"Raw Arrays","text":"<p>For custom data or external bifurcation calculations:</p> <pre><code>import numpy as np\n\n# Raw parameter and state value arrays\nr_values = np.array([...])  # parameter values\nx_values = np.array([...])  # corresponding state values\n\nbifurcation_diagram(\n    (r_values, x_values),\n    xlabel=\"r\",\n    ylabel=\"x*\",\n    title=\"Custom Bifurcation Data\"\n)\n</code></pre>"},{"location":"guides/plotting/bifurcation-diagrams/#plot-customization","title":"Plot Customization","text":""},{"location":"guides/plotting/bifurcation-diagrams/#styling-options","title":"Styling Options","text":"<p>Bifurcation diagrams use scatter-style plotting with optimized defaults:</p> <pre><code>bifurcation_diagram(\n    result,\n    color=\"blue\",           # Marker color\n    marker=\",\",             # Pixel marker (default)\n    ms=0.5,                 # Marker size (ignored for pixel markers)\n    alpha=0.5,              # Transparency (default)\n    label=\"Logistic Map\"    # Legend label\n)\n</code></pre> <p>Override the defaults for different visual styles:</p> <pre><code># Larger, more visible markers\nbifurcation_diagram(\n    result,\n    marker=\".\",\n    ms=1.0,\n    alpha=1.0,\n    color=\"darkred\"\n)\n</code></pre>"},{"location":"guides/plotting/bifurcation-diagrams/#axis-control","title":"Axis Control","text":"<p>Set axis limits and labels:</p> <pre><code>bifurcation_diagram(\n    result,\n    xlim=(2.5, 4.0),       # Parameter range\n    ylim=(0, 1),            # State range\n    xlabel=\"r\",             # Parameter axis label\n    ylabel=\"x*\",            # State axis label\n    title=\"Logistic Map Bifurcations\"\n)\n</code></pre>"},{"location":"guides/plotting/bifurcation-diagrams/#font-sizes-and-layout","title":"Font Sizes and Layout","text":"<p>Customize text appearance:</p> <pre><code>bifurcation_diagram(\n    result,\n    xlabel_fs=12,           # X-axis label font size\n    ylabel_fs=12,           # Y-axis label font size\n    title_fs=14,            # Title font size\n    xtick_fs=10,            # X-axis tick font size\n    ytick_fs=10             # Y-axis tick font size\n)\n</code></pre>"},{"location":"guides/plotting/bifurcation-diagrams/#annotations-and-highlights","title":"Annotations and Highlights","text":""},{"location":"guides/plotting/bifurcation-diagrams/#vertical-lines","title":"Vertical Lines","text":"<p>Add vertical lines to mark important parameter values:</p> <pre><code>bifurcation_diagram(\n    result,\n    vlines=[\n        3.0,                                    # Simple line at r=3\n        (3.449, \"Period-4 bifurcation\"),        # Line with label\n        (3.5699, \"Feigenbaum point\")             # Another labeled line\n    ],\n    vlines_color=\"red\",\n    vlines_kwargs={\n        \"linestyle\": \"--\",\n        \"alpha\": 0.7,\n        \"linewidth\": 1\n    }\n)\n</code></pre>"},{"location":"guides/plotting/bifurcation-diagrams/#advanced-styling","title":"Advanced Styling","text":"<p>Control vertical line appearance:</p> <pre><code>bifurcation_diagram(\n    result,\n    vlines=[(3.0, \"r=3\"), (3.57, \"Chaos onset\")],\n    vlines_kwargs={\n        \"linestyle\": \":\",\n        \"alpha\": 0.5,\n        \"label_rotation\": 90,      # Rotate labels\n        \"label_position\": \"top\"    # Position labels above/below\n    }\n)\n</code></pre>"},{"location":"guides/plotting/bifurcation-diagrams/#complete-example","title":"Complete Example","text":"<p>Here's a comprehensive example showing multiple customization options:</p> <pre><code>from dynlib.plot import bifurcation_diagram, theme, fig, export\n\n# Configure theme\ntheme.use(\"notebook\")\ntheme.update(grid=True)\n\n# Create figure\nax = fig.single(size=(12, 8))\n\n# Plot with full customization\nbifurcation_diagram(\n    result,\n    color=\"black\",\n    alpha=0.8,\n    xlim=(2.5, 4.0),\n    ylim=(0, 1),\n    xlabel=\"r\",\n    ylabel=\"x*\",\n    title=\"Logistic Map: Period-Doubling Cascade\",\n    xlabel_fs=14,\n    ylabel_fs=14,\n    title_fs=16,\n    vlines=[\n        (3.0, \"Period-2\"),\n        (3.449, \"Period-4\"),\n        (3.5699, \"Feigenbaum point\")\n    ],\n    vlines_kwargs={\n        \"color\": \"red\",\n        \"linestyle\": \"--\",\n        \"alpha\": 0.6,\n        \"linewidth\": 1.5\n    },\n    ax=ax\n)\n\nexport.show()\n</code></pre>"},{"location":"guides/plotting/bifurcation-diagrams/#tips-for-effective-bifurcation-plots","title":"Tips for Effective Bifurcation Plots","text":"<ol> <li>Resolution: Use high-resolution parameter sweeps (10,000+ points) for smooth diagrams</li> <li>Transients: Ensure sufficient transient time to reach attractors</li> <li>Markers: Pixel markers (<code>,</code>) work well for dense data; use larger markers for sparse data</li> <li>Alpha: Lower alpha values help visualize point density in dense regions</li> <li>Annotations: Use vertical lines to highlight bifurcation points and transitions</li> <li>Zooming: For complex cascades, consider plotting zoomed regions separately</li> </ol> <p>The <code>bifurcation_diagram()</code> function integrates seamlessly with dynlib's analysis workflow, automatically handling the conversion from trajectory sweeps to visual bifurcation diagrams. /home/ismail/remote/PYTHON/my-packages/dynlib/docs/guides/plotting/bifurcation-diagrams.md"},{"location":"guides/plotting/cobweb/","title":"Cobweb Plots","text":"<p>Cobweb plots are a powerful visualization tool for analyzing the behavior of one-dimensional discrete dynamical systems (maps). They provide an intuitive way to understand how iterations of a function evolve over time and help identify important dynamical features like fixed points, periodic orbits, and chaotic behavior.</p>"},{"location":"guides/plotting/cobweb/#how-cobweb-plots-work","title":"How Cobweb Plots Work","text":"<p>A cobweb plot visualizes the iterative process of applying a function repeatedly. For a function \\(f(x)\\), starting from an initial value \\(x_0\\), the iteration generates a sequence:</p> \\[x_{n+1} = f(x_n)\\] <p>The cobweb plot represents this iteration geometrically by:</p> <ol> <li>Function curve: Plotting \\(y = f(x)\\)</li> <li>Identity line: Plotting \\(y = x\\) (shown as a dashed line)</li> <li>Iteration path: Drawing a \"staircase\" that shows how each iteration moves from \\((x_n, x_n)\\) to \\((x_n, x_{n+1})\\) to \\((x_{n+1}, x_{n+1})\\)</li> </ol> <p>The staircase is constructed by: - Drawing a vertical line from \\((x_n, x_n)\\) to \\((x_n, f(x_n))\\) - Drawing a horizontal line from \\((x_n, f(x_n))\\) to \\((f(x_n), f(x_n))\\)</p> <p>This creates a path that zigzags between the function curve and the identity line, visually representing the iterative process.</p>"},{"location":"guides/plotting/cobweb/#basic-usage","title":"Basic Usage","text":"<pre><code>from dynlib.plot import cobweb\n\n# Using a simple function\ndef logistic(x, r=4.0):\n    return r * x * (1 - x)\n\ncobweb(\n    f=logistic,\n    x0=0.1,      # initial condition\n    steps=50,     # number of iterations\n    xlim=(0, 1),  # x-axis limits\n)\n</code></pre>"},{"location":"guides/plotting/cobweb/#working-with-dynlib-models","title":"Working with Dynlib Models","text":"<p>Cobweb plots work seamlessly with dynlib models:</p> <p><pre><code>from dynlib import setup\nfrom dynlib.plot import cobweb\n\nmodel = \"\"\"\ninline:\n[model]\ntype=\"map\"\nname=\"Logistic Map\"\n\n[states]\nx=0.1\n\n[params]\nr=4.0\n\n[equations.rhs]\nx = \"r * x * (1 - x)\"\n\"\"\"\n\nsim = setup(model, stepper=\"map\")\ncobweb(\n    f=sim.model,  # Pass the model directly\n    x0=0.1,\n    xlim=(0, 1),\n    steps=50,\n)\n</code></pre> When passing DSL inline to <code>setup()</code> (or <code>build()</code>), start the string with <code>inline:</code> so dynlib treats it as an embedded model definition instead of a path.</p>"},{"location":"guides/plotting/cobweb/#key-parameters","title":"Key Parameters","text":""},{"location":"guides/plotting/cobweb/#function-specification","title":"Function Specification","text":"<ul> <li><code>f</code>: The function or model to iterate. Can be:</li> <li>A callable function <code>f(x)</code> or <code>f(x, r)</code></li> <li>A dynlib Model object with a <code>map()</code> method</li> <li>A Sim object (will use <code>sim.model</code>)</li> </ul>"},{"location":"guides/plotting/cobweb/#iteration-control","title":"Iteration Control","text":"<ul> <li><code>x0</code>: Initial value for the iteration</li> <li><code>steps</code>: Number of iteration steps to plot (default: 50)</li> <li><code>t0</code>: Starting time index (default: 0.0)</li> <li><code>dt</code>: Time step size (default: 1.0)</li> </ul>"},{"location":"guides/plotting/cobweb/#model-specific-options","title":"Model-Specific Options","text":"<ul> <li><code>state</code>: For multi-dimensional models, specify which state variable to use (by name or index)</li> <li><code>fixed</code>: Dictionary of fixed parameter/state values</li> <li><code>r</code>: Override for the 'r' parameter (common in bifurcation analysis)</li> </ul>"},{"location":"guides/plotting/cobweb/#plot-styling","title":"Plot Styling","text":"<ul> <li><code>xlim</code>/<code>ylim</code>: Axis limits (auto-calculated if not specified)</li> <li><code>color</code>: Color for the function curve</li> <li><code>identity_color</code>: Color for the identity line (y=x)</li> <li><code>stair_color</code>: Color for the iteration staircase</li> <li><code>lw</code>: Line width for the function curve</li> <li><code>stair_lw</code>: Line width for the staircase</li> <li><code>alpha</code>: Transparency</li> </ul>"},{"location":"guides/plotting/cobweb/#labels-and-appearance","title":"Labels and Appearance","text":"<ul> <li><code>xlabel</code>/<code>ylabel</code>: Axis labels</li> <li><code>title</code>: Plot title</li> <li><code>legend</code>: Whether to show legend (default: True)</li> </ul>"},{"location":"guides/plotting/cobweb/#interpreting-cobweb-plots","title":"Interpreting Cobweb Plots","text":""},{"location":"guides/plotting/cobweb/#fixed-points","title":"Fixed Points","text":"<p>Fixed points occur where \\(x = f(x)\\). In the cobweb plot, these appear as intersection points between the function curve and the identity line.</p>"},{"location":"guides/plotting/cobweb/#stability","title":"Stability","text":"<ul> <li>Stable fixed points: The staircase spirals inward toward the fixed point</li> <li>Unstable fixed points: The staircase spirals outward away from the fixed point</li> </ul>"},{"location":"guides/plotting/cobweb/#periodic-orbits","title":"Periodic Orbits","text":"<p>Periodic behavior appears as closed loops in the cobweb plot. A period-2 orbit, for example, creates a rectangular path that the staircase follows repeatedly.</p>"},{"location":"guides/plotting/cobweb/#chaos","title":"Chaos","text":"<p>Chaotic behavior is indicated by the staircase never settling into a regular pattern, often filling regions of the plot densely.</p>"},{"location":"guides/plotting/cobweb/#advanced-examples","title":"Advanced Examples","text":""},{"location":"guides/plotting/cobweb/#multi-parameter-analysis","title":"Multi-Parameter Analysis","text":"<pre><code># Analyze different r values\nr_values = [2.5, 3.2, 3.5, 4.0]\n\nfor r in r_values:\n    cobweb(\n        f=logistic,\n        x0=0.1,\n        r=r,  # Override r parameter\n        xlim=(0, 1),\n        title=f\"Logistic Map (r={r})\",\n    )\n</code></pre>"},{"location":"guides/plotting/cobweb/#multi-state-models-iterate-a-single-variable","title":"Multi-State Models (iterate a single variable)","text":"<p>Cobweb plots still visualize a single state trajectory even when the underlying map has many states. Set <code>state</code> to the variable you want to follow and keep the rest constant via <code>fixed</code>. This effectively reduces the system to a 1D map for the chosen state while the other states stay pinned at the provided values.</p> <pre><code>from dynlib import setup\n\nmulti_state_model = \"\"\"\ninline:\n[model]\ntype = \"map\"\nname = \"Two-State Map\"\n\n[states]\nx = 0.5\ny = 1.0\n\n[params]\na = 3.0\n\n[equations.rhs]\nx = \"a * x * (1 - x) + 0.1 * y\"\ny = \"0.9 * y\"\n\"\"\"\n\nsim = setup(multi_state_model, stepper=\"map\")\ncobweb(\n    f=sim.model,\n    x0=sim.state[\"x\"],\n    state=\"x\",\n    fixed={\"y\": 1.0},\n    steps=100,\n)\n</code></pre> <p>Because the plot still shows just the selected <code>state</code>, cobweb plots remain limited to one-dimensional maps; multi-state systems are visualized by slicing out one coordinate at a time.</p>"},{"location":"guides/plotting/cobweb/#custom-styling","title":"Custom Styling","text":"<pre><code>cobweb(\n    f=sim.model,\n    x0=0.1,\n    xlim=(0, 1),\n    color=\"blue\",\n    identity_color=\"red\",\n    stair_color=\"green\",\n    stair_lw=1.5,\n    alpha=0.8,\n    title=\"Custom Styled Cobweb Plot\",\n)\n</code></pre>"},{"location":"guides/plotting/cobweb/#limitations","title":"Limitations","text":"<ul> <li>Cobweb plots are designed for 1D maps only; multi-state models must be reduced to a single iterated state using <code>state</code>/<code>fixed</code>.</li> <li>Models using <code>lag()</code> functions are not supported (cannot evaluate safely)</li> <li>Requires discrete map models (<code>spec.kind == 'map'</code>)</li> </ul>"},{"location":"guides/plotting/cobweb/#related-functions","title":"Related Functions","text":"<ul> <li><code>plot.return_map()</code>: Plot return maps (\\(x_n\\) vs \\(x_{n+1}\\))</li> <li><code>plot.series()</code>: Plot time series of the iteration</li> <li><code>plot.phase()</code>: Phase space plots for higher-dimensional systems</li> </ul>"},{"location":"guides/plotting/decorations/","title":"Plot Decorations","text":"<p>Dynlib plotting helpers expose a single set of decoration arguments that every high-level renderer forwards through <code>_apply_decor()</code> in <code>src/dynlib/plot/_primitives.py</code>. The helper accepts the same parameters from <code>series.plot()</code>, <code>series.step()</code> and similar entry points, so decorations behave identically everywhere.</p>"},{"location":"guides/plotting/decorations/#vertical-lines-vlines","title":"Vertical lines (<code>vlines</code>)","text":"<ul> <li>Pass either a list of scalar values or <code>(x, label)</code> tuples to <code>vlines</code>. Tuples are rendered with labels next to the corresponding line without needing a separate <code>text()</code> call.</li> <li>You can supply <code>vlines_kwargs</code> (or the convenience <code>vlines_color</code>/<code>vlines_kwargs</code> pairing found on most helpers) to adjust appearance. Default kwargs are <code>color='black'</code>, <code>linestyle='--'</code>, <code>linewidth=1</code>, <code>alpha=0.7</code>.</li> <li>Label positioning is controlled by four special kwargs that <code>_apply_decor()</code> intercepts before forwarding the rest to <code>ax.axvline()</code>:</li> <li><code>label_position</code>: one of <code>'top'</code>, <code>'bottom'</code>, <code>'center'</code>. Determines whether the text anchors near the top/bottom/center of the axis before applying offsets.</li> <li><code>placement_pad</code>: adds additional offset along the axis (fraction of axis height if <code>&lt;1</code>, data units otherwise) when computing the text anchor point.</li> <li><code>label_pad</code>: moves the label perpendicular to the line (i.e., horizontally), again interpreting values <code>&lt;1</code> as axis fractions and <code>&gt;=1</code> as data units.</li> <li><code>label_rotation</code>/<code>label_color</code>: override the rotation (default 90\u00b0) and text color (defaults to the line color).</li> </ul> <p>Example: <pre><code>series.plot(\n    x=t,\n    y=x_traj,\n    vlines=[(3.0, \"period-2\"), 3.57],\n    vlines_kwargs={\n        \"label_position\": \"bottom\",\n        \"placement_pad\": 0.08,\n        \"label_pad\": 0.05,\n        \"label_rotation\": 90,\n        \"linestyle\": \":\",\n        \"color\": \"firebrick\",\n    },\n)\n</code></pre></p>"},{"location":"guides/plotting/decorations/#horizontal-lines-hlines","title":"Horizontal lines (<code>hlines</code>)","text":"<ul> <li>Works the same way as <code>vlines</code>, but for y coordinates. Labels can be provided via <code>(y, label)</code> tuples.</li> <li><code>hlines_color</code> exists for the common case of only changing the color; it merges into <code>hlines_kwargs</code> before <code>_apply_decor()</code> runs.</li> <li>Special kwargs are similar but mirror the horizontal geometry:</li> <li><code>label_position</code>: <code>'left'</code>, <code>'right'</code>, or <code>'center'</code> to choose which side of the axis the label hugs.</li> <li><code>placement_pad</code>: shifts the anchor point along the x axis (<code>&lt;1</code> = axis fraction, <code>&gt;=1</code> = data units).</li> <li><code>label_pad</code>: offsets the label perpendicular to the line (moves it vertically) with the same axis-vs-data-unit interpretation.</li> <li><code>label_rotation</code> defaults to <code>0</code> degrees for horizontal text, and <code>label_color</code> again defaults to the line color.</li> </ul> <p>Example: <pre><code>series.plot(\n    x=t,\n    y=x_traj,\n    hlines=[(0.25, \"low\"), (0.75, \"high\")],\n    hlines_kwargs={\n        \"label_position\": \"left\",\n        \"placement_pad\": 0.1,\n        \"label_pad\": 0.02,\n        \"label_color\": \"navy\",\n        \"linestyle\": \"-\",\n        \"alpha\": 0.6,\n    },\n)\n</code></pre></p>"},{"location":"guides/plotting/decorations/#vertical-bands-vbands","title":"Vertical bands (<code>vbands</code>)","text":"<ul> <li>Pass a list of <code>(start, end)</code> tuples (optionally with a third entry for color) to shade vertical regions: <code>(start, end)</code> uses the default color <code>C0</code>, <code>(start, end, \"teal\")</code> overrides it.</li> <li><code>_apply_decor()</code> enforces <code>start &lt; end</code> and renders using <code>ax.axvspan(start, end, color=color, alpha=0.1)</code>.</li> </ul> <p>Example: <pre><code>series.plot(\n    x=t,\n    y=x_traj,\n    vbands=[(2.5, 2.9, \"gold\"), (3.4, 3.6)],\n)\n</code></pre></p>"},{"location":"guides/plotting/decorations/#horizontal-bands-hbands","title":"Horizontal bands (<code>hbands</code>)","text":"<ul> <li>Behaves like <code>vbands</code> but uses <code>ax.axhspan()</code> to fill horizontal strips. Tuples may include an optional color.</li> <li>The helper also checks <code>start &lt; end</code> before plotting and defaults to <code>color='C0'</code> with <code>alpha=0.1</code>.</li> </ul> <p>Example: <pre><code>series.plot(\n    x=t,\n    y=x_traj,\n    hbands=[(0, 0.2), (0.8, 1.0, \"lightcoral\")],\n)\n</code></pre></p>"},{"location":"guides/plotting/decorations/#summary-of-special-kwargs-all-decorating-helpers","title":"Summary of special kwargs (all decorating helpers)","text":"<ul> <li><code>vlines_kwargs</code> / <code>hlines_kwargs</code> accept the usual Matplotlib line arguments plus these label-placement helpers: <code>label_position</code>, <code>placement_pad</code>, <code>label_pad</code>, <code>label_rotation</code>, <code>label_color</code>.</li> <li><code>placement_pad</code> and <code>label_pad</code> treat values <code>&lt;1</code> as fractions of the relevant axis span and <code>&gt;=1</code> as data units, so you can switch between relative and absolute offsets.</li> <li>Tuple-based line definitions (value + label) trigger automatic text rendering; you can still supply <code>label_color</code> and <code>label_rotation</code> to customize each label globally.</li> <li>Bands (<code>vbands</code>, <code>hbands</code>) only accept <code>(start, end)</code> or <code>(start, end, color)</code> and raise <code>ValueError</code> when the tuple length is incorrect or when <code>start &gt;= end</code>.</li> </ul> <p>If you need other axes annotations (e.g., manual <code>text()</code> calls or extra artists), you can mix them with these decorations; <code>_apply_decor()</code> only runs once per axes and leaves any other artists untouched.</p>"},{"location":"guides/plotting/export/","title":"Exporting plots","text":"<p>The <code>dynlib.plot.export</code> helper wraps the Matplotlib <code>savefig</code>/<code>show</code> workflow so your scripts keep the same consistent defaults regardless of whether you draw a single panel, grid layout, or higher-level container.</p>"},{"location":"guides/plotting/export/#core-functions","title":"Core functions","text":""},{"location":"guides/plotting/export/#exportsavefigfig_or_ax-path-fmtspng-dpi300-transparentfalse-pad001-metadatanone-bbox_inchestight","title":"<code>export.savefig(fig_or_ax, path, *, fmts=(\"png\",), dpi=300, transparent=False, pad=0.01, metadata=None, bbox_inches=\"tight\")</code>","text":"<ul> <li><code>fig_or_ax</code> accepts a figure, axes, or any dynlib layout object (<code>fig.grid</code>, <code>AxesGrid</code>, etc.). The helper finds the underlying figure automatically so you can call it right after plotting without grabbing <code>fig.figure</code>.</li> <li><code>path</code> can either include an extension (e.g., <code>\"plots/phase.png\"</code>) or omit it (e.g., <code>\"plots/phase\"</code>). When you pass an extension, the helper writes only that format; omit the extension and specify <code>fmts</code> to save multiple formats in one go.</li> <li><code>fmts</code> defaults to <code>(\"png\",)</code> unless you inferred formats from the path. The helper normalizes, deduplicates, and lowercases the values you provide so you can pass <code>(\".PNG\", \".pdf\")</code> without extra parsing.</li> <li>The remaining keyword arguments mirror Matplotlib's <code>savefig</code>. Use <code>dpi</code> for resolution, <code>transparent</code> for alpha backgrounds, <code>pad</code> to add whitespace, and <code>metadata</code> to embed search-friendly tags. When you rely on dynlib's <code>fig</code> helpers with <code>constrained_layout=True</code>, the helper automatically avoids applying a tight bounding box that could clip decorations.</li> </ul>"},{"location":"guides/plotting/export/#exportshow","title":"<code>export.show()</code>","text":"<p>Call <code>export.show()</code> at the end of a script, notebook cell, or in any interactive session to trigger Matplotlib's <code>plt.show()</code>. It follows dynlib's styling, so figure numbering and layouts behave the same way whether you use the CLI or import the helpers in a script.</p>"},{"location":"guides/plotting/export/#best-practices","title":"Best practices","text":"<ul> <li>Keep <code>export</code> imports next to your plotting helpers: <code>from dynlib.plot import fig, series, export</code>. That way you can consistently call <code>export.show()</code> after every figure set.</li> <li>When saving multiple formats, leave the extension off <code>path</code> and rely on <code>fmts</code>. For example, <code>export.savefig(ax, \"figures/lorenz\", fmts=(\"svg\",\"png\"))</code> writes <code>lorenz.svg</code> and <code>lorenz.png</code> with the same dpi/pad settings.</li> <li>Pass dynlib containers like <code>axes = fig.grid(...)</code> or the return value of helpers such as <code>plot.vectorfield()</code> directly to <code>savefig</code>; <code>export</code> traverses the container to locate the figure automatically.</li> <li>Use <code>metadata</code> (a dict of string keys/values) for searchable keywords or author info when generating publication-ready images.</li> </ul> <p>For a worked example and more formatting notes, return to the Plotting basics guide or explore the rest of the plotting docs.</p>"},{"location":"guides/plotting/manifold-plot/","title":"Manifold Plots","text":"<p><code>plot.manifold()</code> renders 1D manifold traces (stable/unstable branches, heteroclinic connections, homoclinic loops) as 2D projections with consistent styling and legend handling. It is the plotting companion to the manifold analysis utilities, so you can focus on extracting the manifolds elsewhere and rely on this helper to visualize whatever segments those analyses produce.</p>"},{"location":"guides/plotting/manifold-plot/#what-the-helper-draws","title":"What the helper draws","text":"<p><code>plot.manifold()</code> expects sequences of <code>(state_x, state_y)</code> samples that follow a manifold branch. It accepts raw segments or higher-level results and projects the selected state components onto <code>x</code>/<code>y</code> axes. Each supplied branch appears as either a <code>LineCollection</code> (for plain lines) or individual <code>plot</code> calls (when markers are requested), and any branch with a non-<code>None</code> label automatically enters the legend.</p>"},{"location":"guides/plotting/manifold-plot/#feeding-the-helper","title":"Feeding the helper","text":"<ul> <li>Segments: Pass <code>segments=[arr1, arr2, \u2026]</code> where each <code>arr</code> is a <code>(steps, states)</code> array. The helper enforces that each array has at least two rows and enough columns to cover the requested <code>components</code>.</li> <li>Branches: Supply a <code>branches</code> tuple like <code>(branch_pos, branch_neg)</code> when you manage positive/negative branches yourself. Each branch list can contain multiple segments.</li> <li>Result objects: Most manifold-analysis results expose a <code>branches</code> attribute compatible with <code>plot.manifold()</code>, so you can pass them directly:</li> <li><code>dynlib.analysis.trace_manifold_1d_map(...)</code> / <code>trace_manifold_1d_ode(...)</code> return <code>ManifoldTraceResult</code> with two branch lists (positive/negative).</li> <li><code>dynlib.analysis.heteroclinic_tracer(...)</code> and <code>dynlib.analysis.homoclinic_tracer(...)</code> return <code>HeteroclinicTraceResult</code> and <code>HomoclinicTraceResult</code> respectively; both expose <code>.branches</code> (the latter branches contain the single traced orbit) plus <code>.kind</code>/<code>.meta</code> so <code>plot.manifold()</code> labels them automatically.</li> <li>If you wrap your own segments in a custom structure, make sure it provides a <code>branches</code> attribute that resolves to a two-tuple of sequences before passing it as <code>result=\u2026</code>.</li> </ul> <pre><code>from dynlib import setup\nfrom dynlib.analysis import trace_manifold_1d_map, heteroclinic_tracer\nfrom dynlib.plot import fig, manifold\n\nsim = setup(\"models/henon.map\", stepper=\"map\")\nunstable = trace_manifold_1d_map(sim, kind=\"unstable\", branch_len=500)\nhex_trace = heteroclinic_tracer(sim, source_eq=\"E0\", target_eq=\"E1\", preset=\"default\")\n\nax = fig.single()\nmanifold(result=unstable, components=(0, 1), label=\"Unstable manifold\", ax=ax)\nmanifold(result=hex_trace, components=(0, 1), style=\"discrete\", label=\"Heteroclinic orbit\", ax=ax)\n</code></pre>"},{"location":"guides/plotting/manifold-plot/#styling-branches","title":"Styling branches","text":"<p><code>style</code>, <code>color</code>, <code>lw</code>, <code>ls</code>, <code>marker</code>, <code>ms</code>, and <code>alpha</code> behave like any other <code>plot</code> helper, but <code>style</code> also accepts the built-in presets:</p> <ul> <li><code>\"continuous\"</code>, <code>\"flow\"</code> / <code>\"cont\"</code>: solid line without markers (ideal for ODE-generated branches).</li> <li><code>\"discrete\"</code>, <code>\"map\"</code>: marker-only (good for discrete-time manifolds).</li> <li><code>\"mixed\"</code> / <code>\"connected\"</code>: markers connected by lines.</li> <li><code>\"line\"</code> / <code>\"scatter\"</code>: explicit shorthand for lines-only or markers-only.</li> </ul> <p>Per-branch overrides are handled with <code>groups</code>. Each group is either a mapping (<code>{\"segments\": \u2026, \"label\": \u2026, \"style\": \u2026}</code>) or a tuple <code>(segments, label?, style?)</code> (? means optional; can be <code>None</code>). The helper inherits the global <code>style</code> but mixes in preset overrides or explicit mappings for each group, letting you color the stable branch differently from the unstable branch or the heteroclinic trace.</p>"},{"location":"guides/plotting/manifold-plot/#choosing-projections-and-axes","title":"Choosing projections and axes","text":"<p>Use <code>components=(i, j)</code> to select which state indices (<code>int</code>s) to draw (e.g., <code>(0, 1)</code> for the first two states). Components must be distinct and within the dimensionality of the supplied segments.</p> <p>Axis labels, limits, and aspect ratios are controlled by:</p> <ul> <li><code>xlabel</code>, <code>ylabel</code>, <code>title</code>, <code>xlabel_fs</code>, <code>ylabel_fs</code>, <code>title_fs</code></li> <li><code>xlim</code>, <code>ylim</code>, <code>aspect</code>, <code>xlabel_rot</code>, <code>ylabel_rot</code></li> <li><code>xpad</code>, <code>ypad</code>, <code>titlepad</code> for extra spacing</li> </ul> <p>If your result provides metadata (e.g., <code>result.meta</code> from a <code>ManifoldTraceResult</code>), you can reuse it to annotate the plot title/labels before calling <code>manifold()</code>.</p> <p><code>plot.manifold()</code> returns the <code>Axes</code>, so you can layer decorations (vertical/horizontal lines, bands) as described in Plot Decorations or integrate the manifold into multi-panel figures created by <code>fig.grid()</code>/<code>plot.fig()</code>.</p>"},{"location":"guides/plotting/manifold-plot/#legend-and-grouping-tips","title":"Legend and grouping tips","text":"<ul> <li>Set <code>label=</code> on the helper or via <code>groups</code> to tag each branch. The legend only appears if at least one label is set and <code>legend=True</code> (default).</li> <li>Use <code>groups</code> to overlay branch fragments with different styles or colors (for example, highlight the first segment of a heteroclinic trace with a thicker line while keeping the remainder subtle).</li> <li>When plotting multiple manifolds together (e.g., stable vs. unstable), pass <code>legend=True</code> only once in the final call to avoid duplicate handles.</li> </ul>"},{"location":"guides/plotting/manifold-plot/#tips","title":"Tips","text":"<ul> <li>Slice large result arrays before plotting if you only want a windowed view; the helper respects the provided segments exactly.</li> <li>Combine <code>plot.manifold()</code> with other plot helpers (phase portraits, time series) by passing the same <code>ax=</code> and controlling <code>legend</code>.</li> <li>Because <code>linecollection</code> is used when no markers are requested, <code>alpha</code>/<code>linewidth</code> apply uniformly to entire segments.</li> <li>If you want to reuse the same style across calls, keep a dictionary and update it for each group (<code>style={\"color\": \"C0\"}</code>) rather than repeating the preset string.</li> </ul> <p><code>plot.manifold()</code> mirrors the appearance and workflow of the analysis utilities, so once you have a <code>ManifoldTraceResult</code>, <code>HeteroclinicTraceResult</code>, or <code>HomoclinicTraceResult</code>, you can document and style the manifold without additional data massaging.</p>"},{"location":"guides/plotting/themes-and-facets/","title":"Themes &amp; Facets","text":"<p>Dynlib's plotting system provides powerful theming and faceting capabilities to create consistent, publication-ready figures. This guide covers how to use <code>plot.theme</code> for styling and <code>plot.fig</code>/<code>plot.facet</code> for multi-panel layouts.</p>"},{"location":"guides/plotting/themes-and-facets/#theming-overview","title":"Theming Overview","text":"<p>Themes in dynlib control the visual appearance of all plots, ensuring consistency across figures. The theme system manages:</p> <ul> <li>Font sizes and families</li> <li>Line widths and marker styles</li> <li>Color palettes</li> <li>Grid and background settings</li> <li>Spacing and margins</li> </ul> <p>Themes are applied globally and affect all subsequent plots until changed.</p>"},{"location":"guides/plotting/themes-and-facets/#built-in-presets","title":"Built-in Presets","text":"<p>Dynlib includes several predefined themes optimized for different use cases:</p> <ul> <li>notebook: Default theme for interactive Jupyter notebooks with balanced styling.</li> <li>paper: Clean theme for publications, with subtle grids disabled and optimized font sizes.</li> <li>talk: High-contrast theme for presentations, with larger elements and bolder lines.</li> <li>dark: Dark background theme with adjusted colors for better visibility.</li> <li>mono: Monochrome theme using grayscale colors.</li> </ul>"},{"location":"guides/plotting/themes-and-facets/#using-themes","title":"Using Themes","text":"<p>Set a theme at the beginning of your plotting script:</p> <pre><code>from dynlib.plot import theme\n\n# Use a preset\ntheme.use(\"paper\")\n\n# Or customize on top of a preset\ntheme.use(\"notebook\", tokens={\"scale\": 1.2, \"grid\": False})\n</code></pre>"},{"location":"guides/plotting/themes-and-facets/#customizing-themes","title":"Customizing Themes","text":"<p>You can modify theme settings without changing presets:</p> <pre><code># Temporarily adjust settings\ntheme.update(tokens={\"fontsize_title\": 16, \"line_w\": 2.0})\n\n# Or push/pop for scoped changes\ntheme.push(tokens={\"palette\": \"mono\"})\n# ... create plots ...\ntheme.pop()  # Reverts to previous theme\n</code></pre>"},{"location":"guides/plotting/themes-and-facets/#color-palettes","title":"Color Palettes","text":"<p>Dynlib supports multiple color palettes:</p> <ul> <li>classic: Standard Matplotlib colors</li> <li>cbf: Colorblind-friendly palette (recommended for accessibility)</li> <li>mono: Grayscale palette</li> </ul> <p>Register custom palettes:</p> <pre><code>theme.register_palette(\"my_colors\", [\"#ff0000\", \"#00ff00\", \"#0000ff\"])\ntheme.use(\"notebook\", tokens={\"palette\": \"my_colors\"})\n</code></pre>"},{"location":"guides/plotting/themes-and-facets/#theme-tokens","title":"Theme Tokens","text":"<p>Themes are controlled by tokens that specify individual styling properties. Key tokens include:</p> <ul> <li>scale: Overall size multiplier</li> <li>fontsize_*: Font sizes for different elements (base, label, title, etc.)</li> <li>line_w: Line width</li> <li>marker_size: Marker size</li> <li>grid: Whether to show grid lines</li> <li>palette: Color palette name</li> <li>background: \"light\" or \"dark\"</li> </ul> <p>Access current token values:</p> <pre><code>current_scale = theme.get(\"scale\")\nfont_size = theme.get(\"fontsize_title\")\n</code></pre>"},{"location":"guides/plotting/themes-and-facets/#figure-grids-and-layouts","title":"Figure Grids and Layouts","text":"<p>Dynlib provides high-level helpers for creating figure layouts that work seamlessly with themes.</p>"},{"location":"guides/plotting/themes-and-facets/#basic-figure-creation","title":"Basic Figure Creation","text":"<pre><code>from dynlib.plot import fig\n\n# Single plot\nax = fig.single(title=\"My Plot\")\n\n# Grid of subplots\naxes = fig.grid(rows=2, cols=3, title=\"Parameter Sweep\")\n\n# 3D plot\nax_3d = fig.single3D(title=\"3D Trajectory\")\n\n# Flexible grid that wraps subplots\naxes = fig.wrap(n=7, cols=3)  # Creates 3x3 grid, hides last 2 axes\n</code></pre> <p>All <code>fig</code> helpers accept parameters for customization:</p> <ul> <li><code>size</code>: Figure size as (width, height) tuple</li> <li><code>scale</code>: Size multiplier</li> <li><code>sharex</code>/<code>sharey</code>: Whether to share axes</li> <li><code>title</code>: Figure title</li> </ul>"},{"location":"guides/plotting/themes-and-facets/#integration-with-plotting","title":"Integration with Plotting","text":"<p>Pass created axes to plotting functions:</p> <pre><code>from dynlib.plot import fig, series\n\nax = fig.single()\nseries.plot(x=time, y=signal, ax=ax, label=\"Signal\")\n</code></pre>"},{"location":"guides/plotting/themes-and-facets/#faceting-for-multi-panel-figures","title":"Faceting for Multi-Panel Figures","text":"<p>Faceting automatically creates grids and iterates over data categories, perfect for parameter sweeps or grouped data.</p>"},{"location":"guides/plotting/themes-and-facets/#basic-faceting","title":"Basic Faceting","text":"<pre><code>from dynlib.plot import facet, series\n\n# Data for different parameters\ndata = {\n    \"r=2.5\": trajectory_r25,\n    \"r=3.0\": trajectory_r30,\n    \"r=3.5\": trajectory_r35,\n}\n\n# Create faceted plot\nfor ax, param in facet.wrap(data.keys(), cols=2, title=\"Bifurcation Analysis\"):\n    traj = data[param]\n    series.plot(x=time, y=traj, ax=ax, title=param)\n</code></pre> <p>The <code>facet.wrap</code> function:</p> <ul> <li>Takes an iterable of keys (categories)</li> <li>Creates a grid with specified number of columns</li> <li>Yields (axis, key) pairs for iteration</li> <li>Automatically handles layout and hides unused axes</li> </ul>"},{"location":"guides/plotting/themes-and-facets/#faceting-parameters","title":"Faceting Parameters","text":"<ul> <li><code>cols</code>: Number of columns in the grid</li> <li><code>title</code>: Overall figure title</li> <li><code>size</code>, <code>scale</code>: Figure sizing</li> <li><code>sharex</code>/<code>sharey</code>: Axis sharing</li> </ul>"},{"location":"guides/plotting/themes-and-facets/#advanced-faceting-example","title":"Advanced Faceting Example","text":"<pre><code>import numpy as np\nfrom dynlib.plot import facet, series, theme\n\n# Parameter sweep\nr_values = np.linspace(2.8, 4.0, 12)\n\ntheme.use(\"paper\")\nfor ax, r in facet.wrap(r_values, cols=4, title=\"Logistic Map Bifurcations\"):\n    # Simulate trajectory for this r\n    x = 0.1\n    traj = [x]\n    for _ in range(100):\n        x = r * x * (1 - x)\n        traj.append(x)\n\n    series.plot(x=range(len(traj)), y=traj, ax=ax, title=f\"r={r:.1f}\")\n</code></pre>"},{"location":"guides/plotting/themes-and-facets/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Set themes early: Apply themes at the start of your script before creating any figures.</p> </li> <li> <p>Use consistent palettes: Choose colorblind-friendly palettes like \"cbf\" for better accessibility.</p> </li> <li> <p>Leverage faceting: For parameter sweeps or grouped data, faceting reduces boilerplate code.</p> </li> <li> <p>Customize thoughtfully: Use <code>theme.update()</code> for small adjustments rather than creating entirely new themes.</p> </li> <li> <p>Scope changes: Use <code>theme.push()</code>/<code>pop()</code> for temporary theme modifications.</p> </li> <li> <p>Size appropriately: Use the <code>scale</code> parameter or theme tokens to adjust figure sizes for different outputs (screen vs. print).</p> </li> </ol> <p>Themes and faceting work together to make your dynlib plots professional and consistent, whether for exploratory analysis or publication figures.</p>"},{"location":"guides/plotting/vectorfields/","title":"Vector Fields and Vector Field Animations","text":"<p>Vector fields visualize the direction and magnitude of change in dynamical systems. In dynlib, vector fields are computed by evaluating the system's right-hand side (RHS) equations on a 2D grid of points, showing how trajectories would evolve from each point.</p> <p>Most snippets in this guide assume <code>from dynlib import build, plot</code>. When we need numerical sequences for sweeps or animations, you will also see <code>numpy</code> being used\u2014import it as <code>import numpy as np</code> in those contexts.</p>"},{"location":"guides/plotting/vectorfields/#basic-vector-field-plotting","title":"Basic Vector Field Plotting","text":"<p>The core function for plotting vector fields is <code>plot.vectorfield()</code>. It evaluates your model's equations on a grid and displays the resulting vectors.</p>"},{"location":"guides/plotting/vectorfields/#simple-example","title":"Simple Example","text":"<pre><code>from dynlib import build, plot\n\n# Define a simple 2D system\nmodel_uri = \"\"\"\ninline:\n[model]\ntype = \"ode\"\n\n[states]\nx = 0.0\ny = 0.0\n\n[params]\na = 1.0\nb = -1.0\n\n[equations.rhs]\nx = \"a * x + y\"\ny = \"b * x + y\"\n\"\"\"\n\n# You can also pass a Sim object created by setup()\nmodel = build(model_uri)\nplot.theme.use(\"notebook\")\n\n# Plot the vector field\nplot.vectorfield(\n    model,\n    xlim=(-2, 2),\n    ylim=(-2, 2),\n    grid=(25, 25)\n)\n\nplot.export.show()\n</code></pre> <p>When passing DSL inline to <code>build()</code> (or <code>setup()</code>), start the string with <code>inline:</code> (as shown above) so dynlib knows to treat the content as an embedded model definition instead of a path.</p>"},{"location":"guides/plotting/vectorfields/#vector-field-options","title":"Vector Field Options","text":""},{"location":"guides/plotting/vectorfields/#grid-and-limits","title":"Grid and Limits","text":"<ul> <li><code>xlim</code>, <code>ylim</code>: Tuples specifying the plot boundaries (default: <code>(-1, 1)</code>)</li> <li><code>grid</code>: Tuple of <code>(nx, ny)</code> specifying grid resolution (default: <code>(20, 20)</code>)</li> </ul> <p>Higher grid values give smoother, more detailed plots but take longer to compute.</p>"},{"location":"guides/plotting/vectorfields/#variable-selection","title":"Variable Selection","text":"<p>For systems with more than 2 variables, specify which 2 to plot:</p> <pre><code># For a 3D Lorenz system\nplot.vectorfield(\n    model,\n    vars=(\"x\", \"y\"),  # Plot x vs y\n    fixed={\"z\": 10.0},  # Fix z at 10\n    xlim=(-20, 20),\n    ylim=(-30, 30)\n)\n</code></pre>"},{"location":"guides/plotting/vectorfields/#vector-normalization","title":"Vector Normalization","text":"<ul> <li><code>normalize=True</code>: Scale all vectors to unit length, showing only direction</li> <li><code>normalize=False</code> (default): Show actual magnitudes</li> </ul> <pre><code># Compare normalized vs magnitude-preserving\nplot.vectorfield(model, normalize=True)   # Shows flow directions\nplot.vectorfield(model, normalize=False)  # Shows flow speeds\n</code></pre>"},{"location":"guides/plotting/vectorfields/#coloring-options","title":"Coloring Options","text":""},{"location":"guides/plotting/vectorfields/#single-color","title":"Single Color","text":"<pre><code>plot.vectorfield(model, color=\"blue\")\n</code></pre> <p>The <code>color</code> argument flows directly into Matplotlib, so you can use any named color, hex string, or RGBA tuple for a consistent palette.</p>"},{"location":"guides/plotting/vectorfields/#speed-based-coloring","title":"Speed-Based Coloring","text":"<p>Color vectors by their magnitude:</p> <pre><code>plot.vectorfield(\n    model,\n    speed_color=True,\n    speed_cmap=\"plasma\",\n    normalize=False  # Speed coloring works best with actual magnitudes\n)\n</code></pre> <p>Pass <code>speed_norm</code> to fix the full range manually (or let a sweep compute a shared norm with <code>share_speed_norm=True</code>) so you can compare different plots on the same scale.</p>"},{"location":"guides/plotting/vectorfields/#plot-modes","title":"Plot Modes","text":"<ul> <li><code>mode=\"quiver\"</code> (default): Arrow/quiver plot</li> <li><code>mode=\"stream\"</code>: Streamline plot using matplotlib's streamplot</li> </ul> <pre><code># Streamlines can be smoother for dense flows\nplot.vectorfield(model, mode=\"stream\", speed_color=True)\n</code></pre>"},{"location":"guides/plotting/vectorfields/#nullclines","title":"Nullclines","text":"<p>Nullclines show where the system has zero velocity in x or y directions:</p> <pre><code>plot.vectorfield(\n    model,\n    nullclines=True,\n    nullcline_style={\"colors\": [\"red\", \"blue\"], \"linewidths\": 1.5}\n)\n</code></pre> <p>Nullclines are computed on a denser grid by default for accuracy.</p> <p>Use <code>nullcline_grid</code> when you need even finer contours or resizing relative to the main grid.</p>"},{"location":"guides/plotting/vectorfields/#interactive-features","title":"Interactive Features","text":"<p><code>plot.vectorfield</code> returns a <code>VectorFieldHandle</code>, so the same call that draws the arrows also gives you a programmatic handle you can update, simulate, or clear. Pass <code>interactive=True</code> to hook into the click/tap callbacks described below, or call <code>handle.update()</code> to redraw with new params/fixed states without recreating the plot.</p> <p>Enable interactive plotting to explore trajectories:</p> <pre><code>handle = plot.vectorfield(\n    model,\n    interactive=True,\n    T=10.0,  # Trajectory duration\n    trajectory_style={\"color\": \"red\", \"linewidth\": 2}\n)\n</code></pre> <p>Interactive Controls: - Click anywhere on the plot to launch a trajectory from that point - Press N to toggle nullclines on/off - Press C to clear drawn trajectories <code>handle.clear_trajectories()</code> also removes collected paths if you want to reset programmatically.</p>"},{"location":"guides/plotting/vectorfields/#parameter-sweeps","title":"Parameter Sweeps","text":"<p>Use <code>plot.vectorfield_sweep()</code> to compare vector fields across parameter values. It returns a <code>VectorFieldSweep</code> containing <code>.handles</code>, <code>.axes</code>, and <code>.colorbar</code> so you can adjust individual facets after plotting or grab the shared <code>speed_norm</code> used for coloring. Pass <code>param</code>/<code>values</code> for a simple 1D sweep, or provide the <code>sweep</code> mapping when you need custom overrides for parameters and fixed states; the <code>target</code> argument chooses whether each sweep <code>value</code> edits params (default) or fixed states.</p> <pre><code>plot.vectorfield_sweep(\n    model,\n    param=\"a\",  # Parameter to vary\n    values=[-1.0, 0.0, 1.0, 2.0],  # Values to test\n    xlim=(-3, 3),\n    ylim=(-3, 3),\n    cols=2,  # 2 columns in the grid\n    normalize=True,\n    facet_titles=\"a = {value:.1f}\"  # Custom titles\n)\n</code></pre> <p>Shared normalization (<code>share_speed_norm=True</code>) keeps the coloring consistent across all facets, and <code>add_colorbar=True</code> draws a single legend for the speed coloring when one is available.</p>"},{"location":"guides/plotting/vectorfields/#vector-field-animations","title":"Vector Field Animations","text":"<p>Animate how vector fields change with parameters using <code>plot.vectorfield_animate()</code>:</p> <pre><code>import numpy as np\n\n# Animate parameter changes\nanim = plot.vectorfield_animate(\n    model,\n    param=\"a\",\n    values=np.linspace(-2, 2, 100),  # 100 frames\n    fps=15,\n    title_func=lambda v, idx: f\"Parameter a = {v:.2f}\",\n    normalize=True,\n    speed_color=True\n)\n\n# Save animation\nanim.animation.save(\"vectorfield_animation.gif\", writer=\"pillow\")\n</code></pre> <p><code>plot.vectorfield_animate()</code> returns a <code>VectorFieldAnimation</code> that keeps both the live <code>VectorFieldHandle</code> (accessible via <code>.handle</code>) and the underlying <code>matplotlib.animation.FuncAnimation</code> so you can update the handle manually or save the animation later. Provide either <code>frames</code>, <code>values</code> (with <code>param</code>), or <code>duration</code>/<code>fps</code>, and use <code>params_func</code>, <code>fixed_func</code>, or <code>title_func</code> when you need custom overrides for each frame.</p>"},{"location":"guides/plotting/vectorfields/#animation-options","title":"Animation Options","text":"<ul> <li><code>fps</code>: Frames per second (default: 15)</li> <li><code>interval</code>: Milliseconds between frames (alternative to fps)</li> <li><code>title_func</code>: Function to generate titles for each frame</li> <li><code>repeat</code>: Whether animation loops (default: True)</li> <li><code>blit</code>: Use blitting for smoother animation (may not work in all backends)</li> </ul>"},{"location":"guides/plotting/vectorfields/#advanced-usage","title":"Advanced Usage","text":""},{"location":"guides/plotting/vectorfields/#updating-plots-dynamically","title":"Updating Plots Dynamically","text":"<p>The <code>vectorfield()</code> function returns a <code>VectorFieldHandle</code> that allows dynamic updates:</p> <pre><code>handle = plot.vectorfield(model, params={\"a\": 1.0})\n\n# Update parameters without replotting\nhandle.update(params={\"a\": 2.0})\n\n# Update fixed values\nhandle.update(fixed={\"z\": 15.0})\n</code></pre>"},{"location":"guides/plotting/vectorfields/#custom-evaluation","title":"Custom Evaluation","text":"<p>For low-level control, use <code>plot.eval_vectorfield()</code> to get raw vector data:</p> <pre><code>X, Y, U, V = plot.eval_vectorfield(\n    model,\n    xlim=(-2, 2),\n    ylim=(-2, 2),\n    grid=(50, 50),\n    normalize=True\n)\n\n# Use with matplotlib directly\nimport matplotlib.pyplot as plt\nplt.quiver(X, Y, U, V)\n</code></pre> <p>Pass <code>return_speed=True</code> when you need the magnitude grid (e.g., to color with a colormap or compare normalized vs non-normalized speeds).</p>"},{"location":"guides/plotting/vectorfields/#higher-dimensional-systems","title":"Higher-Dimensional Systems","text":"<p>For systems with &gt;2 dimensions, project onto 2D slices:</p> <pre><code># Lorenz system: x-y plane with z fixed\nplot.vectorfield(\n    lorenz_model,\n    vars=(\"x\", \"y\"),\n    fixed={\"z\": 25.0}\n)\n\n# Same system: y-z plane with x fixed\nplot.vectorfield(\n    lorenz_model,\n    vars=(\"y\", \"z\"),\n    fixed={\"x\": 0.0}\n)\n</code></pre> <p>When you slice higher-dimensional systems, make sure every other state is pinned with <code>fixed</code> so the evaluation stays within the desired plane.</p>"},{"location":"guides/plotting/vectorfields/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Grid size: Larger grids give better resolution but slower computation</li> <li>Normalization: Normalized plots compute faster (no magnitude calculation)</li> <li>Nullclines: Computed on separate grid; use <code>nullcline_grid</code> to control density</li> <li>JIT compilation: Set <code>jit=True</code> for repeated evaluations of the same model</li> <li>Disk caching: Pass <code>disk_cache=True</code> when building from a URI to reuse compiled artifacts between runs</li> </ul>"},{"location":"guides/plotting/vectorfields/#common-patterns","title":"Common Patterns","text":""},{"location":"guides/plotting/vectorfields/#phase-portrait-with-trajectories","title":"Phase Portrait with Trajectories","text":"<pre><code>ax = plot.fig.single()\nhandle = plot.vectorfield(\n    model,\n    ax=ax,\n    normalize=True,\n    nullclines=True\n)\n\n# Add specific trajectories\nfrom dynlib import Sim\nsim = Sim(model)\nsim.run(t_end=20.0, state_ic=[1.0, 0.0])\nplot.series(sim, ax=ax, vars=(\"x\", \"y\"))\n</code></pre>"},{"location":"guides/plotting/vectorfields/#bifurcation-analysis-setup","title":"Bifurcation Analysis Setup","text":"<pre><code># Build the sweep range with numpy\nimport numpy as np\n\n# Sweep parameter and observe qualitative changes\nplot.vectorfield_sweep(\n    model,\n    param=\"r\",\n    values=np.linspace(0, 1, 9),\n    normalize=True,\n    speed_color=True,\n    title=\"Bifurcation in vector field structure\"\n)\n</code></pre>"},{"location":"guides/plotting/vectorfields/#animation-with-custom-parameter-functions","title":"Animation with Custom Parameter Functions","text":"<pre><code># Parameter updates can reuse NumPy for oscillations\nimport numpy as np\n\n# Oscillating parameter\ndef param_func(frame_idx):\n    return {\"a\": 2.0 * np.sin(2 * np.pi * frame_idx / 50)}\n\nplot.vectorfield_animate(\n    model,\n    frames=50,\n    params_func=param_func,\n    fps=10\n)\n</code></pre>"},{"location":"guides/simulation/","title":"Simulation guides","text":"<ul> <li>Basics</li> <li>Configuration</li> <li>Just-In-Time compilation</li> <li>Runtime presets</li> <li>Runner variants</li> <li>Session state &amp; printing</li> <li>Exporting compiled sources</li> <li>Simulation steppers</li> <li>Snapshots &amp; resume</li> <li>Runner &amp; wrapper</li> </ul>"},{"location":"guides/simulation/basics/","title":"Simulation Basics","text":"<p>This guide walks through the two core phases of running a dynlib simulation: 1. Compile your model into a <code>FullModel</code>. 2. Drive that compiled artifact with a <code>Sim</code> instance.</p> <p>It also highlights the shortcut <code>setup()</code> for quickly getting a simulation up and running.</p>"},{"location":"guides/simulation/basics/#1-compile-and-inspect-a-fullmodel","title":"1. Compile and Inspect a <code>FullModel</code>","text":"<p>Every dynlib simulation begins with <code>build()</code> (or, when you need more control, the lower-level compiler entry points). <code>build()</code> takes the model specification (URI, path, or inline DSL) along with optional steppers, mods, and JIT flags, and returns a <code>FullModel</code>.</p> <pre><code>from dynlib import build\n\nmodel = build(\"my_model.toml\", stepper=\"rk4\", jit=True)\n</code></pre> <p>A <code>FullModel</code> includes:</p> <ul> <li>Compiled callables (<code>rhs</code>, <code>stepper</code>, <code>runner</code>, <code>events_pre</code>, <code>events_post</code>, etc.).</li> <li>Metadata (<code>spec</code>, <code>stepper_name</code>, <code>workspace_sig</code>, dtype, simulation defaults, guards).</li> <li>Helper methods, such as <code>export_sources()</code> for extracting generated Python code, and <code>full_model.spec</code> for examining states, parameters, auxiliary variables, and <code>[sim]</code> defaults.</li> </ul> <p>Since the compiled <code>model</code> is a standard Python object, you can inspect or reuse it before integrating it into a runtime. For example:</p> <ul> <li>Check <code>model.stepper_name</code> to confirm the chosen integrator.</li> <li>Examine <code>model.spec.states</code>, <code>model.spec.aux</code>, and <code>model.spec.params</code> to plan what to record.</li> <li>Re-export source code for debugging using <code>model.export_sources(\"./compiled\")</code>.</li> </ul> <p>Use <code>FullModel</code> directly only when you need to inspect or reuse compiled components. Most workflows pass the <code>FullModel</code> directly to <code>Sim</code>.</p>"},{"location":"guides/simulation/basics/#2-run-a-simulation-with-sim","title":"2. Run a Simulation with <code>Sim</code>","text":"<p><code>Sim</code> wraps a <code>FullModel</code> and manages resumable session state, results buffers, snapshots, and preset banks.</p> <pre><code>from dynlib import Sim\n\nsim = Sim(model)\nsim.config(record_interval=5, max_steps=2000)\nsim.run(T=10.0, record=True)\nresults = sim.results()\n</code></pre> <p>Key runtime concepts:</p> <ul> <li><code>run(...)</code> starts the simulation. You can override any <code>[sim]</code> defaults, such as <code>dt</code>, <code>T</code>/<code>N</code>, <code>record</code>, <code>record_interval</code>, <code>max_steps</code>, and selective recording via <code>record_vars</code>.</li> <li><code>Sim.config(...)</code> sets persistent defaults to avoid repeating settings on every <code>run()</code>.</li> <li><code>Sim.assign(...)</code> updates states/parameters or clears history before running.</li> <li><code>Sim.results()</code> provides a <code>ResultsView</code> for named access, while <code>Sim.raw_results()</code> gives direct array views via the low-level <code>Results</code> buffer.</li> <li><code>Sim.reset()</code> returns to a named snapshot (the <code>\"initial\"</code> snapshot is created automatically on the first run) and clears recorded history.</li> <li><code>Sim.create_snapshot(...)</code>, <code>list_snapshots()</code>, and <code>name_segment()</code> enable control over reproducible segments for multiple scenarios.</li> <li><code>run(resume=True)</code> continues from the current state, allowing seamless stitching of simulation segments.</li> </ul> <p><code>Sim</code> respects the <code>[sim]</code> table in the DSL, so simulation parameters have sensible defaults. <code>run()</code> only changes what you specify.</p>"},{"location":"guides/simulation/basics/#3-quick-setup-with-setup","title":"3. Quick Setup with <code>setup()</code>","text":"<p>For a fast way to compile and run, use the <code>setup()</code> helper. It combines <code>build()</code> and <code>Sim()</code> in one call, applies the same defaults, and provides access to the compiled model via <code>sim.model</code>.</p> <pre><code>from dynlib import setup\n\nsim = setup(\"my_model.toml\", stepper=\"rk4\", jit=True)\nsim.run(T=10.0)\nprint(sim.results().t)\n</code></pre> <p>Since <code>setup()</code> gives you a ready-to-run <code>Sim</code>, it's the quickest way to start simulations. Reserve the explicit <code>build()</code> + <code>Sim()</code> approach for cases where you need to manipulate the <code>FullModel</code> first (e.g., inspecting guards, exporting sources, or caching for reuse).</p>"},{"location":"guides/simulation/basics/#workflow-tips","title":"Workflow Tips","text":"<ul> <li>Build once and reuse the <code>FullModel</code> for different scenarios or data shapes.</li> <li>Keep a <code>Sim</code> instance alive for snapshots, presets, or repeated configurations; resetting and reusing is more efficient than rebuilding.</li> <li>Rely on <code>[sim]</code> defaults for most settings, using <code>Sim.config()</code> and targeted <code>run()</code> overrides as needed.</li> <li>Use <code>setup()</code> for rapid prototyping, testing, or demos.</li> <li>Enable <code>jit=True</code> only when numba is installed and simulations are long enough to justify compilation overhead. For short runs, use <code>jit=False</code> to stick with the interpreter.</li> </ul>"},{"location":"guides/simulation/configuration/","title":"Simulation Configuration","text":"<p>This guide explains how to tune runtime defaults, adjust the model state/parameter bank, and control recording and caps when working with <code>Sim</code>.</p>"},{"location":"guides/simulation/configuration/#persisting-defaults-with-simconfig","title":"Persisting defaults with <code>Sim.config()</code>","text":"<p><code>Sim.config()</code> lets you set persistent defaults that <code>run()</code> will use whenever a particular argument is unspecified. It covers the most common simulation knobs plus any stepper-specific <code>Config</code> fields.</p> <pre><code>sim.config(\n    dt=0.01,\n    max_steps=5000,\n    record=True,\n    record_interval=10,\n    cap_rec=2048,\n    cap_evt=4,\n    tol=1e-6,          # forwarded to the active stepper config\n)\n</code></pre> <p>Highlights:</p> <ul> <li><code>dt</code> sets the nominal time step (or label spacing for discrete models) and is stored on the simulation state as <code>_nominal_dt</code>. It must be positive.</li> <li><code>max_steps</code> becomes the default safety limit (continuous) or target iteration count (discrete) whenever you omit <code>N</code>/<code>T</code>.</li> <li><code>record</code> and <code>record_interval</code> define the default logging behavior and are inherited by future <code>run()</code> calls unless overridden.</li> <li><code>cap_rec</code>/<code>cap_evt</code> control the initial sizes of the trajectory/event buffers. They grow automatically if needed, but larger initial caps can reduce reallocations.</li> <li>Any extra keyword arguments are forwarded to <code>Sim.stepper_config()</code> so you can configure <code>tol</code>, <code>max_iter</code>, or other stepper knobs globally.</li> </ul> <p>Remember that explicit arguments to <code>run()</code> always override these defaults, so mix <code>config()</code> with <code>run(...)</code> overrides for reproducible scripts.</p>"},{"location":"guides/simulation/configuration/#tweaking-states-and-parameters-with-simassign","title":"Tweaking states and parameters with <code>Sim.assign()</code>","text":"<p><code>Sim.assign()</code> updates the session\u2019s current state and parameter vectors by name, without recompiling anything.</p> <pre><code>sim.assign({\"v\": -65.0, \"I\": 5.0})\nsim.assign(I=8.0, clear_history=True)\n</code></pre> <p>Key behaviors:</p> <ul> <li>Accepts a mapping and/or keyword arguments; keywords override map entries.</li> <li>Resolves names first against <code>states</code>, then <code>params</code>; unknown names raise a clear <code>ValueError</code> with \u201cdid you mean \u2026?\u201d suggestions.</li> <li>Casts inputs to the model dtype, emitting a warning if precision would be lost.</li> <li><code>clear_history=True</code> wipes the accumulated <code>Results</code>, segments, and pending tags without altering time, workspace, snapshots, or stepper config.</li> <li>Changes take effect immediately for the next <code>run()</code> unless you pass explicit <code>ic</code>/<code>params</code> arguments to <code>run()</code>.</li> </ul> <p>Use <code>assign()</code> when you want to reuse a <code>Sim</code> with new conditions, tweak parameters between experiments, or prime the system before resuming.</p>"},{"location":"guides/simulation/configuration/#recording-options","title":"Recording options","text":"<p><code>Sim.run()</code> offers fine control over logging alongside the defaults you already set via <code>config()</code> or <code>[sim]</code> table.</p> <ul> <li><code>record</code> (bool): turn recording on/off. When <code>False</code>, only the global time axis is updated; no state/aux buffers grow.</li> <li><code>record_interval</code> (int): capture every N-th step (default <code>1</code>). Useful for downsampling or capturing fast simulations cheaply.</li> <li><code>record_vars</code>: selective recording list. Acceptable entries:</li> <li><code>None</code> (default) : All available state variables.</li> <li>Unprefixed names refer to states.</li> <li><code>\"aux.&lt;name&gt;\"</code> explicitly targets auxiliary variables, but posting <code>aux</code> names without the prefix is also accepted and disambiguated.</li> <li>An empty list (<code>[]</code>) disables state/aux recording while still logging timestamps, steps, and flags.</li> </ul> <p>Selective recording keeps the same <code>Results</code> buffer layout but only fills the requested subsets, which saves memory/time for large state vectors.</p> <p>You can also adjust recording capacity before a run with <code>cap_rec</code> and <code>cap_evt</code>, or let dynlib grow the buffers automatically while <code>record_interval</code>/<code>record_vars</code> decide what gets captured.</p>"},{"location":"guides/simulation/configuration/#managing-simulation-horizons","title":"Managing simulation horizons","text":"<ul> <li><code>dt</code> records the nominal step size. Use <code>config(dt=\u2026)</code> for a persistent default, or override per-run.</li> <li><code>T</code> (continuous) or <code>N</code> (discrete) define how far the runner goes; if both are omitted, <code>max_steps</code> takes over (the default still respects <code>[sim].max_steps</code>).</li> <li>When working with maps (<code>kind=\"map\"</code>), <code>N</code> determines iterations and <code>T</code> is derived; for ODEs, <code>T</code> is the end time and <code>N</code> is inferred.</li> <li><code>max_steps</code> is enforced as a safety guard on continuous models and acts as the default iteration count when you omit <code>N</code> on discrete ones. Raise it when the horizon grows or shrink it to avoid runaway loops. If a runner reaches the <code>max_steps</code>, then a warning is raised to avoid silent unexpected behaviors.</li> <li><code>transient</code> can skip recording for an initial warm-up period (either time or iterations) without influencing the stored <code>Results</code>. Nothing is recorded during the <code>transient</code> period. Beware that time is started from <code>t0</code> after the transient period, so this might be counter-intuitive for some users.</li> <li><code>resume=True</code> allows restarting from the last <code>SessionState</code>; note that <code>ic</code>, <code>params</code>, <code>t0</code>, and <code>dt</code> cannot be overridden in resume mode.</li> </ul> <p>Pair these options with <code>Sim.reset()</code>/<code>Sim.create_snapshot()</code> when orchestrating multi-stage experiments, so you retain control over segments and recorded history even as you tweak horizons.</p>"},{"location":"guides/simulation/configuration/#summary","title":"Summary","text":"<ul> <li>Use <code>Sim.config()</code> to declare long-lived defaults for <code>dt</code>, <code>max_steps</code>, recording, capacities, and stepper tuning.</li> <li>Call <code>Sim.assign()</code> anytime you need to update state/parameter values without rebuilding the model.</li> <li>Leverage <code>run(record_vars=\u2026)</code>, <code>record_interval</code>, and the buffer caps to trade off fidelity vs. memory.</li> <li>Adjust <code>T</code>, <code>N</code>, and <code>max_steps</code> depending on whether you simulate maps or continuous systems, and rely on <code>transient</code>/<code>resume</code> to control staging.</li> <li>Combine configuration options with snapshots, segments, and <code>setup()</code> when you need both reproducibility and speed.</li> </ul>"},{"location":"guides/simulation/export-sources/","title":"Exporting compiled sources","text":"<p>When you need to peek inside what dynlib is generating, <code>FullModel.export_sources()</code> (and the sibling helper, <code>dynlib.compiler.build.export_model_sources</code>) write every available callable into a directory so you can open it in your editor, run linting, or keep a record of a simulation build.</p> <p>Exporting sources is useful whenever you:</p> <ul> <li>want to understand how the DSL equations become Python functions (rhs, steppers, events, etc.)</li> <li>need to audit what changed between steppers, events, or solver options</li> <li>are preparing artifacts for regression testing, demos, or sharing with teammates</li> </ul>"},{"location":"guides/simulation/export-sources/#step-by-step-export-workflow","title":"Step-by-step export workflow","text":"<pre><code>from dynlib import build\n\nmodel = build(\"decay.toml\", stepper=\"euler\", jit=True)\nfiles = model.export_sources(\"compiled_sources\")\nprint(files[\"rhs\"])\n</code></pre> <ol> <li>Call <code>build(...)</code> or <code>setup(...)</code> to get a <code>FullModel</code>. If you already have a <code>Sim</code>, use <code>sim.model</code> to reach the compiled artifact.</li> <li>Pass a writable <code>output_dir</code>. The directory is created automatically (<code>mkdir -p</code> semantics).</li> <li>The return value is a dictionary mapping component names to the <code>Path</code> of the written file.</li> <li>Every time you rebuild with different options you can export again into a new directory to compare source diffs.</li> </ol> <p>If you prefer a free-standing helper, import <code>export_model_sources</code> from <code>dynlib.compiler.build</code> and pass the <code>FullModel</code> instance.</p>"},{"location":"guides/simulation/export-sources/#what-gets-written","title":"What gets written","text":"<p>The export writes a <code>.py</code> file for each compiled component that carries source text on the model object:</p> <ul> <li><code>rhs.py</code>, <code>events_pre.py</code>, <code>events_post.py</code>, <code>update_aux.py</code></li> <li><code>stepper.py</code> and (when available) <code>jvp.py</code>, <code>jacobian.py</code>, <code>inv_rhs.py</code></li> </ul> <p>In addition, <code>model_info.txt</code> summarizes the spec: spec hash, kind, stepper name, dtype, listed states/parameters, RHS equations, and a short preview of any events (phase, guard, and the first ~50 characters of the action block). Having this metadata alongside the code makes it easier to correlate a compiled snapshot to the DSL input.</p> <p>Because <code>FullModel</code> retains the sources regardless of <code>disk_cache</code> or the stepper you selected, the export works even when the compiler reused cached artifacts or when you swap between <code>euler</code>, <code>rk4</code>, or custom steppers. The files are written with UTF-8 encoding so you can open them in any standard editor.</p>"},{"location":"guides/simulation/export-sources/#tips","title":"Tips","text":"<ul> <li>If you need a record of the generated runner/stepper for debugging, export after compiling and before running long simulations.</li> <li>Treat each export directory as a snapshot: keep it around to track regressions or to document how a particular option (e.g., <code>jit=True</code> vs <code>jit=False</code>) affects the generated code.</li> <li>The helper returns <code>Path</code> objects so you can immediately read the contents (e.g., <code>files[\"stepper\"].read_text()</code>).</li> </ul>"},{"location":"guides/simulation/jit/","title":"JIT Compilation in Simulations","text":"<p>dynlib currently relies on Numba as the sole just-in-time backend. Because <code>build()</code> and <code>setup()</code> now default to <code>jit=False</code> and <code>disk_cache=False</code>, turning on JIT is a deliberate choice: pass <code>jit=True</code> when you need the compiled kernels. If Numba is not installed, that flag raises <code>JITUnavailableError</code>, so install numba first. The runtime design assumes the compiled kernel is GIL-free, therefore no other JIT engines (PyPy, Cython, LLVM wrappers, etc.) are supported.</p>"},{"location":"guides/simulation/jit/#turning-on-jit","title":"Turning on JIT","text":"<ul> <li>A plain <code>build(model)</code> or <code>setup(model)</code> runs the simulation entirely in Python.</li> <li>Pass <code>jit=True</code> to compel dynlib to compile the RHS, events, auxiliary updater, stepper, runner, and guards with Numba.</li> <li>While <code>jit=False</code> is safe for quick experiments or short batches, <code>jit=True</code> pays off for long-running simulations where the upfront compilation cost is amortized.</li> <li>Pair <code>jit=True</code> with <code>disk_cache=True</code> to persist compiled artifacts across processes; leaving <code>disk_cache=False</code> keeps everything in-memory and avoids writing to the cache root.</li> </ul> <pre><code>from dynlib import setup\n\nsim = setup(\"builtin://ode/vanderpol\", stepper=\"rk4\", jit=True, disk_cache=True)\nsim.run(T=20.0)\n</code></pre> <p>You can also call <code>build()</code> directly when you need to inspect the <code>FullModel</code>. Its compiled attributes (<code>model.rhs</code>, <code>model.stepper</code>, <code>model.runner</code>, etc.) expose the usual Numba <code>signatures</code> once JIT-ed.</p>"},{"location":"guides/simulation/jit/#what-gets-compiled","title":"What gets compiled","text":"<p>The JIT path covers the pieces that run inside the numerically hot loop:</p> <ul> <li>Triplet functions: <code>rhs</code>, <code>events_pre</code>, <code>events_post</code>, and <code>update_aux</code> are compiled together so they stay performant when invoked from the stepper/runner.</li> <li>Stepper: <code>stepper.emit()</code> produces the integration kernel, which is also JIT-compiled when the stepper is marked as JIT-capable.</li> <li>Runner: The runner template (ordinary, fast-path, or analysis variant) is compiled with the same <code>jit</code> flag so the entire wrapper \u2192 runner stack runs without crossing back to Python.</li> <li>Guards: When JIT is enabled, guard helpers that validate states/params are compiled once and reused to keep the <code>nopython</code> contract intact.</li> </ul>"},{"location":"guides/simulation/jit/#caching-jit-artifacts","title":"Caching JIT artifacts","text":"<p>Caching eliminates redundant compilation when you rerun the same model or rebuild it in another process.</p> <ul> <li> <p><code>disk_cache=True</code> : Persists compiled triplets, steppers, and runners under </p> <ul> <li><code>~/.cache/dynlib/jit/...</code> (Linux), </li> <li><code>~/Library/Caches/dynlib/jit/...</code> (macOS), </li> <li><code>%LOCALAPPDATA%/dynlib/Cache/jit/...</code> (Windows). </li> </ul> </li> <li> <p><code>disk_cache=False</code> : Keeps everything in memory; useful when you cannot write to the cache root or when you specifically want a clean compilation per run. </p> </li> <li> <p>Source visibility : Generated source code stays available on the <code>model</code> object (<code>model.rhs_source</code>, <code>model.stepper_source</code>, \u2026) regardless of <code>disk_cache</code>.</p> </li> </ul>"},{"location":"guides/simulation/jit/#how-the-cache-key-is-constructed","title":"How the cache key is constructed","text":"<ul> <li><code>runner_variants.get_runner</code> and the triplet/stepper cache builders derive cache keys from deterministic inputs: the model hash, stepper name, dtype, guard struct signature, runner variant, analysis signature, <code>cache_token</code>, JIT flag, and template version.</li> <li>The triplet/stepper caches store compiled modules under <code>cache_root/jit/triplets|steppers/.../&lt;digest&gt;</code>, so two runs with the same hash reuse the compiled artifact immediately.</li> <li>Runners inject <code>analysis</code> hooks and thus only cache non-analysis variants (<code>njit(cache=True)</code> flags are omitted for analysis-aware runners because the hooks are resolved at runtime). Variants are still cached in-process and on disk via <code>runner_cache</code>, and <code>cache_token</code> (based on the configured cache context) makes sure caches are invalidated when workspace layout or dtype changes.</li> </ul>"},{"location":"guides/simulation/jit/#configuring-the-cache-root","title":"Configuring the cache root","text":"<p>You can override the cache root via configuration files or environment variables:</p> <ol> <li><code>DYNLIB_CONFIG</code> points to a TOML file that may contain <code>cache_root = \"/custom/root\"</code> or a <code>[cache]</code> table with <code>root = \"/custom/root\"</code>.</li> <li><code>load_config()</code> also honors <code>DYN_MODEL_PATH</code>, so you can combine <code>cache_root</code> overrides with custom TAG roots.</li> <li>If the configured root is unwritable, dynlib falls back to <code>/tmp/dynlib-cache</code> (and warns once). If that too fails, the runtime warns and keeps the JIT cache entirely in memory (no files written).</li> </ol>"},{"location":"guides/simulation/jit/#cache-resilience","title":"Cache resilience","text":"<ul> <li>The on-disk cache rebuilds itself when it detects corruption: it deletes the bad module, re-renders the generated source, and retries compilation.</li> <li><code>CacheLock</code> guards prevent races when multiple processes try to populate the same digest simultaneously.</li> <li>The caches also support a manual invalidation path by touching the <code>cache_token</code> (the runner builder picks up the current struct signature and dtype), so ABI-affecting changes automatically create new entries.</li> <li>Changes in runner or stepper source code are not tracked or hashed. Any change in the source code will corrupt the cache or you will get old behavior due to cached artifacts. In such cases delete the cache. CLI can be used to delete the cache (for example: <code>dynlib cache clear --all</code>).</li> </ul>"},{"location":"guides/simulation/jit/#checking-compilation-status","title":"Checking compilation status","text":"<p>If you want to know whether a callable was actually JIT-compiled:</p> <pre><code>from dynlib import build\n\ndef is_jitted(fn):\n    return hasattr(fn, \"signatures\") and bool(fn.signatures)\n\nmodel = build(\"model.toml\", stepper=\"euler\", jit=True)\nprint(\"RHS jitted\", is_jitted(model.rhs))\nprint(\"Runner jitted\", is_jitted(model.runner))\n</code></pre> <p><code>model.export_sources(...)</code> still works even when <code>disk_cache=True</code>; the exported directory contains every compiled component (<code>rhs.py</code>, <code>stepper.py</code>, <code>runner.py</code>, etc.), which makes it easy to inspect what dynlib is compiling behind the scenes.</p>"},{"location":"guides/simulation/jit/#best-practices","title":"Best practices","text":"<ul> <li>Reserve <code>jit=True</code> for simulations that execute long enough to amortize the upfront compilation cost.</li> <li>Keep <code>disk_cache=True</code> for development cycles where you rebuild the same models repeatedly; turn it off when you need a clean slate (e.g., CI or tests that ensure a fresh compilation).</li> <li>If a run fails with a Numba error, inspect the traceback, fix any unsupported Python constructs, and rerun \u2013 dynlib does not silently fall back to Python when <code>jit=True</code>.</li> <li>When you add new observer hooks or change the dtype/stepper, the cache key changes automatically, so you do not need to manually delete cache directories.</li> </ul> <p>With these knobs you can achieve near-native performance while still keeping traceability and reproducibility via persistent caches.</p>"},{"location":"guides/simulation/presets/","title":"Runtime presets","text":"<p>This guide focuses on how to work with the preset bank while a simulation is running. The DSL side of preset definitions lives in <code>docs/guides/modeling/presets.md</code>, but once a <code>FullModel</code> is compiled the <code>Sim</code> instance keeps its own in-memory cache of those presets plus anything you add or import later.</p>"},{"location":"guides/simulation/presets/#preset-bank-in-sim","title":"Preset bank in <code>Sim</code>","text":"<p>Every <code>Sim</code> keeps a preset bank that is populated during initialization with the inline <code>[presets.&lt;name&gt;]</code> tables from the model spec. Use <code>list_presets(pattern=\"*\")</code> to inspect what is currently available; it returns alphabetically sorted names and supports <code>glob</code>-style filters (<code>*</code>, <code>?</code>, <code>[]</code>).</p> <pre><code>sim = Sim(model)\nprint(sim.list_presets())  # ['bursting', 'regular_spiking', ...]\n</code></pre> <p>The bank is shared across runs, snapshots, and resume segments, so you can switch between presets without rebuilding the model.</p>"},{"location":"guides/simulation/presets/#applying-a-preset-before-a-run","title":"Applying a preset before a run","text":"<p>Call <code>sim.apply_preset(name)</code> to push a preset\u2019s states and/or parameters into the current session. Only the keys listed in the preset are updated\u2014anything else (time, <code>dt</code>, stepper workspace, recorded history) is left untouched\u2014so this is a safe, incremental way to reconfigure the session prior to <code>run()</code> or between segments.</p> <pre><code>sim.apply_preset(\"bursting\")\nsim.run(T=2.0, record=True)\n</code></pre> <p>If you need to change a parameter that was not part of the preset, use <code>sim.assign(...)</code> after applying the preset, or create a new preset that includes the additional key. Applying a preset also works after <code>reset()</code>/<code>import_snapshot()</code> so you can branch off a saved state with a new combination of values.</p>"},{"location":"guides/simulation/presets/#capturing-new-presets-on-the-fly","title":"Capturing new presets on the fly","text":"<p><code>sim.add_preset(name, *, states=None, params=None, overwrite=False)</code> registers a new entry into the preset bank.</p> <ul> <li>When both <code>states</code> and <code>params</code> are omitted, the method snapshots the current session values. Otherwise, provide mappings or 1-D NumPy arrays for the variables you want to store.</li> <li>Pass <code>overwrite=True</code> to replace an existing preset, otherwise a <code>ValueError</code> is raised to avoid clobbering.</li> </ul> <pre><code>sim.assign(I=15.0)\nsim.run(T=1.0)\nsim.add_preset(\"after_stim\", overwrite=True)  # captures the latest states and params\n</code></pre> <p>You can also create partial presets (e.g., only storing a subset of states) by passing one of the keyword arguments.</p>"},{"location":"guides/simulation/presets/#importing-and-exporting-presets","title":"Importing and exporting presets","text":"<p>Use <code>sim.load_preset(name_or_pattern, path, *, on_conflict=\"error\")</code> to read presets from a TOML file that follows the <code>dynlib-presets-v1</code> schema (<code>[__presets__].schema = \"dynlib-presets-v1\"</code>). You can match a single preset name or pass a glob pattern like <code>\"fast_*\"</code>. The loader validates the file, enforces numeric tables, and makes sure every referenced state/parameter exists in the active model.</p> <ul> <li><code>on_conflict=\"error\"</code> (default) raises if the bank already contains the preset.</li> <li><code>\"keep\"</code> skips the file preset and leaves the bank untouched (warning emitted).</li> <li><code>\"replace\"</code> overwrites the bank entry with the file version (warning emitted).</li> </ul> <pre><code>sim.load_preset(\"fast_*\", \"presets.toml\", on_conflict=\"replace\")\nsim.apply_preset(\"fast_spiking\")\nsim.run(T=5.0)\n</code></pre> <p>Conversely, <code>sim.save_preset(name, path, *, overwrite=False)</code> writes a bank entry back to disk. The helper ensures a <code>[__presets__]</code> header exists, keeps unrelated presets in the file untouched, and either appends a new <code>[presets.&lt;name&gt;]</code> table or updates the one that already exists (if <code>overwrite=True</code>).</p> <pre><code>sim.save_preset(\"after_stim\", \"presets.toml\", overwrite=True)\n</code></pre> <p>Persisting presets lets you build experiment curricula, share configurations with colleagues, or version-control the exact states/parameter sets that produced a result.</p>"},{"location":"guides/simulation/presets/#tips-for-working-with-runtime-presets","title":"Tips for working with runtime presets","text":"<ul> <li>When switching between presets inside a single workflow, <code>apply_preset()</code> is usually enough to reconfigure the session; you only need <code>reset()</code> or snapshots if you also want to rewind time or clear the recorder.</li> <li>Combine <code>add_preset()</code> and <code>save_preset()</code> to capture a replayable state and export it for other projects.</li> <li>Remember that presets only touch the variables they list\u2014if you need to override every parameter or keep a fixed story of time, pair them with snapshots or <code>assign()</code> calls before running.</li> </ul>"},{"location":"guides/simulation/results/","title":"Simulation Results","text":"<p>This guide dives into <code>Sim.results()</code> / <code>Sim.raw_results()</code> so you can understand what dynlib records, how to slice/filter/export results, and how to keep large simulations manageable.</p>"},{"location":"guides/simulation/results/#1-named-access-with-resultsview","title":"1. Named access with <code>ResultsView</code>","text":"<p><code>Sim.results()</code> returns a <code>ResultsView</code> that provides ergonomic access to simulation results with names derived from the model spec:</p> <ul> <li><code>res.t</code>, <code>res.step</code>, <code>res.flags</code> give you the time axis, step indices, and status flags as NumPy views.</li> <li><code>res[\"x\"]</code>, <code>res[\"aux.energy\"]</code>, or <code>res[[\"x\",\"y\"]]</code> return the recorded series for states and aux variables, stacking multi-variable requests into compact copies when necessary.</li> <li><code>res.analyze(...)</code> builds a <code>TrajectoryAnalyzer</code> / <code>MultiVarAnalyzer</code> for quick statistics (max/min/crossings), and <code>res.observers</code> surfaces runtime observer outputs through the ergonomic <code>ObserverResult</code> wrapper.</li> <li><code>res.segment</code> mirrors the main API while letting you focus on a single run (auto <code>run#N</code> names or manual tags). Each <code>SegmentView</code> slices <code>t</code>, <code>step</code>, <code>flags</code>, and even <code>events()</code> for that chunk without copying.</li> </ul>"},{"location":"guides/simulation/results/#2-raw-access-with-results","title":"2. Raw access with: <code>Results</code>","text":"<p>For advanced users needing direct access to the underlying buffers, <code>Sim.raw_results()</code> hands you a <code>Results</code> dataclass that mirrors the runner buffers without copying. The key fields are the backing arrays (time <code>T</code>, states <code>Y</code>, optional aux <code>AUX</code>, <code>STEP</code>, <code>FLAGS</code>), the event log (<code>EVT_CODE</code>, <code>EVT_INDEX</code>, <code>EVT_LOG_DATA</code>), filled counts <code>n</code>/<code>m</code>, exit <code>status</code>, and snapshots of the final state/params/workspaces. Each accessor provides a view limited to the filled region so you always see contiguous records, and <code>Results.to_pandas()</code> can materialize the columns as a tidy <code>DataFrame</code> for downstream NumPy/Pandas workflows.</p> <p>When you need the entire buffer, use <code>Sim.raw_results()</code>. For most users, <code>Sim.results()</code> wraps this low-level object with names, helpers, and segments.</p>"},{"location":"guides/simulation/results/#3-slicing-filtering-and-exporting","title":"3. Slicing, filtering, and exporting","text":"<ul> <li>Treat <code>res[\"var\"]</code> as your primary slicing hook; use <code>res[[\"x\",\"y\"]]</code> to stack multiple series and keep the natural ordering.</li> <li>For trajectory slices per segment, index <code>res.segment[0]</code> or <code>res.segment[\"run#1\"]</code>. Each segment respects its recording window and exposes <code>events()</code> for the wrapped portion.</li> <li>When you prefer tabular exports, <code>Results.to_pandas()</code> gives <code>t</code>, <code>step</code>, <code>flag</code>, each state column, and prefixed aux columns so you can hand the frame to Pandas/NumPy directly.</li> </ul>"},{"location":"guides/simulation/results/#event-logging-results-access","title":"Event logging results access","text":"<p>Events are stored alongside the trajectory, and each event row carries a code, owning record index, and logged data blob. <code>ResultsView</code> resolves the DSL-defined names/tags so <code>res.event(\"threshold\")</code> knows which code, fields, and tags to use. Due to NumPy's limitations on arbitrary row views, filtering (time ranges, head/tail, sorting) allocates compact arrays, but the API keeps the allocations isolated so the rest of the results stay view-only.</p> <ul> <li>Call <code>res.event(\"spike\")</code> to get an <code>EventView</code>, then chain <code>.time(t0, t1)</code>, <code>.head(k)</code>, <code>.tail(k)</code>, or <code>.sort(by=\"t\")</code> before grabbing individual fields with <code>ev[\"id\"]</code> or <code>ev[[\"t\",\"id\"]]</code>. <code>ev.table()</code> materializes all logged columns in order.</li> <li>Use <code>res.event(tag=\"group\")</code> for a grouped view over multiple event types; <code>group.select(...)</code> lets you union or intersect fields while <code>group.table(...)</code> can sort the combined rows.</li> <li><code>res.event.summary()</code> gives quick counts per event type, and <code>res.event.names()/fields()/tags()</code> help you discover what is recorded.</li> </ul>"},{"location":"guides/simulation/results/#4-working-with-large-datasets-and-external-tools","title":"4. Working with large datasets and external tools","text":"<ul> <li>Control logging via <code>Sim.config()</code> and <code>run()</code> hooks: toggle <code>record</code>, jump every <code>record_interval</code> steps, or pass <code>record_vars</code>/<code>[]</code> to capture only what you need.</li> <li>Increase <code>cap_rec</code>/<code>cap_evt</code> to preallocate buffers, lower <code>record_interval</code> for downsampling, or disable state/aux logging entirely while still recording time/steps/flags.</li> <li>Use <code>transient</code>, <code>resume</code>, and snapshots (<code>Sim.reset()</code>, <code>Sim.create_snapshot()</code>) to manage staged experiments without overwhelming buffers.</li> <li>Export to NumPy/Pandas via the already exposed arrays (<code>res.t</code>, <code>res[\"x\"]</code>, <code>.events()</code>, <code>.table()</code>) or <code>Results.to_pandas()</code> when you need a <code>DataFrame</code> with consistent column names.</li> <li><code>res.segment[...]</code>, <code>res.event(...)</code>, and <code>res.observers</code> keep the slices you care about independent of the rest of the buffer so you can stream them into downstream analyzers without copying more than necessary.</li> </ul>"},{"location":"guides/simulation/results/#summary","title":"Summary","text":"<ul> <li>Use <code>Sim.results()</code> when you want ergonomic names and helpers, and fall back to <code>Sim.raw_results()</code> when you need the raw buffer.</li> <li>Explore segments, events, and observers through <code>ResultsView</code> to extract slices, and use <code>Results.to_pandas()</code> or stacking with <code>res[[\"x\",\"y\"]]</code> to hand trajectories to NumPy/Pandas.</li> <li>Tune <code>record</code>, <code>record_interval</code>, <code>record_vars</code>, and buffer caps before long runs to keep memory usage stable, then replay or export the events/segments you care about.</li> </ul>"},{"location":"guides/simulation/runner-variants/","title":"Runner Types","text":"<p>Understanding how the runner layer is structured makes it easier to reason about performance trade\u2011offs, observer support, and how the fast-path API diverges from the ordinary wrapper loop.</p>"},{"location":"guides/simulation/runner-variants/#ordinary-runners","title":"Ordinary runners","text":"<p><code>run_with_wrapper</code> (see <code>src/dynlib/runtime/wrapper.py</code>) orchestrates the default execution path. It:</p> <ul> <li>converts <code>Sim</code> knobs (t0/tend, adaptive flags, discrete horizons, stop phases, selective recording choices, observers, etc.) into buffers and scalar inputs that match the frozen runner ABI.</li> <li>allocates recording/event arrays and workspaces once, then calls a <code>RunnerVariant.BASE</code> or <code>RunnerVariant.ANALYSIS</code> runner through <code>runner_variants.get_runner</code>.</li> <li>handles runner signals such as <code>GROW_REC</code>, <code>GROW_EVT</code>, <code>DONE</code>, <code>EARLY_EXIT</code>, <code>USER_BREAK</code>, or <code>NAN_DETECTED</code>, growing buffers or pausing/resuming as needed so the compiled kernel never has to reallocate memory.</li> <li>copies final state/dt, traces, and observer metadata into a <code>Results</code> object before returning. The wrapper therefore keeps the hot loop lean and lets the compiled runner focus on numerical stepping.</li> </ul> <p>Because this path tracks events, variable recording lengths, stop phases, and growth codes, we call it the ordinary runner. It is the most flexible runner and the one used by <code>Sim.run</code> unless <code>fastpath</code> execution is explicitly requested. Both the continuous (ODE) and discrete (map) steppers share the ordinary runner templates (<code>RunnerVariant.BASE</code> or <code>RunnerVariant.ANALYSIS</code> with <code>discrete</code> flag), so the wrapper can handle time-based horizons and iteration-budget horizons with the same ABI.</p>"},{"location":"guides/simulation/runner-variants/#fast-path-runners","title":"Fast-path runners","text":"<p><code>runtime/fastpath/executor.py</code> drives the specialized, fixed-step path. The executor allocates everything upfront (workspaces, selective recording buffers, stop flags, variational hooks) and then calls <code>runner_variants.get_runner</code> with <code>RunnerVariant.FASTPATH</code> or <code>RunnerVariant.FASTPATH_ANALYSIS</code>.</p> <p>Fast-path runners are stripped down:</p> <ul> <li>no event-log growth or sticky buffer resizing\u2014everything is sized based on the chosen <code>RecordingPlan</code> (via <code>RecordingPlan.capacity</code>) before the first invocation.</li> <li>no <code>GROW_*</code> statuses; the runner assumes the buffers it received are large enough, which keeps the loop tight.</li> <li>no event/interruption loop inside the runner template itself; the executor is responsible for any preparatory transient warm-up, final trimming, and metadata construction.</li> </ul> <p>This makes fast-path runners ideal for repeated batch runs (<code>run_batch_fastpath</code>), throughput benchmarks, or any scenario where you can guarantee fixed-step sizes and memory caps. The executor still marshals observer traces, variational hooks, and runtime workspaces, but it does so outside the numerically hot loop.</p>"},{"location":"guides/simulation/runner-variants/#analysis-runners","title":"Analysis runners","text":"<p>Whenever observers are attached, both the ordinary and fast-path runners switch to an analysis variant:</p> <ul> <li><code>RunnerVariant.ANALYSIS</code> (wrapper path) and <code>RunnerVariant.FASTPATH_ANALYSIS</code> (fast-path path) inject the observer hooks as globals (<code>ANALYSIS_PRE</code> and <code>ANALYSIS_POST</code>) so the wrapper or executor does not need to pass function handles through the runner ABI.</li> <li><code>runner_variants.compile_analysis_hooks</code> resolves <code>ObserverModule.resolve_hooks</code>, pre-compiles both hooks (or uses a no-op fallback), and stores them in the <code>runner</code> cache key, which includes <code>analysis_signature_hash</code>.</li> <li>The analysis runners also wire up <code>analysis_ws</code>, <code>analysis_out</code>, and trace buffers, plus they honor <code>analysis.trace.record_interval()</code> and metadata such as <code>analysis_kind</code>, so users can capture side-channel data alongside the main simulation steps.</li> <li>Variational observers can supply a <code>runner_variational_step</code> callback that the runner calls instead of the default stepper, allowing hooks to adjust proposals without breaking JIT compatibility.</li> </ul> <p>The analysis runners inherit all of the base runner features (recording, stopping, growth) or fast-path simplifications, depending on the variant.</p> <p>-## Architecture Reference</p> <p><code>runner_variants.py</code> is the consolidated source of truth for every runner template. <code>Sim.run()</code> uses the base runner when no observers are attached, while <code>runtime/fastpath/executor.py</code> asks for analysis-aware fast-path runners when observers are present. Each executor/ordinary runner variant is separately cached so that fast-path batches and wrapper calls get their own compiled kernels.</p>"},{"location":"guides/simulation/runner-variants/#runner_variantspy","title":"<code>runner_variants.py</code>","text":"<ul> <li>Defines templates and compilation logic for all runner variants (<code>BASE</code>, <code>ANALYSIS</code>, <code>FASTPATH</code>, <code>FASTPATH_ANALYSIS</code>), covering both continuous and discrete models.</li> <li>Exposes <code>get_runner(variant, ...)</code>, which builds a cache key, injects observer hooks as globals, optionally JIT-compiles with Numba, and stores both LRU (in-memory) and on-disk runner caches.</li> <li>Responsible for generating Python source, bootstrapping analysis hooks, and ensuring the same runner templates back both <code>wrapper.py</code> and <code>executor.py</code>.</li> </ul>"},{"location":"guides/simulation/runner-variants/#executorpy-fast-path","title":"<code>executor.py</code> (fast-path)","text":"<ul> <li>Orchestrates fixed-step fast-path execution, allocating buffers, workspaces, optional transient warm-up, and result marshalling.</li> <li>Chooses runners with <code>get_runner(RunnerVariant.FASTPATH, ...)</code> or <code>RunnerVariant.FASTPATH_ANALYSIS</code> depending on observer presence.</li> <li>Supports single and batch execution (with optional parallelization) while leaving trajectory logic inside the shared runner templates.</li> <li>Finalizes observer traces/metadata so the caller receives the same analysis payloads as the ordinary wrapper path.</li> </ul>"},{"location":"guides/simulation/runner-variants/#runner-generation-via-runner_variantspy","title":"Runner generation via runner_variants.py","text":"<p><code>src/dynlib/compiler/codegen/runner_variants.py</code> is the single source of truth for every runner template. - <code>RunnerVariant</code> enumerates the four supported flavors: <code>BASE</code>, <code>ANALYSIS</code>, <code>FASTPATH</code>, <code>FASTPATH_ANALYSIS</code>. - <code>_RUNNER_TEMPLATE_MAP</code> pairs each variant and the continuous/discrete flag with the right template string and function name. - <code>get_runner</code> builds a cache key composed of <code>(model_hash, stepper_name, analysis_sig, variant, runner_kind, dtype, cache_token, jit flag, template version)</code> and looks in either <code>_variant_cache_continuous</code> or <code>_variant_cache_discrete</code>. - If the runner is missing, it synthesizes the source, optionally JIT-compiles it with Numba, injects the <code>ANALYSIS_PRE</code>/<code>ANALYSIS_POST</code> hook globals, and stores the callable in both the local LRU and the on-disk <code>runner_cache</code>. - <code>analysis_signature_hash</code> reduces each observer set to a stable 16-character hash so runners remain cachable even when observers resolve to dynamically generated hooks.</p> <p>Both the wrapper and the fast-path executor call <code>get_runner</code>, so adding a new runner variant (e.g., a variant that always writes to a special log or that fuses extra diagnostics) means adding a new template string, registering it in <code>_RUNNER_TEMPLATE_MAP</code>, and calling it from the appropriate execution path.</p>"},{"location":"guides/simulation/runner-variants/#fast-path-executor-responsibilities","title":"Fast-path executor responsibilities","text":"<p><code>executor.py</code> does more than call a runner:</p> <ul> <li>It implements <code>_RunContext</code>, <code>_WorkspaceBundle</code>, and <code>_call_runner</code>, which allocate the right buffers, manage cursor resets, and unify the call site between <code>run_single_fastpath</code>, <code>run_batch_fastpath</code>, and the optimized batch helpers.</li> <li>It selects the fast-path runner variant based on whether observers are provided and passes <code>analysis=None</code> or the actual observer module to <code>get_runner</code>, mirroring the wrapper\u2019s logic but in a more constrained setting.</li> <li>When observers are present, the executor still collects trace buffers, metadata (<code>build_observer_metadata</code>), and optional variational step callbacks so the runner can emit analysis output.</li> <li>Batch helpers optionally use a thread pool to run the same runner across multiple IC/parameter sets, relying on the fact that the compiled runner is jit\u2011safe and GIL-free.</li> </ul> <p>The separation means the fast-path executor and ordinary wrapper reuse the same templates and caching infrastructure but diverge in how much bookkeeping happens around the inner loop.</p>"},{"location":"guides/simulation/session-introspection/","title":"Session state &amp; printing","text":"<p><code>Sim</code> keeps a live <code>SessionState</code> so you can inspect or mutate the running session without tearing down the compiled model. This guide walks through the helpers that answer \"what is currently stored in the session?\", how to change it safely, and how to surface the underlying DSL equations when you need to print them. For more detailed inrospection see the <code>export_sources()</code> usage.</p>"},{"location":"guides/simulation/session-introspection/#inspecting-the-session-state","title":"Inspecting the session state","text":"<ul> <li><code>session_state_summary()</code> returns the current time (<code>t</code>), step count, nominal <code>dt</code>, stepper name, status, and whether <code>resume=True</code> is still allowed (<code>can_resume</code>/<code>reason</code>). It also includes the stored stepper config digest so you can detect whether a future <code>run()</code> call would reuse the same configuration.</li> <li><code>can_resume()</code> and <code>compat_check()</code> let you verify whether the runtime pins (spec hash, stepper, workspace signature, dtype, dynlib version) match the active model before trying to continue a session.</li> <li>The summary is a great way to build dashboards or logging right after <code>run()</code> finishes or before constructing a <code>Snapshot</code>.</li> </ul>"},{"location":"guides/simulation/session-introspection/#example","title":"Example","text":"<pre><code>summary = sim.session_state_summary()\nprint(f\"Current time {summary['t']} (step {summary['step']})\")\nif not summary[\"can_resume\"]:\n    print(\"Resume unavailable:\", summary[\"reason\"])\n</code></pre>"},{"location":"guides/simulation/session-introspection/#mutating-session-values-mid-flight","title":"Mutating session values mid-flight","text":"<p><code>Sim.assign(...)</code> updates states and parameters by name without changing time, the workspace, or results history (unless you explicitly clear it). The method infers names from the model, offers \"did you mean\" hints, coerces values to the model dtype, and throws if you try to mutate unknown variables.</p> <ul> <li>Pass a mapping or keywords: <code>sim.assign(v=-65.0, I=12.0)</code> keeps the same session time but tweaks the next run's initial values.</li> <li>Use <code>clear_history=True</code> to drop the accumulated results/segments while keeping the current <code>SessionState</code>. This is useful when you want to start a new recording without resetting to an earlier snapshot.</li> </ul> <pre><code>sim.assign({\"v\": -70.0, \"I\": 10.0}, clear_history=True)\nsim.run(T=1.0, record=True)\n</code></pre>"},{"location":"guides/simulation/session-introspection/#exporting-and-printing-numeric-values","title":"Exporting and printing numeric values","text":"<p>Several helpers let you read state/parameter vectors or dictionaries from the session, the model spec, or a named snapshot:</p> <ul> <li><code>state_vector(source='session', copy=True)</code> / <code>param_vector(...)</code> return 1\u2011D NumPy arrays in the DSL declaration order. <code>source</code> can be <code>\"session\"</code>, <code>\"model\"</code>, or <code>\"snapshot\"</code>, and <code>copy=False</code> gives a view into the underlying storage if you need to mutate values directly.</li> <li><code>state_dict(...)</code> / <code>param_dict(...)</code> wrap the above arrays into <code>name -&gt; float</code> maps for quick logging or JSON serialization.</li> <li><code>state(name)</code> / <code>param(name)</code> read a single scalar from the current session with helpful suggestions when you mistype a name.</li> </ul> <pre><code>print(sim.state_dict())  # session values as a dict\nprint(sim.param_vector(source=\"model\"))  # model defaults as ndarray\nsnapshot_states = sim.state_vector(source=\"snapshot\", snapshot=\"initial\")\n\nprint(sim.state(\"v\"))  # scalar lookup\n</code></pre> <p>These helpers are useful when producing debug prints halfway through a run, rendering UI panels, or exporting checkpoint metadata alongside a snapshot or preset.</p>"},{"location":"guides/simulation/session-introspection/#printing-the-dsl-equations","title":"Printing the DSL equations","text":"<p><code>FullModel.print_equations()</code> reflects the original DSL specification (not the generated runner) so you can include pretty-printed equations in docs or logs.</p> <ul> <li><code>tables</code> selects which TOML tables to render: the default <code>\"equations\"</code> table shows the main dynamics, but you can pass other registered tables (<code>\"equations.inverse\"</code>, <code>\"equations.jacobian\"</code>, etc.) or use <code>tables=\"all\"</code> to print everything.</li> <li><code>include_headers</code> toggles whether section titles appear, and <code>file=</code> lets you redirect output to any writable stream.</li> <li><code>FullModel.available_equation_tables()</code> lists all registered keys so you can validate what you can request.</li> </ul> <pre><code>model.print_equations()  # prints the main equations with headers\n\nwith open(\"equations.txt\", \"w\") as out:\n    model.print_equations(tables=\"all\", include_headers=False, file=out)\n\nprint(FullModel.available_equation_tables())\n</code></pre> <p>Combining <code>print_equations()</code> with <code>session_state_summary()</code> or <code>state_dict()</code> makes it easy to produce reproducible reports that tie the numeric state to the exact equations that generated it.</p>"},{"location":"guides/simulation/snapshots-and-resume/","title":"Snapshots &amp; Resume","text":"<p><code>Sim</code> keeps a live <code>SessionState</code> that encapsulates time, states, parameters, the stepper workspace, and runtime metadata. Snapshots capture that state at a point in time so you can rewind, branch, or serialize a simulation, while <code>run(resume=True)</code> lets you grow recorded segments without rebuilding the model from scratch.</p>"},{"location":"guides/simulation/snapshots-and-resume/#snapshot-fundamentals","title":"Snapshot fundamentals","text":"<ul> <li>Initial snapshot: The <code>\"initial\"</code> snapshot is created automatically before the first <code>run()</code> so you always have a known starting point to fall back to.</li> <li><code>create_snapshot(name, description=\"\u2026\")</code>: Clones the current <code>SessionState</code>, records the current <code>time_shift</code>/<code>dt</code>, stamps the snapshot with <code>name</code>/<code>description</code>, and saves the full workspace + stepper config. Duplicate names raise an error, so pick descriptive identifiers.</li> <li><code>list_snapshots()</code> returns <code>name</code>, simulation time <code>t</code>, step count, creation timestamp, and any description you provided.</li> <li><code>compat_check(snapshot)</code> compares <code>SessionPins</code> (spec hash, stepper, workspace signature, dtype, dynlib version) to guarantee a snapshot comes from a compatible build. <code>reset()</code> uses the same guard and will fail fast when the model, stepper, or dtype has changed.</li> </ul> <p>Snapshots are lightweight to create and cheap to keep around, so take one whenever you hit a milestone (e.g., after applying a stimulus, finishing a parameter sweep, etc.).</p>"},{"location":"guides/simulation/snapshots-and-resume/#resetting-and-restarting","title":"Resetting and restarting","text":"<ul> <li><code>reset(name=\"initial\")</code> rolls the session back to a named snapshot and wipes recorded history, segments, pending run tags, and resume state. It restores <code>_time_shift</code> and <code>_nominal_dt</code> from the snapshot so that future <code>run()</code> calls start from that exact moment.</li> <li>After <code>reset</code>, the recorder is cleared, which also resets the stored <code>record_vars</code> selection, so you can choose a different subset of variables before the next run.</li> <li><code>session_state_summary()</code> reports <code>can_resume</code>/<code>reason</code>, letting you query whether <code>resume=True</code> is allowed without triggering the run logic.</li> </ul>"},{"location":"guides/simulation/snapshots-and-resume/#running-and-resuming","title":"Running and resuming","text":"<p><code>Sim.run(resume=True)</code> continues from the most recent <code>SessionState</code> instead of restarting integration from <code>t0</code>. Key behaviors:</p> <ol> <li>Session continuity: The workspace, stepper configuration, and <code>time_shift</code> from the previous run are preserved, so the next segment feels like an uninterrupted extension in both deterministic and adaptive steppers.</li> <li>Recording constraints: You cannot override <code>ic</code>, <code>params</code>, <code>t0</code>, or <code>dt</code>, so <code>resume</code> always starts where the session left off. Warm-up <code>transient &gt; 0</code> is disallowed because resume segments must continue immediately. <code>record_vars</code> cannot be re-specified either; the first recorded run after a <code>reset</code> fixes the variable list and every subsequent <code>resume</code> run reuses that list automatically.</li> <li>Segment tracking: Each recorded run appends a <code>Segment</code> entry describing <code>t_start</code>, <code>t_end</code>, <code>step_start</code>, <code>step_end</code>, and whether the chunk was produced via resume. Pass <code>tag=\"label\"</code> to the <code>run()</code> call to assign a friendly name\u2014<code>run#0</code>, <code>run#1</code>, etc. are generated otherwise. Rename with <code>name_segment()</code> or <code>name_last_segment()</code> when you need human-readable labels for <code>ResultsView</code>.</li> <li>Results stitching: Resume reuses the same <code>_ResultAccumulator</code>, so <code>raw_results()</code>/<code>results()</code> see a seamless time-series spanning every segment. <code>run(resume=True)</code> throws if the requested horizon does not extend beyond the current time, avoiding overlaps.</li> <li>Compatibility guard: Before resuming, <code>can_resume()</code> compares the current pins to those captured in the <code>SessionState</code>. If it returns <code>(False, reason)</code>, rewrite the simulation by calling <code>reset()</code> or rebuild with a compatible <code>FullModel</code>.</li> <li>No parameter overrides inside resume: For a resumed segment you cannot pass new <code>ic</code>, <code>params</code>, <code>t0</code>, or <code>dt</code>. The run keeps the parameters, stepper workspace, and timing from the previous segment, so changing values requires a reset, snapshot, or a separate <code>run()</code> call that does not set <code>resume=True</code>.</li> </ol> <p>Typical pattern:</p> <pre><code>sim.run(T=2.0, record=True, tag=\"phase-1\")\nsim.create_snapshot(\"phase-1\", \"after the first stimulus\")\n\n# Continue without rebuilding; the second run is appended\nsim.run(T=5.0, resume=True, tag=\"phase-2\")\n\n# Start a different branch by resetting to the saved snapshot\nsim.reset(\"phase-1\")\nsim.run(T=3.0, record=True, tag=\"phase-1-replay\")\n</code></pre> <p>If you need to change parameters between segments, do so before the resumed run: reset to an earlier snapshot, <code>assign()</code> the new parameter/state values (or import a snapshot that already encodes them), then run without <code>resume</code> or call <code>run(resume=True)</code> once the new values are in place. Resume never accepts <code>ic</code>, <code>params</code>, <code>t0</code>, or <code>dt</code> overrides, so any new configuration must be done via snapshots/assignments that happen before the resumed segment starts.</p>"},{"location":"guides/simulation/snapshots-and-resume/#examples-of-changing-parameters-between-segments","title":"Examples of changing parameters between segments","text":"<p>Example 1: Branching with parameter changes (no resume)</p> <pre><code># Run initial segment\nsim.run(T=2.0, record=True, tag=\"baseline\")\n\n# Create snapshot at end of first segment\nsim.create_snapshot(\"after-baseline\", \"End of baseline run\")\n\n# Reset to snapshot and change a parameter\nsim.reset(\"after-baseline\")\nsim.assign(I=15.0)  # Change input current parameter\n\n# Run new segment with modified parameter (starts fresh recording)\nsim.run(T=3.0, record=True, tag=\"modified-current\")\n</code></pre> <p>Example 2: Continuing with parameter changes (using resume)</p> <pre><code># Run first segment\nsim.run(T=2.0, record=True, tag=\"phase-1\")\n\n# Create snapshot\nsim.create_snapshot(\"phase-1-end\", \"End of phase 1\")\n\n# Reset and modify parameters\nsim.reset(\"phase-1-end\")\nsim.assign(a=0.02, b=0.25)  # Change Izhikevich parameters\n\n# Continue from the reset point with new parameters\nsim.run(T=5.0, resume=True, tag=\"phase-2-modified\")\n</code></pre> <p>Example 3: Using <code>assign()</code> with <code>clear_history=True</code> to start fresh</p> <p>The <code>assign()</code> method has an optional <code>clear_history</code> parameter. When <code>clear_history=True</code>, it clears all previous results and segments while preserving the current session state (time, workspace, etc.) with the new assigned values. This effectively allows you to create a new segment without resetting to a snapshot:</p> <pre><code># Run initial segment\nsim.run(T=2.0, record=True, tag=\"initial\")\n\n# Assign new parameter values and clear history to start fresh recording\nsim.assign(I=20.0, clear_history=True)\n\n# This run creates a new segment (since history was cleared)\nsim.run(T=3.0, record=True, tag=\"new-segment\")\n</code></pre> <p>Note that <code>clear_history=True</code> does not change the simulation time or workspace state\u2014it only clears the recorded results, allowing the next <code>run()</code> to start a new segment from the current session state.</p>"},{"location":"guides/simulation/snapshots-and-resume/#persistence-and-portability","title":"Persistence and portability","text":"<ul> <li><code>export_snapshot(path, source=\"current\" | \"snapshot\", name=...)</code> writes a <code>.npz</code> file containing:</li> <li><code>meta.json</code> (schema version, pins, names, time/step counters, <code>time_shift</code>, <code>nominal_dt</code>, stepper config names/values)</li> <li><code>y</code> and <code>params</code> vectors</li> <li>Workspace buckets (<code>workspace/runtime/&lt;name&gt;</code>, <code>workspace/stepper/&lt;name&gt;</code>) and <code>stepper_config</code> if present</li> <li>The write happens atomically via a temporary file so partial writes never corrupt existing snapshots.</li> <li><code>inspect_snapshot(path)</code> reads <code>meta.json</code> without changing the session, letting you verify compatibility before importing.</li> <li><code>import_snapshot(path)</code> replaces the current session state with the contents of a snapshot file, clears results/segments, resets <code>_time_shift</code>/<code>_nominal_dt</code>, and rejects files whose pins do not match the active model.</li> </ul> <p>Use export/import when you need to checkpoint a long computation, share a resume point with a colleague, or persist workflow state between CI runs.</p>"},{"location":"guides/simulation/snapshots-and-resume/#segment-naming-and-resume-metadata","title":"Segment naming and resume metadata","text":"<ul> <li>Each <code>Segment</code> carries a <code>cfg_hash</code> (stepper configuration digest) plus <code>resume</code> flag so downstream tools can tell whether a chunk was created during a fresh run or via <code>resume</code>.</li> <li>Use <code>tag</code> on <code>run()</code> or <code>name_segment()</code> afterward to keep your <code>segments</code> listing readable; <code>ResultsView</code> exposes these names so you can quickly extract the portion you care about.</li> <li>When you reset, the segment list empties, but snapshots remain. Continue appending segments only with <code>resume=True</code>\u2014otherwise <code>run()</code> clears the accumulator and starts a new recording pass.</li> </ul> <p>Snapshot and resume controls keep your experiments reproducible: take snapshots at branch points, reset to them when you need to test variations, and resume to build long trajectories without losing history.</p>"},{"location":"guides/simulation/steppers/","title":"Steppers","text":"<p><code>dynlib</code> uses steppers to advance one simulation step. They are mostly integrators but they are not called integrators or solvers because a map type stepper is used to advance discrete maps. Also ODE integrators / solvers might not be suitable for future dynamical system types. Choose the stepper that matches your problem class (ODE vs map), time-control strategy (fixed vs adaptive), and numerical scheme (explicit, implicit, splitting). You can override the model default via <code>build(..., stepper=\"rk4\")</code> or, for the fast path in application code, <code>setup(..., stepper=\"rk4\")</code>. Every compiled <code>Model</code> or <code>Sim</code> surface exposes <code>model.stepper_name</code> so you can confirm which integrator was selected after compilation.</p>"},{"location":"guides/simulation/steppers/#choosing-a-stepper","title":"Choosing a Stepper","text":"<p>There are three axes you should always check before running a simulation:</p> <ul> <li>Kind (<code>Kind = \"ode\" | \"map\"</code>) describes the mathematical nature of the stepper. ODE steppers expect an RHS <code>f(t, y)</code> and multiply by <code>dt</code>, while the <code>map</code> stepper treats the compiled callable as a discrete update that already returns the next state (dt is only a label).</li> <li>Time control (<code>TimeCtrl = \"fixed\" | \"adaptive\"</code>) determines whether the integrator advances with a constant <code>dt</code> or internally retries and resizes the step. Adaptive steppers (RK45, BDF2a, TR-BDF2a) expose <code>atol/rtol</code> tolerant controls, while fixed-step steppers rely on the driver <code>Sim.run()</code> arguments.</li> <li>Scheme (<code>Scheme = \"explicit\" | \"implicit\" | \"splitting\"</code>) is the algebraic structure of the method. Explicit steppers have no nonlinear solves, whereas implicit steppers (SDIRK2, BDF2, BDF2a, TR-BDF2a) call Newton iterations and usually support optional analytic Jacobians. Splitting schemes will show up in the future.</li> </ul> <p>The combination of these axes plus the <code>family</code>/<code>order</code> metadata in each <code>StepperMeta</code> gives you a concise view of what is physically happening. If you need Jacobians, dense output, or variational stepping for Lyapunov analysis, look at the <code>StepperCaps</code> block (in the docs we expose <code>dense_output</code>, <code>jacobian</code>, <code>jit_capable</code>, <code>requires_scipy</code>, and <code>variational_stepping</code> flags).</p>"},{"location":"guides/simulation/steppers/#available-steppers","title":"Available Steppers","text":"<p>| Name      | Kind | Time control | Scheme | Order | Key notes | | <code>map</code>     | map | fixed    | explicit | 1  | Discrete iterates (<code>F(t, y)</code> returns next state). <code>dt</code> only labels time. | | <code>euler</code>   | ode | fixed    | explicit | 1  | Forward Euler, minimal workspace, variational-stepping capable. | | <code>rk2</code>     | ode | fixed    | explicit | 2  | Explicit midpoint (RK2) with simple 2-stage update and variational support. | | <code>rk4</code>     | ode | fixed    | explicit | 4  | Classic Runge\u2013Kutta 4th order, alias <code>rk4_classic</code>, <code>classical_rk4</code>. | | <code>rk45</code>    | ode | adaptive | explicit | 5\u00b9 | Dormand\u2013Prince RK45 with embedded order 4 error estimate. | | <code>ab2</code>     | ode | fixed    | explicit | 2  | Adams\u2013Bashforth 2 multistep with Heun startup, maintains derivative history. | | <code>ab3</code>     | ode | fixed    | explicit | 3  | Adams\u2013Bashforth 3 with a two-step startup that hands control over to the multistep loop. | | <code>sdirk2</code>  | ode | fixed    | implicit | 2  | Alexander SDIRK2 (\u03b3 = (2\u2212\u221a2)/2), stiffly accurate but requires Jacobians. | | <code>bdf2</code>    | ode | fixed    | implicit | 2  | Implicit BDF2 with Newton solver; optionally accepts external Jacobians. | | <code>bdf2a</code>   | ode | adaptive | implicit | 2  | Variable-step BDF2 with error estimation. | | <code>tr-bdf2a</code>| ode | adaptive | implicit | 2  | TR-BDF2 adaptive integrator (L-stable, BE partner) with the same config knobs as <code>bdf2a</code>. |</p> <p>\u00b9 Embedded order: 4 (error estimate). Adaptive steppers override <code>dt</code> internally but still report <code>dt_next</code> for the runner.</p> <p>Each canonical stepper name is registered once; aliases such as <code>forward_euler</code>, <code>rk4_classic</code>, <code>trbdf2a</code>, and <code>sdirk2_jit</code> are automatically mapped to the same spec. Use the canonical name to avoid surprises when sharing configs or presets.</p> <p>For maps you don't have to explicitly define <code>stepper=map</code>. For ODE models <code>rk4</code> is the default stepper.</p>"},{"location":"guides/simulation/steppers/#stepper-registry-discovery","title":"Stepper Registry &amp; Discovery","text":"<p>The stepper registry is both user-facing and developer-facing. It is populated automatically when the stepper modules import, but you can also register custom specs with <code>dynlib.register()</code> if you need a specialized method.</p> <pre><code>from dynlib import list_steppers, select_steppers, get_stepper\n\nprint(list_steppers(kind=\"ode\"))\ninfos = select_steppers(scheme=\"implicit\", stiff=True, jit_capable=True)\nprint([info.name for info in infos])\nspec = get_stepper(\"rk45\")\nprint(spec.meta.order, spec.meta.aliases)\n</code></pre> <p><code>list_steppers()</code> returns sorted canonical names and accepts the same keyword filters as <code>select_steppers()</code> (kind, scheme, stiff, jit_capable, etc.). <code>select_steppers()</code> yields <code>StepperInfo</code> instances (aliased to <code>StepperMeta</code>), and you can also pass <code>name_pattern</code> or a custom <code>predicate</code> for fine-grained discovery (e.g., look for options that support variational stepping or dense-output).</p> <p>The CLI mirrors the Python API: <code>dynlib steppers list</code> prints the same canonical names, and available flags mirror the keyword filters you saw above so you can narrow the output (for example by kind or scheme).</p>"},{"location":"guides/simulation/steppers/#stepper-metadata-fields","title":"Stepper metadata fields","text":"<ul> <li><code>name</code>: canonical stepper name (aliases resolve to this spec).</li> <li><code>kind</code>: <code>ode</code> vs <code>map</code>.</li> <li><code>time_control</code>: <code>fixed</code> or <code>adaptive</code>.</li> <li><code>scheme</code>: <code>explicit</code>, <code>implicit</code>, or <code>splitting</code>.</li> <li><code>geometry</code>: reserved set for geometry-aware methods (currently empty for built-in steppers).</li> <li><code>family</code>: classification such as <code>runge-kutta</code>, <code>adams-bashforth</code>, <code>bdf</code>, <code>dirk</code>, <code>tr-bdf2</code>, or <code>iter</code>.</li> <li><code>order</code>, <code>embedded_order</code>: describe the primary and embedded accuracy.</li> <li><code>stiff</code>: indicates whether the method is intended for stiff problems.</li> <li><code>aliases</code>: other names that map to the canonical spec.</li> <li><code>caps</code>: see below.</li> </ul>"},{"location":"guides/simulation/steppers/#stepper-capability-flags-steppercaps","title":"Stepper capability flags (<code>StepperCaps</code>)","text":"<ul> <li><code>dense_output</code>: supports continuous interpolation / dense output (currently False for built-ins).</li> <li><code>jacobian</code>: <code>\"none\" | \"internal\" | \"optional\" | \"required\"</code> describes how the stepper consumes external Jacobians.</li> <li><code>jit_capable</code>: true for all built-in steppers; false if the method relies on foreign dependencies.</li> <li><code>requires_scipy</code>: true if SciPy is needed.</li> <li><code>variational_stepping</code>: indicates support for <code>emit_step_with_variational()</code> (used in Lyapunov analysis).</li> </ul> <p>The registry helpers (<code>list_steppers</code>, <code>select_steppers</code>) accept these metadata fields as filters. For example, <code>select_steppers(kind=\"ode\", variational_stepping=True)</code> returns only ODE steppers that also implement the variational interface.</p>"},{"location":"guides/simulation/steppers/#stepper-workspace","title":"Stepper Workspace","text":"<p>The stepper workspace is a private, stepper-specific scratch area that lives alongside the runtime metadata. Each stepper defines a NamedTuple that describes the arrays it needs during a single step. The workspace is allocated once per simulation via the stepper\u2019s <code>make_workspace(n_state, dtype)</code> hook and reused for every step.</p>"},{"location":"guides/simulation/steppers/#key-characteristics","title":"Key characteristics","text":"<ul> <li>Ownership: private to each stepper spec and passed as <code>stepper_ws</code> to the ABI.</li> <li>Lifetime: persistent until the <code>Sim</code> is destroyed or the workspace memory is explicitly freed.</li> <li>Content: NumPy arrays, e.g., stage buffers, derivative histories, Jacobian scratch, Newton guesses.</li> <li>Allocation: driven by the stepper\u2019s <code>workspace_type()</code> and <code>make_workspace()</code>.</li> <li>Type: a <code>NamedTuple</code> so fields are accessed by name instead of by index.</li> </ul>"},{"location":"guides/simulation/steppers/#example-workspace-layouts","title":"Example workspace layouts","text":""},{"location":"guides/simulation/steppers/#euler-workspace","title":"Euler workspace","text":"<pre><code>class Workspace(NamedTuple):\n    dy: np.ndarray\n    kv: np.ndarray\n</code></pre>"},{"location":"guides/simulation/steppers/#rk4-workspace","title":"RK4 workspace","text":"<pre><code>class Workspace(NamedTuple):\n    y_stage: np.ndarray\n    k1: np.ndarray\n    k2: np.ndarray\n    k3: np.ndarray\n    k4: np.ndarray\n    v_stage: np.ndarray\n    kv1: np.ndarray\n    kv2: np.ndarray\n    kv3: np.ndarray\n    kv4: np.ndarray\n</code></pre>"},{"location":"guides/simulation/steppers/#rk45-workspace-adaptive","title":"RK45 workspace (adaptive)","text":"<pre><code>class Workspace(NamedTuple):\n    y_stage: np.ndarray\n    k1: np.ndarray\n    k2: np.ndarray\n    k3: np.ndarray\n    k4: np.ndarray\n    k5: np.ndarray\n    k6: np.ndarray\n    k7: np.ndarray\n</code></pre>"},{"location":"guides/simulation/steppers/#workspace-allocation","title":"Workspace allocation","text":"<p>Steppers implement <code>make_workspace(n_state, dtype, model_spec=None)</code> to instantiate the NamedTuple and zero-initialize the arrays. The <code>workspace_type()</code> hook informs tooling (e.g., the compiler) how to pack the workspace into serialized snapshots, and <code>variational_workspace()</code> is available when the stepper supports Lyapunov/variational analysis.</p>"},{"location":"guides/simulation/steppers/#why-every-stepper-needs-rhs-arrays","title":"Why every stepper needs RHS arrays","text":"<p>Whatever the scheme, the stepper needs to store one or more evaluations of <code>f(t, y)</code> so it can combine them into a proposal. The workspace keeps these RHS buffers (<code>dy</code> for Euler, <code>k1..k4</code> for RK4, <code>f_prev/f_curr</code> for AB2/AB3, Newton residuals for implicit steppers). Every method writes the derivative vectors into its own slots, then assembles <code>y_prop</code>, <code>t_prop</code>, <code>dt_next</code>, and <code>err_est</code>.</p>"},{"location":"guides/simulation/steppers/#runtime-workspace","title":"Runtime Workspace","text":"<p>The runtime workspace handles lag buffers and other DSL machinery state, separate from stepper scratch space.</p>"},{"location":"guides/simulation/steppers/#structure","title":"Structure","text":"<pre><code>RuntimeWorkspace = namedtuple(\n    \"RuntimeWorkspace\",\n    [\"lag_ring\", \"lag_head\", \"lag_info\"],\n)\n</code></pre> <ul> <li><code>lag_ring</code>: circular buffer storing historical state snapshots.</li> <li><code>lag_head</code>: current head indices used for each lagged state.</li> <li><code>lag_info</code>: metadata describing the layout of each lag (state index, depth, offset).</li> </ul> <p>Lag buffers are accessed with runtime helpers inside generated code, e.g.:</p> <pre><code>prev_x = lag_value(runtime_ws, state_idx=0, lag_steps=1)\n</code></pre>"},{"location":"guides/simulation/steppers/#workspace-design-benefits","title":"Workspace design benefits","text":"<ul> <li>Separation of concerns: stepper scratch stays isolated from runtime metadata.</li> <li>Type safety: NamedTuple workspaces carry descriptive field names instead of numeric offsets.</li> <li>Flexibility: each stepper shapes its workspace to exactly the buffers it needs.</li> <li>Safety: runtime workspaces reserve their own head slots, so lag buffers never interfere with stepper scratch.</li> </ul>"},{"location":"guides/simulation/steppers/#stepper-abi","title":"Stepper ABI","text":"<p>The compiled stepper callable follows a fixed ABI so the runner and results infrastructure can stay generic. The signature is:</p> <pre><code>status = stepper(\n    t: float,\n    dt: float,\n    y_curr: float[:],\n    rhs,\n    params: float[:] | int[:],\n    runtime_ws,\n    stepper_ws,\n    stepper_config: float64[:],\n    y_prop: float[:],\n    t_prop: float[:],\n    dt_next: float[:],\n    err_est: float[:],\n) -&gt; int32\n</code></pre> <ul> <li><code>rhs</code>: compiled RHS function the stepper repeatedly invokes.</li> <li><code>runtime_ws</code>: shared runtime workspace for lag buffers and metadata.</li> <li><code>stepper_ws</code>: the Active stepper workspace described above.</li> <li><code>stepper_config</code>: config array packed from the stepper\u2019s dataclass (use <code>pack_config()</code>).</li> <li><code>y_prop</code>, <code>t_prop</code>, <code>dt_next</code>, <code>err_est</code>: output buffers that the runner consumes after each call.</li> </ul> <p>Adaptive steppers rewrite <code>dt_next</code> and <code>err_est</code> before the runner accepts the step, while fixed-step steppers usually write the current <code>dt + t</code> and zero error.</p>"},{"location":"guides/simulation/steppers/#workspace-serialization","title":"Workspace Serialization","text":"<p>Stepper workspaces are serializable so you can snapshot a running simulation and restore it later. Use the helper functions that capture the workspace arrays when taking a snapshot:</p> <pre><code>snapshot = snapshot_workspace(stepper_ws)\nrestore_workspace(stepper_ws, snapshot)\n</code></pre> <p>Snapshots capture both the runtime workspace and the stepper workspace so you can pause, rewind, or branch simulations with exact stepper state.</p>"},{"location":"guides/simulation/steppers/#variational-stepping-overview","title":"Variational Stepping Overview","text":"<p>Some steppers support a combined state + tangent integration path that is useful for Lyapunov, sensitivity, or variational analyses. Look for <code>StepperSpec</code> implementations that set <code>StepperCaps(variational_stepping=True)</code>; they expose a <code>variational_workspace()</code> hook and <code>emit_step_with_variational()</code> method. Those facilities keep extra tangent buffers next to the state workspace, let you invoke the Jacobian-vector product (<code>jvp_fn</code>) in lockstep with the state RHS, and keep the tangent state synchronized with <code>y_prop</code>. When you need Lyapunov exponents or other variational diagnostics, choose one of these steppers (Euler, RK2, RK4, RK45, AB2, AB3, etc.) and call the variational stepping helpers rather than manually chaining the state and tangent integrators.</p>"},{"location":"guides/simulation/steppers/#extending-steppers-developer-guide","title":"Extending Steppers (Developer Guide)","text":"<p>For contributors who need a custom integrator or map, the <code>dynlib</code> stepper stack is intentionally modular. A new stepper spec simply implements the <code>StepperSpec</code> protocol, registers itself, and optionally exposes runtime configuration via <code>ConfigMixin</code>.</p>"},{"location":"guides/simulation/steppers/#1-define-the-metadata-and-capabilities","title":"1. Define the metadata and capabilities","text":"<ul> <li>Create a <code>StepperMeta</code> that describes the new method: canonical <code>name</code>, <code>kind</code>, <code>time_control</code>, <code>scheme</code>, <code>family</code>, <code>order</code>, <code>stiff</code>, and any <code>aliases</code>.</li> <li>Provide a <code>StepperCaps</code> instance that advertises optional behaviors (<code>dense_output</code>, <code>jacobian</code>, <code>jit_capable</code>, <code>requires_scipy</code>, <code>variational_stepping</code>). These flags are used by <code>select_steppers()</code>/<code>list_steppers()</code> and CLI filters, so set them truthfully for tooling discoverability.</li> </ul>"},{"location":"guides/simulation/steppers/#2-implement-the-spec-use-configmixin-when-you-need-runtime-knobs","title":"2. Implement the spec (use <code>ConfigMixin</code> when you need runtime knobs)","text":"<pre><code>class MyStepperSpec(ConfigMixin):\n    @dataclass\n    class Config:\n        tol: float = 1e-6\n        max_iter: int = 20\n        __enums__ = {\"method\": {\"foo\": 0, \"bar\": 1}}\n\n    def __init__(self, meta: StepperMeta | None = None):\n        self.meta = meta or StepperMeta(\n            name=\"my_stepper\",\n            kind=\"ode\",\n            time_control=\"fixed\",\n            scheme=\"explicit\",\n            family=\"custom\",\n            order=2,\n            stiff=False,\n            caps=StepperCaps(jit_capable=True, variational_stepping=True),\n        )\n\n    def workspace_type(self) -&gt; type | None:\n        return MyStepperWorkspace\n\n    def make_workspace(...):\n        ...\n\n    def emit(...):\n        ...\n</code></pre> <ul> <li><code>ConfigMixin</code> automatically implements <code>config_spec()</code>, <code>default_config()</code>, <code>pack_config()</code> and <code>config_enum_maps()</code> based on the nested <code>Config</code> dataclass, so you only need to declare the fields you care about.</li> <li>Inside <code>emit</code>, read <code>stepper_config</code> (packed float array) to apply runtime overrides, defaulting to <code>default_config(model_spec)</code> for values left unspecified by the user.</li> </ul>"},{"location":"guides/simulation/steppers/#3-workspace-combinatorial-helpers","title":"3. Workspace &amp; combinatorial helpers","text":"<ul> <li>Describe the workspace layout as a <code>NamedTuple</code> with NumPy arrays for stage buffers, histories, Jacobian scratch, or Newton residuals. <code>workspace_type()</code> exposes this layout, while <code>make_workspace(n_state, dtype)</code> zero-initializes the buffers.</li> <li>If the stepper supports Lyapunov/variational analysis, implement <code>variational_workspace()</code> to describe the analysis scratch (see <code>EulerSpec.variational_workspace()</code> for a pattern).</li> </ul>"},{"location":"guides/simulation/steppers/#4-register-the-spec","title":"4. Register the spec","text":"<p>Register the stepper with the global registry so it becomes discoverable to <code>build()</code>, <code>setup()</code>, and <code>dynlib steppers list</code>.</p> <pre><code>from dynlib import register\n\nregister(MyStepperSpec())\n</code></pre> <p>Call <code>register()</code> once (typically at module import time) using the canonical spec instance. Canonical names and aliases are deduplicated by the registry helpers.</p>"},{"location":"guides/simulation/steppers/#5-testing-and-cli-visibility","title":"5. Testing and CLI visibility","text":"<ul> <li>Prepare tests like <code>test_&lt;stepper_name&gt;_basic.py</code> or add the stepper into the parameter list of existing tests like <code>test_ode_stepper_contract.py</code>.</li> <li>Update the CLI or presets if you want the stepper to appear in <code>dynlib steppers list</code> examples.</li> </ul> <p>Following this flow keeps user-visible metadata, config, ABI, and workspace wiring aligned with the built-in steppers, making your custom integrator pluggable into the existing tooling.</p>"},{"location":"guides/simulation/wrapper-and-runner/","title":"Wrapper and Runner Interaction","text":"<p>The main simulation scheme is organized as follows: wrapper \u2283 runner \u2283 stepper. Runner and stepper form a jittable simulation kernel. This kernel is designed for numba compatibility, so it runs in a tight loop without complex python operations. <code>emit()</code> method of the stepper provides the stepper side calculator of this kernel. It returns a jittable function. At each simulation step runner calls this function. Stepper function has its own internal loop. It can retry until a successful next step value is obtained. At each step, runner checks the status of stepper result, buffers, recordings etc. If an unusual event occurs before the simulation finishes, it can pause the simulation and return all responsibility to the wrapper with a status code. Wrapper investigtates the status code and performs the necessary action that can't be performed with a jittable kernel (like buffer reallocation). After the necessary action wrapper restarts the runner (unless the status is terminal).</p> <p>Below the details of this scheme are explained.</p>"},{"location":"guides/simulation/wrapper-and-runner/#responsibilities-in-the-stack","title":"Responsibilities in the stack","text":"<ul> <li><code>Sim._execute_run</code> prepares seeds, recording selections, stop-phase masks, and workspace hints before calling <code>run_with_wrapper</code>.  The wrapper therefore sees the same inputs that <code>Sim.run</code> would, along with the compiled callables and <code>[sim]</code> defaults it needs to drive execution (<code>src/dynlib/runtime/sim.py:2339</code>).</li> <li><code>run_with_wrapper</code> then becomes the conductor: it reserves recording/event buffers, workspaces, observer hooks, and stepping parameters before every runner invocation (<code>src/dynlib/runtime/wrapper.py:34</code>).  This keeps the hot runner loop lean and focused on stepping, while the wrapper handles setup, growth, and post-processing.</li> </ul>"},{"location":"guides/simulation/wrapper-and-runner/#what-the-wrapper-does","title":"What the wrapper does","text":"<ol> <li>Allocate and seed every workspace. Runtime and stepper workspaces are created once and optionally seeded from <code>seed.workspace</code> to enable resume scenarios.</li> <li>Manage recording &amp; event pools. The wrapper slices recording arrays just for the selected state/aux indices, allocates event-log buffers with the requested <code>max_log_width</code>, and keeps cursor ints for runner results.</li> <li>Triage execution configuration. It translates <code>Sim</code> knobs (dt, adaptive flags, discrete horizons, WRMS picks, stop phases, observer modules) into the inputs the runner needs, including the initial <code>dt_curr</code>, stop-phase mask, and which runner variant to load.</li> <li>Wire up analysis &amp; observers. If observers are registered, the wrapper allocates their workspaces, trace buffers, and variational hooks, then packages metadata so the rest of the runtime can e.g. add diagnostics after the runner returns.</li> <li>Drive the runner loop. Inside <code>while True</code>, it repeatedly calls the compiled runner, passes the buffers it owns, and responds to the status codes the runner returns.</li> </ol>"},{"location":"guides/simulation/wrapper-and-runner/#runner-abi-contract","title":"Runner ABI contract","text":"<p>The runner is a JIT-friendly callable that knows nothing about recordings, observers, or buffer growth; it only obeys the frozen ABI defined in <code>runner_api.py</code>.  Each call receives: scalars like <code>(t0, t_end, dt_init, max_steps)</code>, model storage (<code>y_curr</code>, <code>params</code>), workspaces, recording buffers, event logs, analysis slots, and low-level cursors/caps.  It drives a single epoch of stepping and may only exit through the well-defined statuses.</p> <p>Important statuses: - <code>DONE</code> / <code>EARLY_EXIT</code> tell the wrapper the horizon was reached (or a stop condition triggered).  The wrapper then copies the final state and queues a <code>Results</code> object. - <code>GROW_REC</code> / <code>GROW_EVT</code> tell the wrapper it needs to resize the recording or event buffers, re-enter the runner with updated caps, and keep the cursors returned so the runner can resume where it left off. - <code>STEPFAIL</code>, <code>NAN_DETECTED</code>, <code>USER_BREAK</code>, <code>TRACE_OVERFLOW</code> bubble back as warnings; the wrapper still builds a <code>Results</code> snapshot so callers can inspect partial output. - <code>OK</code> stays internal; the wrapper keeps re-invoking the runner until one of the exiting statuses is seen.</p>"},{"location":"guides/simulation/wrapper-and-runner/#looping-and-re-entry","title":"Looping and re-entry","text":"<p>When the runner reports growth, the wrapper: - enlarges the appropriate buffer while copying existing data, updates the cap, - rewinds the start cursors (<code>i_start</code>, <code>step_start</code>), and - uses the last committed time/dt so the runner resumes the next chunk without losing continuity.</p> <p>If the runner finishes normally, the wrapper snapshots the workspaces, final state/dt, recorded arrays, event logs, and observer trace info before returning <code>Results</code> to <code>Sim</code>.</p>"},{"location":"guides/simulation/wrapper-and-runner/#data-flow-summary","title":"Data flow summary","text":"<ol> <li><code>Sim._execute_run</code> packages up the state seed and <code>[sim]</code> knobs and hands them to <code>run_with_wrapper</code>.</li> <li>The wrapper prepares buffers, analysis metadata, and selective recording lists, then calls the compiled runner (which consumes <code>stepper</code>, <code>rhs</code>, event-callables, and the data buffers).</li> <li>The runner returns a status; the wrapper interprets it, grows buffers if needed, and loops until the run completes or aborts.</li> <li>Finally, the wrapper builds a <code>Results</code> instance with the recorded arrays, event logs, traces, and final state so that <code>Sim.results()</code> can return user-friendly views.</li> </ol> <p>This separation keeps the handwritten wrapper responsible for Python-side bookkeeping while letting the compiled runner concentrate on the numerically intensive stepping loop.</p>"},{"location":"project/changelog/","title":"Changelog","text":"<p>Source: <code>CHANGELOG.md</code></p> <pre><code>## Changelog\n\n---\n\n## [0.37.10] \u2013 2026-01-30\n### Fixed\n- Stepper sources were not being attached to sources with `export_model_sources()` when `disk_cache=False` is chosen.\n  This was causing some tests of `test_export_sources.py` to fail. Fixed this process in `build.py` so that stepper \n  sources are always attached regardless of `disk_cache`.\n- Fixed failing test `test_runner_diskcache.py` by removing a hard-coded python path. \n\n---\n\n## [0.37.9] \u2013 2026-01-30\n### Fixed\n- Mkdocs mkdocs-gen-files plugin for generating doc files was not playing well with multi-language support. \n  Removed this plugin. For displaying built-in model references, changelog, todo, issues in docs, the script \n  `tools/gen_model_docs.py` should be run manually. `.github/workflows/docs.yml` will run this script with every\n  commit, so Github pages will always display the up-to-date version.\n- Fixed broken `mkdocs.yml` path prefixes due to the deployment.\n\n### Changed\n- Updated documentation links.\n- Updated `tools/gen_model_docs.py` and `mkdocs_helpers.py` for manual doc generation.\n\n---\n\n## [0.37.8] \u2013 2026-01-30\n### Fixed\n- Performed package install in docs.yml for Github pages deployment.\n\n---\n\n## [0.37.7] \u2013 2026-01-30\n### Fixed\n- Fixed missing dependency for Github pages deployment.\n\n---\n\n## [0.37.6] \u2013 2026-01-30\n### Changed\n- Introduced docs.yml for Github pages deployment.\n\n---\n\n## [0.37.5] \u2013 2026-01-30\n### Changed\n- Updated github links in documentation.\n\n---\n\n## [0.37.4] \u2013 2026-01-30\n### Changed\n- pyproject.toml was still incompatible with PYPI. Removed the incorrect line.\n\n---\n\n## [0.37.3] \u2013 2026-01-30\n### Changed\n- Fixed license statement in pyproject.toml.\n\n---\n\n## [0.37.2] \u2013 2026-01-30\n### Added\n- BSD 3-Clause License.\n- Turkish README file.\n\n### Changed\n- Minor documentation changes.\n\n---\n\n## [0.37.1] \u2013 2026-01-30\n### Added\n- Added Turkish documentation and improved existing English documentation.\n\n---\n\n## [0.37.0] \u2013 2026-01-29\n### Added\n- `mkdocs` compatible documentation in docs folder with multiple language support. Only English docs are available\n  in this version.\n- Added auto-generation scripts `gen_model_docs.py` and `mkdocs_helpers.py` for mkdocs. `tools/gen_model_docs.py`\n  is a single wrapper; so it should be run to generate docs locally. \n\n### Changed\n- Made `jit=False` and `disk_cache=False` defaults in `setup()` and `build()`.\n- Removed unnecessary [meta] tables from built-in models.\n\n---\n\n## [0.36.13] \u2013 2026-01-27\n### Changed\n- Renamed `label` key in [model] DSL table with `name` key. Replaced all occurrences throughout the package.\n- Removed temporary development docs. \n\n---\n\n## [0.36.12] \u2013 2026-01-27\n### Added\n- Added `model.print_equations()` for printing DSL equations (no generated code) and a demo example:\n  `print_equations_demo.py`. It accepts `tables` argument so that users can print various equations like \n  `equations.inverse` and `equations.jacobian`. This method is extendible via `register_equation_table()`\n  method inside `build.py` file. This method is only available for quickly checking equations. To view other\n  tables like aux values and events use `export_sources()` method.\n\n---\n\n## [0.36.11] \u2013 2026-01-27\n### Added\n- Added `homoclinic_finder` analysis tool for searching and finding a homoclinic orbit for a given equilibrium.\n  A single parameter of an ODE system is changed between an interval during the search.\n- Added `homoclinic_tracer` analysis tool for finding a homoclinic orbit of an equilibrium for fixed parameter values. \n  Its result can be plotted using `plot.manifold` plotter utility.\n- Added example `homoclinic_finder_tracer.py` for finding a parameter value of an ODE model that might have a\n  homoclinic orbit and the tracer is used to visualize the homoclinic orbit for the found parameter.\n\n---\n\n## [0.36.10] \u2013 2026-01-26\n### Added\n- Added `heteroclinic_finder` analysis tool for searching and finding a heteroclinic orbit between two equilibria.\n  A single parameter of an ODE system is changed between an interval during the search.\n- Added `heteroclinic_tracer` analysis tool for finding a heteroclinic orbit between two equilibria for fixed\n  parameter values. Its result can be plotted using `plot.manifold` plotter utility.\n- Added example `heteroclinic_finder_tracer.py` for finding a parameter value of an ODE model that might have a\n  heteroclinic orbit between its two equilibria. The tracer is used to visualize the heteroclinic orbit for the found \n  parameter.\n\n---\n\n## [0.36.9] \u2013 2026-01-25\n### Added\n- Added analysis tool `trace_manifold_1d_ode()` for tracing stable/unstable 1D manifolds of ODE models. The results\n  can be plotted using the same `plot.manifold()` utility introduced previously.\n- Added an example `manifold_ode_saddle.py` for demonstrating ODE manifold tracing. \n\n---\n\n## [0.36.8] \u2013 2026-01-25\n### Added\n- Added analysis tool `trace_manifold_1d_map()` for tracing stable/unstable 1D manifolds of nD maps.\n- Added `plot.manifold()` plot utility for plotting manifold analysis results.\n- Added an example `manifold_henon.py` for demonstrating manifold tracing.\n- Added another built-in Henon map model in `henon2.toml` which is the version used in Kathleen Alligood's book.\n\n---\n\n## [0.36.7] \u2013 2026-01-18\n### Added\n- Introduced a fixed points / equilibria calculator in `analysis/fixed_points.py` file. It uses Newton solver with\n  model type awareness (ODE vs map). Seeds are required as initial guesses. `fixed_points()` method is attached to \n  the `FullModel` class for user convenience (fixed points of a model can be calculated easily for that model with\n  its current parameters).\n\n### Tests\n- Introduced `test_fixed_points.py` for testing the fixed point calculation feature.\n\n---\n\n## [0.36.6] \u2013 2026-01-17\n### Fixed\n- `basin_auto` plot results were rotated. `basin_auto.py` now uses `np.meshgrid(..., indexing=\"ij\")` with explicit \n  order=\"C\" raveling for consistent grid flattening.\n\n---\n\n## [0.36.5] \u2013 2026-01-17\n### Changed\n- Moved all of the runtime analysis utilities from `./analysis/runtime` folder to `./runtime/observers` folder.\n- Renamed all runtime analyses as `observers`. `Sim.run()` now accepts `observers` argument instead of `analysis`.\n  Added _observer suffix to the names of these utilities to prevent import name clashes. These changes should provide \n  a clear separation between runtime and offline standalone analysis utilities.\n- Added _sweep suffix to the names of sweep utilities to prevent import name clashes.\n- Updated all analysis related examples and tests.\n\n---\n\n## [0.36.4] \u2013 2026-01-12\n### Added\n- Inverse RHS equations support for map DSL definitions. [equations.inverse] (with `expr` keyword) or \n  [equations.inverse.rhs] can be used to define inverse map equations. Numba compatibility and caching is provided. \n\n### Tests\n- Added `test_inverse_equations.py` to test new inverse map behavior and updated old DSL related tests.\n\n---\n\n## [0.36.3] \u2013 2026-01-08\n### Added\n- Added basin of attraction calculation analysis tool `basin_known`. It can calculate basin of attraction of known\n  attractors numerically.\n- Added various basin of attraction calculation examples.\n- Added `basin_plot` utility for plottin basin of attraction results.\n- Added various utilities for investigating basin analysis results in `basin_stats.py`.\n\n### Changed\n- For sweep and basin analyses introduced chunk-based process parallelism with efficient worker initialization: \n  a chunk of the analysis is assigned to a worker; each worker process initializes its `Sim` object once and reuses \n  it across all chunks assigned to that worker, avoiding redundant JIT compilation and allocation overheads.\n- Renamed `analysis/basin.py` -&gt; `analysis/basin_auto.py`.\n\n### Tests\n- Fixed tests that contain `exprs` keyword.\n\n---\n\n## [0.36.2] \u2013 2026-01-06\n### Added\n- Added basin of attraction calculation analysis tool `basin_auto` in `analysis/basin.py`. It can search for \n  attractors and determine their basins using recurrence-based basin estimation method (Datseris &amp; Wagemakers 2022), \n  with an additional persistence-based early assignment and coarsened-grid fingerprint merging. Internally it is \n  called PCR-BM (Persistent Cell-Recurrence Basin Mapping).\n- Added Henon map basin of attraction calculation demo example: `basin_henon_demo.py`.\n- Added ODE-based limit cycle basin of attraction calculation example: `basin_limit_cycle.py`.\n- Added basin of attraction plotting utility `plot_basin` in `plot/basin.py`.\n- Added ETO (Energy Template Oscillator) with Circular L Curve built-in model `eto-circular.toml`.\n- Added Duffing oscillator built-in model: `duffing.toml`.\n\n### Changed\n- Replaced underscore (_) from the built-in model names with hypen (-). For example: `exp_if.toml` -&gt; `exp-if.toml`.\n- Analyses can now trigger early exit from hooks by setting `runtime_ws.stop_flag`, even when the DSL stop table is \n  absent, as long as the analysis declares a `stop_phase_mask` (e.g., post\u2011step).\n\n### Fixed\n- Some DSL tables were using `expr` keyword for equation definitions and some were using `exprs`. Unified all \n  equation expression keywords as `expr`. Typos were not causing any errors but steppers would not advance. Now \n  any typo raises an error with a hint.\n\n### Tests\n- Added tests for analysis triggered early exit in `test_stop_early_exit.py`.\n\n---\n\n## [0.36.1] \u2013 2026-01-04\n### Added\n- Added early exit feature: simulations can now stop early when a specified condition is met using the `stop` \n  field in the [sim] section.\n- Added support for stop conditions with built-in DSL macros like `cross_up()`, `in_interval()`, `increasing()`,\n  `decreasing()`, and others.\n- Added `exited_early` property to results to check if simulation stopped due to a stop condition.\n- Added example `early_exit_demo.py`.\n- Extended runtime workspace with `stop_flag` and `stop_phase_mask` arrays for stop condition evaluation. Since \n  only phase=`post` is supported `stop_phase_mask` is not necessary but it is there for future phase=`pre` and \n  phase=`post` extension.\n\n### Changed\n- Updated all runners (base, analysis, fastpath variants for both continuous and discrete systems) to evaluate \n  stop conditions after each step.\n- Modified `update_aux()` function to also handle stop flag updates when stop conditions are enabled.\n- Updated results API to consider `EARLY_EXIT` as a successful completion status alongside `DONE`.\n- Enhanced model specification to include `StopSpec` for parsing and validating stop conditions.\n- Updated AST checker to validate stop condition expressions and collect lag requests for stop conditions.\n- Modified mods system to support setting `sim.stop` via TOML modifications.\n- Updated emitter to compile stop condition expressions into the `update_aux` function.\n- Attached exiting `EARLY_EXIT` status code (7) to the new early termination mechanism.\n\n### Tests\n- Added test file `test_stop_early_exit.py`.\n\n---\n\n## [0.36.0] \u2013 2026-01-02\n### Added\n- Added `RunnerVariant` enum to consolidate runner architecture: `BASE`, `ANALYSIS`, `FASTPATH`, and \n  `FASTPATH_ANALYSIS`.\n- Added FASTPATH runner templates for both continuous (ODE) and discrete (map) systems. Fastpath runners skip\n  event processing and buffer growth checks for fixed-step execution.\n- Added `get_runner()` unified API in `runner_variants.py` to replace separate `get_runner_variant()` and \n  `get_runner_variant_discrete()` paths. Now supports explicit variant selection with hooks baked in as globals.\n- Added `EARLY_EXIT` status code (7) in `runner_api.py` for future use with basin of attraction analysis.\n- Renamed `runtime/fastpath/runner.py` to `runtime/fastpath/executor.py` for clarity.\n- Added `runner_cache.py` disk cache helper module for runner variants with variant-aware and template-version \n  aware cache keys.\n\n### Changed\n- Consolidated runner templates into single source of truth in `runner_variants.py`, reducing code duplication.\n- Analysis hooks are now always injected as global symbols (`ANALYSIS_PRE`, `ANALYSIS_POST`) rather than function \n  arguments. This enables simpler, more JIT-friendly code generation.\n- Unified wrapper and fastpath execution to use `get_runner()` with explicit `RunnerVariant` selection based on \n  analysis presence and execution mode (continuous vs discrete).\n- Updated `run_with_wrapper()` to always require `model_hash` and `stepper_name` for runner selection.\n- Removed legacy dual-ABI runner path (analysis_kind + dispatch arguments). All variants now use hook globals.\n- Disk cache keys now include variant type and template version for invalidation support.\n- Fastpath now uses `RunnerVariant.FASTPATH_ANALYSIS` instead of legacy `ANALYSIS` path, enabling \n  future capability specialization.\n\n### Removed\n- Removed legacy `compiler/codegen/runner.py` (ODE runner template).\n- Removed legacy `compiler/codegen/runner_discrete.py` (discrete runner template).\n- Removed `analysis_dispatch_pre` and `analysis_dispatch_post` from runner ABI. Hooks are now baked in.\n\n### Tests\n- Updated `test_analysis_runtime.py` to use new unified runner API and explicit `model_hash`/`stepper_name`.\n- Updated `test_fastpath_runner.py` to import from `executor` module.\n- Updated `test_wrapper_reentry.py` to provide required `model_hash` and `stepper_name` arguments.\n\n---\n\n## [0.35.9] \u2013 2025-12-29\n### Fixed\n- The `ab2` and `ab3` state history usage was wrong. Shifted tangent\u2011only Lyapunov propagation into `pre_step` \n  so `ab2`/`ab3` see (y_n, v_n) when forming g_n = J(y_n)v_n. `post_step` now only normalizes/accumulates (flow) \n  or computes Jv for map mode.\n\n---\n\n## [0.35.8] \u2013 2025-12-29\n### Changed\n- Changed version numbers to v0 and updated all git tags accordingly. This will be an indicator that the package\n  is still alpha not a stable release.\n\n---\n\n## [0.35.7] \u2013 2025-12-29\n### Added\n- Variational stepping support to the steppers: `rk2`, `ab2`, and `ab3`.\n\n### Changed\n- Multi-step variational stepping is now supported for Lyapunov analyses. However, combined calculations (advance \n  the state and the tangents together in a single stepper call) is not possible for them. All calculations are\n  tangent-only (advance only the tangents using a variational step routine while the state is advanced by the \n  normal runner path). Also Lyapunov Spectrum calculations always prefer tangent-only calculations.\n\n---\n\n## [0.35.6] \u2013 2025-12-28\n### Added\n- `sweep.lyapunov_spectrum()` utility for plotting Lyapunov spectrum change of a system for a range of parameters.\n  Just like `sweep.lyapunov_mle()` it supports fast-path runner and parallelization.\n- Added `sweep.lyapunov_spectrum()` example `lyapunov_sweep_spectrum_demo.py`.\n\n### Changed\n- Removed `SweepAnalysis.peaks()` method and introduced `SweepAnalysis.extrema()`. `peaks()` was only finding \n  maxima. New extrema() method can find maxima, minima and both (default) via its `kind` argument.\n- Renamed `lyapunov_sweep_demo.py` -&gt; `lyapunov_sweep_mle_demo.py`.\n\n### Fixed\n- Fast-path runner was treating transient duration as part of the `T` value. This issue was fixed for `N` before \n  but forgotten for `T` values. Now `T` values also ignore transient duration and recording starts at `t0` after \n  the `transient`.\n\n### Tests\n- Fixed `test_fastpath_runner.py`. It was assuming wrong fast-path transient behavior.\n\n---\n\n## [0.35.5] \u2013 2025-12-27\n### Added\n- Added `JITUnavailableError` for clear failures when `jit=True` but numba is missing.\n- Added variational workspace helpers for Euler and RK4 steppers so Lyapunov analyses can reuse stepper buffers.\n- Added labeled horizontal-line support to plots.\n\n### Changed\n- Lyapunov MLE/spectrum now use stepper-provided variational workspaces and can prefer combined state+tangent steps.\n  Previously state+tangent steps were hardcoded in `lyapunov.py`.\n- JIT-related code paths now raise instead of warning when numba is unavailable (guards, runners, steppers).\n- Plot line label placement is more configurable (position, pad, rotation, color) and theme defaults are updated.\n- Examples are updated to use the new vline/hline/vband helpers.\n\n### Tests\n- Renamed variational stepping tests to `tests/unit/test_variational_stepping.py`.\n\n---\n\n## [0.35.4] \u2013 2025-12-27\n### Added\n- Added `builtin://ode/lorenz` model definition.\n- Added support for horizontal lines (`hlines`) and horizontal bands (`hbands`) in plot utilities.\n- Added variational stepping support to `Euler` stepper. Both Euler and RK4 now advertise \n  `variational_stepping=True` capability.\n- Added `lyapunov_lorenz_demo.py` demonstrating Max Lyapunov and Lyapunov spectrum analyses of the Lorenz system.\n\n### Changed\n- Renamed `bands` argument to `vbands` in plot functions to distinguish from the new `hbands`.\n- Lyapunov analyses (`lyapunov_mle`, `lyapunov_spectrum`) now strictly require the stepper to support variational \n  stepping. If the stepper does not support it, a `ValueError` is raised (no longer falls back to Euler).\n- `CombinedAnalysis` now enforces stricter rules:\n    - Rejects combination if more than one analysis requires runner-level variational stepping.\n    - Rejects combination if any analysis mutates state.\n- `AnalysisResult` now provides `trace_steps`, `trace_time`, and `record_interval` attributes.\n- Transient warm-up phase now explicitly disables analysis hooks.\n\n### Tests\n- Updated `test_rk4_variational.py` to reflect strict stepper requirements and new `CombinedAnalysis` rules. \n  Added `test_transient_warmup_skips_analysis_hooks`.\n\n---\n\n## [0.35.3] \u2013 2025-12-24\n### Added\n- Variational stepping support (simultaneous numerical integration of both the original dynamical system and \n  its variational / tangent equations using the same numerical method) for RK4 stepper via \n  `emit_step_with_variational()` and `emit_tangent_step()` methods.\n\n### Changed\n- Lyapunov exponent analysis (`lyapunov_mle` and `lyapunov_spectrum`) now automatically uses variational \n  stepping when the chosen stepper supports it (currently RK4), otherwise falls back to Euler integration.\n- When computing Lyapunov exponents, the analysis tracks how small perturbations grow over time by integrating \n  \"tangent vectors\" (directional derivatives). For accurate results, both the main system and tangent vectors \n  should use the same numerical method. This update enables RK4 to integrate tangent vectors with full \n  4th-order accuracy instead of 1st-order Euler, significantly improving reliability for continuous systems.\n\n### Fixed\n- Lyapunov exponent calculations now use the same numerical method (e.g., RK4) for both the system state and \n  the tangent vectors, ensuring mathematical consistency and improved accuracy. Previously, tangent vectors \n  were always integrated using Euler method regardless of the chosen stepper.\n\n### Tests\n- Added comprehensive test suite (`test_rk4_variational.py`) covering RK4 variational mode selection, runtime \n  verification, Euler fallback behavior for steppers without variational support, and numerical accuracy \n  validation with known linear systems.\n\n### Known Issues\n- Only RK4 stepper is supported for variational stepping. Other fixed step steppers should be modified similarly.\n\n---\n\n## [0.35.2] \u2013 2025-12-24\n### Fixed\n- Combined runtime analyses now share trace capacity correctly. Each module writes into its own slice with a\n  shared step-level cursor, preventing double-increment of `trace_count` and eliminating spurious\n  `TRACE_OVERFLOW` when multiple analyses with different trace widths run together. Both Python and generated\n  JIT hooks use the synchronized counter and import `numpy` explicitly in the generated namespace.\n\n---\n\n## [0.35.1] \u2013 2025-12-24\n### Changed\n- Refactored analysis hook dispatch to eliminate `NumbaExperimentalFeatureWarning`. Analysis hooks (`pre_step`,\n  `post_step`) are now injected as global symbols (`ANALYSIS_PRE`, `ANALYSIS_POST`) into generated runner source\n  code via `exec()` with a custom namespace, making call targets statically resolvable by Numba instead of using \n  first-class function arguments.\n- Runner variants are cached (64 entries max) keyed by (model_hash, stepper_name, analysis_signature_hash, \n  runner_type, jit), ensuring the same runner/analysis combination compiles only once per parameter sweep. Cache\n  mechanism uses LRU (Least Recently Used) eviction.\n- Replaced `literal_unroll` over callable containers with explicit sequential call codegen for combined hooks, \n  avoiding callable containers entirely.\n- When no analysis is active, base runner templates are used without any `analysis_kind` branching overhead.\n\n### Added\n- `signature(dtype) -&gt; tuple` method to `AnalysisModule` protocol for stable cache key generation.\n- New module `dynlib.compiler.codegen.runner_variants` with `get_runner_variant()`, \n  `get_runner_variant_discrete()`, `analysis_signature_hash()`, and `clear_variant_cache()` API.\n\n### Fixed\n- Resolved `NumbaExperimentalFeatureWarning` caused by first-class function types in analysis hook dispatch.\n\n---\n\n## [0.35.0] \u2013 2025-12-24\n### Added\n- `lyapunov_spectrum()` analysis utility for performing Benettin QR / Shimada\u2013Nagashima (reorthonormalization) \n  style Lyapunov spectrum analysis.\n- Introduced `mode` option to `lyapunov_mle` and `lyapunov_spectrum` analyses which can be `auto`, `flow`, or `map`.\n  `auto` (default) mode can detect type of Lyapunov exponent calculation from the DSL model type.\n\n### Known Issues\n- Analyses hooks cause `NumbaExperimentalFeatureWarning` because they are passed as first-class functions to the \n  jitted runner.\n- Analyses occasionally cause `TRACE_OVERFLOW` which should not be possible.\n- `flow` mod analyses use Euler integration regardless of the `Sim` stepper.\n\n---\n\n## [0.34.10] \u2013 2025-12-24\n### Changed\n- Removed the legacy `dynlib.runtime.model.Model` dataclass. `Sim` now expects the `FullModel` returned by `build()`, \n  eliminating the duplicate runtime model type. Maintaining both `Model` and `FullModel` class was hard. For example \n  `export_sources()` shortcut was attached to the old `Model` class instead of the newer `FullModel` class.\n- Updated `export_sources.md` doc file and `export_sources_demo.py` example.\n\n### Tests\n- Replaced `Model` class usage with `FullModel` class.\n\n---\n\n## [0.34.9] \u2013 2025-12-24\n### Tests\n- Added comprehensive test coverage for external Jacobian mode in implicit steppers (`bdf2`, `bdf2a`, `tr-bdf2a`, \n  `sdirk2`) via new test file `test_jacobian_external_mode.py`. Tests verify accuracy against analytic solutions,\n  consistency between internal and external modes, and correct behavior on both simple (1D exponential decay) and\n  complex (2D Van der Pol oscillator) systems.\n\n---\n\n## [0.34.8] \u2013 2025-12-23\n### Changed\n- Modified steppers relying on Jacobian matrices (`bdf2`, `bdf2a`, `tr-bdf2a`, `sdirk`) so that they can utilize\n  DSL-generated Jacobian functions in their calculations alongside their previous finite difference numerical\n  approximations. These two modes can be selected using the stepper config value `jacobian_mode` which can be\n  `external` (use DSL Jacobian) or `internal` (use numerical approximation). Default is `internal` because I am\n  worried about users providing a faulty Jacobian matrix.\n- Set JacobianPolicy of `bdf2`, `bdf2a`, `tr-bdf2a`, `sdirk` steppers to `optional` meaning that they can work\n  both with external and internal Jacobians.\n- For steppers to utilize DSL Jacobian functions, added `jacobian_fn` and `jvp_fn` callable args to the `emit()` \n  function of all steppers. They are optional so steppers not using Jacobians are not changed.\n- Ensured that `aux` values are calculated exactly once in Jacobian matrix entries to prevent repeated \n  recalculations and slowing down the steppers unnecessarily. This feature is called as aux hoisting.\n- Removed `bdf2_scipy` and `bdf2a_scipy` because they were performing very poorly and there was no reason to keep\n  them around. However, stepper features like `jit_capable` are kept for future use.\n- Updated `export_sources.md` file encouraging users to utilize `Model.export_sources()` instead of the standalone\n  function.\n\n### Added\n- Example for comparing run times of steppers with `external` and `internal` Jacobian modes. `external` mode is\n  slightly faster for all steppers.\n\n### Tests\n- Added `test_aux_hoist_jacobian.py` to test correct dependency resolution during `aux` variable hoisting in DSL \n  Jacobian functions.\n- Removed `bdf2_scipy` and `bdf2a_scipy` related tests.\n\n---\n\n## [0.34.7] \u2013 2025-12-23\n### Changed\n- Each parameter result had its own result data class. Unified sweep results with a single template: `SweepResult` \n  + `TrajectoryPayload`. Removed individual data classes like `ParamSweepTrajResult` and the `ParamSweepMLEResult`\n  introduced in the previous version. Future sweep analyses should use this template.\n\n---\n\n## [0.34.6] \u2013 2025-12-22\n### Added\n- Lyapunov MLE parameter sweep functionality via `sweep.lyapunov_mle()` for computing maximum Lyapunov exponents \n  across parameter ranges.\n  - Returns `ParamSweepMLEResult` with converged MLE values, log growth, step counts, and optional convergence \n    traces.\n  - Supports parallel execution via `parallel_mode` parameter (\"auto\", \"threads\", \"none\").\n  - Includes `stack_traces()` method for uniform-length trace analysis.\n  - Exported in `dynlib.analysis` namespace alongside `scalar`, `traj` sweep functions.\n- Example script `examples/analysis/lyapunov_sweep_demo.py` demonstrating bifurcation diagram and MLE sweep \n  visualization for the logistic map.\n\n### Changed\n- `_LyapunovModule.resolve_hooks()` now caches compiled JIT hooks per dtype to avoid redundant JIT compilation \n  on every run, improving performance for repeated analysis calls.\n\n---\n\n## [0.34.5] \u2013 2025-12-22\n### Added\n- `ResultsView.analysis` now returns `AnalysisResult` wrappers that dynamically expose analysis-specific outputs \n  and traces via named access.\n  - Generic design: field names are auto-discovered from each analysis module's `output_names` and `trace_names` \n    metadata - no hardcoding per analysis type.\n  - Attribute access for values: e.g., for Lyapunov MLE, `lyap.log_growth`, `lyap.steps` (from `output_names`), \n    and `lyap.mle` (from `trace_names`). Different analyses will have different field names.\n  - Trace attributes return final scalar values: `lyap.mle` returns the converged value (last element).\n  - Bracket access for full arrays: `lyap[\"mle\"]` returns complete trace array for plotting/analysis.\n  - Mapping interface is provided as low-level generic API: `lyap[\"out\"]`, `lyap[\"trace\"]`, `lyap[\"stride\"]`.\n  - Discovery support: `lyap.output_names`, `lyap.trace_names`, `list(lyap)`, `dir(lyap)` for introspection and \n    tab-completion.\n  - Scales from 1D (single MLE value) to nD (Lyapunov spectrum, multiple metrics) automatically.\n\n### Changed\n- Updated `lyapunov_logistic_map_demo.py` to demonstrate new API: `lyap.mle` instead of manual \n  `lyap[\"out\"][0] / lyap[\"out\"][1]` computation.\n\n### Tests\n- Extended `test_analysis_runtime.py` for the new `AnalysisResult` feature.\n\n---\n\n## [0.34.4] \u2013 2025-12-22\n### Changed\n- Moved `src/dynlib/analysis/post/sweep.py` -&gt; `src/dynlib/analysis/post/sweep.py` to gather all sweeps into one \n  place. Changed sweep imports accordingly.\n\n### Fixed\n- `lyapunov_mle()` now validates inputs consistently: a model or explicit `jvp` (with `n_state`) is required, and\n  `record_interval` is optional (defaults to stride 1). This prevents silent misuse when the factory is called\n  without a model context while keeping `Sim`-injected factory usage unchanged.\n\n---\n\n## [0.34.3] \u2013 2025-12-22\n### Changed\n- Simplified runtime analysis API with consistent factory pattern:\n  - `lyapunov_mle()` now uses simple conditional logic: if `model` parameter is provided, returns `AnalysisModule` \n    directly; otherwise returns a factory function.\n  - Factory accepts `model` parameter that `Sim.run()` injects automatically via signature introspection.\n  - All parameters have sensible defaults: `jvp` and `n_state` extracted from model when not provided.\n  - Usage patterns:\n    - `analysis=lyapunov_mle()` \u2014 factory mode, Sim injects model (most common).\n    - `analysis=lyapunov_mle(record_interval=2)` \u2014 factory with custom params, Sim injects model.\n    - `analysis=lyapunov_mle(model=sim.model)` \u2014 direct mode, returns AnalysisModule immediately.\n  - This simple if/else pattern generalizes cleanly to future analysis modules with different signatures.\n- Updated logistic map Lyapunov example to demonstrate simplified factory API.\n\n---\n\n## [0.34.2] \u2013 2025-12-22\n### Fixed\n- Runtime `CombinedAnalysis` now composes child hooks with precomputed offsets and numba-friendly closures, \n  making combined analyses eligible for fast-path/JIT execution while preserving the Python path when `jit=False`.\n- Analysis JIT compilation remains opt-in; pure-Python runners continue to dispatch uncompiled hooks when JIT is \n  not requested or numba is unavailable.\n- With this and previous changes, all of the issues blocking numba compatibility (`jit=True`) of runtime analysis \n  modules are resolved.\n\n---\n\n## [0.34.1] \u2013 2025-12-21\n### Added\n- DSL models can now declare Jacobians directly in TOML via `[equations.jacobian].exprs` with deterministic \n  state order semantics (state decleration order is used for determining the order of the matrix).\n- Jacobian declarations generate JVP (Jacobian Vector Product) operators (and optional dense fill) that are \n  JIT/disk-cache aware and wired into models.\n- Lyapunov runtime analysis now consumes JVPs, making Jacobian-dependent analyses work without Python \n  callbacks.\n\n### Changed\n- State declaration order is now part of the spec hash to avoid cache ambiguity and is preserved through mods\n  /build.\n- Capability checks now distinguish JVP and dense-Jacobian requirements; `Sim` validates analysis requirements \n  early.\n- Logistic map Lyapunov example updated to use DSL Jacobian instead of a Python function.\n\n### Known Issues\n- Models without a declared Jacobian still fall back to Python-only analyses; declarative TOML Jacobians are \n  now compiled to JVPs but dense numeric Jacobians are not generated automatically.\n- Steppers using numerical Jacobian approximations can benefit from builtin Jacobian functions.\n\n---\n\n## [0.34.0] \u2013 2025-12-21\n### Added\n- Runtime analysis system for computing diagnostics during simulation execution:\n  - New `dynlib.analysis.runtime` module with `AnalysisModule`, `AnalysisHooks`, and `TraceSpec` for building \n    analysis pipelines.\n  - `lyapunov_mle()` function computes maximum Lyapunov exponents for detecting chaos in discrete and continuous \n    systems.\n  - Analysis modules can run alongside integration via `Sim.run(analysis=...)` parameter.\n  - Support for both Python and JIT-compiled analysis hooks for performance.\n  - Trace buffers allow sampling analysis results at configurable intervals during runs.\n  - Fast-path integration now supports analysis modules when JIT hooks are provided.\n- New Lyapunov example (`lyapunov_logistic_map_demo.py`) demonstrating chaos detection in the logistic map.\n\n### Changed\n- Reorganized analysis tools into two submodules for clarity:\n  - `dynlib.analysis.post`: Post-run analysis (sweeps, bifurcations, trajectory statistics) - moved from \n    `dynlib.analysis`.\n  - `dynlib.analysis.runtime`: During-run analysis (Lyapunov, online diagnostics).\n- Enhanced `Results` and `ResultsView` with `.analysis` property for accessing runtime analysis outputs.\n- Analysis module imports updated: use `from dynlib.analysis.post import sweep, traj` instead of \n  `from dynlib.analysis import .sweep, traj`\n- Runner ABI version incremented to 3 to accommodate analysis buffer arguments\n- All runners (continuous/discrete) now accept analysis workspace, output, trace buffers, and dispatch hooks.\n- Fast-path capability checking now validates analysis module requirements (fixed-step, Jacobian, event \n  compatibility).\n\n### Tests\n- Added comprehensive tests for runtime analysis infrastructure (`test_analysis_runtime.py`).\n\n### Known Issues\n- Numba option will not work for runtime analysis modules. There are lots of problems for numba compatibility.\n- Jacobian equation definitions are very crude and creates numba compatibility issues. TOML DSL definition would \n  be better.\n\n---\n\n## [0.33.1] \u2013 2025-12-18\n### Changed\n- Fixed some minor plot related bugs. \n- `export.savefig()` now can infer save format from the file extension of path. Otherwise `fmts` arg should \n  be used. If `fmts` and a path with file extension are used together, then an error is raised.\n\n### Tests\n- Added unit tests for `savefig()` behavior.\n\n---\n\n## [0.33.0] \u2013 2025-12-18\n### Added\n- Introduced comprehensive bifurcation analysis tools for exploring parameter-dependent dynamics:\n  - `BifurcationExtractor` class provides post-processing of trajectory sweeps into bifurcation scatter data\n  - Multiple extraction modes: `.all()` (all points), `.tail(n)` (attractor cloud), `.final()` (convergent \n    states), `.peaks()` (local maxima)\n  - `BifurcationResult` dataclass holds bifurcation data with metadata for plotting\n  - `bifurcation_diagram()` plotting function with scatter-optimized defaults\n  - Convenient API: `sweep_result.bifurcation(\"x\").tail(50)` extracts bifurcation data from parameter sweeps\n  - New module `dynlib.analysis.bifurcation` for bifurcation post-processing utilities\n  - New module `dynlib.plot.bifurcation` for bifurcation diagram plotting\n- Added three comprehensive bifurcation examples:\n  - `bifurcation_logistic_map.py`: Basic bifurcation diagram demonstration\n  - `bifurcation_logistic_map_annotated.py`: Advanced analysis with annotations and zoomed cascade views\n  - `bifurcation_logistic_map_comparison.py`: Comparison of different extraction modes (final/tail/peaks)\n- `sweep.traj()` now accepts `parallel_mode` and `max_workers` parameters for controlling fast-path batch \n  execution parallelism.\n\n### Changed\n- Plot module has been reorganized for better API clarity and consistency:\n  - Moved `cobweb()` from `dynlib.plot.analysis` to `dynlib.plot.cobweb()`\n  - Moved `hist()` from `dynlib.plot.analysis` to `dynlib.plot.utils`\n  - Added top-level convenience function `return_map()` as alias for `phase.return_map()`\n  - Removed `dynlib.plot.analysis` module (replaced by domain-specific modules)\n  - Updated examples to use new plot API imports\n\n### Fixed\n- Fixed critical bug where `N` parameter was incorrectly reduced by transient steps, causing fewer points to \n  be recorded than expected. Now `N` correctly specifies the number of recorded steps *after* transient warm\n  up completes.\n- Vector field `scale` parameter now properly applies only when `normalize=True` is set, fixing unintended \n  scaling behavior.\n\n### Tests\n- Added comprehensive test coverage for bifurcation diagram functionality\n- Added regression test `test_fastpath_transient_with_N()` to prevent transient/N interaction bugs\n\n---\n\n## [0.32.1] \u2013 2025-12-16\n### Changed\n- Applied minor bug fixes to the new fast-path runner feature.\n- Centralized fast-path capability gating in `src/dynlib/analysis/sweep.py` by adding `_assess_fastpath_support`, \n  reusing the same support for both batch and per-run fallbacks so we don\u2019t re-evaluate or fabricate support \n  objects.\n- `_run_batch_fast` now returns `(result, support)` without emitting its own warnings; batch callers warn once via\n  `_warn_fastpath_fallback`, including the capability reason when available.\n- Fallback runs reuse the same `FastpathSupport` and suppress per-run warnings, ensuring only a single, informative \n  warning per sweep when fast-path is unavailable.\n\n---\n\n## [0.32.0] \u2013 2025-12-16\n### Added\n- Introduced a fast-path analysis runner (`dynlib.runtime.fastpath`) optimized for parameter sweeps and \n  batch simulations:\n  - **Recording plans**: `FixedStridePlan` and `TailWindowPlan` pre-allocate buffers to avoid dynamic growth\n  - **Capability gating**: Automatic validation ensures fast-path constraints are met before execution\n  - **Stateless execution**: Runs don't mutate `Sim` session state, enabling safe parallel execution\n  - **Three-level API hierarchy**:\n    - Low-level: `run_single_fastpath()`, `run_batch_fastpath()` for raw model arrays\n    - High-level standalone: `fastpath_for_sim()`, `fastpath_batch_for_sim()` for `Sim` objects\n    - User-facing method: `Sim.fastpath()` for ergonomic one-off executions\n  - **Parallel execution modes**:\n    - `parallel_mode=\"auto\"`: Automatically selects optimal strategy (default)\n    - `parallel_mode=\"threads\"`: ThreadPoolExecutor with GIL-free execution for JIT builds (~Nx speedup)\n    - `parallel_mode=\"none\"`: Sequential execution for debugging\n    - `max_workers` parameter controls thread pool size\n  - **Transient warm-up**: Optional `transient` parameter discards initial samples before recording\n  - **Selective recording**: Compatible with `record_vars` for memory-efficient variable selection\n- Added `RecordingPlan` base class with `FixedStridePlan(stride)` for regular sampling and \n  `TailWindowPlan(stride, window)` for keeping only last N samples.\n- Added `FastpathSupport` and `assess_capability()` for runtime validation of fast-path eligibility.\n\n### Changed\n- Parameter sweeps (`analysis.sweep.scalar()`, `analysis.sweep.traj()`) now attempt fast-path backend when \n  eligible before falling back to `Sim.run()`, providing automatic optimization without user intervention.\n- Fast-path batch execution achieves near-linear speedup with JIT compilation (e.g., 8x on 8 cores) by \n  leveraging Numba's GIL-free execution in threaded environments.\n- Sweep operations now emit a one-time warning when falling back to `Sim.run()`, helping users identify \n  performance optimization opportunities without flooding output. Pure Python + threads: ~1.1-1.3x speedup \n  (limited by GIL).\n\n### Known Issues\n- Fast-path requires fixed-step steppers (Euler, RK4, Map, etc.); adaptive steppers fall back to `Sim.run()`.\n- Event logging is unsupported (apply-only events work fine).\n- Lagged systems (`lag_x(k)`) currently disabled pending ring-buffer management improvements.\n- Recording interval must be positive and known in advance.\n\n---\n\n## [0.31.5] \u2013 2025-12-15\n### Added\n- Vector field plots can now create animations across parameter sweeps via `vectorfield_animate()` with \n  configurable frame rates, repeat settings, and custom update functions for parameters and fixed states.\n- Vector field plots support multi-panel parameter sweeps via `vectorfield_sweep()` with shared or independent \n  colormaps, custom titles, and flexible grid layouts.\n- Added examples `vectorfield_sweep_demo.py`, `vectorfield_animate_demo.py`, and `vectorfield_animation.py` to \n  demonstrate the new features.\n\n### Changed\n- When `normalize=True` in vector field plots, quiver arrows now use data-unit scaling to show unit vectors at \n  their true size instead of being auto-rescaled.\n\n### Tests\n- Added unit tests for vector field animations covering parameter sweeps, custom functions, frame control, and \n  animation properties.\n- Added unit tests for vector field sweep functionality including shared speed normalization, custom sweep \n  definitions, and facet titles.\n\n---\n\n## [0.31.4] \u2013 2025-12-15\n### Added\n- Vector field plots can color arrows and streamlines by speed magnitude via `speed_color=True`, with optional\n  `speed_cmap`/`speed_norm` forwarded to Matplotlib.\n\n---\n\n## [0.31.3] \u2013 2025-12-15\n### Added\n- Vector field plotting now supports a streamlines mode via `mode=\"stream\"` with kwargs forwarded to \n  `matplotlib.streamplot()`.\n\n---\n\n## [0.31.2] \u2013 2025-12-15\n### Added\n- Vectorfield plot demo `vectorfield_highdim_demo.py` for demonstrating vector fields of 2D slices of higher\n  dimensional systems.\n\n### Changed\n- Renamed `series.multi()` `series` argument to `y` for API consistency.\n\n---\n\n## [0.31.1] \u2013 2025-12-15\n### Added\n- Interactive vector field plots respond to clicks by simulating trajectories from that point using the compiled \n  model\u2019s stepper, while nullclines can be toggled without recomputation (key `N`) and trajectories can be cleared \n  via keyboard shortcuts (key `C`).\n- Vector field plotting now accepts a `stepper` override when compiling from URIs/ModelSpecs and exposes `T`/`dt` \n  arguments of the stepper.\n\n### Tests\n- Added coverage for stepper overrides in vector field plotting and interactive trajectory handling.\n\n---\n\n## [0.31.0] \u2013 2025-12-15\n### Added\n- Added vector field plotting functions for ODE models into `plot/vectorfield.py`. It creates quiver plots and \n  can calculate nullclines numerically. \n- Added demo example for vector field plotting.\n\n### Tests\n- Added unit tests for vector field evaluation and plotting in `tests/unit/test_vectorfield_eval.py`.\n\n---\n\n## [0.30.11] \u2013 2025-12-10\n### Added\n- Added `TrajectoryAnalyzer`/`MultiVarAnalyzer` utilities under `dynlib.analysis` and exported them for easy \n  imports.\n- Added `ResultsView.analyze()` helper that returns trajectory analyzers for recorded states/aux variables \n  with stats, extrema, crossing detection, and time-above/below helpers. `summary()` call returns all trajectory \n  analysis results.\n- Added `examples/analysis/demo_trajectory_analysis.py` showing analyzer usage on a damped oscillator run.\n\n### Tests\n- Added unit tests covering analyzer selection (states vs aux), percentile validation, crossing/time-above \n  calculations, and analyzer caching for multi-var cases.\n\n---\n\n## [0.30.10] \u2013 2025-12-03\n### Added\n- Added iterable `.runs` property to `ParamSweepTrajResult` for intuitive access to individual sweep runs:\n  - `SweepRun` dataclass provides `.param_value`, `.t`, and `[\"var\"]` access for each run\n  - `SweepRunsView` provides list-like interface supporting indexing, iteration, and length\n  - Consistent API: `run[\"x\"]` works like `res[\"x\"]` but for individual runs\n  - Example: `for run in res.runs: plot(run.t, run[\"x\"])`\n\n### Changed\n- Removed redundant `.t_all` shortcut properties from `ParamSweepTrajResult` in favor of unified `.runs` interface. \n  Now `res.t` is equivalent to `res.runs[0].t` as a shortcut.\n\n---\n\n## [0.30.9] \u2013 2025-12-02\n### Added\n- Added `dt_max` parameter to adaptive ODE steppers (RK45, BDF2, BDF2A_scipy, TR-BDF2A) to limit maximum step size \n  during step size calculation.\n- Added `inf` and `nan` imports to generated stepper modules for proper numba caching.\n\n### Changed\n- Enhanced initial step size selection to respect `dt_max` configuration from stepper configs.\n- Listed `prod()` DSL expression as builtin (it was implemented but not defined).\n\n---\n\n## [0.30.8] \u2013 2025-12-02\n### Added\n- Added `phase.multi()` function to plot multiple 2D phase trajectories on the same axes, useful for showing how \n  trajectories change with different parameters in phase space.\n- Added `parameter_sweep.py` example showing how to use the sweep functions with a simple exponential decay model.\n\n### Changed\n- Enhanced `sweep.scalar()` and `sweep.traj()` functions with better documentation, support for initial time \n  offsets, and improved result classes with named variable access.\n\n---\n\n## [0.30.7] \u2013 2025-11-25\n### Added\n- Enhanced the `analysis.sweep()` utility with data stacking for consistent run lengths, named access to \n  variables, and time axis convenience properties:\n  - `res.t` will yield time values for the first sim. \n  - `res.t_runs` and `res.t_all` will allow access to whole time value ndarray.\n  - `res[x]` will yield parameter sweep results for the `x` variable as (K,N) ndarray.\n- Added support for numpy ndarrays in `plot.multi` function, allowing direct plotting of 1D and 2D arrays with \n  automatic naming.\n\n---\n\n## [0.30.6] \u2013 2025-11-25\n### Added\n- Added a new `analysis` module with parameter sweep tools for running simulations with different parameter \n  values and collecting results. It is an early sketch.\n\n---\n\n## [0.30.5] \u2013 2025-11-24\n### Added\n- Added support for `range()` function in DSL expressions. Arguments are automatically cast to integers for \n  proper Numba compatibility.\n- Added validation to check that all identifiers used in expressions are properly declared as states, parameters, \n  auxiliary variables, functions, or constants, or are supported builtins and macros. This prevents typos and \n  undefined references.\n\n### Tests\n- Updated test models to remove manual `int()` casts around `range()` calls, as the function now handles type \n  conversion internally.\n\n---\n\n## [0.30.4] \u2013 2025-11-24\n### Added\n- Added user-defined `[constants]` table support to inline model-specific numeric literals across DSL\n  expressions, with collision guards against states/params/aux and reserved identifiers.\n\n---\n\n## [0.30.3] \u2013 2025-11-24\n### Added\n- DSL builtin constants `pi` and `e` are now inlined as numeric literals across equations, aux/functions,\n  events, and initial value expressions. These identifiers are reserved and cast to the model dtype at\n  codegen time to avoid runtime lookups or dtype mismatches.\n- Added cross-section identifier guard in `src/dynlib/dsl/astcheck.py` and wired it into build_spec so models \n  now error when a name is reused across states/params/aux/functions (e.g., param V vs aux V).\n\n### Tests\n- Added semantic validation coverage in `tests/unit/test_semantic_validation.py` to ensure these conflicts \n  raise a clear `ModelLoadError`.\n\n---\n\n## [0.30.2] \u2013 2025-11-23\n### Changed\n- Runners now refresh auxiliary variable values before recording initial conditions to ensure aux data is \n  available at the start for recording.\n- Results API now properly handles variable names from recorded data instead of listing all available states. \n\n---\n\n## [0.30.1] \u2013 2025-11-23\n### Changed\n- Warm-up now matches the new runner ABI and quadruplet callables so JIT compilation is triggered during \n  build again.\n- `_warmup_jit_runner` now allocates AUX/selective-recording buffers, computes event log width, and passes \n  `state_rec_indices`, `aux_rec_indices`, and counts to the runner along with the AUX buffer.\n- `_all_compiled` checks `update_aux` too, preventing skips when only the aux updater lacks signatures.\n\n---\n\n## [0.30.0] \u2013 2025-11-23\n### Added\n- Added `update_aux` callable to compute auxiliary variables from current state values. This function is \n  called after each committed step to ensure aux variables are available for recording and event conditions. \n  Inside RHS the aux values are still replaced by expressions to perform fast stepper multi-stage calculations.\n- Added selective variable recording via new `record_vars` parameter in `Sim.run()`. Users can now specify \n  exactly which variables to record:\n  - `record_vars=None` (default): Record all states (backward compatible)\n  - `record_vars=[\"x\", \"y\"]`: Record specific states\n  - `record_vars=[\"aux.energy\"]`: Record specific aux variables with explicit prefix\n  - `record_vars=[\"energy\"]`: Record aux variables with auto-detection (no prefix needed)\n  - `record_vars=[\"x\", \"energy\", \"aux.power\"]`: Mix states and aux variables\n  - `record_vars=[]`: Record nothing (only time, step, flags; equivalent to `record=False`)\n- Added `aux_values` array to `RuntimeWorkspace` for storing computed auxiliary variable values during \n  simulation.\n- Enhanced `Results` class with `AUX` array for recorded auxiliary variables, plus `state_names` and `aux_names` \n  metadata.\n- Added `get_var()` and `__getitem__()` methods to `Results` for accessing recorded variables by name with auto-\n  detection.\n- Added `to_pandas()` support for auxiliary variables in selective recording.\n\n### Changed\n- Updated runner functions to call `update_aux` after each committed step to maintain aux variable values.\n- Modified JIT compilation to handle quadruplet (rhs, events_pre, events_post, update_aux) instead of triplet.\n- Enhanced `ResultsView` to support accessing auxiliary variables alongside states.\n- Updated `Sim` class to handle selective recording with proper buffer allocation and metadata tracking.\n- Modified `run_with_wrapper` to pass selective recording parameters to runners.\n\n### Tests\n- Added 4 new tests in `tests/unit/test_selective_recording.py` to verify auto-detection behavior:\n  - `test_aux_auto_detection_without_prefix`: Aux variables work without prefix\n  - `test_mixed_auto_detect_and_explicit_prefix`: Mixing both syntaxes\n  - `test_state_priority_over_aux_same_name`: States take priority in detection\n  - `test_unknown_variable_helpful_error`: Error messages list available variables\n- Updated existing tests to match improved error messages.\n- Added comprehensive test coverage for selective recording functionality including buffer growth, resume \n  behavior, and error handling.\n\n### Known Issues\n- JIT warm-up is broken again. Possibly related to the new quadruplet approach.\n\n---\n\n## [0.29.6] \u2013 2025-11-23\n### Added\n- Added support for adding and removing parameters via mods. Now `add.params` can be used to add new \n  parameters and `remove.params` to remove existing ones.\n- Added validation to prevent unsupported targets in mod operations. Now clear error messages are shown \n  when trying to use invalid targets like `add.states` or `remove.states`.\n- Added comprehensive documentation for mods in `docs/mods.md`, explaining all verb operations, supported \n  targets, error handling, and best practices.\n\n### Tests\n- Added tests for parameter modification via mods, including adding/removing parameters and validation of \n  unsupported targets.\n\n---\n\n## [0.29.5] \u2013 2025-11-23\n### Added\n- Added support for `sum()` and `prod()` generator comprehensions in DSL expressions. These allow summing or \n  multiplying over ranges with optional conditions, like `sum(i*i for i in range(10))` or \n  `prod((i+1) for i in range(1, 5) if i % 2 == 0)`. They are compiled into efficient for-loops and work in \n  equations, aux variables, events, and functions.\n- Updated documentation in `docs/dsl_macros_and_functions.md` with a new \"Generator Comprehensions\" section \n  explaining the syntax and examples.\n\n### Tests\n- Added comprehensive tests in `tests/unit/test_sum_generator_lowering.py` to verify the functionality works \n  correctly with both JIT and non-JIT compilation.\n\n---\n\n## [0.29.4] \u2013 2025-11-21\n### Added\n- Added validation to prevent auxiliary variables from using reserved names like `t` to avoid conflicts \n  with runtime symbols. `_AUX_RESERVED_NAMES` list can be expanded to restrict aux names in the future.\n\n### Changed\n- Renamed auxiliary variable in Ikeda map model from `t` to `theta` for clarity and to avoid reserved \n  name conflict.\n\n### Tests\n- Added a test for reserved auxiliary name validation.\n\n---\n\n## [0.29.3] \u2013 2025-11-20\n### Added\n- Added documentation for DSL model file template in `docs/dsl_model_template.md`.\n- Added several builtin models for ODE and MAP types:\n  - ODE models: `exp_if` (Exponential Integrate-and-Fire), `fitzhugh_nagumo`, `hodgkin_huxley`, `leaky_if` \n    (Leaky Integrate-and-Fire), `quadratic_if`, `resonate_if`.\n  - MAP models: `henon`, `ikeda`, `logistic`, `lozi`, `sine`, `standard`.\n\n---\n\n## [0.29.2] \u2013 2025-11-20\n### Added\n- Added `choose_default_stepper()` function to automatically select appropriate steppers based on model type\n  if DSL model spec and user does not provide one. The hard-coded defaults are `map` -&gt; `map` and `ode` -&gt; `rk4`.\n- Added theme usage examples in collatz.py, detect_transition.py, and logistic_map.py to demonstrate theme \n  presets.\n\n### Changed\n- Improved plotting primitives with enhanced docstrings and better parameter handling.\n- Standardized arguments of plotting functions.\n\n---\n\n## [0.29.1] \u2013 2025-11-20\n### Added\n- Added plotting theme system using `ThemeSpec` dataclass with inheritance support for better theme management \n  and customization.\n- Added `themes_demo.py` example to demonstrate all available theme presets with sample plots.\n\n### Changed\n- Enhanced savefig function to properly handle constrained layout without clipping.\n- Improved style resolution with clear priority hierarchy separating visual patterns from rendering properties.\n\n---\n\n## [0.29.0] \u2013 2025-11-20\n### Added\n- Added `dynlib` CLI entry point with `model validate`, `steppers list`, and `cache` management \n  subcommands for model validation, registry inspection, and JIT cache cleanup. The CLI entry point is\n  placed into `src/dynlib/cli.py`.\n\n### Tests\n- Added unit tests covering the new CLI flows (model validation success/failure, stepper filters, cache \n  listing/clearing).\n\n---\n\n## [0.28.9] \u2013 2025-11-20\n### Added\n- Added validation script for adaptive ODE steppers tolerance sweep.\n- Added RK2 (explicit midpoint) stepper for fixed-step ODE simulations.\n- Added SDIRK2 (Alexander) stepper, a JIT-compatible implicit method for stiff ODEs.\n\n### Tests\n- Added basic accuracy and contract tests for RK2 and SDIRK2 steppers.\n\n---\n\n## [0.28.8] \u2013 2025-11-20\n### Added\n- Added automatic initial step size selection for adaptive ODE steppers using Hairer/Shampine-style WRMS \n  norm heuristics. Now dt arg for adaptive ode steppers is just a suggestion and max step bound. Stepper \n  tol, atol, meta.order values are accessed automatically during heuristics. Placed the algorithm into \n  `initial_step.py` module. Heuristics are disabled if `resume=True`. \n\n### Changed\n- Updated simulation wrapper to choose initial dt based on stepper type and configuration.\n- Modified Sim class to support WRMS config for adaptive steppers.\n\n### Tests\n- Added tests for new initial step size selection heuristic feature.\n\n---\n\n## [0.28.7] \u2013 2025-11-20\n### Changed\n- Improved `bdf2a` stepper startup by using Richardson extrapolation for better accuracy on the first step. \n- Optimized `tr-bdf2a` stepper by switching to modified Newton method with frozen Jacobian for faster \n  convergence. Full explicit Backwards Euler stage can be further optimized by estimating the error instead \n  of full implicit solve operation. However, for the sake of robustness, I skipped this optimization.\n\n### Fixed\n- Fixed wrong error estimation coefficients for `bdf2a` and `tr-bdf2a` steppers. Using error**0.5 was causing \n  parity between numba and python results. Used math.sqrt(error) for exactly matching results.\n\n### Tests\n- Added accuracy and contract tests for `bdf2a` and `tr-bdf2a` steppers.\n\n---\n\n## [0.28.6] \u2013 2025-11-19\n### Added\n- Added `bdf2a` stepper, an adaptive BDF2 method with variable step size for stiff ODEs.\n- Added `tr-bdf2a` stepper, an adaptive TR-BDF2 method combining trapezoidal rule and BDF2 for better \n  stability. It is not optimized, I might optimize it in the next version if it is feasible.\n\n### Changed\n- Improved RK45 stepper performance by moving k1 computation outside the adaptive retry loop.\n- Renamed `StepperMeta` `stiff_ok` key to `stiff`.\n\n---\n\n## [0.28.5] \u2013 2025-11-19\n### Added\n- Added `select_steppers()` function to filter steppers by metadata fields like kind, scheme, jit_capable, \n  etc.\n- Added `list_steppers()` function to get a list of stepper names matching filter criteria.\n- Added `validation/` folder with `ode_steppers_dt_sweep.py` script for benchmarking ODE stepper accuracy \n  across different time steps.\n\n### Tests\n- Fixed stepper name in `test_stepper_config.py` test to use a stepper with model config key.\n\n---\n\n## [0.28.4] \u2013 2025-11-19\n### Added\n- Added `state()` and `param()` methods to `Sim` class for accessing individual state and parameter \n  values by name.\n- Added `stepper` property to `Sim` class to access the stepper specification.\n- Added a simple exponential decay model (`expdecay.toml`) as a builtin example.\n\n### Changed\n- Moved guards configuration earlier in `build()` to ensure guards are ready before JIT compilation.\n- Updated `get_guards()` to install guard consumers automatically.\n\n### Fixed\n- `jit=True` and `disk_cache=False` combination was raising nopython errors for NaN/Inf guards (like \n  allfinite1d). Added `register_guards_consumer` function in `guards.py` to allow guards to update \n  existing stepper namespaces. In the future a proper numba inlineable functions registry would be \n  better but this fix works right now.\n- Added endpoint clipping in the runner to handle cases where dt would overshoot `t_end`, ensuring \n  accurate final time steps.\n- Registered guards consumers in RK45 and BDF2 steppers for proper NaN/Inf detection updates.\n- Reordered history rotation in BDF2 stepper to prevent aliasing issues between current and proposed \n  states.\n\n---\n\n## [0.28.3] \u2013 2025-11-19\n### Added\n- Added `bdf2a_scipy` stepper which is adaptive BDF2 solver based on scipy root solvers.\n\n### Tests\n- Added accuracy and contract tests for `bdf2a_scipy`.\n\n### Fixed\n- `bdf2` was underperforming according to the `accuracy_demo.py`. Added scale-aware residual bookkeeping \n  and a correction-based convergence check to the Newton loop so the solver can no longer declare success \n  while the update is still O(dt) in size; both BDF1 and BDF2 branches now track the largest state \n  magnitude and require the max residual and the scaled correction to fall below newton_tol before exiting, \n  which restores the intended second-order accuracy. This fixed its very low accuracy.\n\n---\n\n## [0.28.2] \u2013 2025-11-18\n### Added\n- Added Van der Pol oscillator model and its example with jit-enabled `bdf2` stepper.\n- Added a warning when `max_steps` is hit by the runners.\n- Added `accuracy_demo.py` to examples for comparing errors of ode steppers against known models.\n\n### Changed\n- Renamed `bdf2_jit` -&gt; `bdf2` and `bdf2` -&gt; `bdf2_scipy` because jittable custom bdf implementation is \n  way faster than minpack-based scipy solver and its accuracy is similar. I will treat jittable BDF2 \n  implementation as the main BDF stepper.\n\n### Tests\n- Added accuracy and contract tests for `bdf2_scipy`.\n\n---\n\n## [0.28.1] \u2013 2025-11-18\n### Added\n- Added support for extra stepper configuration defaults in the [sim] section of model files. Previously \n  only hardcoded rtol/atol values were handled as [sim] stepper config values. Now unknown keys in [sim] \n  are stored as stepper defaults and used when building stepper configurations. The precedence is still \n  as in v2.28.0. [sim] stepper config values are not used if user overrides the stepper. Not all configs \n  should be listed. The stepper defaults are applied for the ones not provided.\n\n### Changed\n- Updated `SimDefaults` class to handle extra stepper configuration keys dynamically.\n\n### Tests\n- Added tests for stepper config handling, including runtime overrides, model defaults, and extra sim keys.\n\n---\n\n## [0.28.0] \u2013 2025-11-18\n### Added\n- Introduced `ConfigMixin` base class in `config_base.py` for automatic stepper configuration handling. \n  It makes stepper declarations more concise.\n- Added `config_utils.py` file that provides common tools for stepper config values handling. \n- Added new `bdf2` stepper that uses `scipy.optimize.root` for solving implicit equations.\n- Added `requires_scipy` flag to stepper capabilities to indicate scipy dependency.\n- Added support for string enum values in stepper configurations via `config_enum_maps()`.\n\n### Changed\n- Refactored all stepper implementations to use `ConfigMixin` for config management.\n- Updated `_build_stepper_config` to automatically convert string config values to integer enum values \n  using `convert_config_enums` (provided in `config_utils.py`).\n- Updated stepper config default value precedence to: Stepper Config Defaults &lt; Model [sim] table values \n  &lt; User Inputs. This is handled by the `default_config` method of the `ConfigMixin` class. So this base \n  class must be applied to the steppers for this precedence to apply.\n\n---\n\n## [0.27.2] \u2013 2025-11-18\n### Added\n- Added `jit_capable` flag to `StepperCaps` to specify if a stepper supports JIT compilation.\n- Introduced `softdeps.py` module for centralized detection of optional dependencies like numba and \n  scipy.\n- Added `stepper_checks.py` module to validate stepper capabilities and dependencies before building \n  models.\n- New `StepperJitCapabilityError` exception raised when requesting JIT for incompatible steppers.\n\n### Changed\n- Updated `build()` function to perform stepper capability checks, ensuring compatibility with \n  requested options.\n- Refactored dependency detection in `guards.py`, `jit/compile.py`, `runner.py`, and \n  `runner_discrete.py` to use the centralized `softdeps` system.\n\n### Tests\n- Added `test_stepper_jit_capability.py` to test JIT capability validation and error handling.\n\n---\n\n## [0.27.1] \u2013 2025-11-17\n### Changed\n- Improved BDF2_JIT stepper by adding checks for NaN/Inf values during calculations to exit early in \n  case of invalid data. Also improved Jacobian calculations.\n\n### Tests\n- Added BDF2_JIT stepper contract and accuracy tests.\n\n---\n\n## [0.27.0] \u2013 2025-11-17\n### Added\n- Jit compatible BDF2 (Backward Differentiation Formula 2nd Order) stepper `bdf2_jit` is added. It \n  utilizes a simple Newton method plus custom numeric Jacobian. Therefore, it is not as reliable as \n  other solvers utilizing minpack or similar dedicated root finders. However, it is numba compatible, \n  so it can be used for fast simulations or analysis of stiff models to some extend.\n\n## Changed\n- Changed `JacobianPolicy` values as `none`, `internal`, `optional`, `required`.\n  - `none`     : No Jacobian during calculations.\n  - `internal` : Uses a numerical Jacobian approximation. Users can't pass externally.\n  - `optional` : Users can provide external Jacobian. Fallback is `internal`.\n  - `required` : USers should pass an external Jacobian.\n\n### Fixed\n- Simulations were continuing after transient or subsequent runs with `resume=True` even though a \n  `STEPFAIL` was raised by the steppers previously. Ensured the transient warm-up respects runner \n  failures by validating each warm-result before touching session state or shifting time, so `Sim.run` \n  now aborts immediately on a `STEPFAIL`/`NAN_DETECTED` instead of rolling forward with stale values. \n  Wrapped the recorded run in the same guard, so no rebasing, session-state updates, or segment \n  stitching happens unless the wrapper reports `DONE`, keeping resume histories consistent.\n- Added `_ensure_runner_done` to give a clear RuntimeError that includes the failing phase and status \n  name, centralizing the exit check.\n\n### Tests\n- Added regression tests `tests/unit/test_sim_failure.py` that monkeypatch `_execute_run` to simulate \n  `STEPFAIL` returns, covering both transient and main segments, and verifying that state/records remain \n  untouched and `run()` raises.\n- Updated `tests/unit/test_nan_inf_guards.py` to import pytest, expect `Sim.run()` to raise a RuntimeError \n  mentioning `NAN_DETECTED`, and assert the session state remains untouched after the aborted run. This \n  aligns the test with the stricter failure handling added to `Sim.run`.\n\n---\n\n## [0.26.5] \u2013 2025-11-16\n### Added\n- Added new `StepperCaps` dataclass to hold stepper-specific features that can be added or removed \n  without changing the rest of the stepper `StepperMeta` declarations.\n\n### Changed\n- Moved `dense_output` flag from `StepperMeta` to `StepperCaps` for better organization.\n- Updated all stepper implementations (Euler, RK4, RK45, AB2, AB3, Map) to use the new caps structure.\n\n---\n\n## [0.26.4]\n### Tests\n- Updated all tests according to the new workspaces design.\n- All tests pass and examples work at this point.\n\n### Fixed\n- Running the entire unit suite started failing with `ModuleNotFoundError: dynlib_stepper_&lt;digest&gt;` \n  because numba\u2019s cache metadata points to generated module names that were no longer importable \n  once earlier tests cleaned up their in-memory modules. Added a cache importer meta-path finder \n  plus sys.modules registration (`cache_importer.py`) so cached steppers/runners/triplets can \n  always be re-imported from the dynlib cache root, which restores `pytest tests/unit` stability \n  while keeping individual test \n  runs unchanged.\n\n---\n\n## [0.26.3] \u2013 2025-11-16\n### Changed\n- Removed NaN/Inf checks from `AB2` and `AB3` steppers, since they are fixed-step solvers.\n- Removed workbanks related docstrings from steppers.\n\n---\n\n## [0.26.2] \u2013 2025-11-16\n### Changed\n- Updated `snapshot_demo.py` and `uri_demo.py` examples. All examples work at this point.\n\n### Tests\n- Updated `test_snapshot_persistence.py` test.\n\n---\n\n## [0.26.1] \u2013 2025-11-16\n### Changed\n- Updated the docs throughout the package. Removed remnants of the old workbanks docs.\n- Removed stepper_banks.md file and introduced stepper_workspace.md file.\n- Updated ISSUES.md and TODO.md files.\n\n### Fixed\n- Cobweb plotter was still using the old workbanks API. Now it also uses runtime workspace.\n\n---\n\n## [0.26.0] \u2013 2025-11-15\n### Added\n- Introduced separate stepper and runtime workspaces to cleanly separate responsibilities:\n  - **Stepper workspace**: Private to each stepper, implemented as a NamedTuple-of-NumPy-views \n    containing stepper-specific scratch arrays (e.g., stages, histories, Jacobians).\n  - **Runtime workspace**: Private to the runner and DSL machinery, implemented as a NamedTuple \n    containing lag buffers (lag_ring, lag_head, lag_info) for historical state access.\n- Added `StepperSpec.workspace_type()` and `StepperSpec.make_workspace()` methods for steppers \n  to declare and allocate their workspace.\n- Added `RuntimeWorkspace` NamedTuple in `src/dynlib/runtime/workspaces.py` for lag buffer \n  management.\n- Added `make_runtime_workspace()` helper in `src/dynlib/runtime/workspaces.py` to allocate \n  runtime workspace from lag metadata.\n\n### Changed\n- Removed `WorkBanks` and `StructSpec` from public API: Eliminated the shared banking scheme \n  (sp, ss, sw*, iw0, bw0) that mixed stepper scratch with runtime state. Workspaces are now owned \n  by their respective components.\n- Updated stepper ABI: Simplified stepper signature to `stepper(t, dt, y_curr, rhs, params, \n  runtime_ws, stepper_ws, stepper_config, y_prop, t_prop, dt_next, err_est) -&gt; int32`, removing bank \n  arguments and passing workspaces directly.\n- Updated runner ABI: Runner now accepts `runtime_ws` and `stepper_ws` instead of bank arrays. \n  Runner handles lag updates using runtime workspace instead of global `_LAG_STATE_INFO` and ss/iw0 \n  banks. Removed `_LAG_STATE_INFO`.\n- Refactored lagging system: Lag buffers moved to dedicated runtime workspace with circular \n  buffer access. Removed partitioning of ss/iw0 banks for lags.\n- Migrated all steppers: Updated Euler, RK4, RK45, AB2, AB3, and Map steppers to use new \n  workspace pattern. Each stepper defines its own NamedTuple workspace type and factory.\n- Updated code generation: RHS/event lowering now accesses lags via runtime workspace helpers \n  instead of ss/iw0. Generated code remains Numba-friendly.\n- Enhanced workspace serialization: Added `snapshot_workspace()` and `restore_workspace()` \n  helpers for workspace persistence during resume.\n\n### Fixed\n- Eliminated cross-talk between lagging and stepper workspaces, preventing lag corruption in complex \n  models.\n- Improved workspace reallocation safety: workspaces never grow during runs, only RecordingPools / \n  EventPools do.\n\n### Tests\n- Added comprehensive tests for new workspace allocation and migration.\n- Updated all stepper tests to use new ABI.\n- Added tests for lag system with runtime workspace.\n- Verified resume/snapshot functionality with separated workspaces.\n\n### Known Issues\n- Many parts need refactoring for the new workspace approach. Most tests and examples will fail at \n  this point.\n\n---\n\n## [0.25.1] \u2013 2025-11-15\n### Added\n- Added AB3 (Adams-Bashforth 3rd order) stepper for ODE simulations.\n- Added basic and contract tests for AB3.\n\n---\n\n## [0.25.0] \u2013 2025-11-15\n### Added\n- Added AB2 (Adams-Bashforth 2nd order) stepper for ODE simulations.\n- Added basic tests for AB2 stepper accuracy.\n- Added contract tests for ODE steppers to ensure JIT on/off parity and proper registration.\n- Added separate test files for RK4 and RK45 steppers using the new API.\n\n### Changed\n- Updated RK45 stepper default tolerances (atol=1e-6, rtol=1e-3, max_factor=5.0) for better balance.\n\n### Tests\n- Reorganized ODE stepper tests. Now each stepper will have two test files:\n    1) `test_&lt;stepper_name&gt;_basic.py`\n      - Accuracy vs analytic decay\n      - Order test (dt vs dt/2)\n    2) `test_ode_stepper_contract.py` (single file for all steppers)\n      - JIT on/off parity\n      - Buffer growth invariance (your cap_rec tests)\n      - Transient warm-up behavior\n      - Registry / alias correctness\n      - Maybe a transient or growth test\n- Refactored test files to use the `setup()` helper instead of manual model building.\n- Deleted duplicate test model files (`decay_rk4.toml`, `decay_rk45.toml`).\n- Removed old combined RK4/RK45 integration test file.\n\n---\n\n## [0.24.1] \u2013 2025-11-14\n### Added\n- Added scalar DSL macros usable in aux, equations, and event actions: `sign(x)`, `heaviside(x)`, \n  `step(x)`, `relu(x)`, `clip(x, a, b)`, and `approx(x, y, tol)`. They lower to comparisons and \n  builtins only, keeping generated code Numba-friendly.\n\n### Tests\n- Added regression coverage for the new macros in `tests/unit/test_scalar_macros.py`.\n\n---\n\n## [0.24.0] \u2013 2025-11-14\n### Added\n- Added DSL event macros for common transition detection: \n    - `cross_up(state, threshold)`, \n    - `cross_down(state, threshold)`, \n    - `cross_either(state, threshold)`, \n    - `changed(state)`, \n    - `in_interval(value, lower, upper)`, \n    - `enters_interval(state, lower, upper)`, \n    - `leaves_interval(state, lower, upper)`, \n    - `increasing(state)`, `decreasing(state)`.\n\n### Changed\n- Updated `detect_transition.py` example to use the new `cross_up` macro instead of manual lag \n  condition.\n\n### Tests\n- Added comprehensive tests for event macros in `test_event_macros.py`.\n- Updated lag detection to recognize macro usage in expressions.\n\n---\n\n## [0.23.6] \u2013 2025-11-14\n### Fixed\n- Event log buffer reallocation was causing data loss for post events. Reordered event handling in \n  runners (both `runner.py` and `runner_discrete.py`) to check post-events on proposed state before \n  committing. This way reallocation during post-events now occur before commit, and this prevents \n  uncaught event logs.\n\n### Changed\n- DSL event tables now default to `phase = \"post\"` when the key is omitted, simplifying the common\n  case where only post-step events are needed.\n\n### Tests\n- Added unit coverage ensuring the parser backfills the default event phase.\n\n---\n\n## [0.23.5] \u2013 2025-11-14\n### Added\n- Added support for numeric expressions in states and parameters. You can now use strings like \n  \"8/3\" or \"1/2\" that get evaluated to numbers.\n- Added a new example `detect_transition.py` showing how to use the lag system to detect when \n  a state variable crosses from negative to positive.\n\n### Changed\n- Improved TOML parsing error messages with better context, line numbers, and helpful hints for \n  common mistakes like division in values.\n- Updated plotting functions to accept single numbers in `vlines` parameter, not just tuples.\n\n### Tests\n- Added tests for numeric expressions in model states and parameters.\n- Added comprehensive tests for improved TOML error messages.\n\n### Known Issues\n- Event log buffer reallocation causes data loss.\n\n---\n\n## [0.23.4] \u2013 2025-11-14\n### Added\n- Added `uses_lag` and `equations_use_lag` flags to model classes to track lag feature usage.\n- Added `detect_equation_lag_usage` function to check if model equations depend on lag functions. \n  It tries to uncover all dependencies because aux and functions used in equations may also rely \n  on lagged values. \n\n### Changed\n- Updated cobweb plotting to prevent usage with models that have lag in equations, as it cannot \n  evaluate them properly. Future analysis / plot tools that use model equations should not forget \n  that lag mechanism will not work without a proper Sim object. They should perform a similar check.\n\n---\n\n## [0.23.3] \u2013 2025-11-14\n### Fixed\n- `_LAG_STATE_INFO` value was shared globally between different python (non-jitted) runners. This \n  was causing corrupted lag info between different runners. Fixed lag state info to be per-runner \n  instance instead of global, preventing interference between models with different lag configurations.\n\n### Tests\n- Added new tests covering lag info corruption issue to `test_lag_system.py`.\n\n---\n\n## [0.23.2] \u2013 2025-11-14\n### Changed\n- Removed support for the `prev_&lt;name&gt;` DSL shorthand. Now `lag_&lt;name&gt;()` is used as a shorthand for \n  one-step lag. `lag_&lt;name&gt;(k)` usage stays the same.\n\n---\n\n## [0.23.1] \u2013 2025-11-14\n### Added\n- Added `ss_lag_reserved` field to `StructSpec` for lag buffer allocation in stepper state. If\n  a stepper needs to use the ss bank, it should use starting from this index. iw0 bank already\n  has `iw0_lag_reserved` from the previous version.\n\n### Changed\n- Updated stepper banks documentation with lag system partitioning rules for `ss` banks.\n- Updated build process to include lag reservations in struct specification.\n\n---\n\n## [0.23.0] \u2013 2025-11-14\n### Added\n- Added lag system to access historical state values in models using `lag_&lt;name&gt;(k)` for k steps\n  back or `prev_&lt;name&gt;` for one step back. This enables delay differential equations and lagged \n  feedback in both ODE and map models.\n- Added automatic detection and validation of lag usage in model expressions, with sanity limits \n  on lag depths.\n- Added circular buffer storage for lagged states using existing `ss` and `iw0` stepper banks with \n  partitioning to avoid ABI changes.\n- Added lag buffer initialization with initial conditions and updates after committed steps only.\n- Added comprehensive documentation for the lag system in `docs/lag_system.md`.\n- Added `lag_state_info` metadata to `FullModel` and `Model` classes for runtime lag buffer \n  management.\n\n### Changed\n- Updated all stepper implementations (`euler`, `rk4`, `rk45`, `map`) to pass `ss` and `iw0` \n  parameters to RHS and event functions for lag support.\n- Updated runner functions (`runner.py`, `runner_discrete.py`) to maintain lag buffers after step \n  commits and embed lag metadata as compile-time constants.\n- Updated code generation (`emitter.py`, `rewrite.py`) to handle lag notation in expressions and \n  generate circular buffer access code.\n- Updated model building (`build.py`) to augment stepper struct specs with lag requirements and \n  convert lag maps to runtime indices.\n- Updated DSL parsing and validation (`astcheck.py`, `spec.py`) to collect lag requests and build \n  lag metadata.\n- Updated simulation wrapper (`wrapper.py`) to initialize lag buffers on first run.\n- Updated stepper banks documentation (`stepper_banks.md`) with `iw0` partitioning rules for lag \n  heads.\n- Updated plotting primitives (`_primitives.py`) to handle lag buffers in cobweb plots.\n\n### Tests\n- Added comprehensive unit tests for lag system functionality in `tests/unit/test_lag_system.py`, \n  including buffer tracking, resume behavior, and correctness validation.\n- Updated existing tests to accommodate new function signatures with `ss` and `iw0` parameters.\n\n### Known Issues\n- Some lag feature related issues will be resolved in the following updates.\n\n---\n\n## [0.22.0] \u2013 2025-11-13\n### Added\n- Added support for builtin models using the \"builtin://\" URI scheme. This lets users access bundled \n  models without setting up paths manually.\n- Added Izhikevich neuron model as a builtin model with presets for different spiking patterns like \n  regular spiking, bursting, and fast spiking.\n- Updated path resolution to automatically include the builtin models directory in the search paths.\n\n### Changed\n- Updated izhikevich.py example to use the builtin Izhikevich model and show how to apply presets \n  during simulation runs.\n\n### Tests\n- Updated path resolution tests to check that the builtin tag is registered and models can be found.\n\n---\n\n## [0.21.6] \u2013 2025-11-13\n### Added\n- Added `add_preset()` method to `Sim` class. It lets you create new presets from the current \n  session state or by providing specific values for states and parameters.\n- Added support for partial presets. You can now define presets with only some states or \n  parameters instead of requiring all of them. Parameters are no longer mandatory.\n\n### Changed\n- Updated preset validation to allow empty states or params sections, as long as at least one is \n  defined.\n- Modified `apply_preset()` to update only the provided values, leaving other states and parameters\n  unchanged.\n- Enhanced `load_preset()` and `save_preset()` to handle partial presets and provide better error \n  messages.\n- Updated presets demo in examples to show how to use the new preset features.\n\n### Tests\n- Added new tests for partial presets to the `test_presets.py` and updated existing ones.\n\n---\n\n## [0.21.5] \u2013 2025-11-13\n### Changed\n- Updated cobweb plotting function so that it works with new v2 sim or model objects.\n- Updated logistic_map.py example to use themes, grid layouts, and cobweb plots.\n\n---\n\n## [0.21.4] \u2013 2025-11-13\n### Added\n- Added `state_vector()`, `param_vector()`, `state_dict()`, and `param_dict()` methods to `Sim` \n  class. They let getting state and parameter values as arrays or dictionaries from the current \n  session, model defaults, or saved snapshots.\n\n### Changed\n- Updated `izhikevich.py` to show how to access state/parameter values from snapshots.\n\n---\n\n## [0.21.3] \u2013 2025-11-13\n### Added\n- Added `Sim.config()` method to set default simulation settings like dt, max_steps, record options,\n  and capacities. Stepper specific parameters can also be set with this method. They are forwarded\n  to `stepper_config()`.\n- Added `facet.py` example showing how to create faceted plots with multiple subplots.\n- Added support for colored bands in plotting functions, allowing bands to have custom colors.\n\n### Changed\n- Renamed plotting parameters from `events` to `vlines` for better clarity in time series plots.\n- Updated `izhikevich.py` example to use `sim.config(dt=0.01)` and added enhanced plotting features \n  like ylim, colored bands, and vertical lines.\n- Moved plot related examples into the `examples/plot` folder.\n\n---\n\n## [0.21.2] \u2013 2025-11-13\n### Added\n- Introduced `Sim.assign()` method in `src/dynlib/runtime/sim.py` for assigning state and parameter\n  values dynamically during a simulation session.\n\n### Changed\n- Enhanced `_select_seed()` in `Sim` to use current session state values as defaults for \n  `resume=False` runs, allowing explicit overrides with `ic` and `params` arguments.\n- Updated `examples/izhikevich.py` to demonstrate dynamic parameter assignment using `Sim.assign()`.\n\n### Tests\n- Added `tests/unit/test_sim_assign.py` to validate the functionality of `Sim.assign()`.\n\n---\n\n## [0.21.1] \u2013 2025-11-13\n### Changed\n- Removed `tomli` package fallbacks and updated Python requirement as &gt;= 3.11 instead of 3.10.\n\n---\n\n## [0.21.0] \u2013 2025-11-12\n### Added\n- Reintroduced `guards.py` in `src/dynlib/compiler/` to provide universal finiteness checks for \n  steppers. This guard is applied universally to all steppers inside the runners and adaptive \n  steppers also use these checks internally inside their step size calculation loops.\n- Added `allfinite1d` and `allfinite_scalar` functions for finiteness checks.\n- Integrated `guards` with `runner`, `runner_discrete`, and `rk45` stepper for NaN/Inf detection.\n- Added `test_nan_inf_guards.py` to validate the functionality of `guards`.\n\n### Changed\n- Updated `RK45Spec` to use `guards` for internal loops.\n- Enhanced `build_callables` in `src/dynlib/compiler/build.py` to configure finiteness guards \n  based on JIT settings.\n\n---\n\n## [0.20.2] \u2013 2025-11-12\n### Changed\n- Removed `guards.py` because it was poorly designed and implemented; was causing a lot of numba\n  compatibility and caching issues.\n\n### Known Issues\n- All tests pass now but there is no NaN/Inf checks anywhere at this point.\n\n---\n\n## [0.20.1] \u2013 2025-11-12\n### Fixed\n- `build()` warm-up function `_warmup_jit_runner` was generating the wrong runner when dtype is not \n  float64. Updated `_warmup_jit_runner` in `src/dynlib/compiler/build.py` to ensure stepper control \n  values are always float64, regardless of model dtype. This fixed wrong runner caching issue during \n  warm-up.\n- Enhanced comments in `src/dynlib/compiler/build.py` to clarify the use of Python floats for stepper \n  configurations.\n- Fixed exception handling in `_jit_compile_with_disk_cache` in `src/dynlib/compiler/jit/compile.py` \n  to catch `DiskCacheUnavailable` correctly.\n\n### Known Issues\n- `rk45.py` tests are failing. \n\n---\n\n## [0.20.0] \u2013 2025-11-12\n### Added\n- Introduced `Segment` dataclass in `src/dynlib/runtime/sim.py` to represent simulation segments.\n- Added `SegmentsView` and `SegmentView` classes in `src/dynlib/runtime/results_api.py` for \n  accessing recorded simulation segments.\n- Implemented `Sim.name_segment` and `Sim.name_last_segment` methods for renaming simulation \n  segments.\n\n### Changed\n- Enhanced `Sim.run` in `src/dynlib/runtime/sim.py` to support tagging and recording simulation \n  segments.\n- Updated `Sim.results` to include segment metadata in `ResultsView`.\n\n### Tests\n- Added new tests to `tests/steppers/common/test_sim_session.py` to validate segment functionality.\n\n---\n\n## [0.19.4] \u2013 2025-11-12\n### Added\n- Added `examples/collatz.py` to demonstrate map simulation with integer dtype and ternary if \n  usage.\n\n### Changed\n- [params] table was mandatory in DSL model declarations. Made it optional.\n\n### Fixed\n- Fixed a bug in `src/dynlib/compiler/codegen/runner_discrete.py` where the `header` variable was \n  causing caching issues. Replaced `textwrap.dedent` with `inspect.cleandoc`during header creation.\n  Did the same with `runner.py` for symmetry.\n- When using `dtype=int64` (or other integer dtypes) for models, the stepper control arrays (dt_next, \n  t_prop, err_est) were incorrectly being created with the model's dtype instead of float64. This\n  was causing non-monotone time series. Now they are always float64 alongside tracked time. \n\n### Tests\n- Added `test_int_dtype.py` for testing integer data type usage with maps.\n\n---\n\n## [0.19.3] \u2013 2025-11-11\n### Added\n- Introduced `guards.py` in `src/dynlib/runtime/` to provide universal finiteness checks for \n  steppers. This guard is applied universally to all steppers inside the runners and adaptive\n  steppers also use these checks internally inside their step size calculation loops.\n- Added `allfinite1d` function and `configure_allfinite_guard` to toggle between Python and \n  JIT implementations.\n\n### Changed\n- Refactored `runner.py` and `runner_discrete.py` to use `guards.allfinite1d` for finiteness \n  checks.\n- Updated `EulerSpec`, `RK4Spec`, `RK45Spec`, and `MapSpec` to remove redundant finiteness \n  checks and rely on `guards.allfinite1d`.\n- Enhanced `build_callables` in `src/dynlib/compiler/build.py` to configure finiteness guards \n  based on JIT settings.\n\n---\n\n## [0.19.2] \u2013 2025-11-11\n### Changed\n- Gathered all ode-solver steppers under `src/dynlib/steppers/ode` folder.\n\n---\n\n## [0.19.1] \u2013 2025-11-11\n### Added\n- Added `examples/logistic_map.py` to demonstrate the logistic map simulation using the new \n  discrete runner.\n- Implemented `RunnerDiskCache` in `src/dynlib/compiler/codegen/_runner_cache.py` for managing \n  disk-backed runner caching.\n\n### Changed\n- Refactored `runner` and `runner_discrete` to use `RunnerDiskCache` for caching.\n- Enhanced `src/dynlib/compiler/codegen/runner.py` and `runner_discrete.py` to improve modularity\n  and maintainability.\n\n### Fixed\n- `runner_discrete` jit option was not implemented properly and it was accepting a wrong argument. \n  Refactored `runner_discrete` so that now it completely mirrors `runner`. The caching was also \n  not working properly. The new common `RunnerDiskCache` solved that issue.\n\n---\n\n## [0.19.0] \u2013 2025-11-11\n### Changed\n- Split runners into two: `runner_discrete` for discrete-time models; `runner` (old `runner` \n  untouched) for continuous-time models.\n- Sim.run: replaced legacy `t_end` with `T` (continuous end time) and added `N` for discrete\n  iteration counts. `Sim` now distinguishes discrete (maps) vs continuous systems and enforces\n  the correct parameters, improving transient and resume behavior.\n- Wrapper: `run_with_wrapper` accepts `discrete`/`target_steps` and passes a general `horizon`\n  argument to the runner so it can work in iteration (N) or time (T) modes.\n- Build/codegen: added and exported a discrete runner (`runner_discrete`) and wired build to\n  select the discrete runner for `map`-kind steppers; disk-cache configuration was added for\n  the discrete runner as well.\n- Steppers: exported the discrete `map` stepper so it is available for selection/registration.\n- Docs/examples: updated usages to call `sim.run(T=...)` where appropriate (replacing\n  `t_end`).\n\n### Tests\n- Reorganized whole tests folder.\n- Added `test_discrete_runner.py` test for new `runner_discrete` and maps.\n\n---\n\n## [0.18.0] \u2013 2025-11-11\n### Added\n- Added source code export functionality for compiled models. All compiled models now store the \n  generated Python source code for RHS, events, and stepper functions.\n- Added `export_model_sources(model, output_dir)` function in `src/dynlib/compiler/build.py` to \n  export all compiled sources to a directory for inspection and debugging.\n- Added source code fields to `FullModel` and `Model` classes:\n  - `rhs_source`: Generated RHS (right-hand side) function source code\n  - `events_pre_source`: Pre-step event handler source code\n  - `events_post_source`: Post-step event handler source code\n  - `stepper_source`: Numerical integration stepper source code\n- Added `examples/export_sources_demo.py` demonstrating basic source export.\n- Added comprehensive documentation in `docs/export_sources.md`.\n\n### Changed\n- Modified `CompiledPieces` dataclass to store source code from compilation.\n- Updated `build_callables()` to preserve source code through the compilation pipeline.\n- Enhanced `_StepperCacheEntry` to cache stepper source code for reuse.\n- Source code is now available regardless of `disk_cache` setting (always stored in model object).\n\n---\n\n## [0.17.1] \u2013 2025-11-11\n### Added\n- Added `setup()` helper to `src/dynlib/__init__.py`. It combines `build()` + `Sim()` calls. It is \n  more convenient for end users.\n\n---\n\n## [0.17.0] \u2013 2025-11-11\n### Added\n- Added presets feature for quick storage of state/param values. Presets can be defined inside model\n  file or in external toml files.\n- Added `_read_presets` function in `src/dynlib/dsl/parser.py` to parse `[presets.&lt;name&gt;]` blocks \n  from TOML files.\n- Introduced `PresetSpec` dataclass in `src/dynlib/dsl/spec.py` to represent presets in the model \n  DSL.\n- Added `Sim` presets API in `src/dynlib/runtime/sim.py`:\n  - `list_presets(pattern)`: Lists preset names matching a glob pattern.\n  - `apply_preset(name)`: Applies a preset to the current session.\n  - `load_preset(name_or_pattern, path, on_conflict)`: Loads presets from a TOML file.\n  - `save_preset(name, path, include_states, overwrite)`: Saves a preset to a TOML file.\n- Added `examples/presets_demo.py` to demonstrate the presets feature.\n\n### Changed\n- Enhanced `build_spec` in `src/dynlib/dsl/spec.py` to validate and include presets in the model \n  specification.\n- Updated `validate_tables` in `src/dynlib/dsl/schema.py` to validate the `[presets]` table.\n- Enhanced `Sim` initialization in `src/dynlib/runtime/sim.py` to auto-load inline presets from the \n  model specification.\n\n### Tests\n- Added `tests/unit/test_presets.py` to cover inline and file-based presets, including validation, \n  loading, saving, and error handling.\n\n---\n\n## [0.16.2] \u2013 2025-11-10\n### Added\n- Persisted runtime `stepper_config` data in `SessionState`, snapshots, and snapshot metadata so\n  resumes continue with the exact tolerances last used (plus field-name lists for inspection).\n- Added `Sim.stepper_config(**kwargs)` helper and extended `session_state_summary()` diagnostics with\n  stepper-config previews/digests.\n\n---\n\n## [0.16.1] \u2013 2025-11-10\n### Added\n- Introduced snapshot export/import functionality in `Sim`:\n  - `export_snapshot()`: Exports session state to disk as a strict snapshot file.\n  - `import_snapshot()`: Imports session state from a snapshot file, replacing the current session.\n  - `inspect_snapshot()`: Returns parsed metadata from a snapshot file without modifying simulation \n    state.\n- Added `examples/snapshot_demo.py` to demonstrate snapshot export/import and inspection.\n\n### Changed\n- Updated `Sim` class in `src/dynlib/runtime/sim.py`:\n  - Added internal helpers for snapshot handling, including `_snapshot_pick_state`, \n    `_snapshot_build_meta`, `_snapshot_write_npz`, `_snapshot_read_npz`, and `_snapshot_restore`.\n  - Enhanced `Sim.run()` to support snapshot-based workflows.\n\n### Tests\n- Added `tests/integration/test_snapshot_persistence.py` to validate snapshot export/import \n  functionality.\n\n---\n\n## [0.16.0] \u2013 2025-11-10\n### Added\n- `Sim` now tracks an internal `SessionState` so `run(resume=True)` continues from the exact last\n  integrator conditions (time, state, params, dt, workspace).\n- Snapshot API: `create_snapshot()`, `reset()`, and `list_snapshots()` capture/restore\n  SessionState, with an auto `initial` snapshot created before the first run.\n- New helpers `session_state_summary()`, `can_resume()`, and `compat_check()` surface resume\n  diagnostics.\n- Seam-aware result stitching drops duplicate seam samples, offsets STEP/EVT indices, and asserts\n  monotone time; events referencing a dropped seam record are dropped (documented policy).\n\n### Changed\n- `Results` contract now includes `final_params_view`, `t_final`, `final_dt`, `step_count_final`, \n  and `final_stepper_ws`. `run_with_wrapper` captures these values along with snapshots of the \n  stepper workspace and accepts a `workspace_seed` for resume.\n- Runner redefines `EVT_INDEX` as the owning record index (or `-1` when no record exists);\n  downstream docs/tests updated accordingly.\n\n### Tests\n- Added integration coverage for resume stitching, record-off then resume, and snapshot reset in\n  `tests/integration/test_sim_session.py`.\n\n---\n\n## [0.15.3] \u2013 2025-11-09\n### Added\n- `Sim.run()` accepts a `transient` warm-up duration that advances the model before recording while\n  keeping events functional and resetting the public time axis to `t0`.\n- `Results` now exposes the final committed state via `final_state_view` for scenarios that need to\n  reuse the converged state (e.g., transient warm-up, chained simulations).\n### Changed\n- `run_with_wrapper` captures the final committed state and stores it on the returned `Results`.\n\n---\n\n## [0.15.2] \u2013 2025-11-09\n### Changed\n- Renamed `run()` args: \n  - `y0` -&gt; `ic` \n  - `record_every_step` -&gt; `record_interval`\n- Renamed `build()` args:\n  - `stepper_name` -&gt; `stepper`\n  - `model_dtype` -&gt; `dtype`\n\n---\n\n## [0.15.1] \u2013 2025-11-09\n### Changed\n- Forgot to add `**stepper_kwargs` in the previous version. Refactored `Sim.run()` in `sim.py` to \n  accept `**stepper_kwargs` for runtime overrides instead of explicit stepper parameters.\n- Updated `_build_stepper_config()` in `Sim` to construct stepper configuration arrays from\n  `**stepper_kwargs`.\n\n---\n\n## [0.15.0] \u2013 2025-11-09\n### Added\n- Introduced runtime stepper configuration system. Now steppers can declare their internal config \n  values. During build process a read-only struct buffer is filled to pass these values into the \n  steppers. `Sim.run()` can pass these values at runtime. If not provifed, then model [sim] defaults \n  are used. If it is also not present, then internal defaults of the stepper are used. Here are the \n  details:\n  - `config_spec()`: Returns dataclass type or None for stepper configuration.\n  - `default_config(model_spec)`: Creates default configuration with model-specific overrides.\n  - `pack_config(config)`: Packs configuration into a float64 array.\n- Added `stepper_config` parameter to `runner` ABI in `src/dynlib/runtime/runner_api.py`.\n- Enhanced `Sim.run()` in `src/dynlib/runtime/sim.py` to accept `**stepper_kwargs` for runtime \n  overrides.\n- Added `RK45Config` dataclass in `src/dynlib/steppers/rk45.py` with runtime parameters:\n  - `atol`, `rtol` (tolerances)\n  - `safety`, `min_factor`, `max_factor` (step control)\n  - `max_tries`, `min_step` (failure thresholds)\n- Added `_build_stepper_config()` in `Sim` to construct stepper configuration arrays.\n\n### Changed\n- Updated `run_with_wrapper` in `src/dynlib/runtime/wrapper.py` to pass `stepper_config` to the \n  runner.\n- Enhanced `_warmup_jit_runner` in `src/dynlib/compiler/build.py` to initialize `stepper_config` \n  during warmup.\n- Refactored `RK45Spec` in `src/dynlib/steppers/rk45.py` to use `RK45Config` for runtime \n  configuration.\n- Updated `runner` in `src/dynlib/compiler/codegen/runner.py` to accept `stepper_config` as a \n  parameter.\n- Modified `EulerSpec` and `RK4Spec` to return `None` for `config_spec()` and handle empty \n  configurations gracefully.\n\n### Tests\n- Added tests for runtime stepper configuration in `tests/unit/test_stepper_config.py`.\n\n---\n\n## [0.14.2] \u2013 2025-11-08\n### Added\n- Previously only runners were cached. Added disk caching support for stepper and triplet functions\n  in `runner.py`. This way all jittable parts are cached. This improved build times but compilation \n  cost is unavoidable. Use numba for long simulations or simulations / analyses that call `run()` \n  repeatedly. Use disk cache only for fixed models.\n\n### Changed\n- Enhanced `build_callables` in `src/dynlib/compiler/build.py` to include disk caching for RHS and \n  event functions.\n- Improved `emit_rhs_and_events` in `src/dynlib/compiler/codegen/emitter.py` to return source code \n  for RHS and events.\n- Refactored `jit_compile` in `src/dynlib/compiler/jit/compile.py` to support disk caching.\n\n---\n\n## [0.14.1] \u2013 2025-11-08\n### Added\n- Introduced `Timer` utility in `src/dynlib/utils/timer.py` for measuring execution time.\n- Added `izhikevich_benchmark.py` to observe build and run times with and without JIT and disk\n  caching.\n\n### Changed\n- Enhanced `build` function in `src/dynlib/compiler/build.py` to support warm-up for JIT runners.\n  So `build()` also causes numba compilation instead of lazy compilation after `run()` call.\n- Improved error handling in `src/dynlib/compiler/codegen/runner.py` for disk cache unavailability.\n\n### Fixed\n- Updated `resolve_cache_root` in `src/dynlib/compiler/paths.py` to handle unwritable cache \n  directories gracefully. Cache root resolution now probes writability and falls back to a temp \n  directory when the platform default cannot be written to (such as sandboxed environments), \n  ensuring disk caching actually speeds up repeated builds instead of silently falling back to \n  in-memory JIT. \n\n---\n\n## [0.14.0] \u2013 2025-11-07\n### Added\n- Introduced opt-in disk-backed runner caching via `build(..., disk_cache=...)`, including\n  configurable cache roots, deterministic digesting, and automatic regeneration on corruption.\n  - `cache_root=True`: persistent on-disk cache.\n  - `cache_root=False`: in-memory (per-process) JIT only; no files written.\n  - Config defines the cache root. If not available platform defaults are used:\n      Linux: ${XDG_CACHE_HOME:-~/.cache}/dynlib\n      macOS: ~/Library/Caches/dynlib\n      Windows: %LOCALAPPDATA%\\dynlib\\Cache\n\n### Tests\n- Added `tests/unit/test_runner_diskcache.py` to cover materialization, reuse, recovery, and\n  fallback scenarios for the new cache layer.\n\n---\n\n## [0.13.2] \u2013 2025-11-07\n### Fixed\n- The runner was dropping records when buffer growth was triggered. Enhanced `runner` function\n  in `src/dynlib/compiler/codegen/runner.py`:\n  - Added logic to handle pending steps before growth.\n  - Improved recording mechanism for steps during re-entries.\n\n---\n\n## [0.13.1] \u2013 2025-11-07\n### Fixed\n- Buffer reallocation was resetting the wrapper time value. Refactored `run_with_wrapper` in \n  `src/dynlib/runtime/wrapper.py` to track committed time and step size for re-entries, \n  ensuring that reallocation does not corrupt recording.\n\n### Added\n- Added `Sim` to `__all__` in `src/dynlib/__init__.py` for better accessibility.\n- Added `izhikevich.py` example in `examples/` demonstrating neuron spiking behavior.\n\n### Tests\n- `test_euler_growth_matches_reference` in `tests/integration/test_euler_basic.py` now ensures \n  buffer growth does not alter recorded trajectories.\n\n---\n\n## [0.13.0] \u2013 2025-11-07\n### Added\n- Introduced `Sim.results` and `Sim.raw_results` methods for accessing simulation results. The \n  first one returns new `ResultsView` object while the latter returns old low-level `Results` object. \n- Added `EventAccessor` and `EventGroupView` in `src/dynlib/runtime/results_api.py` for grouped \n  event access.\n\n### Changed\n- Updated `Sim.run` in `src/dynlib/runtime/sim.py` to return `None` and store results internally.\n\n### Fixed\n- Updated tests for the new `ResultsView` API.\n- Added `test_sim_results_api.py` test for testing the new `ResultsView` API.\n\n---\n\n## [0.12.5] \u2013 2025-11-07\n### Changed\n- Removed unused `src/dynlib/utils/arrays.py` and `utils` folder because user inputs are always\n  copied with `np.array()` and this file is not useful right now.\n\n---\n\n## [0.12.4] \u2013 2025-11-07\n### Changed\n- Updated `validate_stepper_function` in `src/dynlib/compiler/codegen/validate.py` to include\n `StructSpec` validation.\n- Enhanced `report_validation_issues` to handle warnings and errors more effectively.\n- Modified `build` function in `src/dynlib/compiler/build.py` to pass `StructSpec` to \n  `validate_stepper_function`.\n\n### Added\n- Introduced `test_stepper_guardrails.py` in `tests/unit/` to validate `StructSpec` sizes, \n  persistence flags, and bank assignments.\n- Added new validation rules for `iw0` and `bw0` banks to reject float assignments.\n- Added warnings for ephemeral banks being read before write.\n\n---\n\n## [0.12.3] \u2013 2025-11-07\n### Added\n- Introduced `StepperKindMismatchError` to handle mismatched stepper and model kinds.\n\n### Changed\n- Updated `build` function to validate stepper kind against model kind and raise \n  `StepperKindMismatchError` if incompatible.\n\n---\n\n## [0.12.2] \u2013 2025-11-07\n### Changed\n- Removed `priority` field from `ModSpec` in `src/dynlib/compiler/mods.py`.\n- Updated exclusivity handling in `apply_mods_v2` to enforce stricter group rules.\n- Improved error messages for exclusivity conflicts in `src/dynlib/compiler/mods.py`.\n\n### Tests\n- Removed priority fields from `tests/unit/test_mods.py` .\n- Updated `test_mods_group_exclusive_conflict_raises` to validate stricter exclusivity rules.\n\n---\n\n## [0.12.1] \u2013 2025-11-07\n### Added\n- TODO.md, ISSUES.md files.\n\n### Changed\n- Mods won't change [Sim] defaults in models. This is documented.\n\n---\n\n## [0.12.0] \u2013 2025-11-06\n### Added\n- Event tagging feature for compile-time metadata and filtering:\n  - Added `tags: Tuple[str, ...]` field to `EventSpec` dataclass in `src/dynlib/dsl/spec.py`\n  - Tags are immutable, order-stable (sorted), and deduplicated tuples\n  - Compile-time only; no ABI or runtime impact\n  - Added `tag_index: Dict[str, Tuple[str, ...]]` to `ModelSpec` for fast reverse lookup\n  - Tag index maps each tag to tuple of event names that have that tag\n- DSL support for event tags:\n  - Parser accepts `tags = [\"tag1\", \"tag2\", ...]` under each event in TOML files\n  - Empty or absent tags field defaults to empty tuple (no tags)\n  - Tags are normalized: duplicates removed, alphabetically sorted\n- Tag validation in `src/dynlib/dsl/astcheck.py`:\n  - Added `validate_event_tags` function with pattern `[A-Za-z_][A-Za-z0-9_-]*`\n  - Tags must start with letter or underscore, contain only alphanumerics, underscores, hyphens\n  - Empty tags rejected; non-string tags caught by parser\n  - Duplicates normalized away (not an error)\n\n### Changed\n- Spec hash includes tags for deterministic cache invalidation.\n- Updated `_json_canon` in `src/dynlib/dsl/spec.py` to serialize tags in EventSpec and tag_index\n  in ModelSpec.\n- Added helper `_build_tag_index` to construct reverse index during spec building.\n\n### Tests\n- Added comprehensive test suite in `tests/unit/test_event_tags.py`:\n  - Tag parsing, normalization, and validation\n  - Tag index construction and event lookup\n  - Format validation (valid slugs, invalid special chars, empty tags)\n  - Spec hash stability and changes with tags\n  - Integration with TOML file loading\n- Added test data file `tests/data/models/tagged_events.toml` demonstrating tag usage.\n\n---\n\n## [0.11.3] \u2013 2025-11-06\n### Changed\n- Exclusive groups now raise a ModelLoadError when more than one exclusive mod is supplied,\n  so conflicts no longer slip through unnoticed.\n - `src/dynlib/compiler/mods.py`:  updated exclusivity docs and enforce a conflict check \n   that raises with the conflicting mod names instead of silently selecting a winner.\n\n### Tests\n- Replaced the previous \u201cpick a winner\u201d assertion with a conflict-raises check in \n  `tests/unit/test_mods.py`.\n\n---\n\n## [0.11.2] \u2013 2025-11-06\n### Changed\n- Updated `_apply_remove` in `src/dynlib/compiler/mods.py`:\n  - Added validation to raise errors for non-existent `events`, `aux`, and `functions` during \n    removal.\n  - Improved error messages for better debugging.\n- Enhanced `_apply_replace` in `src/dynlib/compiler/mods.py`:\n  - Added validation to ensure replaced `events`, `aux`, and `functions` exist.\n  - Improved error handling for invalid replacements.\n\n### Tests\n- Added new test cases in `tests/unit/test_mods.py`:\n  - `test_mods_remove_nonexistent_event_raises`: Verifies error is raised for non-existent event \n    removal.\n  - `test_mods_replace_nonexistent_raises`: Ensures replacement of non-existent entities raises \n    errors.\n- Updated `tests/unit/test_mods_aux_functions.py`:\n  - `test_remove_aux_nonexistent_raises`: Validates error handling for non-existent aux removal.\n  - `test_remove_functions_nonexistent_raises`: Ensures error is raised for non-existent function \n    removal.\n\n---\n\n## [0.11.1] \u2013 2025-11-06\n### Changed\n- Updated `Results` class in `src/dynlib/runtime/results.py`:\n  - Added `status` field to store runner exit status.\n  - Added `ok` property to check if the runner exited cleanly.\n  - Updated docstrings to reflect the new `status` field.\n- Enhanced `run_with_wrapper` function in `src/dynlib/runtime/wrapper.py`:\n  - Added `status` field to `Results` object returned by the function.\n  - Improved early termination handling with warnings for specific statuses.\n  - Refactored status handling logic for clarity.\n\n### Tests\n- New assertions for `status` and `ok` properties in `tests/unit/test_wrapper_reentry.py`.\n\n---\n\n## [0.11.0] \u2013 2025-11-06\n### Changed\n- Removed `REJECT` status code from the stepper/runner contract:\n  - Clarified architectural contracts: fixed-step steppers do single attempts; adaptive steppers \n    handle internal accept/reject loops\n  - Runner never sees rejection codes; adaptive steppers (like RK45) handle retries internally \n    and only return terminal codes\n  - Updated status enum in `src/dynlib/runtime/runner_api.py`: removed `REJECT=1`\n  - Updated all exports in `src/dynlib/__init__.py` to remove `REJECT`\n  - Simplified runner comments in `src/dynlib/compiler/codegen/runner.py`\n  - Updated wrapper imports in `src/dynlib/runtime/wrapper.py`\n  - Stepper contract now clear: return `OK` (step accepted) or terminal codes (`NAN_DETECTED`, \n    `STEPFAIL`)\n\n### Added\n- NaN/Inf detection in fixed-step steppers:\n  - Added finiteness checks to Euler stepper (`src/dynlib/steppers/euler.py`)\n  - Added finiteness checks to RK4 stepper (`src/dynlib/steppers/rk4.py`)\n  - Both now return `NAN_DETECTED` if proposal contains non-finite values\n  - Maintains consistency with adaptive stepper (RK45) which already had such checks\n\n---\n\n## [0.10.2] \u2013 2025-11-06\n### Changed\n- Dropped the legacy `EVT_TIME` buffer entirely; logged times live in `EVT_LOG_DATA`.\n\n---\n\n## [0.10.1] \u2013 2025-11-06\n### Changed\n- Removed `record` key from events in favor of unified `log` mechanism:\n  - Events no longer support `record=True/False`\n  - Use `log=[\"t\"]` to capture event occurrence times\n  - Use `log=[\"t\", \"x\", ...]` to capture both time and other values\n  - The `\"t\"` signal is treated like any other loggable value in `EVT_LOG_DATA`\n  - Eliminates non-orthogonal design where `record` and `log` overlapped\n  - Event buffers only grow when events actually have `log` items\n  - Migration: Replace `record=true` with `log=[\"t\"]`, or add `\"t\"` to existing log arrays\n\n### Fixed\n- Event buffer allocation is now more efficient:\n  - No buffer space wasted on events without logging\n  - Events only increment buffer counter when they have actual log data\n\n### Changed\n- Updated event function signature in `src/dynlib/compiler/codegen/emitter.py`:\n  - Old: `events_phase(...) -&gt; (event_code, has_record, log_width)`\n  - New: `events_phase(...) -&gt; (event_code, log_width)`\n- Updated runner in `src/dynlib/compiler/codegen/runner.py`:\n  - Removed `has_record` conditional logic\n  - Simplified event recording: only fires when `log_width &gt; 0`\n  - All log values (including `\"t\"`) go to `EVT_LOG_DATA`\n- Updated `EventSpec` dataclass in `src/dynlib/dsl/spec.py`:\n  - Removed `record: bool` field\n- Updated parsers to reject deprecated `record` key with helpful error:\n  - `src/dynlib/dsl/parser.py`: Raises error directing users to use `log=[\"t\"]`\n  - `src/dynlib/compiler/mods.py`: Same validation in mod files\n- Updated `src/dynlib/runtime/runner_api.py` documentation\n\n### Tests\n- Updated all test models and test cases to use `log=[\"t\"]` instead of `record=True`.\n\n---\n\n## [0.10.0] \u2013 2025-11-06\n### Fixed\n- Event logging now properly separates `record` and `log` functionality:\n  - Previously, events only logged if BOTH `record=True` AND `log` was non-empty, silently \n    ignoring events with `record=True` but empty `log=[]`\n  - `EVT_INDEX` was stuck at zero and log signal values were never materialized\n  - New behavior:\n    - `record=True` \u2192 logs event occurrence times to `EVT_TIME` and `EVT_CODE`\n    - `log=[signals]` \u2192 logs signal values to new `EVT_LOG_DATA` buffer (independent of `record`)\n    - Both features are now orthogonal and can be used independently or together\n  - `EVT_INDEX` now stores the log width (number of signals logged per event)\n  - Events with `log` but no `record` set `EVT_TIME=-1.0` as a sentinel\n\n### Added\n- New `EVT_LOG_DATA` buffer in `EventPools` to store logged signal values:\n  - Shape: `(cap_evt, max_log_width)` where `max_log_width` is computed from all events\n  - Values are model dtype (same as state variables)\n  - Accessible via `Results.EVT_LOG_DATA_view` property\n- Helper function `_parse_log_signal()` in `src/dynlib/compiler/codegen/emitter.py`:\n  - Supports formats: `\"x\"` (state), `\"param:a\"`, `\"aux:E\"`, `\"t\"` (time)\n  - Validates that referenced symbols exist in the model spec\n- Event log scratch buffer `evt_log_scratch` passed to runner for temporary log value storage\n\n### Changed\n- Event function signature in `src/dynlib/compiler/codegen/emitter.py`:\n  - Old: `events_phase(t, y_vec, params) -&gt; event_code`\n  - New: `events_phase(t, y_vec, params, evt_log_scratch) -&gt; (event_code, has_record, log_width)`\n  - Events now write log values into `evt_log_scratch` before returning\n- Runner signature in `src/dynlib/compiler/codegen/runner.py`:\n  - Added `EVT_LOG_DATA` and `evt_log_scratch` parameters\n  - Runner now copies log data from scratch buffer to `EVT_LOG_DATA[m, :]` when `log_width &gt; 0`\n  - Records event time/code only when `has_record=True`\n- Updated `allocate_pools()` in `src/dynlib/runtime/buffers.py`:\n  - Added `max_log_width` parameter\n  - Allocates `EVT_LOG_DATA` with shape `(cap_evt, max(1, max_log_width))`\n- Updated `grow_evt_arrays()` in `src/dynlib/runtime/buffers.py`:\n  - Added `dtype` parameter for allocating `EVT_LOG_DATA` with correct dtype\n  - Copies existing log data during growth\n- Updated `Sim.run()` in `src/dynlib/runtime/sim.py`:\n  - Calculates `max_log_width` from event specs before calling wrapper\n- Added `EVT_LOG_DATA` to forbidden writes in `src/dynlib/compiler/codegen/validate.py`\n\n### Tests\n- Updated `test_event_logging_basic()` in `tests/integration/test_event_logging.py`:\n  - Verifies `EVT_INDEX` contains log width (not zero)\n  - Checks that `EVT_LOG_DATA` contains logged signal values\n  - Validates logged values are within expected ranges\n- Fixed `test_codegen_triplet.py` to use new event signature with scratch buffer\n- Fixed `test_buffers_growth.py` to pass `max_log_width` and `dtype` parameters\n\n---\n\n## [0.9.0] \u2013 2025-11-06\n### Added\n- Implemented complete mod support for DSL aux and functions:\n  - Added `add.aux` and `add.functions` verbs in `src/dynlib/compiler/mods.py`\n  - Added `replace.aux` and `replace.functions` verbs with existence validation\n  - Added `remove.aux` and `remove.functions` verbs (silent for non-existent items)\n  - Added `set.aux` and `set.functions` verbs with upsert semantics\n  - All verbs follow the same deterministic application order: remove \u2192 replace \u2192 add \u2192 set\n\n### Changed\n- Enhanced `_apply_remove`, `_apply_replace`, `_apply_add`, and `_apply_set` in \n  `src/dynlib/compiler/mods.py`:\n  - Extended all verb handlers to support aux and functions alongside existing events support\n  - Added `_normalize_function` helper for consistent function definition validation\n  - String expression validation for aux values\n  - Function args and expr validation matching parser requirements\n\n### Tests\n- Updated tests and removed redundant ones.\n- Added 19 comprehensive tests in `tests/unit/test_mods_aux_functions.py`:\n  - `test_add_aux` - Adding new auxiliary variables\n  - `test_add_aux_duplicate_raises` - Duplicate detection\n  - `test_replace_aux` - Replacing existing aux expressions\n  - `test_replace_aux_nonexistent_raises` - Error on missing aux\n  - `test_remove_aux` - Removing aux variables\n  - `test_remove_aux_nonexistent_silent` - Silent handling of non-existent removals\n  - `test_set_aux_upsert` - Upsert semantics (create or update)\n  - `test_add_functions` - Adding new functions\n  - `test_add_functions_duplicate_raises` - Duplicate detection\n  - `test_replace_functions` - Replacing existing functions\n  - `test_replace_functions_nonexistent_raises` - Error on missing function\n  - `test_remove_functions` - Removing functions\n  - `test_remove_functions_nonexistent_silent` - Silent handling\n  - `test_set_functions_upsert` - Upsert semantics\n  - `test_verb_order_remove_then_add` - Verb ordering validation\n  - `test_multiple_mods_aux_and_functions` - Sequential application\n  - `test_invalid_aux_value_type` - Type validation for aux\n  - `test_invalid_function_args` - Args validation\n  - `test_invalid_function_expr` - Expr validation\n\n---\n\n## [0.8.0] \u2013 2025-11-06\n### Added\n- DSL block equations are now parsed (previously they were omitted).\n- Introduced `StructSpec` validation in `src/dynlib/steppers/base.py`:\n  - Ensures all sizes are non-negative integers.\n  - Validates compatibility with declared dense-output coefficients and history lengths.\n- Added `validate_name_collisions` in `src/dynlib/dsl/schema.py`:\n  - Detects duplicate equation targets across RHS and block forms.\n\n### Changed\n- Enhanced `emit_rhs_and_events` in `src/dynlib/compiler/codegen/emitter.py`:\n  - Improved error messages for invalid LHS in block equations.\n- Updated `build_spec` in `src/dynlib/dsl/spec.py`:\n  - Added stricter validation for unknown states and missing equals in equations.\n\n### Tests\n- Added unit tests in `tests/unit/test_equations_block_form.py`:\n  - Verified detection of duplicate targets and invalid LHS in block equations.\n  - Tested auxiliary variable usage and user-defined functions in block equations.\n- Added integration tests in `tests/integration/test_block_equations_sim.py`:\n  - Verified simulation correctness with mixed RHS and block equations.\n  - Tested conservation laws and stepper compatibility.\n\n---\n\n## [0.7.1] \u2013 2025-11-06\n### Changed\n- Updated `_edges_for_aux_and_functions` in `src/dynlib/dsl/astcheck.py`:\n  - Function dependencies now include references to auxiliary variables.\n- Enhanced `build_spec` in `src/dynlib/dsl/spec.py`:\n  - Added validation steps for acyclic expressions, event legality, and function signatures.\n\n### Tests\n- Added integration tests in `tests/integration/test_semantic_validation.py`:\n  - Verified detection of cyclic dependencies in auxiliary variables and functions.\n  - Tested event legality and function argument validation.\n\n---\n\n## [0.7.0] \u2013 2025-11-05\n### Changed\n- Centralized JIT compilation logic in `src/dynlib/compiler/jit/compile.py`:\n  - Introduced `jit_compile` function for consistent error handling.\n  - Updated `maybe_jit_triplet` to use `jit_compile`.\n- Enhanced `runner` function in `src/dynlib/compiler/codegen/runner.py`:\n  - Added event logging for pre/post events.\n  - Improved event buffer growth handling.\n- Updated `emit_rhs_and_events` in `src/dynlib/compiler/codegen/emitter.py`:\n  - Added event codes for logging-enabled events.\n  - Ensured default return value for no events fired.\n- Modified `run_with_wrapper` in `src/dynlib/runtime/wrapper.py`:\n  - Preserved event cursor during buffer growth.\n\n### Tests\n- Added integration tests in `tests/integration/test_event_logging.py`:\n  - Verified event logging functionality.\n  - Tested multiple event firings and state captures.\n- Updated `tests/data/models/decay_with_event.toml`:\n  - Added `log` field to reset event.\n\n---\n\n## [0.6.1] \u2013 2025-11-05\n### Changed\n- Preceding newlines are removed from the inline model declarations. This way `inline:`\n  statement can be placed above `[model]` statements.\n\n### Known Issues\n- A FIX_PLAN.md file is created to implement planned but missing features. These features\n  will be added.\n\n---\n\n## [0.6.0] \u2013 2025-11-05\n### Added\n- Implemented comprehensive path resolution system in `src/dynlib/compiler/paths.py`:\n  - Platform-specific config file locations (Linux/XDG, macOS, Windows)\n  - `DYNLIB_CONFIG` environment variable for custom config paths\n  - `DYN_MODEL_PATH` environment variable with prepend semantics for runtime tag additions\n  - `TAG://` URI scheme for model resolution from configured directories\n  - `inline:` URI scheme for embedding model definitions directly\n  - Support for absolute and relative paths with automatic `.toml` extension resolution\n  - Fragment selectors (`#mod=NAME`) for selecting embedded mods from files\n  - Path traversal prevention outside declared roots\n  - Clear error messages listing all searched candidates on failure\n- Enhanced `build()` function in `src/dynlib/compiler/build.py`:\n  - Accepts both URI strings and ModelSpec objects\n  - `mods` parameter for applying multiple mod files via URIs\n  - `config` parameter for custom PathConfig\n  - Automatically resolves stepper from model's sim defaults if not specified\n- Added `load_model_from_uri()` function for loading models with mod application\n- New exception classes in `src/dynlib/errors.py`:\n  - `ModelNotFoundError`: lists all searched paths\n  - `ConfigError`: configuration file or environment errors\n  - `PathTraversalError`: security violation detection\n  - `AmbiguousModelError`: multiple files match extensionless reference\n- Updated `src/dynlib/compiler/__init__.py` to export new public API\n\n### Changed\n- `build()` signature enhanced with optional `config` parameter\n- `build()` now accepts `Union[ModelSpec, str]` for model parameter\n\n### Tests\n- Added 37 unit tests in `tests/unit/test_paths.py`:\n  - Config loading from all platforms\n  - Environment variable handling\n  - TAG:// resolution with multiple roots and first-match-wins\n  - inline:, absolute, relative path handling\n  - Fragment extraction\n  - Path traversal security checks\n  - Error message quality verification\n- Added 16 integration tests in `tests/integration/test_uri_loading.py`:\n  - End-to-end model building from all URI schemes\n  - Embedded mod selection with fragments\n  - External mod file application\n  - Multiple mods in sequence\n  - Error handling with helpful diagnostics\n  - Backward compatibility with direct ModelSpec usage\n\n### Documentation\n- URI schemes supported:\n  - `inline: [model]\\ntype='ode'\\n...` - Direct TOML content\n  - `/abs/path/model.toml` - Absolute file path\n  - `relative/model.toml` - Relative to current working directory\n  - `TAG://model.toml` - Resolve using configured tag roots\n  - Any of above with `#mod=NAME` - Select embedded mod\n- Config file format:\n  ```toml\n  [paths]\n  proj = [\"/home/user/models\", \"/opt/shared/models\"]\n  user = \"/home/user/personal/models\"\n  ```\n- Config File Paths:\n  - Linux: `${XDG_CONFIG_HOME:-~/.config}/dynlib/config.toml`\n  - macOS: `~/Library/Application Support/dynlib/config.toml`\n  - Windows: `%APPDATA%\\dynlib\\config.toml`\n- Environment variables:\n  - `DYNLIB_CONFIG=/custom/path/config.toml` - Override config location\n  - `DYN_MODEL_PATH=proj=/extra/path,/another:new=/path` - Add paths at runtime\n\n---\n\n## [0.5.0] \u2013 2025-11-05\n### Added\n- Implemented `RK45Spec` in `src/dynlib/steppers/rk45.py` for Dormand-Prince adaptive stepper \n  with embedded 4th/5th order error estimation.\n\n### Changed\n- Enhanced buffer allocation in `src/dynlib/runtime/buffers.py`:\n  - Improved `allocate_pools` to handle workspace banks (sp, ss, sw0-sw3) with size 0 convention.\n  - Size 0 now means \"allocate n_state elements\", size &gt;= 1 uses spec size as-is.\n  - Ensures all RK methods get sufficient workspace without ABI changes.\n- Updated `RK4Spec` for the new banks allocation rule.\n\n### Tests\n- Added comprehensive integration tests in `tests/integration/test_rk4_rk45.py`:\n  - `test_rk4_accuracy`: Verifies RK4 achieves &lt; 1e-5 relative error for exponential decay.\n  - `test_rk4_order_convergence`: Confirms 4th-order convergence (16x error reduction when \n    halving dt).\n  - `test_rk45_adaptive_accuracy`: Validates RK45 adaptive stepping accuracy.\n  - `test_rk45_step_adaptation`: Verifies RK45 outperforms Euler significantly.\n  - `test_rk4_jit_parity` and `test_rk45_jit_parity`: Ensure identical results with JIT on/off.\n  - `test_stepper_registration`: Confirms all steppers and aliases are properly registered.\n- Added test models `tests/data/models/decay_rk4.toml` and `decay_rk45.toml`.\n\n---\n\n## [0.4.1] \u2013 2025-11-05\n### Added\n- Added `get_runner` in `src/dynlib/compiler/codegen/runner.py` for obtaining a generic runner\n  function.\n- Created `runner` function in `src/dynlib/compiler/codegen/runner.py` for fixed-step execution \n  with events and recording.\n- Introduced `EulerSpec` in `src/dynlib/steppers/euler.py` for explicit Euler stepper \n  implementation.\n\n### Changed\n- Updated `build` in `src/dynlib/compiler/build.py` to use `get_runner` instead of generating \n  runner source code from string.\n- Enhanced `emit` in `src/dynlib/steppers/euler.py` to return a callable Python function instead \n  of source code.\n- Improved `StepperSpec` in `src/dynlib/steppers/base.py` to include detailed docstrings for \n  `emit` method.\n\n---\n\n## [0.4.0] \u2013 2025-11-04\n### Added\n- Introduced `Sim.run` method in `src/dynlib/runtime/sim.py` for executing simulations with \n  compiled models.\n- Added `run_with_wrapper` in `src/dynlib/runtime/wrapper.py` for orchestrating simulation runs.\n- Created `EulerSpec` in `src/dynlib/steppers/euler.py` for explicit Euler stepper implementation.\n\n### Changed\n- Updated `allocate_pools` in `src/dynlib/runtime/buffers.py` to ensure `sw0` size is at least \n  `n_state` for steppers requiring workspace.\n- Enhanced `Model` dataclass in `src/dynlib/runtime/model.py` with additional attributes for \n  compiled stepper and runner callables.\n\n### Tests\n- Added integration tests in `tests/integration/test_euler_basic.py` for Euler simulations, event \n  handling, and buffer growth.\n- Updated unit tests in `tests/unit/test_wrapper_reentry.py` to validate re-entry logic for buffer \n  growth.\n\n---\n\n## [0.3.1] \u2013 2025-11-04\n### Fixed\n- Removed redundant validation functions `validate_dtype_rules` and `validate_equation_targets` \n  from `src/dynlib/dsl/astcheck.py`.\n- Fixed unused import `from email.mime import message` in `src/dynlib/errors.py`.\n\n### Tests\n- Updated tests in `tests/unit/test_ast_check.py` to reflect changes in validation logic.\n\n---\n\n## [0.3.0] \u2013 2025-11-04\n### Added\n- Introduced `build_callables` in `src/dynlib/compiler/build.py` for generating RHS and event \n  callables.\n- Added `emit_rhs_and_events` in `src/dynlib/compiler/codegen/emitter.py` for code generation.\n- Implemented `JITCache` in `src/dynlib/compiler/jit/cache.py` for caching compiled callables.\n  - Added `maybe_jit_triplet` in `src/dynlib/compiler/jit/compile.py` for JIT compilation toggle.\n- Created `Model` dataclass in `src/dynlib/runtime/model.py` for simulation models.\n- Added `Sim` class in `src/dynlib/runtime/sim.py` as a placeholder for simulation runners.\n\n### Changed\n- Fixed column-major layout in `tests/unit/test_numba_probe.py` for recording buffers.\n- Enhanced `_normalize_event` in `src/dynlib/compiler/mods.py` to handle nested TOML dicts for \n  actions.\n- Improved `_read_events` in `src/dynlib/dsl/parser.py` to support nested TOML keys for event \n  actions.\n\n### Tests\n- Added unit tests for `build_callables` in `tests/unit/test_codegen_triplet.py`.\n\n---\n\n## [0.2.0] \u2013 2025-11-04\n### Added\n- Implemented `parse_model_v2` in `src/dynlib/dsl/parser.py` for parsing DSL TOML into normalized \n  models.\n- Added validation functions in `src/dynlib/dsl/schema.py` for model headers, tables, and name \n  collisions.\n- Introduced `SimDefaults`, `EventSpec`, and `ModelSpec` dataclasses in \n  `src/dynlib/dsl/spec.py`.\n- Added `build_spec` and `compute_spec_hash` in `src/dynlib/dsl/spec.py` for model specification \n  and hashing.\n- Created `src/dynlib/errors.py` for custom exceptions like `ModelLoadError`.\n- Added `allocate_pools`, `grow_rec_arrays`, and `grow_evt_arrays` in `src/dynlib/runtime/buffers.py` \n  for memory management.\n- Introduced `Results` dataclass in `src/dynlib/runtime/results.py` for simulation outputs.\n- Added `run_with_wrapper` in `src/dynlib/runtime/wrapper.py` for orchestrating simulation runs.\n\n### Tests\n- Added unit tests for `parse_model_v2` in `tests/unit/test_ast_check.py`.\n- Added tests for buffer growth in `tests/unit/test_buffers_growth.py`.\n- Added schema and parser tests in `tests/unit/test_dsl_schema_parser.py`.\n- Added tests for `build_spec` and `compute_spec_hash` in `tests/unit/test_dsl_spec.py`.\n- Added tests for `apply_mods_v2` in `tests/unit/test_mods.py`.\n- Added re-entry tests for `run_with_wrapper` in `tests/unit/test_wrapper_reentry.py`.\n\n---\n\n## [0.1.0] \u2013 2025-11-04\n### Added\n- Introduced `src/dynlib/__init__.py` to re-export constants, types, steppers, and utilities \n  for stable imports.\n- Added `src/dynlib/runtime/runner_api.py` defining stable exit/status codes and the frozen \n  runner ABI.\n- Added `src/dynlib/runtime/types.py` for type literals like `Kind`, `TimeCtrl`, and `Scheme`.\n- Added `src/dynlib/steppers/base.py` with metadata and struct specifications for steppers.\n- Added `src/dynlib/steppers/registry.py` to manage stepper registration and retrieval.\n- Added `src/dynlib/utils/arrays.py` with utility functions for array validation and slicing.\n\n### Tests\n- Added `tests/unit/test_numba_probe.py` to validate future JIT-compiled runner's numba\n  compliance.\n\n---\n\n## [0.0.0] \u2013 2025-11-03\n### Changed\n- Initial commit.\n</code></pre>"},{"location":"project/issues/","title":"Issues","text":"<p>Source: <code>ISSUES.md</code></p> <pre><code># Known Issues\n\nThis file lists the known issues in the project. Each issue includes a brief description, status, and any relevant notes or workarounds.\n\n## Issues\n\n1. **Name**\n   - **Description**: \n   - **Status**: CLOSED.\n   - **Notes**:\n</code></pre>"},{"location":"project/todo/","title":"TODO","text":"<p>Source: <code>TODO.md</code></p> <pre><code># TODO\n\n## Tasks\n\n1. **Dense Output for Interpolation**\n   - **Description**: Implement dense output for interpolation between grid points.\n   - **Status**: Planned.\n   - **Notes**: Test with various interpolation methods.\n\n2. **User Interrupt Handling**\n   - **Description**: Implement support for handling user interrupts (e.g., Ctrl+C) gracefully.\n   - **Status**: Planned.\n   - **Notes**: Ensure proper cleanup and state preservation.\n</code></pre>"},{"location":"reference/","title":"Reference","text":"<p>The reference section collects generated artifacts and registry helpers that complement the conceptual guides. To produce these references <code>tools/gen_model_docs.py</code> should be run manually.</p>"},{"location":"reference/#built-in-models","title":"Built-in models","text":"<p>The <code>reference/models</code> subfolder is populated by <code>tools/gen_model_docs.py</code> via <code>mkdocs-gen-files</code>. Each model under <code>src/dynlib/models/{map,ode}</code> gets a dedicated page showing the TOML source plus links into the literate navigation tree (<code>reference/models/SUMMARY.md</code>).</p> <ul> <li>Built-in model overview \u2014 choose between the map and ODE collections and open any generated TOML listing.</li> </ul>"},{"location":"reference/#generating-docs-locally","title":"Generating docs locally","text":"<ul> <li> <p>The documentation relies on <code>mkdocs</code>. To regenerate or serve the documentation locally:</p> </li> <li> <p>Install MkDocs and required plugins:    <pre><code>pip install mkdocs mkdocs-material mkdocs-literate-nav \"mkdocstrings[python]\" mkdocs-static-i18n\n</code></pre></p> </li> <li> <p>Install additional Markdown extensions:    <pre><code>pip install pymdown-extensions\n</code></pre></p> </li> <li> <p>From the project root, serve the docs:    <pre><code>mkdocs serve\n</code></pre>    Or build them:    <pre><code>mkdocs build\n</code></pre></p> </li> <li> <p>To manually update the auto-generated doc files run:    <pre><code>python tools/gen_model_docs.py\n</code></pre></p> </li> </ul> <p>The generated site will be in the <code>site/</code> directory.</p>"},{"location":"reference/models/","title":"Built-in model library","text":"<ul> <li>Map models</li> <li>ODE models</li> </ul>"},{"location":"reference/models/map/","title":"Map models","text":"<ul> <li>henon</li> <li>henon2</li> <li>ikeda</li> <li>logistic</li> <li>lozi</li> <li>sine</li> <li>standard</li> </ul>"},{"location":"reference/models/map/henon/","title":"<code>henon.toml</code>","text":"<p>Source: <code>src/dynlib/models/map/henon.toml</code> <pre><code>[model]\ntype = \"map\"\nname = \"Henon Map\"\ndtype = \"float64\"\n\n[states]\nx = 0.0\ny = 0.0\n\n[params]\na = 1.4\nb = 0.3\n\n[equations.rhs]\nx = \"1.0 - a * x**2 + y\"\ny = \"b * x\"\n\n[equations.jacobian]\nexpr = [\n    [\"-2.0 * a * x\", \"1.0\"],\n    [\"b\", \"0.0\"]\n]\n</code></pre></p>"},{"location":"reference/models/map/henon2/","title":"<code>henon2.toml</code>","text":"<p>Source: <code>src/dynlib/models/map/henon2.toml</code> <pre><code># Henon map version used in Kathleen Alligood's book\n[model]\ntype = \"map\"\nname = \"Henon Map 2\"\ndtype = \"float64\"\n\n[states]\nx = 0.0\ny = 0.0\n\n[params]\na = 1.4\nb = 0.3\n\n[equations.rhs]\nx = \"a - x**2 + b*y\"\ny = \"x\"\n\n[equations.inverse.rhs]\nx = \"y\"\ny = \"(x - a + y**2) / b\"\n\n[equations.jacobian]\nexpr = [\n    [\"-2.0 * x\", \"b\"],\n    [\"1.0\", \"0.0\"]\n]\n</code></pre></p>"},{"location":"reference/models/map/ikeda/","title":"<code>ikeda.toml</code>","text":"<p>Source: <code>src/dynlib/models/map/ikeda.toml</code> <pre><code>[model]\ntype = \"map\"\nname = \"Ikeda Map\"\ndtype = \"float64\"\n\n[states]\nx = 0.1\ny = 0.0\n\n[params]\nu = 0.9\na = 0.4\nb = 6.0\n\n[aux]\nr2     = \"x**2 + y**2\"\ntheta  = \"a - b / (1.0 + r2)\"\n\n[equations.rhs]\nx = \"1.0 + u * (x * cos(theta) - y * sin(theta))\"\ny = \"u * (x * sin(theta) + y * cos(theta))\"\n</code></pre></p>"},{"location":"reference/models/map/logistic/","title":"<code>logistic.toml</code>","text":"<p>Source: <code>src/dynlib/models/map/logistic.toml</code> <pre><code>[model]\ntype=\"map\"\nname=\"Logistic Map\"\n\n[states]\nx=0.1\n\n[params]\nr=4.0\n\n[equations.rhs]\nx = \"r * x * (1 - x)\"\n\n[equations.jacobian]\nexpr = [\n    [\"r - 2 * r * x\"]\n]\n</code></pre></p>"},{"location":"reference/models/map/lozi/","title":"<code>lozi.toml</code>","text":"<p>Source: <code>src/dynlib/models/map/lozi.toml</code> <pre><code>[model]\ntype = \"map\"\nname = \"Lozi Map\"\ndtype = \"float64\"\n\n[states]\nx = 0.0\ny = 0.0\n\n[params]\na = 1.7\nb = 0.5\n\n[equations.rhs]\nx = \"1.0 - a * abs(x) + b * y\"\ny = \"x\"\n</code></pre></p>"},{"location":"reference/models/map/sine/","title":"<code>sine.toml</code>","text":"<p>Source: <code>src/dynlib/models/map/sine.toml</code> <pre><code>[model]\ntype = \"map\"\nname = \"Sine Map\"\ndtype = \"float64\"\n\n[states]\nx = 0.5\n\n[params]\nr  = 0.9\npi = 3.141592653589793\n\n[equations.rhs]\nx = \"r * sin(pi * x)\"\n\n[equations.jacobian]\nexpr = [\n    [\"r * pi * cos(pi * x)\"]\n]\n</code></pre></p>"},{"location":"reference/models/map/standard/","title":"<code>standard.toml</code>","text":"<p>Source: <code>src/dynlib/models/map/standard.toml</code> <pre><code>[model]\ntype = \"map\"\nname = \"Standard Map\"\ndtype = \"float64\"\n\n[states]\np     = 0.0\ntheta = 0.1\n\n[params]\nK  = 0.971635\n\n[equations.rhs]\np     = \"((p + K * sin(theta)) + pi) % (2*pi) - pi\"\ntheta = \"(theta + p + K * sin(theta)) % (2*pi)\"\n\n[equations.jacobian]\nexpr = [\n    [\"1.0\", \"K * cos(theta)\"],\n    [\"1.0\", \"1.0 + K * cos(theta)\"]\n]\n</code></pre></p>"},{"location":"reference/models/ode/","title":"ODE models","text":"<ul> <li>duffing</li> <li>eto-circular</li> <li>exp-if</li> <li>expdecay</li> <li>fitzhugh-nagumo</li> <li>hodgkin-huxley</li> <li>izhikevich</li> <li>leaky-if</li> <li>lorenz</li> <li>quadratic-if</li> <li>resonate-if</li> <li>vanderpol</li> </ul>"},{"location":"reference/models/ode/duffing/","title":"<code>duffing.toml</code>","text":"<p>Source: <code>src/dynlib/models/ode/duffing.toml</code> <pre><code>[model]\ntype = \"ode\"\nname = \"Duffing Oscillator\"\ndtype = \"float64\"\n\n[states]\nx = 0.1\ny = 0.1\n\n[params]\ndelta = 0.2\nalpha = -1.0\nbeta  = 1.0\ngamma = 0.3\nomega = 1.2\n\n[equations.rhs]\nx = \"y\"\ny = \"-delta*y - alpha*x - beta*x**3 + gamma*cos(omega*t)\"\n\n[equations.jacobian]\nexpr = [\n    [\"0\", \"1\"],\n    [\"-alpha - 3*beta*x**2\", \"-delta\"]\n]\n</code></pre></p>"},{"location":"reference/models/ode/eto-circular/","title":"<code>eto-circular.toml</code>","text":"<p>Source: <code>src/dynlib/models/ode/eto-circular.toml</code> <pre><code># ETO (Energy Template Oscillator) with Circular L Curve\n# See https://doi.org/10.28948/ngumuh.1458253 (\u00d6zt\u00fcrk, 2024)\n\n[model]\ntype = \"ode\"\nname = \"ETO-Circular\"\ndtype = \"float64\"\n\n[states]\nx = 0.1\ny = 0.1\n\n[params]\n# These defaults are for limit cycle\na  = 2.0\nmu = 0.8\n\n[equations.rhs]\nx = \"-x*(x**2+y**2-a) + mu*(x+y)*(x**2+y**2-a) + a*y\"\ny = \"-y*(x**2+y**2-a) + mu*(y-x)*(x**2+y**2-a) - a*x\"\n\n[equations.jacobian]\nexpr = [\n    [\"(mu-1)*(x**2 + y**2 - a) + 2*x*((mu-1)*x + mu*y)\", \"mu*(x**2 + y**2 - a) + 2*y*((mu-1)*x + mu*y) + a\"],\n    [\"-mu*(x**2 + y**2 - a) + 2*x*(-mu*x + (mu-1)*y) - a\", \"(mu-1)*(x**2 + y**2 - a) + 2*y*(-mu*x + (mu-1)*y)\"]\n]\n</code></pre></p>"},{"location":"reference/models/ode/exp-if/","title":"<code>exp-if.toml</code>","text":"<p>Source: <code>src/dynlib/models/ode/exp-if.toml</code> <pre><code>[model]\ntype = \"ode\"\nname = \"Exponential Integrate-and-Fire Neuron Model\"\n\n[states]\nv = -70.0\n\n[params]\ntau = 15.0       \nv_rest = -72.0   \nv_th = -45.0     \nv_reset = -75.0 \nvt = -55.0\nD = 2.0\nI = 0.0          \n\n[equations.rhs]\nv = \"(-(v-v_rest)+D*exp((v-vt)/D)+I)/tau\"\n\n[events.reset]\ncond = \"v &gt;= v_th\"\naction = \"v = v_reset\"\n</code></pre></p>"},{"location":"reference/models/ode/expdecay/","title":"<code>expdecay.toml</code>","text":"<p>Source: <code>src/dynlib/models/ode/expdecay.toml</code> <pre><code># Simple exponential decay model: dx/dt = -a*x\n# Analytic solution: x(t) = x0 * exp(-a*t)\n\n[model]\ntype = \"ode\"\nname = \"Exponential Decay\"\n\n[states]\nx = 1.0\n\n[params]\na = 1.0\n\n[equations.rhs]\nx = \"-a * x\"\n\n[equations.jacobian]\nexpr = [\n    [\"-a\"]\n]\n</code></pre></p>"},{"location":"reference/models/ode/fitzhugh-nagumo/","title":"<code>fitzhugh-nagumo.toml</code>","text":"<p>Source: <code>src/dynlib/models/ode/fitzhugh-nagumo.toml</code> <pre><code>[model]\ntype = \"ode\"\nname = \"FitzHugh-Nagumo Neuron\"\ndtype = \"float64\"\n\n[states]\n# Resting equilibrium for I = 0 with a = b = 0.7, R = 0.1, tau = 12.5\n# (computed from the original calc_equilibrium)\nV = -1.74\nw = -1.48\n\n[params]\na   = 0.7\nb   = 0.7\nR   = 0.1\nI   = 0.0\ntau = 12.5\n\n[equations.rhs]\nV = \"V - V**3/3 - w + R*I\"\nw = \"(V + a - b*w) / tau\"\n\n[equations.jacobian]\nexpr = [\n    [\"1 - V**2\", \"-1.0\"],\n    [\"1 / tau\", \"-b / tau\"]\n]\n</code></pre></p>"},{"location":"reference/models/ode/hodgkin-huxley/","title":"<code>hodgkin-huxley.toml</code>","text":"<p>Source: <code>src/dynlib/models/ode/hodgkin-huxley.toml</code> <pre><code>[model]\ntype = \"ode\"\nname = \"Hodgkin-Huxley Neuron (activation-function form)\"\ndtype = \"float64\"\n\n[states]\n# Resting equilibrium for I = 0 (from old resting_ic())\nV = -65.0\nn = 0.31\nm = 0.06\nh = 0.61\n\n[params]\n# Membrane / channels\nC   = 1.0\nEK  = -77.0\nENa = 55.0\nEL  = -54.0\ngK  = 36.0\ngNa = 120.0\ngL  = 0.3\nI   = 0.0\n\n# Na activation (m)\nVmid_m  = -40.0\nk_m     = 9.0\nVmax_m  = -38.0\nsigma_m = 30.0\nCamp_m  = 0.46\nCbase_m = 0.04\n\n# Na inactivation (h)\nVmid_h  = -62.0\nk_h     = -7.0\nVmax_h  = -67.0\nsigma_h = 20.0\nCamp_h  = 7.4\nCbase_h = 1.2\n\n# K activation (n)\nVmid_n  = -53.0\nk_n     = 15.0\nVmax_n  = -79.0\nsigma_n = 50.0\nCamp_n  = 4.7\nCbase_n = 1.1\n\n[functions.boltzmann]\nargs = [\"Vmid\", \"k\", \"V\"]\nexpr = \"1.0 / (1.0 + exp((Vmid - V) / k))\"\n\n[functions.gaussian]\nargs = [\"Vmax\", \"sigma\", \"Camp\", \"Cbase\", \"V\"]\nexpr = \"Cbase + Camp * exp(-((Vmax - V)**2) / (sigma**2))\"\n\n[aux]\n# Steady-state activation / inactivation\nm_inf = \"boltzmann(Vmid_m, k_m, V)\"\nh_inf = \"boltzmann(Vmid_h, k_h, V)\"\nn_inf = \"boltzmann(Vmid_n, k_n, V)\"\n\n# Time constants\ntau_m = \"gaussian(Vmax_m, sigma_m, Camp_m, Cbase_m, V)\"\ntau_h = \"gaussian(Vmax_h, sigma_h, Camp_h, Cbase_h, V)\"\ntau_n = \"gaussian(Vmax_n, sigma_n, Camp_n, Cbase_n, V)\"\n\n[equations.rhs]\nV = \"(I - gK*n**4*(V - EK) - gNa*m**3*h*(V - ENa) - gL*(V - EL)) / C\"\nn = \"(n_inf - n) / tau_n\"\nm = \"(m_inf - m) / tau_m\"\nh = \"(h_inf - h) / tau_h\"\n</code></pre></p>"},{"location":"reference/models/ode/izhikevich/","title":"<code>izhikevich.toml</code>","text":"<p>Source: <code>src/dynlib/models/ode/izhikevich.toml</code> <pre><code>[model]\ntype = \"ode\"\n\n[states]\nv = -65.0\nu = -13.0\n\n[params]\na = 0.02\nb = 0.2\nc = -65.0\nd = 8.0\nI = 10.0\nv_th = 30.0\n\n[equations]\nexpr = \"\"\"\ndv = 0.04 * v * v + 5.0 * v + 140.0 - u + I\ndu = a * (b * v - u)\n\"\"\"\n\n[events.reset]\ncond = \"v &gt;= v_th\"\nphase = \"post\"\naction = \"\"\"\nv = c\nu = u + d\n\"\"\"\n\n# PRESETS:\n[presets.regular_spiking.params]\na = 0.02\nb = 0.2\nc = -65.0\nd = 8.0\n\n[presets.intrinsic_bursting.params]\na = 0.02\nb = 0.2\nc = -55.0\nd = 4.0\n\n[presets.bursting.params]\na = 0.02\nb = 0.2\nc = -50\nd = 2\n\n[presets.fast_spiking.params]\na = 0.1\nb = 0.2\nc = -65\nd = 2\n\n[presets.low_threshold.params]\na = 0.02\nb = 0.25\nc = -65\nd = 2\n\n[presets.resonator.params]\na = 0.1\nb = 0.26\nc = -65\nd = 2\n</code></pre></p>"},{"location":"reference/models/ode/leaky-if/","title":"<code>leaky-if.toml</code>","text":"<p>Source: <code>src/dynlib/models/ode/leaky-if.toml</code> <pre><code>[model]\ntype = \"ode\"\nname = \"Leaky Integrate-and-Fire Neuron Model\"\n\n[states]\nv = -65.0  # Membrane potential in mV\n\n[params]\ntau = 10.0       # Membrane time constant in ms\nv_rest = -65.0   # Resting potential in mV\nv_th = -50.0     # Spike threshold in mV\nv_reset = -65.0  # Reset potential after spike in mV\nI = 0.0          # Input current in nA\n\n[equations.rhs]\nv = \"(v_rest - v + I) / tau\"\n\n[events.reset]\ncond = \"v &gt;= v_th\"\naction = \"v = v_reset\"\n</code></pre></p>"},{"location":"reference/models/ode/lorenz/","title":"<code>lorenz.toml</code>","text":"<p>Source: <code>src/dynlib/models/ode/lorenz.toml</code> <pre><code>[model]\ntype = \"ode\"\nname = \"Lorenz System\"\n\n[states]\nx = 1.0\ny = 1.0\nz = 1.0\n\n[params]\nsigma = 10.0\nrho = 28.0\nbeta = \"8.0/3.0\"\n\n[equations.rhs]\nx = \"sigma * (y - x)\"\ny = \"x * (rho - z) - y\"\nz = \"x * y - beta * z\"\n\n[equations.jacobian]\nexpr = [\n    [\"-sigma\", \"sigma\", \"0\"],\n    [\"rho - z\", \"-1\", \"-x\"],\n    [\"y\", \"x\", \"-beta\"]\n]\n</code></pre></p>"},{"location":"reference/models/ode/quadratic-if/","title":"<code>quadratic-if.toml</code>","text":"<p>Source: <code>src/dynlib/models/ode/quadratic-if.toml</code> <pre><code>[model]\ntype = \"ode\"\nname = \"Quadratic Integrate-and-Fire Neuron Model\"\n\n[states]\nv = -65.0 \n\n[params]\ntau = 15.0\nv_rest = -65.0   \nv_th = 5.0     \nv_reset = -70.0  \nI = 0.0\nvt = -50.0\nR = 10.0 # for lower currents   \n\n[equations.rhs]\nv = \"((v-v_rest)*(v-vt)+R*I) / tau\"\n\n[events.reset]\ncond = \"v &gt;= v_th\"\naction = \"v = v_reset\"\n</code></pre></p>"},{"location":"reference/models/ode/resonate-if/","title":"<code>resonate-if.toml</code>","text":"<p>Source: <code>src/dynlib/models/ode/resonate-if.toml</code> <pre><code># Resonate integrate and fire (Izhikevich's book)\n# Threshold y=1 line reset (0,1)\n# dx/dt = b*x-w*y+I\n# dy/dt = b*y+w*x\n# Complex expression:\n# dz/dt = (b+iw)*z+I\n# If I&gt;0 y increases until y=1, then it is reset\n# Reset is considered a spike (even though there is no spike)\n# After reset orbit focus into origin\n\n[model]\ntype = \"ode\"\nname = \"Resonate Integrate-and-Fire Neuron Model\"\n\n[states]\nx = 0.0  \ny = 0.0 \n\n[params]\nI = 0.0\nb = -0.05\nw = 0.25\ny_th = 1.0\nx_reset = 0.0\ny_reset = 1.0\n\n[equations]\nexpr = \"\"\"\ndx = b*x-w*y+I\ndy = b*y+w*x\n\"\"\"\n\n[events.reset]\ncond = \"y &gt;= y_th\"\naction = \"\"\"\nx=x_reset\ny=y_reset\n\"\"\"\n</code></pre></p>"},{"location":"reference/models/ode/vanderpol/","title":"<code>vanderpol.toml</code>","text":"<p>Source: <code>src/dynlib/models/ode/vanderpol.toml</code> <pre><code>[model]\ntype = \"ode\"\n\n[states]\nx = 2.0\ny = 0.0\n\n[params]\nmu = 1.0\n\n[equations]\nexpr = \"\"\"\ndx = y\ndy = mu*(1-x**2)*y-x\n\"\"\"\n\n[equations.jacobian]\nexpr = [\n    [\"0.0\", \"1.0\"],\n    [\"-2.0 * mu * x * y - 1.0\", \"mu * (1 - x**2)\"]\n]\n</code></pre></p>"},{"location":"tr/","title":"Dynlib","text":"<p>Dynlib, dinamik sistemleri tan\u0131mlamak, sim\u00fcle etmek ve analiz etmek i\u00e7in geli\u015ftirilmi\u015f bir sim\u00fclasyon k\u00fct\u00fcphanesidir. Modeller, TOML tabanl\u0131 bir DSL (Alana \u00d6zg\u00fc Dil) ile tan\u0131mlan\u0131r; b\u00f6ylece ayn\u0131 model tan\u0131m\u0131 hem sim\u00fclasyon hem de analiz i\u00e7in kullan\u0131labilir. \u015eu anda dynlib, ayr\u0131k zamanl\u0131 haritalar\u0131 (maps) ve adi diferansiyel denklemleri (ODE'ler) desteklemekte olup, giderek b\u00fcy\u00fcyen bir analiz ara\u00e7lar\u0131 setine sahiptir.</p> <p>Dynlib'in amac\u0131, dinamik sistemlerle \u00e7al\u0131\u015fmay\u0131 pratik ve tekrarlanabilir hale getirmektir. Uygulama detaylar\u0131 elbette \u00f6nemlidir; ancak \u00e7\u00f6z\u00fcc\u00fcleri, durum dizilerini (state arrays), parametre taramalar\u0131n\u0131, \u00e7izimleri ve veri y\u00f6netimini nas\u0131l ba\u011flayaca\u011f\u0131n\u0131z\u0131 bir kez \u00f6\u011frendikten sonra, her yeni model i\u00e7in bu tesisat\u0131 tekrar kurmak bir darbo\u011faza d\u00f6n\u00fc\u015f\u00fcr. Dynlib, tekrarlayan mekanik i\u015fleri soyutlar, b\u00f6ylece say\u0131sal y\u00f6ntemler ve konfig\u00fcrasyon \u00fczerindeki kontrol\u00fc kaybetmeden modele, parametre rejimlerine ve yorumlamaya odaklanabilirsiniz.</p> <p>Sadece \"NumPy + Matplotlib\" kullan\u0131larak yap\u0131lan sim\u00fclasyonlarla kar\u015f\u0131la\u015ft\u0131r\u0131ld\u0131\u011f\u0131nda dynlib, sim\u00fclasyon ve analiz s\u00fcrecini son derece pratikle\u015ftirir. Dynlib ile model kodunu yeniden yazmaks\u0131z\u0131n say\u0131sal \u00e7\u00f6z\u00fcm metodunu de\u011fi\u015ftirebilir; sim\u00fclasyon ve analizleri \u00e7ok k\u0131sa kodlarla ger\u00e7ekle\u015ftirebilirsiniz. Bu \u00f6zellikle dinamik sistemler derslerinin \u00f6\u011fretim s\u00fcre\u00e7lerinde faydal\u0131 olmaktad\u0131r. \u00d6\u011frenciler d\u00f6ng\u00fc olu\u015fturma, numpy ve matplotlib kullan\u0131m\u0131, n\u00fcmerik \u00e7\u00f6z\u00fcm metodunu ger\u00e7ekle\u015ftirme gibi pek \u00e7ok detayla bo\u011fu\u015furken bir yandan da dinamik sistemleri \u00f6\u011fretmeye \u00e7al\u0131\u015fmak \u00e7o\u011fu zaman as\u0131l ama\u00e7tan saparak dersi bir python kursuna d\u00f6n\u00fc\u015ft\u00fcrmektedir. Dynlib ile ise bu t\u00fcr ger\u00e7ekle\u015ftirim detaylar\u0131yla bo\u011fu\u015fmadan h\u0131zl\u0131ca model olu\u015fturularak sim\u00fclasyon ve analize yo\u011funla\u015f\u0131labilir. Basitle\u015ftirilmi\u015f \u00e7izim ara\u00e7lar\u0131 ile kolayl\u0131kla grafikler elde edilebilir.</p> <p>Sim\u00fclasyonun yan\u0131 s\u0131ra dynlib; \u00e7atallanma diyagramlar\u0131 (bif\u00fcrkasyon), \u00e7ekim havzalar\u0131 (basins of attraction), Lyapunov \u00fcss\u00fc tahmini, manifold izleme ve sabit nokta tespiti gibi yerle\u015fik analiz ara\u00e7lar\u0131n\u0131 i\u00e7erir. Ayr\u0131ca performans i\u00e7in JIT derleme (Just-In-Time Compilation) ve disk \u00f6nbellekleme (caching) imkan\u0131 sa\u011flar. Birden fazla say\u0131sal say\u0131sal \u00e7\u00f6z\u00fcm ailesini (Euler, RK4, RK45, TR-BDF2A, vb.) destekler. Model k\u00fct\u00fcphanesi ile yeni modeller olu\u015fturabilir ve bu modellere kolayl\u0131kla eri\u015febilirsiniz. Sim\u00fclasyonlar\u0131 durdurup tekrar ba\u015flatabilir (resume) ve herhangi bir anda sim\u00fclasyon durumunun kayd\u0131n\u0131 alabilirsiniz (snapshot). Ayr\u0131ca basit bir CLI (komut sat\u0131r\u0131 aray\u00fcz\u00fc) ile komut sat\u0131r\u0131ndan da dynlib ile ilgili i\u015flemler yapabilirsiniz.</p> <p>Uyar\u0131 : Dynlib \u015fu anda aktif geli\u015ftirme a\u015famas\u0131ndad\u0131r. API'ler (uygulama aray\u00fczleri) de\u011fi\u015febilir ve sonu\u00e7lar\u0131 etkileyen hatalar veya say\u0131sal u\u00e7 durumlar olabilir. Dynlib'i ara\u015ft\u0131rma veya kritik kararlar i\u00e7in kullan\u0131yorsan\u0131z, sonu\u00e7lar\u0131 g\u00fcvenilir referanslar ile (\u00f6rne\u011fin alternatif \u00e7\u00f6z\u00fcc\u00fcler, daha k\u00fc\u00e7\u00fck ad\u0131m boyutlar\u0131, analitik kontroller) do\u011frulay\u0131n ve l\u00fctfen kar\u015f\u0131la\u015ft\u0131\u011f\u0131n\u0131z sorunlar\u0131 bildirin.</p>"},{"location":"tr/#kullanlan-terimler","title":"Kullan\u0131lan Terimler","text":"<p>Dynlib \u00e7al\u0131\u015fmas\u0131n\u0131 anlayabilmek i\u00e7in a\u015fa\u011f\u0131daki terimlerin bilinmesi gerekmektedir. Baz\u0131 terimler tamamen dynlib k\u00fct\u00fcphanesi \u00f6zg\u00fc terimlerdir.</p> <ul> <li>Harita/Map: Ayr\u0131k zamanl\u0131 dinamik sistemler (lojistik harita gibi).</li> <li>ODE: Adi diferansiyel denklem sistemi (ing. Ordinary Differential Equations).</li> <li>DSL: Alana \u00f6zg\u00fc dil (ing. Domain-Specific Language). Modelleri tan\u0131mlama i\u00e7in TOML format\u0131nda rahat ana\u015f\u0131l\u0131r bir dil.</li> <li>JIT: Just-in-time derlemenin k\u0131saltmas\u0131. Numba paketi yard\u0131m\u0131yla python kodlar\u0131n\u0131n derlenmesi ile daha y\u00fcksek h\u0131zlarda sim\u00fclasyon / analiz yapma imkan\u0131 sa\u011flar.</li> <li>Stepper: Sim\u00fclasyonlar\u0131n sonraki ad\u0131m\u0131n\u0131 (step) hesaplamakla g\u00f6revli program. ODE stepper'lar\u0131 say\u0131sal integrasyon metodlar\u0131n\u0131 (Euler, RK4, RK45 gibi) i\u00e7erir.</li> <li>Runner: Sim\u00fclasyonlar ko\u015fu (run) olarak nitelendirilirse, runner bir s\u00fcm\u00fclasyon ko\u015fusunu yerine getiren program olarak a\u00e7\u0131klanabilir. Dynlib birden fazla \u00f6zelle\u015fmi\u015f runner program\u0131 i\u00e7erir. Runner ve stepper kombinasyonu JIT ile derlenebildi\u011fi i\u00e7in bir kernel gibi d\u00fc\u015f\u00fcn\u00fclebilir.</li> <li>Wrapper: JIT ile derlenmi\u015f runner'lar ile yap\u0131labilecek i\u015flemler k\u0131s\u0131tl\u0131 oldu\u011fu i\u00e7in her runner program\u0131 bir wrapper kontrol\u00fcnde kullan\u0131l\u0131r. Runner yetersiz kal\u0131rsa salt python program\u0131 olan wrapper kontrol\u00fc devral\u0131r.</li> <li>API: Uygulama programlama aray\u00fcz\u00fc (ing. Application Program Interface). Bir program\u0131 nas\u0131l \u00e7a\u011f\u0131rman\u0131z gerekti\u011fini belirler.</li> <li>CLI: Komut sat\u0131r\u0131 aray\u00fcz\u00fc (ing. Command-Line Interface).</li> <li>URI: Model TOML dosyalar\u0131n\u0131n adresini temsil eder (ing. Uniform Resource Identifier).</li> <li>RHS: Bir e\u015fitli\u011fin sa\u011f tarafta kalan k\u0131sm\u0131 (ing. Right-Hand Side).</li> <li>Anl\u0131k g\u00f6r\u00fcnt\u00fc (snapshot): Sim\u00fclasyonun herhangi bir an\u0131nda durum de\u011fi\u015fkenleri, parametre de\u011ferleri ve sim\u00fclasyon parametreleri gibi t\u00fcm de\u011ferlerin o anki kayd\u0131n\u0131n al\u0131n\u0131p saklanmas\u0131.</li> </ul>"},{"location":"tr/#one-ckanlar","title":"\u00d6ne \u00c7\u0131kanlar","text":"<ul> <li> <p>Modeli bir kez tan\u0131mlay\u0131n (TOML DSL): ODE\u2019leri veya ayr\u0131k haritalar\u0131 tek bir TOML tan\u0131m\u0131yla yaz\u0131n ve ayn\u0131 modeli t\u00fcm sim\u00fclasyonlarda ve analizlerde kullan\u0131n. Modelleme</p> </li> <li> <p>Sim\u00fclasyonlar\u0131 kolayca \u00e7al\u0131\u015ft\u0131r\u0131n: Detaylarla bo\u011fu\u015fmadan pratik bir \u015fekilde sim\u00fclasyon olu\u015fturun. Stepper se\u00e7erek kolayca n\u00fcmerik \u00e7\u00f6z\u00fcm metodunu de\u011fi\u015ftirin. \u0130sterseniz JIT h\u0131zland\u0131rma kullan\u0131n ve h\u0131zl\u0131 derleme i\u00e7in disk \u00f6nbelle\u011fi kullan\u0131n. Anl\u0131k g\u00f6r\u00fcnt\u00fc (snapshot) kaydedin ve sim\u00fclasyona kald\u0131\u011f\u0131n\u0131z yerden devam edin (resume). Sim\u00fclasyon / \u00c7al\u0131\u015fma Zaman\u0131</p> </li> <li> <p>Temel analizleri yap\u0131n: \u00c7atallanma diyagram\u0131, \u00e7ekim havzas\u0131, Lyapunov \u00fcsteli hesab\u0131, sabit nokta bulma, manifold izleme ve parametre taramalar\u0131 i\u00e7in yerle\u015fik ara\u00e7lar\u0131 kullan\u0131n. Ayr\u0131ca Matplotlib tabanl\u0131 \u00e7izim yard\u0131mc\u0131lar\u0131 ile sonu\u00e7lar\u0131 kolayca \u00e7izdirin. Analiz / \u00c7izim</p> </li> <li> <p>CLI: S\u0131k yap\u0131lan i\u015fler i\u00e7in komut sat\u0131r\u0131 \u00fczerinden h\u0131zl\u0131 do\u011frulama ve inceleme komutlar\u0131 kullan\u0131n. CLI</p> </li> </ul>"},{"location":"tr/#buradan-baslayn","title":"Buradan Ba\u015flay\u0131n","text":"<ol> <li>Proje hedeflerini, \u00f6nerilen \u00f6nko\u015fullar\u0131 ve dok\u00fcmanlar\u0131n nas\u0131l d\u00fczenlendi\u011fini anlamak i\u00e7in Ba\u015flarken genel bak\u0131\u015f sayfas\u0131n\u0131 okuyun.</li> <li>Dynlib'i kurmak, CLI ile do\u011frulamak ve Python ile yerle\u015fik (built-in) bir modeli \u00e7al\u0131\u015ft\u0131rmak i\u00e7in H\u0131zl\u0131 Ba\u015flang\u0131\u00e7 ad\u0131mlar\u0131n\u0131 izleyin.</li> <li>DSL ile model olu\u015fturmak ve modeli do\u011frulamak i\u00e7in \u0130lk Modeliniz b\u00f6l\u00fcm\u00fcn\u00fc inceleyin.</li> </ol>"},{"location":"tr/#daha-derine-inin","title":"Daha Derine \u0130nin","text":"<p>Dynlib dok\u00fcmantasyonundaki di\u011fer rehberlere bakarak daha detayl\u0131 kullan\u0131m hakk\u0131nda fikir sahibi olabilirsiniz:</p> <ul> <li>Ana Sayfa</li> </ul>"},{"location":"tr/#baslarken","title":"Ba\u015flarken","text":"<ul> <li>Genel Bak\u0131\u015f</li> <li>H\u0131zl\u0131 Ba\u015flang\u0131\u00e7</li> <li>\u0130lk Modeliniz</li> </ul>"},{"location":"tr/#rehberler","title":"Rehberler","text":""},{"location":"tr/#modelleme","title":"Modelleme","text":"<ul> <li>Modelleme rehberi</li> <li>DSL temelleri</li> <li>Denklemler</li> <li>Matematik ve makrolar</li> <li>\u00dc\u00e7l\u00fc if</li> <li>Model kayd\u0131</li> <li>Yard\u0131mc\u0131 de\u011fi\u015fkenler</li> <li>DSL fonksiyonlar\u0131</li> <li>Olaylar</li> <li>Gecikme</li> <li>Sat\u0131r i\u00e7i modeller</li> <li>Yap\u0131land\u0131rma dosyas\u0131</li> <li>Modlar</li> <li>\u00d6n ayarlar</li> <li>Sim\u00fclasyon varsay\u0131lanlar\u0131</li> </ul>"},{"location":"tr/#simulasyon","title":"Sim\u00fclasyon","text":"<ul> <li>Sim\u00fclasyon rehberi</li> <li>Temeller</li> <li>Yap\u0131land\u0131rma</li> <li>Just-In-Time derleme</li> <li>\u00d6n ayarlar</li> <li>Runner varyantlar\u0131</li> <li>Oturum i\u00e7g\u00f6zlemi</li> <li>Sonu\u00e7lar</li> <li>Ad\u0131mlay\u0131c\u0131lar</li> <li>Anl\u0131k g\u00f6r\u00fcnt\u00fcler ve devam</li> <li>Sarmalay\u0131c\u0131 ve \u00e7al\u0131\u015ft\u0131r\u0131c\u0131</li> <li>Kaynaklar\u0131 d\u0131\u015fa aktarma</li> </ul>"},{"location":"tr/#cizim","title":"\u00c7izim","text":"<ul> <li>\u00c7izim rehberi</li> <li>\u00c7izim temelleri</li> <li>Dekorasyonlar</li> <li>\u00c7izimleri d\u0131\u015fa aktarma</li> <li>\u00d6r\u00fcmcek a\u011f \u00e7izimleri</li> <li>\u00c7ekim havzas\u0131 \u00e7izimleri</li> <li>Vekt\u00f6r alanlar\u0131</li> <li>Manifold \u00e7izimleri</li> <li>Tema ve y\u00fczeyler</li> <li>Bifurkasyon diyagramlar\u0131</li> </ul>"},{"location":"tr/#analiz","title":"Analiz","text":"<ul> <li>Analiz rehberi</li> <li>\u00c7al\u0131\u015fma zaman\u0131 g\u00f6zlemcileri</li> <li>Lyapunov analizi</li> <li>Tarama ara\u00e7lar\u0131</li> <li>Analiz sonras\u0131</li> <li>Sabit noktalar</li> <li>\u00c7ekim havzas\u0131 analizi</li> <li>Bifurkasyon diyagramlar\u0131</li> <li>Manifold analizi</li> </ul>"},{"location":"tr/#ornekler","title":"\u00d6rnekler","text":"<ul> <li>Genel bak\u0131\u015f</li> <li>Analiz katalo\u011fu</li> <li>\u00c7izim katalo\u011fu</li> <li>\u00c7al\u0131\u015fma zaman\u0131 katalo\u011fu</li> <li>Durum y\u00f6netimi</li> <li>Bifurkasyon lojistik haritas\u0131</li> <li>Collatz san\u0131s\u0131</li> <li>Izhikevich n\u00f6ronu</li> </ul>"},{"location":"tr/#referans","title":"Referans","text":"<ul> <li>Genel bak\u0131\u015f</li> <li>Yerle\u015fik modeller</li> </ul>"},{"location":"tr/#proje","title":"Proje","text":"<ul> <li>De\u011fi\u015fiklik g\u00fcnl\u00fc\u011f\u00fc</li> <li>Sorunlar</li> <li>TODO</li> </ul>"},{"location":"tr/examples/","title":"\u00d6rneklere Genel Bak\u0131\u015f","text":"<p>\u0130lgilendi\u011finiz konularla en alakal\u0131 \u00e7al\u0131\u015ft\u0131r\u0131labilir \u00f6rnekleri kolayca bulmak i\u00e7in bu sayfalar\u0131 kullanabilirsiniz. Her sayfa, ilgili \u00f6rne\u011fin ne yapt\u0131\u011f\u0131n\u0131 a\u00e7\u0131klar, kulland\u0131\u011f\u0131 <code>dynlib</code> \u00f6zelliklerini vurgular ve <code>examples/</code> klas\u00f6r\u00fcndeki orijinal koda bir ba\u011flant\u0131 i\u00e7erir.</p>"},{"location":"tr/examples/#katalog","title":"Katalog","text":"<ul> <li><code>Analiz</code> \u2013 \u00c7ekim havzalar\u0131n\u0131n (basin of attraction) hesaplanmas\u0131, Lyapunov \u00fcstel spektrumunun analizi, karars\u0131z periyodik y\u00f6r\u00fcngelerin manifoldlar\u0131n\u0131n izlenmesi, homoklinik ve heteroklinik y\u00f6r\u00fcngelerin bulunmas\u0131 ve parametre taramas\u0131 gibi analiz ara\u00e7lar\u0131n\u0131n kullan\u0131m\u0131n\u0131 g\u00f6steren \u00f6rnekler.</li> <li><code>\u00c7izim</code> \u2013 Zaman serisi ve faz uzay\u0131 \u00e7izimleri, vekt\u00f6r alan\u0131 g\u00f6rselle\u015ftirmeleri, animasyonlar ve temalar gibi <code>dynlib</code>'in \u00e7izim yeteneklerini g\u00f6steren \u00f6rnekler.</li> <li><code>\u00c7al\u0131\u015fma Zaman\u0131</code> \u2013 Sim\u00fclasyonu belirli bir ko\u015ful sa\u011fland\u0131\u011f\u0131nda erken sonland\u0131rma, y\u00f6r\u00fcngedeki ge\u00e7i\u015fleri tespit etme, derlenmi\u015f denklemleri inceleme ve n\u00fcmerik hassasiyeti de\u011ferlendirme gibi \u00e7al\u0131\u015fma zaman\u0131 yeteneklerini g\u00f6steren \u00f6rnekler.</li> <li><code>Durum Y\u00f6netimi</code> \u2013 Sim\u00fclasyon durumunu anl\u0131k g\u00f6r\u00fcnt\u00fcler (snapshots) ile kaydedip y\u00fckleme, modelin kaynak kodunu d\u0131\u015fa aktarma, haz\u0131r ayarlar\u0131 (presets) kullanma ve URI'ler arac\u0131l\u0131\u011f\u0131yla modellere eri\u015fme gibi \u00f6zellikleri g\u00f6steren \u00f6rnekler.</li> <li><code>\u00c7atallanma</code> \u2013 Parametre uzay\u0131n\u0131 tarayarak (sweeping) lojistik harita gibi sistemlerin \u00e7atallanma (bifurcation) diyagramlar\u0131n\u0131n nas\u0131l olu\u015fturuldu\u011funu g\u00f6steren \u00f6rnekler.</li> <li><code>Tamsay\u0131 Harita</code> \u2013 Tamsay\u0131 aritmeti\u011fi ve <code>map</code> tipi ad\u0131mlay\u0131c\u0131 (stepper) kullanarak Collatz dizisi gibi yinelemeli sistemlerin nas\u0131l modellenece\u011fini g\u00f6steren bir \u00f6rnek.</li> <li><code>Izhikevich N\u00f6ron</code> \u2013 Farkl\u0131 parametreler ve uyaranlar (stimulus) alt\u0131nda Izhikevich n\u00f6ron modelinin nas\u0131l sim\u00fcle edilece\u011fini ve farkl\u0131 ate\u015fleme (spiking) desenlerinin nas\u0131l elde edilece\u011fini g\u00f6steren \u00f6rnekler.</li> </ul>"},{"location":"tr/examples/analysis/","title":"Analiz \u00d6rnekleri","text":""},{"location":"tr/examples/analysis/#genel-baks","title":"Genel Bak\u0131\u015f","text":"<p><code>examples/analysis/</code> klas\u00f6r\u00fc, dynlib'in analiz ara\u00e7lar\u0131n\u0131n nas\u0131l kullan\u0131ld\u0131\u011f\u0131n\u0131 g\u00f6steren \u00f6rnekleri i\u00e7erir. Burada da bu \u00f6rneklerden baz\u0131lar\u0131 verilmektedir. Kullan\u0131lan analiz ara\u00e7lar\u0131n\u0131n detayl\u0131 kullan\u0131m\u0131 i\u00e7in Analiz rehberine bak\u0131n\u0131z. </p>"},{"location":"tr/examples/analysis/#cekim-havzas-haritalama-ve-snflandrma","title":"\u00c7ekim havzas\u0131 haritalama ve s\u0131n\u0131fland\u0131rma","text":""},{"location":"tr/examples/analysis/#henon-haritas-havza-kesfi","title":"Henon haritas\u0131 havza ke\u015ffi","text":"<p>Yerle\u015fik Henon haritas\u0131 \u00fczerinde 512\u00d7512'lik bir \u0131zgarada, PCR-BM algoritmas\u0131 ile <code>basin_auto</code> analiz arac\u0131 ile Henon haritas\u0131n\u0131n \u00e7ekerleri ve bu \u00e7ekerlerin \u00e7ekim havzalar\u0131 numerik olarak hesaplanmaktad\u0131r. <code>basin_auto</code> \u00e7eker yap\u0131lar\u0131n\u0131 otomatik olarak bulmaya \u00e7al\u0131\u015f\u0131r.</p> <pre><code>\"\"\"\nAuto basin of attraction calculation for the Henon Map.\n\nDemonstrates the basin_auto function (Persistent Cell-Recurrence Basin Mapping algorithm)\nto identify basins of attraction for the 2D Henon map.\n\nbasin_auto tries to automatically discover attractors and their basins. Its success highly\ndepends on the choice of parameters and the nature of the dynamical system. \n\"\"\"\n\nfrom __future__ import annotations\nimport numpy as np\nfrom dynlib import setup\nfrom dynlib.analysis import basin_auto, print_basin_summary\nfrom dynlib.plot import export, theme, fig, basin_plot\nfrom dynlib.utils import Timer\n\n# Setup Henon map model\nprint(\"Setting up Henon map model...\")\nsim = setup(\"builtin://map/henon\", stepper=\"map\", jit=True)\n\n# Set standard Henon parameters\na_param = 1.4\nb_param = 0.3\nsim.assign(a=a_param, b=b_param)\n\nprint(f\"  Parameters: a={a_param}, b={b_param}\")\nprint(f\"  State variables: x, y\")\n\n# Domain for basin calculation\n# Focusing on a region near the Henon attractor\nx_min, x_max = -2.5, 2.5\ny_min, y_max = -2.5, 2.5\n\n# Grid resolution (increase for higher detail)\ngrid_nx = 512\ngrid_ny = 512\n\nprint(f\"  Grid size: {grid_nx} \u00d7 {grid_ny} = {grid_nx * grid_ny} points\")\nprint(f\"  Domain: x \u2208 [{x_min}, {x_max}], y \u2208 [{y_min}, {y_max}]\")\n\n# Compute basin of attraction\nprint(\"\\nComputing basin of attraction...\")\nprint(\"  Algorithm: PCR-BM (Persistent Cell-Recurrence Basin Mapping)\")\nprint(f\"  Grid size: {grid_nx} \u00d7 {grid_ny} = {grid_nx * grid_ny} points\")\nprint(f\"  Domain: x \u2208 [{x_min}, {x_max}], y \u2208 [{y_min}, {y_max}]\")\n\nwith Timer(\"Basin computation time\"):\n    result = basin_auto(\n        sim,\n        ic_grid=[grid_nx, grid_ny],\n        ic_bounds=[(x_min, x_max), (y_min, y_max)],\n        observe_vars=[\"x\", \"y\"],  # Use both state variables\n        grid_res=[128, 128],  # Cell resolution for recurrence detection\n        merge_downsample=4,\n        post_detect_samples=512,\n        max_samples=2000,  # Number of iterations per initial condition\n        transient_samples=500,  # Skip initial transient\n        window=128,  # Recurrence detection window size\n        u_th=0.95,  # Uniqueness threshold\n        recur_windows=3,  # Required recurrence windows\n        s_merge=0.3,  # Similarity threshold for merging attractors\n        p_in=30,  # Persistence threshold\n        b_max=100.0,  # Blowup threshold (lower to catch diverging trajectories)\n        outside_limit=50,  # Maximum consecutive outside steps\n        parallel_mode=\"auto\",\n    )\n\nprint(\"Done!\")\n\n# Analyze results\nprint_basin_summary(result)\n\n# Visualization\nprint(\"\\nCreating visualization...\")\ntheme.use(\"notebook\")\ntheme.update(grid=False)\n\n# Create figure\nax = fig.single(size=(10, 8))\n\nbasin_plot(\n    result,\n    ax=ax,\n    xlabel=\"x\",\n    ylabel=\"y\",\n    ylabel_rot=0,\n    ypad=15,\n    title=f\"Basin of Attraction - Henon Map (a={a_param}, b={b_param})\",\n    titlepad=15,\n)\n\nexport.show()\nprint(\"\\nVisualization complete!\")\n</code></pre>"},{"location":"tr/examples/analysis/#bilinen-cekerlerin-havzas","title":"Bilinen \u00e7ekerlerin havzas\u0131","text":"<p>Bu \u00f6rnekte ise yine 512\u00d7512'lik bir \u0131zgarada yerle\u015fik Henon haritas\u0131 modeli i\u00e7in <code>basin_known</code> analiz arac\u0131 kullan\u0131m\u0131 g\u00f6sterilmektedir. Bu arac\u0131n kullan\u0131lmas\u0131 i\u00e7in \u00e7eker yap\u0131lar\u0131 \u00f6nceden <code>ReferenceRun</code> veya <code>FixedPoint</code> ile tan\u0131mlanmal\u0131d\u0131r.</p> <pre><code>\"\"\"\nBasin of Attraction for Henon Map using Known Attractors.\n\nDemonstrates the simplified basin_known function to identify basins for the\n2D Henon map. basin_known requires reference(s) of the attractor(s) to be \nprovided beforehand.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport numpy as np\n\nfrom dynlib import setup\nfrom dynlib.analysis import basin_known, print_basin_summary, ReferenceRun\nfrom dynlib.plot import export, theme, fig, basin_plot\nfrom dynlib.utils import Timer\n\n# Setup Henon map model\nprint(\"Setting up Henon map model...\")\nsim = setup(\"builtin://map/henon\", stepper=\"map\", jit=True)\n\n# Set standard Henon parameters\na_param = 1.4\nb_param = 0.3\nsim.assign(a=a_param, b=b_param)\n\nprint(f\"  Parameters: a={a_param}, b={b_param}\")\nprint(f\"  State variables: x, y\")\n\n# Define grid of initial conditions\nprint(\"\\nGenerating initial condition grid...\")\n\n# Domain for basin calculation (region near Henon attractor)\nx_min, x_max = -2.5, 2.5\ny_min, y_max = -2.5, 2.5\n\n# Grid resolution\ngrid_nx = 512\ngrid_ny = 512\n\nprint(f\"  Grid size: {grid_nx} \u00d7 {grid_ny} = {grid_nx * grid_ny} points\")\nprint(f\"  Domain: x \u2208 [{x_min}, {x_max}], y \u2208 [{y_min}, {y_max}]\")\n\n# Compute basin of known attractors\nprint(\"\\nComputing basin of known attractors...\")\n\nwith Timer(\"basin_known computation\"):\n    result = basin_known(\n        sim,\n        attractors=[\n            ReferenceRun(name=\"Henon attractor\", ic=[0.1, 0.1]),\n        ],\n        ic_grid=[grid_nx, grid_ny],\n        ic_bounds=[(x_min, x_max), (y_min, y_max)],\n        max_samples=500,\n        transient_samples=200,\n        signature_samples=500,\n        tolerance=0.05,      # 5% of attractor range\n        min_match_ratio=0.8,  # 80% of points must match\n        escape_bounds=[(-5.0, 5.0), (-5.0, 5.0)],  # Wide bounds for escape detection\n        b_max=1e6, # Blowup threshold / None means literal NaN/Inf\n        parallel_mode=\"auto\",\n        refine=True, # refine is faster for high resolution grids\n    )\n\nprint(\"Done!\")\n\n# Analyze results\nprint_basin_summary(result)\n\n# Visualization\nprint(\"\\nCreating visualization...\")\ntheme.use(\"notebook\")\ntheme.update(grid=False)\n\nax = fig.single(size=(10, 8))\n\nbasin_plot(\n    result,\n    ax=ax,\n    xlabel=\"x\",\n    ylabel=\"y\",\n    ylabel_rot=0,\n    ypad=15,\n    title=f\"Basin of Attraction - Henon Map (a={a_param}, b={b_param})\",\n    titlepad=15,\n)\n\nexport.show()\n\nprint(\"\\nVisualization complete!\")\n</code></pre>"},{"location":"tr/examples/analysis/#limit-dongu-limit-cycle-havzalar","title":"Limit d\u00f6ng\u00fc (limit-cycle) havzalar\u0131","text":"<p>Bu \u00f6rnekte <code>basin_auto</code> kullanarak bir limit d\u00f6ng\u00fcye ait \u00e7ekim havzas\u0131 hesaplanmaktad\u0131r. <code>basin_auto</code> limit d\u00f6ng\u00fcy\u00fc otomatik olarak tespit etmektedir.</p> <pre><code>from dynlib import setup\nfrom dynlib.analysis import basin_auto\nfrom dynlib.plot import export, basin_plot, fig, phase\n\n# Energy Template Oscillator (ETO) with Circular L Curve\nsim = setup(\"builtin://ode/eto-circular\", jit=True, disk_cache=True, stepper=\"rk4\")\n# Globally stable limit cycle parameters\nsim.assign(mu=0.8, a=2.0)\n\nresults = basin_auto(\n    sim,\n    ic_grid=[128, 128],\n    ic_bounds=[(-3, 3), (-3, 3)],\n    dt_obs=0.01,\n    # run long enough to converge + see the cycle\n    max_samples=4000,          # 40 time units\n    transient_samples=2000,    # 20 time units of transient\n    # recurrence / evidence\n    window=512,                # ~5.12 time units &gt; 1 period\n    recur_windows=3,\n    u_th=0.8,                  # less strict; avoids missing clean periodic motion\n    post_detect_samples=1024,  # add extra evidence (aim: &gt;= 1\u20132 periods total)\n    # merging\n    merge_downsample=2,        # coarser fingerprint grid =&gt; more overlap\n    s_merge=0.4,               # easier merge for same attractor under phase shifts\n    # optional: make persistence assignment more stable\n    p_in=12,\n    online_max_cells=8192,     # avoid truncating the stored cell set for a large cycle\n)\n\n# Create an attractor\nsim.run(T=300, transient=100)\nattr = sim.results()\n\n# Plotting\nax = fig.single()\nphase.xy(x=attr[\"x\"], y=attr[\"y\"], ax=ax)\nbasin_plot(results, ax=ax)\n\nprint(\"Globally stable limit cycle.\")\nprint(\"Edges can go outside for high mu values but they should converge back.\")\n\nexport.show()\n</code></pre> <p>Bu \u00f6rnekte ise yine ayn\u0131 limit d\u00f6ng\u00fc bu sefer <code>ReferenceRun</code> ile tan\u0131mland\u0131ktan sonra <code>basin_known</code> arac\u0131 ile \u00e7ekim havzas\u0131 hesaplanmaktad\u0131r. </p> <pre><code>from dynlib import setup\nfrom dynlib.analysis import basin_known, ReferenceRun\nfrom dynlib.plot import export, basin_plot, fig, phase\n\n# Energy Template Oscillator (ETO) with Circular L Curve\nsim = setup(\"builtin://ode/eto-circular\", jit=True, disk_cache=True, stepper=\"rk4\")\n# Globally stable limit cycle parameters\nsim.assign(mu=0.8, a=2.0)\n\nresults = basin_known(\n    sim,\n    attractors=[\n        ReferenceRun(name=\"Limit Cycle Attractor\", ic=[1.0, 0.0]),\n    ],\n    ic_grid=[128, 128],\n    ic_bounds=[(-3, 3), (-3, 3)],\n    dt_obs=0.01,\n    # run long enough to converge + see the cycle\n    signature_samples=8000, # samples are in steps not time\n    max_samples=4000,\n    transient_samples=2000, \n    tolerance=0.05,      # 5% of attractor range\n    min_match_ratio=0.8,  # 80% of points must match\n    escape_bounds=[(-5.0, 5.0), (-5.0, 5.0)],  # Wide bounds for escape detection\n    b_max=1e6, # Blowup threshold / None means literal NaN/Inf\n)\n\n# Create an attractor\nsim.run(T=300, transient=100)\nattr = sim.results()\n\n# Plotting\nax = fig.single()\nphase.xy(x=attr[\"x\"], y=attr[\"y\"], ax=ax)\nbasin_plot(results, ax=ax)\n\nexport.show()\n</code></pre>"},{"location":"tr/examples/analysis/#lyapunov-ustelleri-ve-spektrumu","title":"Lyapunov \u00fcstelleri ve spektrumu","text":""},{"location":"tr/examples/analysis/#lojistik-harita-lyapunov-usteli-hesab","title":"Lojistik harita Lyapunov \u00fcsteli hesab\u0131","text":"<p>Bu \u00f6rnekte <code>observer</code> kullanarak maksimum Lyapunov \u00fcsteli (MLE) ve Lyapunov spektrumu hesab\u0131n\u0131n nas\u0131l yap\u0131laca\u011f\u0131 g\u00f6sterilmektedir. Bir boyutlu lojistik harita i\u00e7in spektrum analizi mant\u0131ks\u0131z olsa da <code>lyapunov_mle_observer</code> ve <code>lyapunov_spectrum_observer</code> ara\u00e7lar\u0131n\u0131n numerik olarak ne kadar farkl\u0131 oldu\u011funa bak\u0131lmaktad\u0131r.</p> <pre><code>\"\"\"\nLyapunov exponent calculation for the logistic map.\n\nDemonstrates the runtime analysis system for computing maximum Lyapunov exponents (MLE)\nand Lyapunov spectrum in discrete dynamical systems using the high-level Sim.run() API.\n\nThe Lyapunov exponent \u03bb characterizes divergence of nearby trajectories:\n    - \u03bb &gt; 0: Chaotic behavior \n    - \u03bb = 0: Periodic orbits\n    - \u03bb &lt; 0: Stable fixed points\n\nFor the logistic map at r=4: \u03bb = ln(2) \u2248 0.6931\n\"\"\"\n\nfrom __future__ import annotations\nimport numpy as np\nfrom dynlib import setup\nfrom dynlib.runtime.observers import lyapunov_mle_observer, lyapunov_spectrum_observer\nfrom dynlib.plot import series, export, theme, fig\n\n\n# Single run with multiple observers\nsim = setup(\"builtin://map/logistic\", jit=True, disk_cache=True)\nmodel = sim.model\n\nrecord_every = 1\n\n# Run simulation using the high-level Sim API with multiple observers\nprint(\"\\nComputing Lyapunov exponents with Sim.run()...\")\nprint(f\"  Parameter: r = 4.0\")\nprint(f\"  Iterations: 5000\")\nprint(f\"  Initial condition: x = 0.4\")\nprint(f\"  Observers: MLE and Spectrum\")\n\nsim.assign(x=0.4, r=4.0)\nsim.run(\n    N=5000,\n    dt=1.0,\n    record_interval=record_every,\n    observers=[\n        lyapunov_mle_observer(model=sim.model, record_interval=record_every),\n        lyapunov_spectrum_observer(model=sim.model, k=1, record_interval=record_every),\n    ],\n)\nresult = sim.results()\n\n# Extract runtime observer results\nprint(\"\\n\" + \"=\"*60)\nprint(\"RESULTS\")\nprint(\"=\"*60)\n\n# Get observer result with ergonomic named access\nlyap = result.observers[\"lyapunov_mle\"]\nspectrum = result.observers[\"lyapunov_spectrum\"]\n\n# Direct access to final MLE (auto-computed from trace)\nmle = lyap.mle  # Final converged value from trace\nlog_growth = lyap.log_growth\nn_steps = int(lyap.steps)\n\n# Get spectrum results (lyapunov_spectrum stores the final value in the trace)\nspectrum_steps = int(spectrum.steps)\n\ntheoretical_mle = np.log(2.0)\nx_trajectory = result[\"x\"]\nlyap_trace = lyap[\"mle\"]  # Full trace array (use bracket for arrays)\nspectrum_trace = spectrum[\"lyap0\"]  # Spectrum trace for first exponent\n\n# Note: trace may have one less point than trajectory if recording starts at t0\nn_points = min(len(x_trajectory), len(lyap_trace), len(spectrum_trace))\niterations = np.arange(n_points)\n\n# Get final spectrum value from trace (after data is loaded)\n# spectrum trace has alternating zeros, so find the last non-zero value\nnonzero_indices = np.nonzero(spectrum_trace)[0]\nspectrum_mle = spectrum_trace[nonzero_indices[-1]] if len(nonzero_indices) &gt; 0 else 0\n\nprint(\"\\nMaximum Lyapunov Exponent (MLE):\")\nprint(f\"  Computed MLE:      {mle:.10f}\")\nprint(f\"  Theoretical MLE:   {theoretical_mle:.10f} (ln(2))\")\nprint(f\"  Relative error:    {abs(mle - theoretical_mle)/theoretical_mle * 100:.4f}%\")\nprint(f\"  Total iterations:  {n_steps}\")\n\nprint(\"\\nLyapunov Spectrum:\")\nprint(f\"  Spectrum \u03bb\u2080:       {spectrum_mle:.10f}\")\nprint(f\"  Theoretical \u03bb\u2080:    {theoretical_mle:.10f} (ln(2))\")\nprint(f\"  Relative error:    {abs(spectrum_mle - theoretical_mle)/theoretical_mle * 100:.4f}%\")\nprint(f\"  Total iterations:  {spectrum_steps}\")\n\n# Visualize\ntheme.use(\"notebook\")\ntheme.update(grid=True)\n\nfig_obj = fig.grid(rows=3, cols=1, size=(10, 12))\n\n# Plot trajectory (first 500 iterations)\nseries.plot(\n    x=iterations[:500],\n    y=x_trajectory[:500],\n    style=\"line\",\n    ax=fig_obj[0, 0],\n    xlabel=\"Iteration (n)\",\n    ylabel=\"$x_n$\",\n    title=f\"Logistic Map Trajectory (r=4.0)\",\n    lw=1.0,\n    color=\"C0\",\n)\n\n# Plot Lyapunov exponent convergence\nseries.plot(\n    x=iterations,\n    y=lyap_trace[:n_points],\n    style=\"line\",\n    ax=fig_obj[1, 0],\n    xlabel=\"Iteration (n)\",\n    ylabel=\"$\\\\lambda$ (MLE)\",\n    title=\"Lyapunov Exponent Convergence\",\n    lw=1.5,\n    color=\"C1\",\n    hlines=[(theoretical_mle, f'Theoretical: \u03bb = ln(2) \u2248 {theoretical_mle:.4f}')],\n    hlines_kwargs={\"color\": \"gray\", \"linestyle\": \"--\", \"linewidth\": 2, \"label_pad\": 0.10},\n)\n\n# Annotate final value\nfig_obj[1, 0].text(\n    0.98, 0.05,\n    f'Computed: \u03bb = {mle:.6f}',\n    transform=fig_obj[1, 0].transAxes,\n    fontsize=11,\n    verticalalignment='bottom',\n    horizontalalignment='right',\n    bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.5)\n)\n\n# Plot Lyapunov spectrum convergence\nseries.plot(\n    x=iterations,\n    y=spectrum_trace[:n_points],\n    style=\"line\",\n    ax=fig_obj[2, 0],\n    xlabel=\"Iteration (n)\",\n    ylabel=\"$\\\\lambda$ (Spectrum)\",\n    title=\"Lyapunov Spectrum Convergence\",\n    lw=1.5,\n    color=\"C2\",\n    hlines=[(theoretical_mle, f'Theoretical: \u03bb = ln(2) \u2248 {theoretical_mle:.4f}')],\n    hlines_kwargs={\"color\": \"red\", \"linestyle\": \"--\", \"linewidth\": 2},\n)\n\n# Annotate final value from spectrum\nspectrum_final = spectrum_trace[n_points-1] if n_points &gt; 0 else 0\nfig_obj[2, 0].text(\n    0.98, 0.05,\n    f'Computed: \u03bb = {spectrum_final:.6f}',\n    transform=fig_obj[2, 0].transAxes,\n    fontsize=11,\n    verticalalignment='bottom',\n    horizontalalignment='right',\n    bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.5)\n)\n\nexport.show()\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Parameter Scan\")\nprint(\"=\"*60)\nprint(f\"{'r':&gt;6s} {'\u03bb (MLE)':&gt;12s} {'Regime':&gt;15s}\")\nprint(\"-\"*60)\n\ntest_r_values = [2.5, 3.2, 3.5, 3.83, 4.0]\nscan_sim = setup(\"builtin://map/logistic\", stepper=\"map\", jit=False)\n\nfor r_test in test_r_values:\n    params_test = np.array([r_test], dtype=model.dtype)\n    scan_sim.run(\n        N=2000,\n        dt=1.0,\n        record=False,\n        record_interval=1,\n        max_steps=2000,\n        cap_rec=1,\n        cap_evt=1,\n        ic=np.array([0.4], dtype=model.dtype),\n        params=params_test,\n        observers=lyapunov_mle_observer,  # Factory mode: Sim injects model\n    )\n\n    lyap_result = scan_sim.results().observers[\"lyapunov_mle\"]\n    mle_test = lyap_result.mle  # Direct final value access\n\n    if mle_test &lt; -0.01:\n        regime = \"Stable\"\n    elif abs(mle_test) &lt; 0.01:\n        regime = \"Periodic\"\n    else:\n        regime = \"Chaotic\"\n\n    print(f\"{r_test:6.2f} {mle_test:12.6f} {regime:&gt;15s}\")\n    scan_sim.reset()\n\nprint(\"=\"*60)\nprint(\"\\nThe logistic map exhibits the period-doubling route to chaos.\")\nprint(\"Chaos emerges around r \u2248 3.57, fully developed at r = 4.\")\n</code></pre>"},{"location":"tr/examples/analysis/#lorenz-sistemi-lyapunov-usteli-hesab","title":"Lorenz sistemi Lyapunov \u00fcsteli hesab\u0131","text":"<p>Bu \u00f6rnekte ise Lorenz sistemi i\u00e7in <code>lyapunov_mle_observer</code> ve <code>lyapunov_spectrum_observer</code> kullanarak Lyapunov \u00fcsteli hesaplanmaktad\u0131r.</p> <pre><code>\"\"\"\nLyapunov exponent calculation for the Lorenz system.\n\nDemonstrates the runtime analysis system for computing maximum Lyapunov exponents (MLE)\nand Lyapunov spectrum in continuous dynamical systems using the high-level Sim.run() API.\n\"\"\"\n\nfrom __future__ import annotations\nfrom dynlib import setup\nfrom dynlib.runtime.observers import lyapunov_mle_observer, lyapunov_spectrum_observer\nfrom dynlib.plot import fig, export, phase, series\n\n# 1. Setup simulation\n# -------------------\nsim = setup(\"builtin://ode/lorenz\", stepper=\"rk4\", jit=True)\n\n# Parameters for standard chaotic regime\nsigma, rho, beta = 10.0, 28.0, 8.0/3.0\ninitial_state = {\"x\": 1.0, \"y\": 1.0, \"z\": 1.0}\n\n# Simulation control\ndt = 0.001\ntotal_time = 400\ntransient = 20\nrecord_interval = 4\n\nprint(f\"Running Lorenz simulation (T={total_time}, dt={dt})...\")\n\n# 2. Run MLE Analysis\n# -------------------\nprint(\"Computing Maximum Lyapunov Exponent (MLE)...\")\nsim.assign(**initial_state, sigma=sigma, rho=rho, beta=beta)\nsim.run(\n    transient=transient,\n    T=total_time,\n    dt=dt,\n    record_interval=record_interval,\n    observers=lyapunov_mle_observer(record_interval=record_interval)\n)\nres_mle = sim.results()\nmle_analysis = res_mle.observers[\"lyapunov_mle\"]\n\n# 3. Run Spectrum Analysis\n# ------------------------\nprint(\"Computing Lyapunov Spectrum (3 exponents)...\")\nsim.reset()\nsim.assign(**initial_state, sigma=sigma, rho=rho, beta=beta)\nsim.run(\n    transient=transient,\n    T=total_time,\n    dt=dt,\n    record_interval=record_interval,\n    observers=lyapunov_spectrum_observer(k=3, record_interval=record_interval)\n)\nres_spec = sim.results()\nspec_analysis = res_spec.observers[\"lyapunov_spectrum\"]\n\n# 4. Results &amp; Validation\n# -----------------------\nprint(\"\\n\" + \"=\"*60)\nprint(\"RESULTS &amp; VALIDATION\")\nprint(\"=\"*60)\n\n# Theoretical values for Lorenz (standard parameters)\nref_lambda1 = 0.9056\nref_lambda2 = 0.0000\nref_lambda3 = -14.5723\n\n# MLE Results\nmle_calc = mle_analysis.mle\nmle_err = abs(mle_calc - ref_lambda1) / abs(ref_lambda1) * 100\nprint(f\"\\nMaximum Lyapunov Exponent (MLE):\")\nprint(f\"  Calculated:  {mle_calc:.4f}\")\nprint(f\"  Theoretical: {ref_lambda1:.4f}\")\nprint(f\"  Error:       {mle_err:.2f}%\")\n\n# Spectrum Results\n# Get final values from traces (using attribute access for final value)\nl1_calc = spec_analysis.lyap0\nl2_calc = spec_analysis.lyap1\nl3_calc = spec_analysis.lyap2\n\n# Calculate errors (handle division by zero for lambda2)\nl1_err = abs(l1_calc - ref_lambda1) / abs(ref_lambda1) * 100\nl3_err = abs(l3_calc - ref_lambda3) / abs(ref_lambda3) * 100\n\nprint(f\"\\nLyapunov Spectrum:\")\nprint(f\"  \u03bb\u2081: {l1_calc:.4f} (Ref: {ref_lambda1:.4f}, Err: {l1_err:.2f}%)\")\nprint(f\"  \u03bb\u2082: {l2_calc:.4f} (Ref: {ref_lambda2:.4f}, Err: N/A)\")\nprint(f\"  \u03bb\u2083: {l3_calc:.4f} (Ref: {ref_lambda3:.4f}, Err: {l3_err:.2f}%)\")\nprint(f\"  Sum: {l1_calc + l2_calc + l3_calc:.4f} (Ref: {ref_lambda1 + ref_lambda2 + ref_lambda3:.4f})\")\n\n# 5. Visualization\n# ----------------\nprint(\"\\nPlotting results...\")\n\n# Create a 3-row, 1-column grid\ngrid = fig.grid(rows=3, cols=1, size=(8, 12), title=\"Lorenz System Lyapunov Analysis\")\nax_phase, ax_mle, ax_spec = grid[0][0], grid[1][0], grid[2][0]\n\n# Plot 1: Phase Portrait (x vs z)\n# Use the trajectory from the spectrum run (it has the same parameters)\nx = res_spec[\"x\"]\nz = res_spec[\"z\"]\nphase.xy(\n    x=x,\n    y=z,\n    ax=ax_phase,\n    lw=0.5,\n    alpha=0.8,\n    title=\"Phase Portrait (Lorenz Attractor)\",\n    xlabel=\"x\",\n    ylabel=\"z\",\n)\n\n# Plot 2: MLE Convergence\n# Use explicit trace_time from analysis result\nt_mle = mle_analysis.trace_time\nmle_trace = mle_analysis[\"mle\"]\nseries.plot(\n    x=t_mle,\n    y=mle_trace,\n    ax=ax_mle,\n    label=f\"MLE (\u03bb\u2081) \u2248 {mle_analysis.mle:.3f}\",\n    title=\"Maximum Lyapunov Exponent Convergence\",\n    ylabel=\"MLE\",\n    legend=True,\n    hlines=[(ref_lambda1, f\"Theoretical \u03bb\u2081 \u2248 {ref_lambda1:.3f}\")],\n    hlines_kwargs={\"alpha\": 0.5},\n)\nax_mle.grid(True, alpha=0.3)\n\n# Plot 3: Lyapunov Spectrum Convergence\n# Use explicit trace_time from analysis result\nt_spec = spec_analysis.trace_time\n# Spectrum trace columns: lyap0, lyap1, lyap2\nl1 = spec_analysis[\"lyap0\"]\nl2 = spec_analysis[\"lyap1\"]\nl3 = spec_analysis[\"lyap2\"]\n\nseries.multi(\n    x=t_spec,\n    y=[l1, l2, l3],\n    names=[f\"\u03bb\u2081 \u2248 {l1[-1]:.3f}\", f\"\u03bb\u2082 \u2248 {l2[-1]:.3f}\", f\"\u03bb\u2083 \u2248 {l3[-1]:.3f}\"],\n    ax=ax_spec,\n    title=\"Lyapunov Spectrum Convergence\",\n    xlabel=\"Time\",\n    ylabel=\"Exponents\",\n    legend=True,\n    hlines=[ref_lambda1, ref_lambda2, ref_lambda3],\n    hlines_kwargs={\"alpha\": 0.3},\n)\n\nax_spec.grid(True, alpha=0.3)\n\n# Save figure\n# export.savefig(grid, \"lyapunov_lorenz_demo.png\")\nexport.show()\n</code></pre>"},{"location":"tr/examples/analysis/#parametre-taramas-ile-lyapunov-usteli-hesaplama","title":"Parametre taramas\u0131 ile Lyapunov \u00fcsteli hesaplama","text":"<p><code>sweep.lyapunov_mle_sweep</code> ile se\u00e7ilen bir parametre de\u011feri i\u00e7in belli bir aral\u0131kta maksimum Lyapunov \u00fcsteli hesab\u0131 yap\u0131labilmektedir. Bu \u00f6rnekte lojistik harita i\u00e7in <code>r</code> \u2208 [2.5, 4] aral\u0131\u011f\u0131nda maksimum Lyapunov \u00fcsteli hesaplanmakta ve sonu\u00e7 \u00e7izdirilmektedir.</p> <pre><code>\"\"\"\nLyapunov exponent parameter sweep for the logistic map.\n\nDemonstrates sweep.lyapunov_mle_sweep for computing maximum Lyapunov exponents (MLE)\nacross a range of parameter values. This reveals the transition from order to chaos\nas a continuous function of the control parameter.\n\nFor the logistic map x_{n+1} = r*x_n*(1-x_n):\n    - r &lt; 3.0: Stable fixed point (\u03bb &lt; 0)\n    - 3.0 &lt; r &lt; ~3.57: Periodic orbits (\u03bb = 0)\n    - r &gt; ~3.57: Chaotic regime (\u03bb &gt; 0)\n    - r = 4.0: Fully chaotic (\u03bb = ln(2) \u2248 0.6931)\n\"\"\"\n\nfrom __future__ import annotations\nimport numpy as np\nfrom dynlib import setup\nfrom dynlib.analysis import sweep\nfrom dynlib.plot import series, export, theme, fig, bifurcation_diagram\n\n\n# Setup simulation\nsim = setup(\"builtin://map/logistic\", jit=True, disk_cache=False)\n\n# Parameter sweep configuration (1000 points won't trigger parallelisation in auto mode)\nr_values = np.linspace(2.5, 4.0, 1000)  \nrecord_every = 1\n\nprint(f\"Computing bifurcation diagram and Lyapunov exponents for {len(r_values)} parameter values...\")\nprint(f\"  Parameter range: r \u2208 [{r_values[0]:.2f}, {r_values[-1]:.2f}]\")\nprint(f\"  Iterations per run: 3000\")\nprint(f\"  Transient: 500\")\nprint(f\"  Trace recording interval: {record_every}\")\n\n# First, compute bifurcation diagram\nprint(\"\\nComputing bifurcation diagram...\")\nsweep_bif = sweep.traj_sweep(\n    sim,\n    param=\"r\",\n    values=r_values,\n    record_vars=[\"x\"],\n    N=200,\n    transient=300,\n)\nresult_bif = sweep_bif.bifurcation(\"x\")\n\n# Then, run parameter sweep with MLE analysis\nprint(\"\\nComputing Lyapunov exponents...\")\nsim.assign(x=0.4)  # Initial condition\nres = sweep.lyapunov_mle_sweep(\n    sim,\n    param=\"r\",\n    values=r_values,\n    N=3000,\n    transient=500,\n    dt=1.0,\n    record_interval=record_every,\n    parallel_mode=\"auto\",  # Enable parallelization\n)\n\nprint(f\"\\nSweep completed!\")\nprint(f\"  Sweep kind: {res.kind}\")\nprint(f\"  MLE range: [{res.mle.min():.4f}, {res.mle.max():.4f}]\")\nprint(f\"  Chaos onset (\u03bb=0): r \u2248 {r_values[np.argmin(np.abs(res.mle))]:.4f}\")\nprint(f\"  MLE at r=4.0: {res.mle[-1]:.4f} (theoretical: {np.log(2):.4f})\")\n\n# Optional: inspect recorded trace per-parameter (list of arrays)\ntrace_runs = res.traces.get(\"mle\")\nif trace_runs:\n    print(f\"  Recorded {len(trace_runs)} convergence traces (first length={trace_runs[0].shape[0]})\")\n\n# ===== Visualization =====\ntheme.use(\"notebook\")\ntheme.update(grid=True, vline_label_placement_pad=0.16)\n\n# Create figure with 2 rows: bifurcation diagram (top) and MLE (bottom)\nax = fig.grid(rows=2, cols=1, size=(12, 10))\n\n# Top panel: Bifurcation diagram\nbifurcation_diagram(\n    result_bif,\n    alpha=0.8,\n    color=\"black\",\n    ax=ax[0, 0],\n    xlim=(2.5, 4.0),\n    ylim=(0, 1),\n    ylabel=\"x*\",\n    title=\"Bifurcation Diagram and Maximum Lyapunov Exponent\",\n    title_fs=14,\n    ylabel_fs=12,\n    vlines=[(3.0, 'r=3\\n(period-2)'), (3.57, 'r\u22483.57\\n(chaos)')],\n    vlines_kwargs={'color': 'darkred', \n                   'linestyle': '--', \n                   'alpha': 0.3, \n                   'linewidth': 1,\n                   'label_position': 'bottom',},\n)\n\n# Bottom panel: MLE vs parameter (sharing same x-axis)\nseries.plot(\n    x=res.values,\n    y=res.mle,\n    style=\"continuous\",\n    ax=ax[1, 0],\n    xlabel=\"r\",\n    ylabel=\"\u03bb (MLE)\",\n    lw=1.5,\n    color=\"darkred\",\n    xlabel_fs=12,\n    ylabel_fs=12,\n    vlines=[3.0, 3.57],\n    vlines_kwargs={'color': 'orange', 'linestyle': '--', 'alpha': 0.3, 'linewidth': 1},\n)\n\n# Add horizontal line at \u03bb=0 (chaos boundary)\nax[1, 0].axhline(0, color=\"gray\", ls=\"--\", lw=1, alpha=0.7)\nax[1, 0].text(2.6, 0.05, \"\u03bb = 0 (chaos boundary)\", fontsize=10, color=\"gray\")\n\n# Set x-limits to match\nax[1, 0].set_xlim(2.5, 4.0)\n\nexport.show()\n\n# ===== Analysis Summary =====\nprint(\"\\n\" + \"=\"*70)\nprint(\"ANALYSIS SUMMARY\")\nprint(\"=\"*70)\n\n# Find chaos onset (where \u03bb crosses zero from negative to positive)\nzero_crossings = np.where(np.diff(np.sign(res.mle)) &gt; 0)[0]\nif len(zero_crossings) &gt; 0:\n    chaos_onset_idx = zero_crossings[0]\n    print(f\"Chaos onset (first \u03bb=0 crossing): r \u2248 {res.values[chaos_onset_idx]:.4f}\")\n\n# Count negative, zero, and positive MLE regions\nn_negative = np.sum(res.mle &lt; -0.01)\nn_zero = np.sum(np.abs(res.mle) &lt;= 0.01)\nn_positive = np.sum(res.mle &gt; 0.01)\n\nprint(f\"\\nRegion distribution:\")\nprint(f\"  Stable (\u03bb &lt; 0):   {n_negative:3d} points ({n_negative/len(res.mle)*100:.1f}%)\")\nprint(f\"  Neutral (\u03bb \u2248 0):  {n_zero:3d} points ({n_zero/len(res.mle)*100:.1f}%)\")\nprint(f\"  Chaotic (\u03bb &gt; 0):  {n_positive:3d} points ({n_positive/len(res.mle)*100:.1f}%)\")\n\nprint(f\"\\nExtreme values:\")\nprint(f\"  Min MLE: {res.mle.min():.6f} at r={res.values[np.argmin(res.mle)]:.4f}\")\nprint(f\"  Max MLE: {res.mle.max():.6f} at r={res.values[np.argmax(res.mle)]:.4f}\")\n</code></pre> <p><code>sweep.lyapunov_spectrum_sweep</code> ise se\u00e7ilen bir parametre de\u011feri i\u00e7in belli bir aral\u0131kta t\u00fcm Lyapunov spektrumunu hesaplamaktad\u0131r. Bu \u00f6rnekte Lorenz sisteminin <code>rho</code> parametresi i\u00e7in [0, 200] aral\u0131\u011f\u0131nda Lyapunov spektrumu hesab\u0131 yap\u0131lmaktad\u0131r.</p> <pre><code>\"\"\"\nLyapunov spectrum parameter sweep for the Lorenz system.\n\nDemonstrates sweep.lyapunov_spectrum_sweep for computing the full Lyapunov spectrum\nacross a range of parameters, and overlays the results with a Lorenz\nbifurcation diagram.\n\nFor the Lorenz system (sigma=10, beta=8/3):\n    - rho &lt; ~24.74: stable fixed points\n    - rho &gt; ~24.74: chaotic regime\n\"\"\"\n\nfrom __future__ import annotations\n\nimport numpy as np\nfrom dynlib import setup\nfrom dynlib.analysis import sweep\nfrom dynlib.plot import series, export, theme, fig, bifurcation_diagram\n\n\n# Setup simulation\nsim = setup(\"builtin://ode/lorenz\", stepper=\"rk4\", jit=True)\n\nsigma, beta = 10.0, 8.0/3.0\ninitial_state = {\"x\": 1.0, \"y\": 1.0, \"z\": 1.0}\n\n# Sweep configuration\nrho_values = np.linspace(0.0, 200.0, 4000)\ndt = 0.01\ntotal_time = 50.0\ntransient = 50.0\nrecord_interval = 1\n\nprint(f\"Computing Lorenz bifurcation + spectrum for {len(rho_values)} values...\")\nprint(f\"  rho range: [{rho_values[0]:.2f}, {rho_values[-1]:.2f}]\")\nprint(f\"  T={total_time}, dt={dt}, transient={transient}\")\n\n# Bifurcation diagram (z vs rho)\nprint(\"\\nComputing bifurcation diagram...\")\nsim.assign(**initial_state, sigma=sigma, rho=rho_values[0], beta=beta)\nbif_sweep = sweep.traj_sweep(\n    sim,\n    param=\"rho\",\n    values=rho_values,\n    record_vars=[\"z\"],\n    T=total_time,\n    dt=dt,\n    transient=transient,\n    record_interval=record_interval,\n)\n# Local extrema give clean bifurcation diagrams for continuous systems\nbif_result = bif_sweep.bifurcation(\"z\").extrema(\n    max_points=50,  # Limit points in chaotic regime\n    min_peak_distance=8\n)\n\n# Lyapunov spectrum sweep\nprint(\"\\nComputing Lyapunov spectrum...\")\nsim.reset()\nsim.assign(**initial_state, sigma=sigma, rho=rho_values[0], beta=beta)\nres = sweep.lyapunov_spectrum_sweep(\n    sim,\n    param=\"rho\",\n    values=rho_values,\n    k=3,\n    T=total_time,\n    dt=dt,\n    transient=transient,\n    record_interval=record_interval,\n    parallel_mode=\"auto\",\n)\n\nprint(\"\\nSweep completed!\")\nprint(\n    \"  Spectrum min/max (lambda1): \"\n    f\"[{res.lyap0.min():.4f}, {res.lyap0.max():.4f}]\"\n)\n\n# ===== Visualization =====\ntheme.use(\"notebook\")\ntheme.update(grid=True)\n\nax = fig.grid(rows=2, cols=1, size=(12, 10), sharex=True)\n\n# Upper panel: Bifurcation diagram\nbifurcation_diagram(\n    bif_result,\n    alpha=0.6,\n    color=\"black\",\n    ax=ax[0, 0],\n    xlabel=\"rho\",\n    ylabel=\"z\",\n    title=\"Lorenz Bifurcation Diagram and Lyapunov Spectrum\",\n    title_fs=14,\n    ylabel_fs=12,\n)\n\n# Lower panel: Lyapunov spectrum vs parameter\nseries.multi(\n    x=res.values,\n    y=[res.lyap0, res.lyap1, res.lyap2],\n    names=[\"$\\\\lambda_1$\", \"$\\\\lambda_2$\", \"$\\\\lambda_3$\"],\n    ax=ax[1, 0],\n    xlabel=\"rho\",\n    ylabel=\"Lyapunov exponents\",\n    legend=True,\n    hlines=[0.0],\n    hlines_kwargs={\"color\": \"gray\", \"ls\": \"--\", \"lw\": 1, \"alpha\": 0.7},\n    xlim=(rho_values[0], rho_values[-1]),\n)\n\nexport.show()\n</code></pre>"},{"location":"tr/examples/analysis/#manifoldlar-ve-yorunge-bulucular","title":"Manifoldlar ve y\u00f6r\u00fcnge bulucular","text":""},{"location":"tr/examples/analysis/#manifold-izleme","title":"Manifold izleme","text":"<p>Bu \u00f6rnekte <code>trace_manifold_1d_map</code> arac\u0131 kullan\u0131larak Henon haritas\u0131n\u0131n bir sabit noktas\u0131 i\u00e7in hem kararl\u0131 hem de karars\u0131z 1-boyutlu manifold hesaplanmaktad\u0131r. Sonu\u00e7 <code>plot.manifold</code> ile \u00e7izdirilmektedir.</p> <pre><code>from dynlib import setup\nfrom dynlib.analysis import trace_manifold_1d_map\nfrom dynlib.plot import manifold, theme, export, fig\n\n\na, b = 1.4, 0.3\nbounds = ((-2.5, 2.5), (-2.5, 2.5))\n\nsim = setup(\"builtin://map/henon2\", jit=True)\nsim.assign(a=1.4, b=0.3)\n\nfp = sim.model.fixed_points(seeds=[[0.8, 0.8]])\nstable_results = trace_manifold_1d_map( sim, \n                                        fp=fp.points[0],\n                                        bounds=bounds,\n                                        kind=\"stable\",\n                                        steps=80,\n                                        hmax=2e-3,\n                                        clip_margin=0.35,\n                                        max_points_per_segment=40000,\n                                        max_segments=300,\n                                    )\n\nunstable_results = trace_manifold_1d_map( sim, \n                                          fp=fp.points[0],\n                                          bounds=bounds,\n                                          kind=\"unstable\",\n                                          steps=80,\n                                          hmax=2e-3,\n                                          clip_margin=0.35,\n                                          max_points_per_segment=120000,\n                                          max_segments=400,\n                                        )\n\ntheme.use(\"paper\")\nax = fig.single(size=(5, 5))\nmanifold(\n    result=stable_results,\n    ax=ax,\n    color=\"blue\",\n    label=\"stable\",\n    xlim=bounds[0],\n    ylim=bounds[1],\n    xlabel=\"$x$\",\n    ylabel=\"$y$\",\n    title=\"Henon map manifolds\",\n    aspect=\"equal\",\n    lw=0.7,\n)\nmanifold(result=unstable_results, ax=ax, color=\"red\", label=\"unstable\", lw=0.7)\nax.plot(fp.points[0][0], fp.points[0][1], \"k+\", ms=12)\nexport.show()\n</code></pre> <p>Bu \u00f6rnekte ise <code>trace_manifold_1d_ode</code> arac\u0131 kullan\u0131larak 2-boyutlu bir ODE sisteminin eyer noktas\u0131na ait kararl\u0131 ve karars\u0131z manifoldlar belirlenerek sonu\u00e7 \u00e7izdirilmektedir.</p> <pre><code>\"\"\"\nExample: Tracing stable and unstable manifolds of a 2D saddle point.\n\nModel: x' = x, y' = -y + x^2\nEquilibrium at origin (0, 0) with:\n  - Unstable eigenvalue \u03bb=+1 (eigenvector along x-axis)\n  - Stable eigenvalue \u03bb=-1 (eigenvector along y-axis)\n\nKnown analytic solutions:\n  - Stable manifold: x = 0 (the y-axis)\n  - Unstable manifold: y = x^2/3\n\"\"\"\nfrom dynlib import setup\nfrom dynlib.analysis import trace_manifold_1d_ode\nfrom dynlib.plot import manifold, theme, export, fig\nimport numpy as np\n\n# Define the saddle model inline\nmodel_toml = \"\"\"\ninline:\n[model]\ntype = \"ode\"\nname = \"saddle2d\"\n\n[sim]\nt0 = 0.0\nT = 10.0\ndt = 0.01\n\n[states]\nx = 0.1\ny = 0.1\n\n[equations.rhs]\nx = \"x\"\ny = \"-y + x*x\"\n\"\"\"\n\n# Setup simulation\nsim = setup(model_toml, jit=True)\nbounds = ((-2.5, 2.5), (-2.5, 2.5))\n\n# Trace stable manifold (backward in time)\nstable_result = trace_manifold_1d_ode(\n    sim,\n    fp={\"x\": 0.0, \"y\": 0.0},\n    kind=\"stable\",\n    bounds=bounds,\n    dt=0.01,\n    max_time=50.0,\n    resample_h=0.01,\n)\n\n# Trace unstable manifold (forward in time)\nunstable_result = trace_manifold_1d_ode(\n    sim,\n    fp={\"x\": 0.0, \"y\": 0.0},\n    kind=\"unstable\",\n    bounds=bounds,\n    dt=0.01,\n    max_time=50.0,\n    resample_h=0.01,\n)\n\n# Validate against analytic solutions\nprint(f\"Stable eigenvalue: {stable_result.eigenvalue:.4f} (expected: -1)\")\nprint(f\"Unstable eigenvalue: {unstable_result.eigenvalue:.4f} (expected: +1)\")\n\n# Check stable manifold (should be x=0)\nstable_x_err = 0.0\nfor branch in stable_result.branches[0] + stable_result.branches[1]:\n    if branch.size &gt; 0:\n        stable_x_err = max(stable_x_err, np.max(np.abs(branch[:, 0])))\nprint(f\"Stable manifold max |x| error: {stable_x_err:.3e}\")\n\n# Check unstable manifold (should be y=x^2/3)\nunstable_err = 0.0\nfor branch in unstable_result.branches[0] + unstable_result.branches[1]:\n    if branch.shape[0] &gt;= 2:\n        x_vals = branch[:, 0]\n        y_vals = branch[:, 1]\n        y_analytic = x_vals**2 / 3.0\n        unstable_err = max(unstable_err, np.max(np.abs(y_vals - y_analytic)))\nprint(f\"Unstable manifold max |y - x\u00b2/3| error: {unstable_err:.3e}\")\n\n# Plot\ntheme.use(\"paper\")\nax = fig.single(size=(6, 6))\n\n# Stable manifold (blue)\nmanifold(\n    result=stable_result,\n    ax=ax,\n    color=\"C0\",\n    label=\"W^s (stable)\",\n    lw=1.5,\n)\n\n# Unstable manifold (red)\nmanifold(\n    result=unstable_result,\n    ax=ax,\n    color=\"C3\",\n    label=\"W^u (unstable)\",\n    lw=1.5,\n)\n\n# Analytic unstable manifold for comparison (dashed black)\nx_analytic = np.linspace(bounds[0][0], bounds[0][1], 500)\ny_analytic = x_analytic**2 / 3.0\nax.plot(x_analytic, y_analytic, \"k--\", lw=1.0, label=\"y = x\u00b2/3 (analytic)\")\n\n# Mark the equilibrium\nax.plot(0, 0, \"ko\", ms=8)\n\nax.set_xlim(bounds[0])\nax.set_ylim(bounds[1])\nax.set_aspect(\"equal\")\nax.set_xlabel(\"x\")\nax.set_ylabel(\"y\")\nax.set_title(\"Stable/Unstable Manifolds: x'=x, y'=-y+x\u00b2\")\nax.legend(loc=\"upper left\")\n\nexport.show()\n</code></pre>"},{"location":"tr/examples/analysis/#homoklinik-ve-heteroklinik-yorunge-bulucular","title":"Homoklinik ve heteroklinik y\u00f6r\u00fcnge bulucular","text":"<p>Bu \u00f6rnekte 2-boyutlu bir ODE sistemi i\u00e7in bir parametre ve denge noktas\u0131 se\u00e7ilmekte ve -1.0 de\u011ferinden ba\u015flayarak [-0.6, -1.2] aral\u0131\u011f\u0131nda se\u00e7ilen parametre de\u011fi\u015ftirilerek denge noktas\u0131 i\u00e7in bir homoklinik y\u00f6r\u00fcnge aranmaktad\u0131r. Arama i\u00e7in <code>homoclinic_finder</code> kullan\u0131lmaktad\u0131r. Sonras\u0131nda homoklinik y\u00f6r\u00fcnge tespit edilen parametre de\u011feri i\u00e7in <code>homoclinic_tracer</code> ve <code>plot.manifold</code> kullan\u0131larak homoklinik y\u00f6r\u00fcnge \u00e7izdirilmektedir.</p> <pre><code>\"\"\"\nExample: Homoclinic finder/tracer (manifold finder/tracer) on an inline model.\n\nWorkflow:\n1) Use homoclinic_finder to locate a parameter value with a homoclinic orbit.\n2) Use homoclinic_tracer to trace and plot the orbit at the found parameter.\n\nThis example demonstrates the simplified API with:\n- List inputs for equilibrium guess (no need for np.array)\n- window parameter as list of tuples\n- preset parameter for common configurations (\"fast\", \"default\", \"precise\")\n\nImportant: Matching Finder and Tracer Settings\n-----------------------------------------------\nThe tracer should use the same section/radius settings as the finder:\n- r_sec (section radius) and t_min_event (minimum event time) should match\n  the finder's configuration to ensure consistent return-section logic.\n- If tracing fails with status 'no_cross', try increasing t_max or loosening\n  the finder's gap_tol/x_tol tolerances.\n\nAdvanced Configuration\n----------------------\nFor fine-grained control, you can use the full configuration classes:\n\n    from dynlib.analysis import (\n        HomoclinicRK45Config,      # RK45 integrator settings (dt0, atol, rtol, etc.)\n        HomoclinicBranchConfig,    # Branch tracing settings (eps, t_max, r_sec, etc.)\n        HomoclinicFinderConfig,    # Finder config\n    )\n\n    # Example: Custom RK45 and branch configuration\n    rk_cfg = HomoclinicRK45Config(dt0=1e-4, atol=1e-12, rtol=1e-9, max_steps=5_000_000)\n    branch_cfg = HomoclinicBranchConfig(\n        t_max=2000.0,\n        r_blow=200.0,\n        r_sec=1e-2,\n        window_min=[-3.0, -3.0],\n        window_max=[3.0, 3.0],\n        rk=rk_cfg,\n    )\n    finder_cfg = HomoclinicFinderConfig(\n        trace=branch_cfg,\n        scan_n=81,\n        max_bisect=60,\n        gap_tol=1e-6,\n        x_tol=1e-4,\n    )\n\n    result = homoclinic_finder(sim, ..., cfg=finder_cfg)\n\nYou can also use `trace_cfg` for unified branch configuration:\n\n    result = homoclinic_finder(\n        sim, ...,\n        trace_cfg=branch_cfg,  # applies to the unstable branch\n        gap_tol=1e-6,\n    )\n\"\"\"\nfrom dynlib import setup\nfrom dynlib.analysis import (\n    homoclinic_finder,\n    homoclinic_tracer,\n)\nfrom dynlib.plot import theme, fig, export, manifold\n\n\nMODEL = \"\"\"\ninline:\n[model]\ntype = \"ode\"\nname = \"homoclinic-demo\"\n\n[sim]\nt0 = 0.0\nT = 10.0\ndt = 0.01\n\n[states]\nx = 0.0\ny = 0.0\n\n[params]\nmu = -0.86\n\n[equations.rhs]\nx = \"y\"\ny = \"mu*y + x - x*x + x*y\"\n\n[equations.jacobian]\nexpr = [\n    [\"0\", \"1\"],\n    [\"1 - 2*x + y\", \"mu + x\"]\n]\n\"\"\"\n\n\nsim = setup(MODEL, jit=True, disk_cache=False)\n\n# ============================================================================\n# SIMPLIFIED API: Using preset and flattened kwargs\n# ============================================================================\n\n# Simple case: just specify essential parameters, uses \"default\" preset\nresult = homoclinic_finder(\n    sim,\n    param=\"mu\",\n    param_min=-1.2,\n    param_max=-0.6,\n    param_init=-1.0,\n    eq_guess=[0.0, 0.0],  # Lists work! No need for np.array\n    # Simplified kwargs:\n    preset=\"default\",  # or \"fast\", \"precise\"\n    window=[(-3, 3), (-3, 3)],  # state-space bounds as (min, max) tuples\n    scan_n=61,\n    max_bisect=60,\n    gap_tol=1e-4,\n    x_tol=1e-4,\n    t_max=2000.0,\n    r_blow=200.0,\n)\n\nprint(\"success:\", result.success)\nprint(\"mu_found:\", result.param_found)\nprint(\"fail:\", result.info[\"fail\"])\nprint(\"best_by_abs_gap:\", result.info[\"best_by_abs_gap\"])\nprint(\"best_by_q:\", result.info[\"best_by_q\"])\nif result.success and result.miss is not None:\n    print(\n        \"gap_found:\",\n        result.info[\"gap_found\"],\n        \"q_found:\",\n        result.info[\"q_found\"],\n        \"t_cross:\",\n        result.info[\"t_cross\"],\n    )\n\nif (not result.success) or result.miss is None:\n    raise SystemExit(\"Homoclinic finder did not converge; see info above.\")\n\n# Trace the orbit using the simplified API\ntrace = homoclinic_tracer(\n    sim,\n    param=\"mu\",\n    param_value=result.param_found,\n    eq=result.miss.eq,          # Can also use lists: [0.0, 0.0]\n    sign_u=result.miss.sign_u,\n    preset=\"default\",  # Use same preset as finder for consistency\n    window=[(-3, 3), (-3, 3)],\n    t_max=2000.0,\n    r_blow=200.0,\n    r_sec=result.miss.r_sec,\n    t_min_event=result.miss.t_min,\n)\n\nprint(\"trace success: \", trace.success)\nprint(\"status: \", trace.meta.status)\nprint(\"event: \", None if trace.meta.event is None else trace.meta.event.kind)\n\nif not trace.success:\n    print(f\"\\nTracing failed with status '{trace.meta.status}'.\")\n    print(\"Consider increasing t_max or loosening gap_tol/x_tol.\")\n\n# Only plot if we have valid trajectory data\ntraj = trace.branch_pos[0] if trace.branch_pos and len(trace.branch_pos) &gt; 0 else None\nif traj is not None and len(traj) &gt; 1:\n    theme.use(\"paper\")\n    ax = fig.single()\n\n    title_suffix = \"\" if trace.success else \" (partial, no return-section hit)\"\n\n    manifold(\n        result=trace,\n        ax=ax,\n        color=\"C0\",\n        lw=1.2,\n        label=\"Homoclinic excursion\" + (\" (closed)\" if trace.success else \" (incomplete)\"),\n        xlim=(-1.6, 1.6),\n        ylim=(-1.0, 1.0),\n        xlabel=\"x\",\n        ylabel=\"y\",\n        title=f\"Homoclinic orbit at mu={result.param_found:.10f}{title_suffix}\",\n        aspect=\"equal\",\n    )\n    ax.scatter([result.miss.eq[0]], [result.miss.eq[1]], s=60, label=\"Equilibrium\")\n    ax.scatter([trace.meta.x_cross[0]], [trace.meta.x_cross[1]], s=30, label=\"Section cross\")\n    ax.legend(loc=\"best\")\n\n    \"\"\"\n    Section cross: This is the point where the unstable manifold trajectory\n    re-enters the return section defined by r_sec around the equilibrium.\n    When a homoclinic orbit exists, the crossing should align with the unstable\n    direction, making the signed return value g close to zero.\n    \"\"\"\n\n    export.show()\nelse:\n    print(\"\\nNo trajectory data to plot.\")\n</code></pre> <p>Bu \u00f6rnekte ise 2-boyutlu ba\u015fka bir ODE sistemi i\u00e7in iki tane denge noktas\u0131 se\u00e7ilmekte ve yine bir parametre i\u00e7in belli bir aral\u0131kta bu iki nokta aras\u0131nda olu\u015facak bir heteroklinik y\u00f6nge aranmaktad\u0131r. Arama i\u015flemi <code>heteroclinic_finder</code> arac\u0131 ile yap\u0131lmaktad\u0131r. Sonras\u0131nda heteroklinik y\u00f6r\u00fcnge tespit edilen parametre de\u011feri i\u00e7in <code>heteroclinic_tracer</code> ve <code>plot.manifold</code> kullan\u0131larak heteroklinik y\u00f6r\u00fcnge \u00e7izdirilmektedir.</p> <pre><code>\"\"\"\nExample: Heteroclinic finder/tracer (manifold finder/tracer) on an inline model.\n\nWorkflow:\n1) Use heteroclinic_finder to locate a parameter value with a heteroclinic orbit.\n2) Use heteroclinic_tracer to trace and plot the orbit at the found parameter.\n\nThis example demonstrates the simplified API with:\n- List inputs for fixed points (no need for np.array)\n- window parameter as list of tuples\n- preset parameter for common configurations (\"fast\", \"default\", \"precise\")\n\nImportant: Matching Finder and Tracer Settings\n-----------------------------------------------\nThe tracer's hit_radius should be chosen carefully based on the finder's accuracy:\n- If finder reports gap_found ~ 1e-4, use hit_radius ~ 0.01 to 0.05\n- If finder reports gap_found ~ 1e-6, use hit_radius ~ 0.001 to 0.01\n- Rule of thumb: hit_radius \u2248 5-50x the finder's gap_found value\n- Use the same preset for both finder and tracer for consistency\n\nThe finder and tracer may have slightly different numerical behavior, so the\ntracer might not achieve the exact same precision as the finder's gap measurement.\nIf the tracer fails with status 'window' or gets close but doesn't hit the target,\neither increase hit_radius or tighten the finder's gap_tol/x_tol tolerances.\n\nAdvanced Configuration\n----------------------\nFor fine-grained control, you can use the full configuration classes:\n\n    from dynlib.analysis import (\n        HeteroclinicRK45Config,      # RK45 integrator settings (dt0, atol, rtol, etc.)\n        HeteroclinicBranchConfig,    # Branch tracing settings (eps, t_max, window, etc.)\n        HeteroclinicFinderConfig2D,  # Finder config for 2D systems\n        HeteroclinicFinderConfigND,  # Finder config for N-dimensional systems\n    )\n\n    # Example: Custom RK45 and branch configuration\n    rk_cfg = HeteroclinicRK45Config(dt0=1e-4, atol=1e-12, rtol=1e-9, max_steps=5_000_000)\n    branch_cfg = HeteroclinicBranchConfig(\n        t_max=500.0,\n        r_blow=500.0,\n        window_min=[-20.0, -20.0],\n        window_max=[20.0, 20.0],\n        rk=rk_cfg,\n    )\n    finder_cfg = HeteroclinicFinderConfigND(\n        trace_u=branch_cfg,\n        trace_s=branch_cfg,\n        scan_n=121,\n        max_bisect=80,\n        gap_tol=1e-6,\n    )\n\n    result = heteroclinic_finder(sim, ..., cfg=finder_cfg)\n\nYou can also use `trace_cfg` for unified branch configuration:\n\n    result = heteroclinic_finder(\n        sim, ...,\n        trace_cfg=branch_cfg,  # applies to both unstable and stable branches\n        gap_tol=1e-6,\n    )\n\"\"\"\nimport numpy as np\n\nfrom dynlib import setup\nfrom dynlib.analysis import (\n    heteroclinic_finder,\n    heteroclinic_tracer,\n)\nfrom dynlib.plot import theme, fig, export, manifold\n\n\nMODEL = \"\"\"\ninline:\n[model]\ntype = \"ode\"\nname = \"heteroclinic-demo\"\n\n[sim]\nt0 = 0.0\nT = 10.0\ndt = 0.01\n\n[states]\nu = 0.0\nv = 0.0\n\n[params]\nc = 0.0\na = 0.3\n\n[equations.rhs]\nu = \"v\"\nv = \"-c*v - u*(1-u)*(u-a)\"\n\n[equations.jacobian]\nexpr = [\n    [\"0\", \"1\"],\n    [\"3*u*u - 2*(1+a)*u + a\", \"-c\"]\n]\n\"\"\"\n\n\nsim = setup(MODEL, jit=True, disk_cache=False)\n\n# NOTE: Stricter hit_radius requires stricter config values!\n#       With 0.02 you will see a gap near fixed points.\nhit_radius = 0.02\n\n# ============================================================================\n# SIMPLIFIED API: Using preset and flattened kwargs\n# ============================================================================\n\n# Simple case: just specify essential parameters, uses \"default\" preset\nresult = heteroclinic_finder(\n    sim,\n    param=\"c\",\n    param_min=-0.5,\n    param_max=1.0,\n    param_init=0.0,\n    source_eq_guess=[0.0, 0.0],  # Lists work! No need for np.array\n    target_eq_guess=[1.0, 0.0],\n    # Simplified kwargs:\n    preset=\"default\",  # or \"fast\", \"precise\"\n    window=[(-10, 10), (-10, 10)],  # state-space bounds as (min, max) tuples\n    scan_n=61,\n    max_bisect=60,\n    gap_tol=1e-4,\n    x_tol=1e-4,\n    t_max=200.0,\n    r_blow=200.0,\n)\n\nprint(\"success:\", result.success)\nprint(\"c_found:\", result.param_found)\nprint(\"fail:\", result.info[\"fail\"])\nprint(\"sign_u, sign_s:\", result.info[\"sign_u\"], result.info[\"sign_s\"])\nprint(\"best_by_abs_gap:\", result.info[\"best_by_abs_gap\"])\nprint(\"best_by_q:\", result.info[\"best_by_q\"])\nif result.success and result.miss is not None:\n    print(\n        \"gap_found:\",\n        result.info[\"gap_found\"],\n        \"gap_tol_eff_found:\",\n        result.info[\"gap_tol_eff_found\"],\n        \"q_found:\",\n        result.info[\"q_found\"],\n    )\n\nif (not result.success) or result.miss is None:\n    raise SystemExit(\"Heteroclinic finder did not converge; see info above.\")\n\n# Trace the orbit using the simplified API\n# Note: hit_radius should be adjusted based on the accuracy of the finder's gap (gap_found).\n# If the finder's gap is ~1e-4, a hit_radius of 1e-3 may be too strict for the tracer.\n# Reasonable values: 0.01 to 0.05 for typical cases, or 5-10x the finder's gap_found.\ntrace = heteroclinic_tracer(\n    sim,\n    param=\"c\",\n    param_value=result.param_found,\n    source_eq=result.miss.source_eq,  # Can also use lists: [0.0, 0.0]\n    target_eq=result.miss.target_eq,\n    sign_u=result.miss.sign_u,\n    preset=\"default\",  # Use same preset as finder for consistency\n    window=[(-10, 10), (-10, 10)],\n    t_max=200.0,\n    hit_radius=hit_radius,  # Adjusted to be more realistic given gap_found ~ 2e-4\n)\n\nprint(\"trace success: \", trace.success)\nprint(\"status: \", trace.meta.status)\nprint(\"event: \", None if trace.meta.event is None else trace.meta.event.kind)\n\nif not trace.success:\n    # Diagnose why tracing failed\n    if trace.branch_pos and len(trace.branch_pos) &gt; 0:\n        traj = trace.branch_pos[0]\n        dist_to_B = np.linalg.norm(traj[-1] - result.miss.target_eq)\n        print(f\"\\nTracing failed with status '{trace.meta.status}'.\")\n        print(f\"Trajectory reached distance {dist_to_B:.6f} from target_eq.\")\n        print(f\"This exceeds hit_radius={hit_radius}.\")\n        print(\"Consider increasing hit_radius or tightening finder tolerances.\")\n\nif not trace.success:\n    # Diagnose why tracing failed\n    if trace.branch_pos and len(trace.branch_pos) &gt; 0:\n        traj = trace.branch_pos[0]\n        dist_to_B = np.linalg.norm(traj[-1] - result.miss.target_eq)\n        print(f\"\\nTracing failed with status '{trace.meta.status}'.\")\n        print(f\"Trajectory reached distance {dist_to_B:.6f} from target_eq.\")\n        print(f\"This exceeds hit_radius={hit_radius}.\")\n        print(\"Consider increasing hit_radius or tightening finder tolerances.\")\n\n# Only plot if we have valid trajectory data\nif trace.branch_pos and len(trace.branch_pos) &gt; 0:\n    theme.use(\"paper\")\n    ax = fig.single()\n\n    # Add title indicating whether full heteroclinic connection was achieved\n    title_suffix = \"\" if trace.success else \" (partial, did not reach B within hit_radius)\"\n\n    manifold(\n        result=trace,\n        ax=ax,\n        color=\"C0\",\n        lw=1.2,\n        label=\"Wu(A)\" + (\" \u2192 B\" if trace.success else \" (incomplete)\"),\n        xlim=(-0.5, 1.5),\n        ylim=(-0.2, 0.4),\n        xlabel=\"u\",\n        ylabel=\"v\",\n        title=f\"Heteroclinic orbit at c={result.param_found:.10f}{title_suffix}\",\n        aspect=\"equal\",\n    )\n    ax.scatter([result.miss.source_eq[0]], [result.miss.source_eq[1]], s=60, label=\"A\")\n    ax.scatter([result.miss.target_eq[0]], [result.miss.target_eq[1]], s=60, label=\"B\")\n    ax.scatter([result.miss.x_u_cross[0]], [result.miss.x_u_cross[1]], s=30, label=\"cross (Wu)\")\n    ax.scatter([result.miss.x_s_cross[0]], [result.miss.x_s_cross[1]], s=30, label=\"cross (Ws)\")\n    ax.legend(loc=\"best\")\n\n    \"\"\"\n    cross (Wu) (or x_u_cross): This is the point where the unstable manifold (Wu) of\n    equilibrium point A crosses a section plane centered at equilibrium point B.\n\n    cross (Ws) (or x_s_cross): This is the point where the stable manifold (Ws) of\n    equilibrium point B crosses the same section plane.\n\n    When a heteroclinic orbit exists, these two crossing points should be very close\n    (ideally the same point), meaning the unstable manifold of A connects to the stable\n    manifold of B. The algorithm searches for parameter values where this \"miss distance\"\n    is minimized.\n    \"\"\"\n\n    export.show()\nelse:\n    print(\"\\nNo trajectory data to plot.\")\n</code></pre>"},{"location":"tr/examples/analysis/#parametre-taramas-ve-yorunge-analizi","title":"Parametre taramas\u0131 ve y\u00f6r\u00fcnge analizi","text":""},{"location":"tr/examples/analysis/#parametre-taramalar","title":"Parametre taramalar\u0131","text":"<p>Bu \u00f6rnekte 1-boyutlu basit bir ODE modelinin <code>a</code> parametresi i\u00e7in farkl\u0131 de\u011ferler se\u00e7ilerek <code>analysis.sweep.traj_sweep</code> arac\u0131 ile her bir parametre i\u00e7in otomatik olarak bir y\u00f6r\u00fcnge (trajectory) hesaplanmaktad\u0131r. Hesaplanan y\u00f6r\u00fcngeler <code>plot.series.multi</code> ile tek seferde \u00e7izdirilmektedir.</p> <pre><code>import numpy as np\nfrom dynlib import setup\nfrom dynlib.plot import series, export\nfrom dynlib.analysis import sweep\n\n\nDSL = \"\"\"\ninline:\n[model]\ntype=\"ode\"\n\n[states]\nx=10.0\n\n[params]\na=-1.0\n\n[equations.rhs]\nx = \"a * x\"\n\"\"\"\n\nsim = setup(DSL, \n            jit=True,\n            disk_cache=False)\n\nvalues = np.arange(-5.0, -1.0, 1.0)\nres=sweep.traj_sweep(sim, param=\"a\", record_vars=[\"x\"], values=values, T=5)\n\n# Plot all trajectories at once (stacked access)\nseries.multi(x=res.t, y=res[\"x\"], legend=False)\nexport.show()\n\n# Access individual runs for custom processing\nprint(f\"\\nSweep has {len(res.runs)} runs:\")\nfor run in res.runs:\n    final_x = run[\"x\"][-1]\n    print(f\"  a={run.param_value:.1f}: x(T)={final_x:.6f}\")\n\n# Access a specific run\nrun = res.runs[2]  # Third run (a=-3.0)\nprint(f\"\\nRun details for a={run.param_value}:\")\nprint(f\"  Time points: {len(run.t)}\")\nprint(f\"  Initial x: {run['x'][0]:.6f}\")\nprint(f\"  Final x: {run['x'][-1]:.6f}\")\n</code></pre>"},{"location":"tr/examples/analysis/#yorunge-analizi","title":"Y\u00f6r\u00fcnge analizi","text":"<p>Bu \u00f6rnekte bir sim\u00fclasyon yap\u0131ld\u0131ktan sonra elde edilen sonu\u00e7lar \u00fczerinde nas\u0131l analiz yap\u0131labilece\u011fi g\u00f6sterilmektedir. <code>res</code> sim\u00fclasyon sonucu olmak \u00fczere <code>res.analyze()</code> ile <code>summary()</code>, <code>argmax()</code>, <code>zero_crossings()</code> ve <code>time_above/below</code> gibi post-analiz opsiyonlar\u0131 kullan\u0131labilmektedir. </p> <pre><code>\"\"\"Demonstration of TrajectoryAnalyzer helpers on a damped oscillator.\"\"\"\n\nfrom __future__ import annotations\nimport numpy as np\nfrom dynlib import setup\n\n\nMODEL = \"\"\"\ninline:\n[model]\ntype=\"ode\"\nname=\"Damped oscillator with aux energy\"\n\n[states]\nx=1.0\nv=0.0\n\n[params]\nomega=2.0\nzeta=0.15\n\n[equations.rhs]\nx = \"v\"\nv = \"-2*zeta*omega*v - omega**2 * x\"\n\n[aux]\nenergy = \"0.5 * (v**2 + (omega * x)**2)\"\n\"\"\"\n\n\ndef _round_dict(values: dict[str, float], digits: int = 3) -&gt; dict[str, float]:\n    return {k: round(float(v), digits) for k, v in values.items()}\n\n\ndef main() -&gt; None:\n    sim = setup(MODEL, stepper=\"rk4\", jit=False, disk_cache=False)\n    sim.config(dt=0.01, max_steps=150_000)\n    sim.run(T=15.0, record_vars=[\"x\", \"v\", \"aux.energy\"])\n    res = sim.results()\n\n    print(\"\\n--- Single-variable analysis (x) ---\")\n    x = res.analyze(\"x\")\n    print(\"summary:\", _round_dict(x.summary()))\n    t_peak, peak = x.argmax()\n    print(f\"peak x at t={t_peak:.3f}: {peak:.3f}\")\n    crossings = x.zero_crossings(direction=\"up\")\n    print(\"first three zero up-crossings (s):\", np.round(crossings[:3], 3))\n    print(f\"time with x &gt;= 0.5: {x.time_above(0.5):.3f}s\")\n    print(f\"time with x &lt; -0.5: {x.time_below(-0.5):.3f}s\")\n\n    print(\"\\n--- Multi-variable analysis (x, v) ---\")\n    mv = res.analyze([\"x\", \"v\"])\n    print(\"argmax by var:\", {k: (round(t, 3), round(v, 3)) for k, (t, v) in mv.argmax().items()})\n    print(\"range by var:\", _round_dict(mv.range()))\n    print(\"mean by var:\", _round_dict(mv.mean()))\n\n    print(\"\\n--- Aux variable analysis (energy) ---\")\n    energy = res.analyze(\"energy\")  # auto-detected aux without explicit prefix\n    print(\"energy min/max:\", (round(energy.min(), 3), round(energy.max(), 3)))\n    print(\"energy range:\", round(energy.range(), 3))\n    below_times = energy.crossing_times(threshold=0.1, direction=\"down\")\n    print(\"first drop below 0.1:\", round(below_times[0], 3) if len(below_times) else \"never\")\n\n    print(\"\\n--- Automatic variable selection ---\")\n    auto = res.analyze()\n    print(\"recorded vars picked by res.analyze():\", auto.vars)\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"tr/examples/bifurcation/","title":"\u00c7atallanma (Bifurcation) Diyagram\u0131: Lojistik Harita","text":""},{"location":"tr/examples/bifurcation/#genel-baks","title":"Genel Bak\u0131\u015f","text":"<p>Bu \u00f6rnek, <code>dynlib</code> k\u00fct\u00fcphanesinin parametre tarama ve \u00e7izim yeteneklerini kullanarak \u00e7atallanma (bifurcation) diyagramlar\u0131n\u0131n nas\u0131l olu\u015fturulaca\u011f\u0131n\u0131 a\u00e7\u0131klamaktad\u0131r. \u00c7atallanma diyagramlar\u0131, bir sistem parametresi de\u011fi\u015ftik\u00e7e sistemin uzun vadedeki davran\u0131\u015f\u0131n\u0131 g\u00f6rselle\u015ftirir. Bu sayede sabit noktalar, periyodik y\u00f6r\u00fcngeler ve kaotik davran\u0131\u015flar aras\u0131ndaki ge\u00e7i\u015fler net bir \u015fekilde g\u00f6zlemlenebilir.</p> <p>Bu kavram\u0131 incelemek i\u00e7in klasik bir \u00f6rnek olan lojistik harita (<code>x_{n+1} = r\u00b7x_n\u00b7(1-x_n)</code>) kullan\u0131lacakt\u0131r. Bu modelde, <code>r</code> parametresi 2.5'ten 4.0'a do\u011fru art\u0131r\u0131l\u0131rken g\u00f6zlemlenen periyot katlanmalar\u0131yla kaosa ge\u00e7i\u015f s\u00fcreci incelenecektir.</p>"},{"location":"tr/examples/bifurcation/#temel-kavramlar","title":"Temel Kavramlar","text":"<ul> <li>Parametre Taramas\u0131: Bir model parametresinin belirli bir aral\u0131ktaki farkl\u0131 de\u011ferleri i\u00e7in sistemin davran\u0131\u015f\u0131n\u0131 (y\u00f6r\u00fcngelerini) hesaplama i\u015flemidir.</li> <li>Diyagram i\u00e7in Veri \u00c7\u0131kar\u0131m\u0131: Parametre taramas\u0131 sonucu elde edilen y\u00f6r\u00fcnge verilerinden, diyagram\u0131 \u00e7izmek i\u00e7in kullan\u0131lacak noktalar\u0131n (sa\u00e7\u0131l\u0131m verisinin) ay\u0131klanmas\u0131d\u0131r.</li> <li>Veri \u00c7\u0131karma Stratejileri: <code>dynlib</code>, y\u00f6r\u00fcngelerden veri ay\u0131klamak i\u00e7in farkl\u0131 stratejiler sunar. \u00d6rne\u011fin, y\u00f6r\u00fcngenin tamam\u0131n\u0131 (<code>all</code>), son k\u0131sm\u0131n\u0131 (<code>tail</code>), sadece son noktas\u0131n\u0131 (<code>final</code>) veya yerel ekstremumlar\u0131n\u0131 (<code>extrema</code>) kullanabilirsiniz.</li> <li>Periyot Katlanmas\u0131 ile Kaosa Ge\u00e7i\u015f: Sistemin kararl\u0131 durumdan periyodik davran\u0131\u015fa, ard\u0131ndan periyotlar\u0131n ikiye katlanarak giderek daha karma\u015f\u0131k hale geldi\u011fi ve sonunda kaosa ula\u015ft\u0131\u011f\u0131 klasik bir senaryodur (Feigenbaum senaryosu).</li> </ul>"},{"location":"tr/examples/bifurcation/#lojistik-harita-modeli","title":"Lojistik Harita Modeli","text":"<p>Lojistik harita denklemi a\u015fa\u011f\u0131daki gibidir:</p> \\[ x_{n+1} = r \\cdot x_n \\cdot (1 - x_n) \\] <p>Bu modelde <code>r</code> parametresinin kritik de\u011ferleri ve sistemin davran\u0131\u015f\u0131: - r &lt; 3.0: Sistem, tek bir kararl\u0131 sabit noktaya yak\u0131nsar. - r = 3.0: \u0130lk periyot katlanmas\u0131 ger\u00e7ekle\u015fir ve 2-periyotlu bir y\u00f6r\u00fcnge ortaya \u00e7\u0131kar. - r \u2248 3.449: Bir sonraki katlanma ile 4-periyotlu y\u00f6r\u00fcnge ba\u015flar. - r \u2248 3.57: Kaosun ba\u015flang\u0131c\u0131 olarak kabul edilen Feigenbaum noktas\u0131 (r\u221e \u2248 3.5699). - r = 4.0: Sistemin tamamen kaotik davran\u0131\u015f sergiledi\u011fi durum.</p>"},{"location":"tr/examples/bifurcation/#temel-ornek","title":"Temel \u00d6rnek","text":"<p>A\u015fa\u011f\u0131daki kod, <code>dynlib</code> k\u00fct\u00fcphanesinin yerle\u015fik lojistik harita modelini kullanarak basit bir \u00e7atallanma diyagram\u0131 olu\u015fturur.</p> <p>Ad\u0131mlar: 1.  Modeli Kur: <code>setup</code> fonksiyonu ile lojistik harita modeli haz\u0131rlan\u0131r. 2.  Parametre Aral\u0131\u011f\u0131n\u0131 Belirle: <code>numpy.linspace</code> ile taranacak <code>r</code> de\u011ferleri olu\u015fturulur. 3.  Parametre Taramas\u0131 Yap: <code>sweep.traj_sweep</code> fonksiyonu, her bir <code>r</code> de\u011feri i\u00e7in modelin y\u00f6r\u00fcngesini hesaplar.     - <code>transient</code>: Sistemin kararl\u0131 hale gelmesi i\u00e7in ba\u015flang\u0131\u00e7ta atlanacak ad\u0131m say\u0131s\u0131.     - <code>N</code>: <code>transient</code> ad\u0131mlar\u0131ndan sonra kaydedilecek ad\u0131m say\u0131s\u0131. 4.  Veriyi \u00c7\u0131kar: <code>bifurcation</code> metodu, y\u00f6r\u00fcnge sonu\u00e7lar\u0131ndan diyagram i\u00e7in gerekli veriyi ay\u0131klar. 5.  Diyagram\u0131 \u00c7iz: <code>bifurcation_diagram</code> fonksiyonu ile sonu\u00e7lar g\u00f6rselle\u015ftirilir.</p> <pre><code>from dynlib import setup\nfrom dynlib.analysis import sweep\nfrom dynlib.plot import bifurcation_diagram, theme, fig, export\nimport numpy as np\n\n# 1. Yerle\u015fik lojistik harita modelini kur\nsim = setup(\"builtin://map/logistic\", stepper=\"map\", jit=True)\n\n# 2. Taranacak 'r' parametresi i\u00e7in de\u011fer aral\u0131\u011f\u0131\nr_values = np.linspace(2.8, 4.0, 5000)\n\n# 3. Parametre taramas\u0131n\u0131 \u00e7al\u0131\u015ft\u0131r\nsweep_result = sweep.traj_sweep(\n    sim,\n    param=\"r\",           # Taranacak parametre\n    values=r_values,     # Parametre de\u011ferleri\n    record_vars=[\"x\"],   # Kaydedilecek de\u011fi\u015fken\n    N=100,               # Her bir 'r' de\u011feri i\u00e7in kaydedilecek ad\u0131m say\u0131s\u0131\n    transient=500,       # Kararl\u0131 y\u00f6r\u00fcngeye ula\u015fmak i\u00e7in atlanacak ad\u0131m say\u0131s\u0131\n)\n\n# 4. Diyagram i\u00e7in y\u00f6r\u00fcngelerden 'x' verisini \u00e7\u0131kar\nresult = sweep_result.bifurcation(\"x\")\n\n# 5. Sonu\u00e7lar\u0131 \u00e7izdir\ntheme.use(\"notebook\")\nax = fig.single(size=(10, 6))\n\nbifurcation_diagram(\n    result,\n    xlabel=\"r\",\n    ylabel=\"x*\",\n    title=\"Lojistik Harita i\u00e7in \u00c7atallanma Diyagram\u0131\",\n    ax=ax\n)\n\nexport.show()\n</code></pre>"},{"location":"tr/examples/bifurcation/#detayl-ornekler","title":"Detayl\u0131 \u00d6rnekler","text":"<p>Proje i\u00e7erisindeki <code>examples/</code> dizininde, bu konuda daha detayl\u0131 \u00e7al\u0131\u015fan kodlar\u0131 bulabilirsiniz.</p>"},{"location":"tr/examples/bifurcation/#1-yuksek-cozunurluklu-catallanma-diyagram","title":"1. Y\u00fcksek \u00c7\u00f6z\u00fcn\u00fcrl\u00fckl\u00fc \u00c7atallanma Diyagram\u0131","text":"<p>Bu \u00f6rnek, standart i\u015f ak\u0131\u015f\u0131n\u0131 kullanarak y\u00fcksek \u00e7\u00f6z\u00fcn\u00fcrl\u00fckl\u00fc bir diyagram olu\u015fturur.</p> <pre><code>\"\"\"\nBifurcation diagram demonstration for the logistic map.\n\n\"\"\"\n\nfrom __future__ import annotations\nimport numpy as np\nfrom dynlib import setup\nfrom dynlib.analysis import sweep\nfrom dynlib.plot import export, theme, fig, bifurcation_diagram\n\nr0 = 2.8\nrend = 4.0\n\nsim = setup(\"builtin://map/logistic\", stepper=\"map\", jit=True, disk_cache=True)\n\nr_values = np.linspace(r0, rend, 20000)\n\nprint(\"Computing bifurcation diagram...\")\nprint(f\"  Parameter: r \u2208 [{r0}, {rend}]\")\nprint(f\"  Grid points: {len(r_values)}\")\n\nsweep_result = sweep.traj_sweep(\n    sim,\n    param=\"r\",\n    values=r_values,\n    record_vars=[\"x\"],\n    N=100,  \n    transient=500,  \n    record_interval=1,  \n    parallel_mode=\"auto\",\n)\n# Extract bifurcation data (defaults to .all() mode - all recorded points)\nresult = sweep_result.bifurcation(\"x\")\n# Alternatively: result = sweep_result.bifurcation(\"x\").tail(50)  # for tail mode\n\nprint(f\"  Total points plotted: {len(result.p)}\")\nprint(\"Done!\")\n\ntheme.use(\"notebook\")\ntheme.update(grid=True)\n\nax = fig.single(size=(10, 8))\n\nbifurcation_diagram(\n    result,\n    color=\"blue\",\n    xlim=(r0, rend),\n    ylim=(0, 1),\n    xlabel=\"r\",\n    ylabel=\"x*\",\n    title=\"Bifurcation Diagram: Logistic Map\",\n    xlabel_fs=12,\n    ylabel_fs=12,\n    title_fs=14,\n    ax=ax,\n)\n\nexport.show()\n# Save figure with high dpi will be more smooth\n# export.savefig(ax, \"bifurcation_logistic_map.png\", dpi=600)\n</code></pre> <p>\u00d6zellikleri: - Daha detayl\u0131 bir g\u00f6r\u00fcnt\u00fc i\u00e7in y\u00fcksek \u00e7\u00f6z\u00fcn\u00fcrl\u00fckl\u00fc parametre taramas\u0131 (20.000 nokta). - Varsay\u0131lan veri \u00e7\u0131karma modu kullan\u0131l\u0131r (<code>all</code>, yani y\u00f6r\u00fcngedeki t\u00fcm noktalar). - Minimum \u00f6zelle\u015ftirme ile sade bir \u00e7izim yap\u0131l\u0131r.</p>"},{"location":"tr/examples/bifurcation/#2-veri-ckarma-stratejilerinin-karslastrlmas","title":"2. Veri \u00c7\u0131karma Stratejilerinin Kar\u015f\u0131la\u015ft\u0131r\u0131lmas\u0131","text":"<p>Bu \u00f6rnek, farkl\u0131 veri \u00e7\u0131karma stratejilerinin diyagram \u00fczerindeki etkisini g\u00f6sterir.</p> <pre><code>\"\"\"\nBifurcation diagram comparison for the logistic map showing different modes.\n\nThis example demonstrates the three different bifurcation analysis modes:\n1. \"final\": Shows only the final state (good for fixed points)\n2. \"tail\": Shows multiple samples from the attractor (reveals periodic orbits)\n3. \"extrema\": Shows local extrema (emphasizes periodic structure)\n\"\"\"\n\nfrom __future__ import annotations\nimport numpy as np\nfrom dynlib import setup\nfrom dynlib.analysis import sweep\nfrom dynlib.plot import export, theme, fig\n\n# Setup the builtin logistic map model\nsim = setup(\"builtin://map/logistic\", stepper=\"map\", jit=True, disk_cache=True)\n\n# Focus on the interesting region where bifurcations occur\nr_values = np.linspace(2.8, 4.0, 1500)\n\nprint(\"Computing bifurcation diagrams in different modes...\")\n\n# Runtime sweep (do once)\nsweep_result = sweep.traj_sweep(\n    sim,\n    param=\"r\",\n    values=r_values,\n    record_vars=[\"x\"],\n    N=500,\n    transient=200,\n)\n\nextractor = sweep_result.bifurcation(\"x\")\n\n# Mode 1: \"final\" - just the final value (good for convergent behavior)\nresult_final = extractor.final()\n\n# Mode 2: \"tail\" - multiple samples from attractor\nresult_tail = extractor.tail(50)\n\n# Mode 3: \"extrema\" - local extrema (maxima + minima)\nresult_extrema = extractor.extrema(tail=100, max_points=30, min_peak_distance=1)\n\nprint(\"Done! Creating comparison plot...\")\n\n# Configure plot theme\ntheme.use(\"notebook\")\ntheme.update(grid=True)\n\n# Create 3-panel comparison\nfrom dynlib.plot import bifurcation_diagram\n\nax = fig.grid(rows=3, cols=1, size=(10, 10))\n\n# Panel 1: Final mode\nbifurcation_diagram(\n    result_final,\n    marker=\".\",\n    ms=0.5,\n    alpha=0.7,\n    color=\"blue\",\n    ax=ax[0, 0],\n    xlim=(2.8, 4.0),\n    ylim=(0, 1),\n    ylabel=\"x*\",\n    title='Mode: \"final\" (last recorded value)',\n    title_fs=12,\n)\n\n# Panel 2: Tail mode\nbifurcation_diagram(\n    result_tail,\n    marker=\".\",\n    ms=0.3,\n    alpha=0.5,\n    color=\"black\",\n    ax=ax[1, 0],\n    xlim=(2.8, 4.0),\n    ylim=(0, 1),\n    ylabel=\"x*\",\n    title='Mode: \"tail\" (attractor cloud)',\n    title_fs=12,\n)\n\n# Panel 3: Extrema mode\nbifurcation_diagram(\n    result_extrema,\n    marker=\".\",\n    ms=0.5,\n    alpha=0.6,\n    color=\"red\",\n    ax=ax[2, 0],\n    xlim=(2.8, 4.0),\n    ylim=(0, 1),\n    xlabel=\"r\",\n    ylabel=\"x*\",\n    title='Mode: \"extrema\" (local maxima and minima)',\n    title_fs=12,\n)\n\nexport.show()\n</code></pre> <p>\u00d6rnekte \u00fc\u00e7 farkl\u0131 strateji yan yana kar\u015f\u0131la\u015ft\u0131r\u0131l\u0131r:</p> <p><pre><code>extractor = sweep_result.bifurcation(\"x\")\n\n# Strateji 1: Sadece y\u00f6r\u00fcngenin son de\u011feri kullan\u0131l\u0131r\nresult_final = extractor.final()\n\n# Strateji 2: Y\u00f6r\u00fcngenin son 50 noktas\u0131 kullan\u0131l\u0131r (\u00e7ekicinin yap\u0131s\u0131n\u0131 g\u00f6sterir)\nresult_tail = extractor.tail(50)\n\n# Strateji 3: Y\u00f6r\u00fcngenin son 100 noktas\u0131ndaki yerel ekstremumlar (maksimum ve minimumlar) kullan\u0131l\u0131r\nresult_extrema = extractor.extrema(tail=100, max_points=30)\n</code></pre> Bu farkl\u0131 stratejiler, sistemin periyodik veya kaotik davran\u0131\u015f\u0131n\u0131 farkl\u0131 a\u00e7\u0131lardan vurgulamaya yard\u0131mc\u0131 olur.</p>"},{"location":"tr/examples/integer-map/","title":"Tamsay\u0131 Haritas\u0131 \u00d6rne\u011fi: Collatz Dizisi","text":""},{"location":"tr/examples/integer-map/#genel-baks","title":"Genel Bak\u0131\u015f","text":"<p>Bu \u00f6rnek, tamsay\u0131 durum de\u011fi\u015fkeni kullanan bir harita (map) sim\u00fclasyonunun nas\u0131l olu\u015fturulaca\u011f\u0131n\u0131 g\u00f6sterir. Dok\u00fcmantasyonun di\u011fer b\u00f6l\u00fcmlerinde g\u00f6sterilen kayan noktal\u0131 (floating-point) aritmeti\u011fe dayal\u0131 lojistik harita \u00f6rneklerinin aksine, bu model Collatz yinelemesini tamsay\u0131lar \u00fczerinde ger\u00e7ekle\u015ftirerek, tamsay\u0131 aritmeti\u011finin kullan\u0131m\u0131n\u0131 sergiler.</p>"},{"location":"tr/examples/integer-map/#one-ckan-kavramlar","title":"\u00d6ne \u00c7\u0131kan Kavramlar","text":"<ul> <li>Ayr\u0131k Zamanl\u0131 Sim\u00fclasyon (<code>map</code>): Durumun her ad\u0131mda bir kez g\u00fcncellendi\u011fi ve s\u00fcrekli zaman kavram\u0131n\u0131n olmad\u0131\u011f\u0131 ayr\u0131k zamanl\u0131 bir sim\u00fclasyon t\u00fcr\u00fcd\u00fcr.</li> <li>Tamsay\u0131 Veri Tipi (<code>int64</code>): Collatz dizisinin elemanlar\u0131n\u0131n tam olarak hesaplanmas\u0131n\u0131 sa\u011flayarak, \u00f6nceden bilinen referans diziyle kar\u015f\u0131la\u015ft\u0131rma yap\u0131lmas\u0131na olanak tan\u0131r.</li> <li><code>assert</code> ile Do\u011frulama: <code>numpy.testing.assert_array_equal</code> fonksiyonu kullan\u0131larak, sim\u00fclasyon sonucu elde edilen y\u00f6r\u00fcngenin, beklenen 1-4-2-1 d\u00f6ng\u00fcs\u00fcyle biten diziyle birebir ayn\u0131 olup olmad\u0131\u011f\u0131 kontrol edilir.</li> <li>Seri Grafi\u011fi: Tamsay\u0131 y\u00f6r\u00fcngesi g\u00f6rselle\u015ftirilerek, dizinin ne zaman 4-2-1 d\u00f6ng\u00fcs\u00fcne yak\u0131nsad\u0131\u011f\u0131 g\u00f6sterilir.</li> </ul>"},{"location":"tr/examples/integer-map/#collatz-konjektur-modelinin-tanmlanmas","title":"Collatz Konjekt\u00fcr Modelinin Tan\u0131mlanmas\u0131","text":"<p>Model, ba\u015flang\u0131\u00e7 de\u011feri 27 olan <code>n</code> ad\u0131nda tek bir tamsay\u0131 durum de\u011fi\u015fkeni ile tan\u0131mlanm\u0131\u015ft\u0131r. Modelin denklemi, <code>n</code>'nin \u00e7ift veya tek olmas\u0131na g\u00f6re farkl\u0131 hesaplama yapan <code>int64</code> t\u00fcr\u00fcnde bir ifadedir. Bu tan\u0131m, a\u015fa\u011f\u0131da g\u00f6r\u00fcld\u00fc\u011f\u00fc gibi TOML format\u0131nda sat\u0131r i\u00e7i (inline) olarak yap\u0131lm\u0131\u015ft\u0131r.</p> <pre><code>[model]\ntype = \"map\"\ndtype = \"int64\"\nname = \"Collatz Conjecture\"\n\n[states]\nn = 27\n\n[equations.rhs]\nn = \"n//2 if n % 2 == 0 else 3*n + 1\"\n</code></pre>"},{"location":"tr/examples/integer-map/#simulasyonun-calstrlmas","title":"Sim\u00fclasyonun \u00c7al\u0131\u015ft\u0131r\u0131lmas\u0131","text":"<p>Betik, <code>setup(..., stepper=\"map\")</code> fonksiyonu ile modeli olu\u015fturur ve <code>len(expected) - 1</code> ad\u0131m kadar sim\u00fclasyonu \u00e7al\u0131\u015ft\u0131r\u0131r. Sim\u00fclasyon sonu\u00e7lar\u0131 <code>sim.results()</code> ile al\u0131n\u0131r. <code>series.plot</code> fonksiyonu, <code>n</code>'nin ad\u0131mlara g\u00f6re de\u011fi\u015fimini g\u00f6steren bir grafik \u00e7izer. Betik ayr\u0131ca, elde edilen dizinin, 27 ile ba\u015flay\u0131p 1-4-2-1 d\u00f6ng\u00fcs\u00fcyle biten bilinen <code>expected</code> dizisiyle tam olarak e\u015fle\u015fip e\u015fle\u015fmedi\u011fini kontrol eder. Son olarak, y\u00f6r\u00fcngenin son k\u0131sm\u0131 ve durum de\u011fi\u015fkeninin veri tipi ekrana yazd\u0131r\u0131larak d\u00f6ng\u00fcn\u00fcn ve veri tipinin korundu\u011fu do\u011frulan\u0131r.</p>"},{"location":"tr/examples/integer-map/#grafik-ve-gorsellestirme","title":"Grafik ve G\u00f6rselle\u015ftirme","text":"<p><code>theme.use(\"paper\")</code> komutu, <code>matplotlib</code>'i yay\u0131n kalitesinde grafikler olu\u015fturacak \u015fekilde ayarlar. <code>export.show()</code> ise olu\u015fturulan grafi\u011fi ekranda g\u00f6sterir. Grafi\u011fin eksen etiketleri (<code>iteration</code> ve <code>n</code>) ve ba\u015fl\u0131\u011f\u0131 (<code>Collatz Conjecture</code>), <code>n</code> de\u011ferlerinin me\u015fhur 4-2-1 d\u00f6ng\u00fcs\u00fcne girmeden \u00f6nceki de\u011fi\u015fimini kolayca incelemeyi sa\u011flar.</p>"},{"location":"tr/examples/integer-map/#referans-kod","title":"Referans Kod","text":"<p>Do\u011frulama ve \u00e7izim mant\u0131\u011f\u0131n\u0131 da i\u00e7eren tam betik a\u015fa\u011f\u0131da verilmi\u015ftir: <pre><code>from dynlib import setup\nfrom dynlib.plot import series, export, theme\nimport numpy as np\nfrom numpy.testing import assert_array_equal\n\nmodel = '''\ninline:\n[model]\ntype = \"map\"\ndtype = \"int64\"\nname = \"Collatz Conjecture\"\n\n[states]\nn = 27\n\n[equations.rhs]\nn = \"n//2 if n % 2 == 0 else 3*n + 1\"\n\n'''\n\nexpected = np.array([\n    27, 82, 41, 124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121,\n    364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175,\n    526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502,\n    251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438,\n    719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367,\n    4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300,\n    650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160,\n    80, 40, 20, 10, 5, 16, 8, 4, 2, 1\n], dtype=np.int64)\n\n\nsim = setup(model, stepper=\"map\")\nsim.run(N=len(expected)-1)\nres = sim.results()\n\ntheme.use(\"paper\")\n\nseries.plot(x=res.step, y=res[\"n\"], xlabel=\"iteration\", ylabel=\"n\", ylabel_rot=0, title=\"Collatz Conjecture\")\nprint(\"1-4-2-1 cycle: \", res[\"n\"][-6:])\nprint(\"dtype for n  : \", res[\"n\"].dtype)\n\nif res[\"n\"][0] == 27:\n    assert_array_equal(res[\"n\"], expected)\n    print(\"\u2705 Collatz sequence matches exactly!\")\n\nexport.show()\n</code></pre> Bu betik, ayn\u0131 zamanda bir regresyon testi i\u015flevi g\u00f6r\u00fcr. \u00c7al\u0131\u015ft\u0131r\u0131ld\u0131\u011f\u0131nda, sim\u00fclasyonla \u00fcretilen her tamsay\u0131 de\u011ferinin, <code>expected</code> olarak tan\u0131mlanan NumPy dizisiyle birebir e\u015fle\u015fti\u011fini do\u011frular.</p>"},{"location":"tr/examples/izhikevich/","title":"Izhikevich N\u00f6ron Modeli","text":""},{"location":"tr/examples/izhikevich/#genel-baks","title":"Genel Bak\u0131\u015f","text":"<p>Bu \u00f6rnek, Izhikevich n\u00f6ron modelinin nas\u0131l sim\u00fcle edilece\u011fini ve farkl\u0131 giri\u015f ak\u0131mlar\u0131 alt\u0131nda membran potansiyelinin nas\u0131l g\u00f6rselle\u015ftirilece\u011fini ad\u0131m ad\u0131m g\u00f6stermektedir. \u00d6rnek, <code>dynlib</code>'in bir sim\u00fclasyonu devam ettirme, model \u00f6n ayarlar\u0131n\u0131 de\u011fi\u015ftirme ve grafikleri a\u00e7\u0131klay\u0131c\u0131 notlarla zenginle\u015ftirme yeteneklerini \u00f6ne \u00e7\u0131kar\u0131r. Bu sayede, s\u00fcr\u00fcc\u00fc ak\u0131m\u0131ndaki de\u011fi\u015fikliklerin n\u00f6ronun ate\u015fleme d\u00fczenini nas\u0131l etkiledi\u011fi net bir \u015fekilde g\u00f6r\u00fclebilir.</p>"},{"location":"tr/examples/izhikevich/#temel-kavramlar","title":"Temel Kavramlar","text":"<ul> <li>Kademeli Ak\u0131m Sim\u00fclasyonu: Sim\u00fclasyonun durumunu koruyarak ve enjekte edilen ak\u0131m\u0131 g\u00fcncelleyerek tek bir sim\u00fclasyonu \u00e7al\u0131\u015ft\u0131rma. Bu y\u00f6ntem, hem ge\u00e7ici dinamikleri hem de yeni \u00e7ekerleri (attractors) yakalamay\u0131 sa\u011flar.</li> <li>\u00d6n Ayarlar\u0131 Uygulama: <code>sim.apply_preset(\"bursting\")</code> komutu ile n\u00f6ronun uyar\u0131labilirli\u011fini belirleyen <code>c</code>, <code>d</code> gibi i\u00e7sel parametreleri de\u011fi\u015ftirme.</li> <li>Anl\u0131k G\u00f6r\u00fcnt\u00fc (Snapshot) Ara\u00e7lar\u0131: Farkl\u0131 rejimlerden ge\u00e7tikten sonra kaydedilen yap\u0131land\u0131rmay\u0131 incelemek i\u00e7in <code>sim.list_snapshots()</code> komutu ve <code>source=\"snapshot\"</code> parametresi ile <code>sim.param_vector</code> / <code>param_dict</code> kullanma.</li> <li>A\u00e7\u0131klamal\u0131 Zaman Serisi Grafikleri: <code>series.plot</code>, enjekte edilen ak\u0131m\u0131n de\u011fi\u015fti\u011fi rejimleri etiketlemek i\u00e7in <code>vbands</code> (dikey \u015feritler) ve <code>vlines</code> (dikey \u00e7izgiler) gibi g\u00f6rsel elemanlar\u0131 destekler.</li> </ul>"},{"location":"tr/examples/izhikevich/#izhikevich-modeli","title":"Izhikevich Modeli","text":"<p><code>dynlib</code> i\u00e7erisindeki yerle\u015fik model, a\u015fa\u011f\u0131daki 2-boyutlu sistemi i\u00e7erir:</p> \\[ \\begin{align} \\frac{dv}{dt} &amp;= 0.04v^2 + 5.0v + 140.0 - u + I \\\\ \\frac{du}{dt} &amp;= a(bv - u) \\end{align} \\] <p>Membran potansiyeli <code>v</code> bir e\u015fik de\u011ferine (<code>v_th</code>, varsay\u0131lan 30.0) ula\u015ft\u0131\u011f\u0131nda, bir s\u0131f\u0131rlama olay\u0131 tetiklenir ve de\u011fi\u015fkenler \u015fu \u015fekilde g\u00fcncellenir: - <code>v</code>'nin yeni de\u011feri <code>c</code> olur. - <code>u</code>'nun yeni de\u011feri <code>u + d</code> olur.</p> <p>Varsay\u0131lan parametreler (<code>a=0.02</code>, <code>b=0.2</code>, <code>c=-65</code>, <code>d=8</code>, <code>I=10</code>) d\u00fczenli ate\u015fleme (regular spiking) davran\u0131\u015f\u0131 \u00fcretir. <code>bursting</code> (patlama) \u00f6n ayar\u0131 ise <code>c</code> ve <code>d</code> de\u011ferlerini de\u011fi\u015ftirerek, artan ak\u0131mla birlikte ortaya \u00e7\u0131kan h\u0131zl\u0131 ate\u015fleme patlamalar\u0131 olu\u015fturur.</p>"},{"location":"tr/examples/izhikevich/#ornek-kod","title":"\u00d6rnek Kod","text":"<p>A\u015fa\u011f\u0131daki kod, farkl\u0131 ak\u0131m seviyelerinde sim\u00fclasyonu \u00e7al\u0131\u015ft\u0131r\u0131r ve \"bursting\" \u00f6n ayar\u0131n\u0131 uygulayarak sonu\u00e7lar\u0131 g\u00f6rselle\u015ftirir.</p> <pre><code>from dynlib import setup\nfrom dynlib.plot import series, export, fig\n\n\nsim = setup(\"builtin://ode/izhikevich\", \n            stepper=\"rk4\", \n            jit=True, \n            dtype=\"float32\")\n\nI0, T0 = 0.0, 300.0\nI1, T1 = 5.0, 600.0\nI2, T2 = 10.0, 900.0\nI3, T3 = 15.0, 1200.0\nI4, T4 = 10.0, 1500.0\n\nsim.config(dt=0.01)\nsim.assign(I=I0)\nsim.run(T=T0, transient=50.0)\nsim.assign(I=I1)\nsim.run(T=T1, resume=True)\nsim.assign(I=I2)\nsim.run(T=T2, resume=True)\nsim.assign(I=I3)\nsim.run(T=T3, resume=True)\nsim.apply_preset(\"bursting\")\nsim.assign(I=I4)\nsim.run(T=T4, resume=True)\n\nres = sim.results()\n\nax = fig.single(size=(8, 4))\nseries.plot(x=res.t, y=res[\"v\"],\n            ax=ax,\n            ylim=(-80, 50),\n            title=\"Membrane Potential (v)\",\n            vbands=[(0,T0,\"b\"), (T0,T1,\"m\"), (T1,T2,\"g\"), (T2,T3,\"r\"), (T3,T4,\"c\")],\n            vlines=[(0, \"I=0\"), (T0, \"I=5\"), (T1, \"I=10\"), (T2, \"I=15\"), (T3, \"I=10\")],\n            vlines_color=\"red\")    \nexport.show()\n\nprint(\"SNAPSHOTS: \", sim.list_snapshots())\nprint(\"Snapshot Parameter Vector: \", sim.param_vector(source=\"snapshot\"))\nprint(\"Snapshot Parameter Dictionary: \", sim.param_dict(source=\"snapshot\"))\n</code></pre> <p>Kodda <code>series.plot</code> fonksiyonu, her bir ak\u0131m ad\u0131m\u0131n\u0131 i\u015faretlemek i\u00e7in dikey \u015feritler ve \u00e7izgiler ekler. <code>run</code> fonksiyonundaki <code>resume=True</code> parametresi, ak\u0131m de\u011feri de\u011fi\u015ftik\u00e7e sim\u00fclasyonun durumunu koruyarak kesintisiz devam etmesini sa\u011flar. Grafik \u00e7izdirildikten sonra, anl\u0131k g\u00f6r\u00fcnt\u00fc (snapshot) yard\u0131mc\u0131 fonksiyonlar\u0131, daha sonraki analizler i\u00e7in kaydedilen parametre setlerini yazd\u0131r\u0131r.</p> <p>```</p>"},{"location":"tr/examples/plotting/","title":"\u00c7izim \u00d6rnekleri","text":""},{"location":"tr/examples/plotting/#genel-baks","title":"Genel Bak\u0131\u015f","text":"<p>Bu sayfada, <code>dynlib</code>'in \u00e7izim ara\u00e7lar\u0131n\u0131n nas\u0131l kullan\u0131laca\u011f\u0131n\u0131 g\u00f6steren demolar yer almaktad\u0131r. Bu ara\u00e7lar, <code>dynlib.plot</code> API'si alt\u0131nda toplanm\u0131\u015f olup; zaman serileri, faz portreleri, d\u00f6n\u00fc\u015f haritalar\u0131 (return maps), vekt\u00f6r alanlar\u0131, histogramlar ve animasyonlar olu\u015fturmak i\u00e7in tutarl\u0131 ve basit bir aray\u00fcz sunar.</p>"},{"location":"tr/examples/plotting/#zaman-serileri-ve-faz-portreleri","title":"Zaman Serileri ve Faz Portreleri","text":""},{"location":"tr/examples/plotting/#lojistik-harita-tanlamalar","title":"Lojistik Harita Tan\u0131lamalar\u0131","text":"<p>A\u015fa\u011f\u0131daki \u00f6rnek, yerle\u015fik lojistik harita modelini olu\u015fturur, bir ba\u015flang\u0131\u00e7 ge\u00e7i\u015f s\u00fcrecini (transient) atlad\u0131ktan sonra sim\u00fclasyonu \u00e7al\u0131\u015ft\u0131r\u0131r. Sonras\u0131nda <code>series.plot</code>, <code>return_map</code> ve <code>cobweb</code> yard\u0131mc\u0131 fonksiyonlar\u0131n\u0131 kullanarak zaman serisini, d\u00f6n\u00fc\u015f haritas\u0131n\u0131 ve \u00f6r\u00fcmcek a\u011f\u0131 diyagram\u0131n\u0131 (cobweb diagram) \u00e7izer. Ayr\u0131ca, analitik tahminleri say\u0131sal olarak bulunan \u00e7ekerlerle (attractors) kar\u015f\u0131la\u015ft\u0131rmak i\u00e7in <code>sim.model.fixed_points(seeds=...)</code> ile bulunan sabit noktalar\u0131 da ekrana yazar.</p> <pre><code>from dynlib import setup\nfrom dynlib.plot import series, export, theme, fig, return_map, cobweb\n\nmodel = '''\ninline:\n[model]\ntype=\"map\"\nname=\"Logistic Map\"\n\n[states]\nx=0.1\n\n[params]\nr=4.0\n\n[equations.rhs]\nx = \"r * x * (1 - x)\"\n'''\n\n# stepper=\"map\" is default and can be omitted for map models\nsim = setup(model, stepper=\"map\", jit=True, disk_cache=True)\nsim.run(N=192, transient=40)\nsim.run(resume=True, N=400)\nres=sim.results()\n\nseeds = [[0.1], [0.7], [0.9]]\nfps = sim.model.fixed_points(seeds=seeds)\nprint(fps.points)\n\ntheme.use(\"notebook\")\ntheme.update(grid=False)\n\n# Create 1x2 grid for time series and return map\nax = fig.grid(rows=1, cols=2, size=(12, 5))\n\n# Time series plot\nseries.plot(\n    x=res.t,\n    y=res[\"x\"],\n    style=\"line\",\n    ax=ax[0, 0],\n    xlabel=\"n\",\n    ylabel=\"$x_n$\",\n    ylabel_rot=0,\n    title=\"Logistic Map (r=4)\",\n    ypad=10,\n    xlabel_fs=13,\n    ylabel_fs=13,\n    title_fs=14,\n    xtick_fs=9,\n    ytick_fs=11,\n    lw=1.0\n)\n\n# Return map: x[n] vs x[n+1]\nreturn_map(\n    x=res[\"x\"],\n    step=1,\n    style=\"scatter\",\n    ax=ax[0, 1],\n    ms=2,\n    color=\"C1\",\n    title=\"Return Map: $x[n]$ vs $x[n+1]$\",\n    xlabel_fs=13,\n    ylabel_fs=13,\n    title_fs=14,\n    xtick_fs=9,\n    ytick_fs=11,\n)\n\ncobweb(\n    f=sim.model,\n    x0=0.1,\n    xlim=(0, 1),\n    steps=50,\n    color=\"green\",\n    stair_color=\"orange\",\n    identity_color=\"red\",\n)\n\nexport.show()\n</code></pre>"},{"location":"tr/examples/plotting/#van-der-pol-osilatoru","title":"Van der Pol Osilat\u00f6r\u00fc","text":"<p>Bu \u00f6rnek, <code>builtin://ode/vanderpol</code> gibi kat\u0131 (stiff) bir diferansiyel denklem modelinin <code>tr-bdf2a</code> gibi \u00f6zel bir \u00e7\u00f6z\u00fcc\u00fc ile nas\u0131l \u00e7al\u0131\u015ft\u0131r\u0131laca\u011f\u0131n\u0131 g\u00f6sterir. Sim\u00fclasyon s\u00fcresini <code>dynlib.utils.Timer</code> ile \u00f6l\u00e7er ve hem zaman serisini hem de faz portresini \u00e7izer. Bu problem \\(\\mu=1000\\) parametre de\u011feriyle di\u011fer numerik \u00e7\u00f6z\u00fcc\u00fcler i\u00e7in sim\u00fclasyonu son derece zordur.</p> <pre><code>from dynlib import setup\nfrom dynlib.plot import series, export, fig, phase\nfrom dynlib.utils import Timer\n\nstepper = \"tr-bdf2a\"\nmu = 1000.0\n\nsim = setup(\"builtin://ode/vanderpol\", \n            stepper=stepper, \n            jit=True,\n            disk_cache=False)\n\nsim.assign(mu=mu)\nsim.config(dt=5e-4, max_steps=6_500_000)\nwith Timer(\"run simulation\"):\n    sim.run(T=3000.0)\nres = sim.results()\n\nseries.plot(x=res.t, y=res[\"x\"],\n            title=f\"Van der Pol Oscillator (\u03bc={mu})\",\n            xlabel=\"Time\",\n            ylabel=\"x\",\n            ylim=(-3, 3),\n            )\n\nphase.xy(x=res[\"x\"], y=res[\"y\"])\nexport.show()\n</code></pre>"},{"location":"tr/examples/plotting/#cizim-yardmclar-galerisi","title":"\u00c7izim Yard\u0131mc\u0131lar\u0131 Galerisi","text":""},{"location":"tr/examples/plotting/#temel-cizim-fonksiyonlar","title":"Temel \u00c7izim Fonksiyonlar\u0131","text":"<p>Bu \u00f6rnek, <code>series.stem</code>, <code>series.step</code>, <code>utils.hist</code>, <code>phase.xy</code> ve <code>series.plot</code>'un <code>map</code> ve <code>mixed</code> stilleri gibi daha az kullan\u0131lan \u00e7izim fonksiyonlar\u0131n\u0131 alt\u0131 farkl\u0131 alt grafikte g\u00f6sterir. Her bir fonksiyonun farkl\u0131 veri t\u00fcrlerini (s\u00fcrekli, ayr\u0131k, da\u011f\u0131l\u0131m) nas\u0131l i\u015fledi\u011fini h\u0131zl\u0131ca g\u00f6rmek i\u00e7in bir referans niteli\u011findedir.</p> <pre><code>from __future__ import annotations\n\"\"\"\nDemonstration of various plotting functions from dynlib.plot module.\nOnly the ones not used in other examples are shown here.\n\"\"\"\n\nimport numpy as np\nfrom dynlib.plot import fig, series, phase, utils, export, theme\n\n\ndef main() -&gt; None:\n    theme.use(\"notebook\")\n\n    # ----- Time data -----\n    t = np.linspace(0, 10, 101)\n    y = np.sin(2 * np.pi * 0.5 * t)\n    y2 = np.cos(2 * np.pi * 0.5 * t)\n    # step-like signal\n    y_step = np.floor(t) % 2\n    # noisy distribution for histogram\n    y_hist = y + 0.3 * np.random.randn(len(t))\n\n    # ----- Discrete (map) data -----\n    r = 3.7\n    x0 = 0.2\n    n_iter = 30\n    xs = [x0]\n    x = x0\n    for k in range(n_iter):\n        x = r * x * (1 - x)\n        xs.append(x)\n    ks = np.arange(len(xs))\n    xs = np.array(xs)\n\n    # Layout: 3 rows x 2 cols\n    ax = fig.grid(rows=3, cols=2, size=(10, 12), sharex=False)\n\n    # Row 0, Col 0: series.stem\n    series.stem(\n        x=t,\n        y=y,\n        ax=ax[0, 0],\n        label=\"sin(t) stems\",\n        color=\"C0\",\n        xlabel=\"$t$\",\n        ylabel=\"$y$\",\n        title=\"series.stem: stem plot\",\n    )\n\n    # Row 0, Col 1: series.step\n    series.step(\n        x=t,\n        y=y_step,\n        ax=ax[0, 1],\n        label=\"step(t)\",\n        color=\"C1\",\n        xlabel=\"$t$\",\n        ylabel=\"$y$\",\n        title=\"series.step: step plot\",\n    )\n\n    # Row 1, Col 0: utils.hist\n    utils.hist(\n        y=y_hist,\n        bins=30,\n        density=False,\n        ax=ax[1, 0],\n        color=\"C2\",\n        title=\"utils.hist: histogram\",\n        xlabel=\"$y$\",\n        ylabel=\"count\",\n    )\n\n    # Row 1, Col 1: phase.xy with scatter style (for discrete maps)\n    phase.xy(\n        x=y,\n        y=y2,\n        style=\"scatter\",\n        ax=ax[1, 1],\n        ms=6,\n        color=\"C3\",\n        title=\"phase.xy: sin vs cos (scatter)\",\n        xlabel=r\"$\\sin$\",\n        ylabel=r\"$\\cos$\",\n    )\n\n    # Row 2, Col 0: series with discrete/map style (stem-like effect)\n    series.plot(\n        x=ks,\n        y=xs,\n        style=\"map\",\n        ax=ax[2, 0],\n        color=\"C4\",\n        title=\"series.plot: logistic iterations (map style)\",\n        xlabel=\"n\",\n        ylabel=\"$x_n$\",\n    )\n\n    # Row 2, Col 1: series with mixed style (line + markers)\n    series.plot(\n        x=ks,\n        y=xs,\n        style=\"mixed\",\n        ax=ax[2, 1],\n        color=\"C5\",\n        title=\"series.plot: logistic iterations (mixed style)\",\n        xlabel=\"n\",\n        ylabel=\"$x_n$\",\n    )\n\n    # Tighten layout and show\n    export.show()\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"tr/examples/plotting/#tema-ayarlar","title":"Tema Ayarlar\u0131","text":"<p>A\u015fa\u011f\u0131daki betik, <code>notebook</code>, <code>paper</code>, <code>talk</code>, <code>dark</code> ve <code>mono</code> gibi mevcut t\u00fcm tema \u00f6n ayarlar\u0131n\u0131 dener. Her bir tema i\u00e7in \u00f6rnek bir fig\u00fcr olu\u015fturur ve PNG dosyas\u0131 olarak kaydeder. Bu sayede her \u00f6n ayar\u0131n renkleri, \u0131zgara \u00e7izgilerini ve tipografiyi nas\u0131l etkiledi\u011fini inceleyebilirsiniz.</p> <pre><code>#!/usr/bin/env python3\n\"\"\"\nDemonstration of all theme presets available in dynlib.plot.theme.\n\nThis script creates a sample figure for each preset and saves it as an image.\n\"\"\"\n\nimport numpy as np\nfrom dynlib.plot import fig, series, theme, export, utils\n\n\ndef create_sample_figure():\n    \"\"\"Create a sample figure with various plot elements.\"\"\"\n    # Generate sample data\n    t = np.linspace(0, 10, 100)\n    y1 = np.sin(t)\n    y2 = np.cos(t)\n    y3 = np.sin(t) * np.exp(-t / 10)\n\n    # Create figure with subplots\n    ax = fig.grid(rows=2, cols=2, size=(8, 6))\n\n    # Line plot\n    series.plot(x=t, y=y1, ax=ax[0, 0], label=\"sin(t)\", xlabel=\"Time\", ylabel=\"Amplitude\", title=\"Line Plot\")\n\n    # Scatter plot\n    series.plot(x=t[::5], y=y2[::5], ax=ax[0, 1], style=\"scatter\", label=\"cos(t) samples\", xlabel=\"Time\", ylabel=\"Amplitude\", title=\"Scatter Plot\")\n\n    # Multiple lines\n    series.plot(x=t, y=y1, ax=ax[1, 0], label=\"sin(t)\", color=\"C0\")\n    series.plot(x=t, y=y2, ax=ax[1, 0], label=\"cos(t)\", color=\"C1\")\n    series.plot(x=t, y=y3, ax=ax[1, 0], label=\"damped sin(t)\", color=\"C2\")\n    ax[1, 0].set_xlabel(\"Time\")\n    ax[1, 0].set_ylabel(\"Amplitude\")\n    ax[1, 0].set_title(\"Multiple Lines\")\n    ax[1, 0].legend()\n\n    # Histogram\n    data = np.random.normal(0, 1, 1000)\n    utils.hist(y=data, ax=ax[1, 1], bins=30, xlabel=\"Value\", ylabel=\"Frequency\", title=\"Histogram\")\n\n    return ax[0, 0].figure\n\n\ndef main():\n    \"\"\"Demonstrate each theme preset.\"\"\"\n    presets = [\"notebook\", \"paper\", \"talk\", \"dark\", \"mono\"]\n\n    for preset in presets:\n        print(f\"Creating figure with '{preset}' preset...\")\n\n        # Apply theme\n        theme.use(preset)\n\n        # Create sample figure\n        fig = create_sample_figure()\n\n        # Save figure\n        export.savefig(fig, f\"theme_{preset}\", fmts=(\"png\",), dpi=150)\n\n        print(f\"Saved theme_{preset}.png\")\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"tr/examples/plotting/#facet-bolumlenmis-grafikler","title":"Facet (B\u00f6l\u00fcmlenmi\u015f) Grafikler","text":"<p><code>plot.facet.wrap</code> fonksiyonu, farkl\u0131 kategorilerdeki veriler i\u00e7in bir alt grafik \u0131zgaras\u0131 olu\u015fturmay\u0131 kolayla\u015ft\u0131r\u0131r. Her bir eksen, kendi veri dilimini ve ba\u015fl\u0131k/etiketleri otomatik olarak al\u0131r. Bu, veri da\u011f\u0131l\u0131mlar\u0131n\u0131 manuel olarak <code>plt.subplots</code> olu\u015fturmadan ke\u015ffetmek i\u00e7in kullan\u0131\u015fl\u0131d\u0131r.</p> <pre><code>import dynlib.plot as plot\nimport numpy as np\n\n# Sample data: a dictionary where keys are categories and values are data arrays\ndata = {\n    'Category A': np.random.randn(100),\n    'Category B': np.random.randn(100) + 1,\n    'Category C': np.random.randn(100) - 1,\n}\n\n# Create facets: 2 columns, with a title\nfor ax, key in plot.facet.wrap(data.keys(), cols=2, title='Data by Category'):\n    values = data[key]\n    ax.hist(values, bins=20, alpha=0.7)\n    ax.set_title(f'Histogram for {key}')\n    ax.set_xlabel('Value')\n    ax.set_ylabel('Frequency')\n\n# Display the plot\nplot.export.show()\n</code></pre>"},{"location":"tr/examples/plotting/#vektor-alanlar","title":"Vekt\u00f6r Alanlar\u0131","text":""},{"location":"tr/examples/plotting/#temel-vektor-alan-cizimi","title":"Temel Vekt\u00f6r Alan\u0131 \u00c7izimi","text":"<p>Bu \u00f6rnek, <code>plot.vectorfield</code> arac\u0131n\u0131 kullanarak bir spiral modelin vekt\u00f6r alan\u0131n\u0131 \u00e7izer. \u00d6rnekte, <code>nullcline</code>'lar\u0131n (s\u0131f\u0131r b\u00fcy\u00fcme \u00e7izgileri) g\u00f6sterimi, ak\u0131\u015f h\u0131z\u0131na g\u00f6re renklendirme (<code>speed_color</code>) ve geri d\u00f6nen <code>handle</code> nesnesi arac\u0131l\u0131\u011f\u0131yla parametrelerin (<code>a</code>, <code>b</code>) g\u00fcncellenerek grafi\u011fin yeniden \u00e7izilmesi g\u00f6sterilmektedir.</p> <pre><code>from __future__ import annotations\n\n\"\"\"\nDemonstration of the dynlib.plot.vectorfield helper.\n\"\"\"\n\nimport numpy as np\n\nfrom dynlib import build, plot\n\n\ndef _make_model():\n    # Simple spiral system with tunable linear terms\n    model_uri = \"\"\"\ninline:\n[model]\ntype = \"ode\"\nname = \"spiral\"\n\n[sim]\nt0 = 0.0\ndt = 0.1\n\n[states]\nx = 0.0\ny = 0.0\n\n[params]\na = 0.8\nb = 0.2\n\n[equations.rhs]\nx = \"a * x - y\"\ny = \"x + b * y\"\n\"\"\"\n    return build(model_uri, jit=False, disk_cache=False)\n\n\ndef main() -&gt; None:\n    plot.theme.use(\"notebook\")\n    model = _make_model()\n\n    ax = plot.fig.single(title=\"Vector field demo\")\n\n    handle = plot.vectorfield(\n        model,\n        ax=ax,\n        xlim=(-2, 2),\n        ylim=(-2, 2),\n        grid=(25, 25),\n        normalize=True,\n        speed_color=True,\n        speed_cmap=\"plasma\",\n        nullclines=True,\n        nullcline_style={\"colors\": [\"#333333\"], \"linewidths\": 1.2, \"alpha\": 0.6},\n    )\n\n    # Update parameters and redraw to illustrate handle.update()\n    handle.update(params={\"a\": 1.2, \"b\": -0.1})\n\n    plot.export.show()\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"tr/examples/plotting/#yuksek-boyutlu-sistemlerin-vektor-alan-kesitleri","title":"Y\u00fcksek Boyutlu Sistemlerin Vekt\u00f6r Alan\u0131 Kesitleri","text":"<p>Bu \u00f6rnekte, 3-boyutlu Lorenz sisteminin vekt\u00f6r alan\u0131, se\u00e7ilen 2-boyutlu d\u00fczlemlere (<code>x/y</code> ve <code>y/z</code>) yans\u0131t\u0131l\u0131r. <code>fixed</code> parametresi ile sabitlenen durum de\u011fi\u015fkenlerinin (<code>z</code> ve <code>x</code>) de\u011ferleri ayarlanabilir. Ayr\u0131ca, <code>interactive=True</code> se\u00e7ene\u011fi aktifle\u015ftirildi\u011fi i\u00e7in panellerden herhangi birine t\u0131klayarak o kesit \u00fczerinden ge\u00e7en k\u0131sa bir y\u00f6r\u00fcngeyi an\u0131nda \u00e7izebilirsiniz.</p> <pre><code>from __future__ import annotations\n\n\"\"\"\nDemonstration of projecting a higher-dimensional vector field onto chosen 2D planes.\n\nWe use the 3D Lorenz system and visualize two slices:\n- x/y plane with z fixed (and then updated to a new z to show handle.update)\n- y/z plane with x fixed\n\nClick on either panel to launch a short trajectory through that slice.\n\"\"\"\n\nfrom dynlib import build, plot\n\n\ndef _lorenz_model():\n    model_uri = \"\"\"\ninline:\n[model]\ntype = \"ode\"\nname = \"lorenz-3d\"\nstepper = \"rk4\"\n\n[sim]\nt0 = 0.0\ndt = 0.01\nt_end = 8.0\n\n[states]\nx = 1.0\ny = 1.0\nz = 1.0\n\n[params]\nsigma = 10.0\nrho = 28.0\nbeta = 2.6666666666666665\n\n[equations.rhs]\nx = \"sigma * (y - x)\"\ny = \"x * (rho - z) - y\"\nz = \"x * y - beta * z\"\n\"\"\"\n    return build(model_uri, jit=False, disk_cache=False)\n\n\ndef main() -&gt; None:\n    plot.theme.use(\"notebook\")\n    model = _lorenz_model()\n\n    ax = plot.fig.grid(rows=1, cols=2, size=(12, 5), sharex=False, sharey=False)\n\n    handle_xy = plot.vectorfield(\n        model,\n        ax=ax[0, 0],\n        vars=(\"x\", \"y\"),\n        fixed={\"z\": 5.0},\n        xlim=(-20, 20),\n        ylim=(-30, 30),\n        grid=(25, 25),\n        normalize=False,\n        nullclines=False,\n        T=6.0,\n        dt=0.01,\n        trajectory_style={\"color\": \"C0\"},\n    )\n    ax[0, 0].set_title(\"x-y slice with z fixed (click to trace)\", fontsize=11)\n\n    handle_yz = plot.vectorfield(\n        model,\n        ax=ax[0, 1],\n        vars=(\"y\", \"z\"),\n        fixed={\"x\": 0.0},\n        xlim=(-30, 30),\n        ylim=(0, 50),\n        grid=(25, 25),\n        normalize=False,\n        nullclines=False,\n        T=6.0,\n        dt=0.01,\n        trajectory_style={\"color\": \"C1\"},\n    )\n    ax[0, 1].set_title(\"y-z slice with x fixed (click to trace)\", fontsize=11)\n\n    # Show that fixed values can be updated without rebuilding the figure.\n    handle_xy.update(fixed={\"z\": 15.0}, redraw=True)\n    handle_xy.ax.set_title(\"x-y slice with z updated to 15.0\", fontsize=11)\n\n    plot.export.show()\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"tr/examples/plotting/#parametre-degerlerine-gore-vektor-alan-taramas","title":"Parametre De\u011ferlerine G\u00f6re Vekt\u00f6r Alan\u0131 Taramas\u0131","text":"<p><code>plot.vectorfield_sweep</code> fonksiyonu, bir model parametresinin (<code>a</code>) farkl\u0131 de\u011ferleri i\u00e7in vekt\u00f6r alanlar\u0131n\u0131 tek bir \u0131zgara \u00fczerinde otomatik olarak \u00e7izer. Bu, farkl\u0131 parametre rejimlerinin sistemin dinami\u011fini nas\u0131l de\u011fi\u015ftirdi\u011fini bir bak\u0131\u015fta kar\u015f\u0131la\u015ft\u0131rman\u0131z\u0131 sa\u011flar.</p> <pre><code>from __future__ import annotations\n\n\"\"\"Demonstration of plot.vectorfield_sweep for a simple 2D system.\"\"\"\n\nfrom dynlib import build, plot\n\n\ndef _make_model():\n    model_uri = \"\"\"\ninline:\n[model]\ntype = \"ode\"\nname = \"spiral\"\n\n[sim]\nt0 = 0.0\ndt = 0.05\n\n[states]\nx = 0.0\ny = 0.0\n\n[params]\na = 0.5\nb = -0.2\n\n[equations.rhs]\nx = \"a * x - y\"\ny = \"x + b * y\"\n\"\"\"\n    return build(model_uri, jit=False, disk_cache=False)\n\n\ndef main() -&gt; None:\n    plot.theme.use(\"notebook\")\n    model = _make_model()\n\n    plot.vectorfield_sweep(\n        model,\n        param=\"a\",\n        values=[-0.6, 0.0, 0.6, 1.2],\n        xlim=(-2.5, 2.5),\n        ylim=(-2.5, 2.5),\n        grid=(22, 22),\n        normalize=True,\n        speed_color=True,\n        speed_cmap=\"plasma\",\n        cols=2,\n        facet_titles=\"a={value:.2f}\",\n        title=\"Vector field sweep over parameter 'a'\",\n        nullclines=True,\n        nullcline_style={\"colors\": [\"#333333\"], \"linewidths\": 1.0, \"alpha\": 0.6},\n        interactive=False,\n        size=(8,6)\n    )\n\n    plot.export.show()\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"tr/examples/plotting/#animasyonlar","title":"Animasyonlar","text":""},{"location":"tr/examples/plotting/#vektor-alan-animasyonlar","title":"Vekt\u00f6r Alan\u0131 Animasyonlar\u0131","text":"<p>A\u015fa\u011f\u0131daki \u00f6rnek, <code>plot.vectorfield_animate</code> kullanarak bir parametrenin (<code>a</code>) belirli de\u011ferler aras\u0131nda nas\u0131l de\u011fi\u015ftirilece\u011fini ve bu de\u011fi\u015fimin vekt\u00f6r alan\u0131n\u0131 nas\u0131l etkiledi\u011fini g\u00f6steren bir animasyon olu\u015fturur. Olu\u015fturulan <code>anim</code> nesnesi, bir de\u011fi\u015fkene atanmal\u0131d\u0131r; aksi takdirde Python'un \u00e7\u00f6p toplay\u0131c\u0131s\u0131 (garbage collector) taraf\u0131ndan silinebilir ve animasyon g\u00f6r\u00fcnt\u00fclenmez.</p> <pre><code>from __future__ import annotations\n\n\"\"\"Demonstration of plot.vectorfield_animate for a simple spiral system.\"\"\"\n\nfrom dynlib import build, plot\n\n\ndef _make_model():\n    model_uri = \"\"\"\ninline:\n[model]\ntype = \"ode\"\nname = \"spiral\"\n\n[sim]\nt0 = 0.0\ndt = 0.05\n\n[states]\nx = 0.0\ny = 0.0\n\n[params]\na = -0.4\nb = 0.25\n\n[equations.rhs]\nx = \"a * x - y\"\ny = \"x + b * y\"\n\"\"\"\n    return build(model_uri, jit=False, disk_cache=False)\n\n\ndef main() -&gt; None:\n    plot.theme.use(\"notebook\")\n    model = _make_model()\n\n    values = [v for v in (-1.0, -0.4, 0.0, 0.6, 1.0, 1.4)]\n    # You have to define anim (or any other name) even if you don't use it. \n    # Otherwise it gets garbage collected.\n    anim = plot.vectorfield_animate(\n        model,\n        param=\"a\",\n        values=values,\n        xlim=(-2.5, 2.5),\n        ylim=(-2.5, 2.5),\n        grid=(24, 24),\n        normalize=True,\n        speed_color=True,\n        speed_cmap=\"plasma\",\n        title_func=lambda v, idx: f\"Vector field: a={float(v):.2f}\",\n        nullclines=True,\n        nullcline_style={\"colors\": [\"#333333\"], \"linewidths\": 1.0, \"alpha\": 0.6},\n        interactive=False,\n        fps=3,\n        blit=False,\n    )\n\n    # Preview the animation in notebook/backends that support it, or save via anim.animation.save(...)\n    plot.export.show()\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>Bu \u00f6rnekte ise, bir sin/cos tabanl\u0131 vekt\u00f6r alan\u0131n\u0131n frekans parametresi <code>k</code>, 300 kare boyunca taranarak bir animasyon olu\u015fturulur.</p> <pre><code># An interesting animation that I like.\n\nimport numpy as np\nfrom dynlib.plot import export, vectorfield_animate\n\n\nDSL = \"\"\"\ninline:\n[model]\ntype=\"ode\"\n\n[states]\nx=0.0\ny=0.0\n\n[params]\nk=0.0\n\n[equations.rhs]\nx = \"sin(k*y)\"\ny = \"sin(k*x)\"\n\"\"\"\n\n# You have to define anim (or any other name) even if you don't use it. \n# Otherwise it gets garbage collected.\nanim=vectorfield_animate(DSL, \n                    param=\"k\", \n                    values=np.linspace(0.1,10,300), \n                    xlim=(-10, 10), \n                    ylim=(-10, 10), \n                    grid=(24, 24), \n                    interval=130,\n                    normalize=True,\n                    title_func=lambda v, idx: f\"Vector field: k={float(v):.2f}\",\n                    )\n\n# Save using writer of your choice, e.g., \"ffmpeg\", \"pillow\", etc.\n# anim.save(\"vectorfield_animation.gif\", writer=\"pillow\", dpi=150)\n\nexport.show()\n</code></pre>"},{"location":"tr/examples/runtime/","title":"\u00c7al\u0131\u015fma Zaman\u0131 Ara\u00e7lar\u0131 ve Tan\u0131lama","text":""},{"location":"tr/examples/runtime/#genel-baks","title":"Genel Bak\u0131\u015f","text":"<p>Bu b\u00f6l\u00fcmdeki \u00e7al\u0131\u015fma zaman\u0131 ara\u00e7lar\u0131, <code>dynlib</code>'in d\u00fc\u015f\u00fck seviyeli kontrol mekanizmalar\u0131n\u0131 kullan\u0131r. <code>setup()</code> fonksiyonu ile \u00e7e\u015fitli ad\u0131m denetleyicileri (stepper), durma ko\u015fullar\u0131 ve olay g\u00f6zlemcileri y\u00f6netilebilir. Yard\u0131mc\u0131 API'lar ise derleyicinin ne derledi\u011fini veya bir y\u00f6r\u00fcngenin ger\u00e7ek zamanl\u0131 olarak nas\u0131l davrand\u0131\u011f\u0131n\u0131 anlamay\u0131 sa\u011flar. Bu betikler, say\u0131sal do\u011frulu\u011fun nas\u0131l kontrol edilece\u011fini, sim\u00fclasyonlar\u0131n nas\u0131l erken sonland\u0131r\u0131laca\u011f\u0131n\u0131, \u00f6nemli ge\u00e7i\u015flerin nas\u0131l tespit edilece\u011fini ve <code>Sim</code> i\u00e7inde tam olarak neyin \u00e7al\u0131\u015ft\u0131\u011f\u0131n\u0131 denetlemek i\u00e7in DSL denklemlerinin nas\u0131l yazd\u0131r\u0131laca\u011f\u0131n\u0131 g\u00f6sterir.</p>"},{"location":"tr/examples/runtime/#ornek-betikler","title":"\u00d6rnek betikler","text":""},{"location":"tr/examples/runtime/#adm-denetleyici-stepper-dogrulugunu-sralama","title":"Ad\u0131m denetleyici (stepper) do\u011frulu\u011funu s\u0131ralama","text":"<p>Bu betik, kay\u0131tl\u0131 her bir ODE ad\u0131m denetleyicisini, k\u00fc\u00e7\u00fck ve sabit bir <code>dt</code> de\u011feriyle iki analitik \u00e7\u00f6z\u00fcme (\u00fcstel s\u00f6n\u00fcm ve harmonik osilat\u00f6r) kar\u015f\u0131 \u00e7al\u0131\u015ft\u0131r\u0131r. Her \u00e7al\u0131\u015ft\u0131rma i\u00e7in bir RMS (K\u00f6k Ortalama Kare) g\u00f6reli hata hesaplan\u0131r. Bu sayede ad\u0131m denetleyicileri do\u011frulu\u011fa g\u00f6re s\u0131ralayabilir, hatalar\u0131 kaydedebilir ve zaman ad\u0131m\u0131n\u0131z kararl\u0131l\u0131k s\u0131n\u0131r\u0131na yak\u0131nken her bir entegrat\u00f6r\u00fcn nas\u0131l davrand\u0131\u011f\u0131n\u0131 kar\u015f\u0131la\u015ft\u0131rabilirsiniz.</p> <pre><code>import numpy as np\nimport warnings\nfrom dynlib import setup, list_steppers, get_stepper\n\n# Suppress RuntimeWarnings to avoid cluttering output with solver convergence messages\nwarnings.simplefilter(\"ignore\", RuntimeWarning)\n\n# Define models and their exact solutions\nmodels = [\n    {\n        \"name\": \"Exponential Decay\",\n        \"model\": '''\ninline:\n[model]\ntype=\"ode\"\n\n[states]\nx=1.0\n\n[params]\na=1.0\n\n[equations]\nexpr = \"\"\"\ndx = -a * x\n\"\"\"\n''',\n        \"exact\": lambda t: np.exp(-t)\n    },\n    {\n        \"name\": \"Harmonic Oscillator\",\n        \"model\": '''\ninline:\n[model]\ntype=\"ode\"\n\n[states]\nx=1.0\nv=0.0\n\n[params]\nomega=100.0\n\n[equations]\nexpr = \"\"\"\ndx = v\ndv = -omega**2 * x\n\"\"\"\n''',\n        \"exact\": lambda t: (np.cos(100.0 * t), -100.0 * np.sin(100.0 * t))\n    }\n]\n\n# Simulation parameters\nT = 10  # total time\ndt = 1e-4  # time step\nN = int(T / dt)  # number of steps\n\node_steppers = list_steppers(kind=\"ode\")\n\nfor model_info in models:\n    model_name = model_info[\"name\"]\n    model_str = model_info[\"model\"]\n    exact_func = model_info[\"exact\"]\n\n    print(f\"\\n=== {model_name} ===\")\n\n    # Dictionary to store errors\n    errors = {}\n    failed_steppers = {}\n\n    for name in ode_steppers:\n        spec = get_stepper(name)\n        try:        \n            print(f\"Running simulation with stepper: {name}\")\n\n            # Setup simulation\n            sim = setup(model_str, stepper=name, jit=False)\n            sim.config(dt=dt, max_steps=N*10)  # allow more steps if needed\n\n            # Run simulation\n            sim.run(T=T)\n            res = sim.results()\n\n            # Compute relative error on x\n            if model_name == \"Exponential Decay\":\n                x_exact = exact_func(res.t)\n                rel_error = np.abs((res[\"x\"] - x_exact) / x_exact)\n            else:  # Harmonic Oscillator\n                x_exact, v_exact = exact_func(res.t)\n                rel_error = np.abs((res[\"x\"] - x_exact) / x_exact)\n\n            rms_rel_error = np.sqrt(np.mean(rel_error**2))\n\n            errors[name] = rms_rel_error\n            print(f\"RMS relative error for {name}: {rms_rel_error:.2e}\")\n\n        except Exception as e:\n            print(f\"Error with stepper {name}: {e}\")\n            failed_steppers[name] = str(e)\n            continue\n\n    # Sort steppers by accuracy (lowest error first)\n    sorted_steppers = sorted(errors.items(), key=lambda x: x[1])\n\n    print(f\"\\n{model_name} - Stepper accuracy ranking (lowest RMS relative error = most accurate):\")\n    for rank, (name, error) in enumerate(sorted_steppers, 1):\n        print(f\"{rank}. {name}: {error:.2e}\")\n\n    if failed_steppers:\n        print(f\"\\n{model_name} - Failed steppers:\")\n        for name, error_msg in failed_steppers.items():\n            print(f\"- {name}: {error_msg}\")\n</code></pre>"},{"location":"tr/examples/runtime/#erken-cks","title":"Erken \u00e7\u0131k\u0131\u015f","text":"<p>Bu \u00f6rnek, <code>cross_up</code>, <code>in_interval</code> ve <code>decreasing</code> gibi makrolar\u0131n DSL <code>stop</code> ifadesi ile beraber kullan\u0131m\u0131n\u0131 g\u00f6sterir. Betik, \u00e7e\u015fitli lojistik harita varyantlar\u0131 i\u00e7in 100 ad\u0131ma kadar \u00e7al\u0131\u015f\u0131r ancak belirtilen ko\u015ful do\u011fru olur olmaz durur. \u00c7\u0131k\u0131\u015f nedenini, y\u00fcr\u00fct\u00fclen ad\u0131m say\u0131s\u0131n\u0131 ve tetikleyici ko\u015fuldan hemen \u00f6nceki ve sonraki de\u011ferleri yazd\u0131r\u0131r. Bu \u00f6zellik, erken durman\u0131n zaman kazand\u0131r\u0131rken \u00e7al\u0131\u015fmay\u0131 nas\u0131l deterministik tuttu\u011funu vurgular.</p> <pre><code>\"\"\"\nEarly Exit Demo\n===============\n\nThis example demonstrates the early exit feature using the `stop` condition\nwith built-in DSL macros. The simulation will terminate early when a specified\ncondition is met.\n\nAvailable macros for stop conditions:\n- cross_up(state, threshold): detects upward threshold crossing\n- cross_down(state, threshold): detects downward threshold crossing  \n- in_interval(state, lower, upper): checks if state is in range\n- enters_interval(state, lower, upper): detects entering a range\n- leaves_interval(state, lower, upper): detects leaving a range\n- increasing(state): detects if state is increasing\n- decreasing(state): detects if state is decreasing\n- changed(state): detects any change in state\n\nNote: Event macros that use lagged values (like cross_up) require the\nsimulation to have at least one prior step, so they won't trigger at t0.\n\"\"\"\n\nfrom dynlib import setup\n\n\ndef get_exit_reason(res):\n    \"\"\"Return a user-friendly description of why the simulation ended.\"\"\"\n    if res.exited_early:\n        return \"Early exit (stop condition met)\"\n    elif res.ok:\n        return \"Completed normally (max steps reached)\"\n    else:\n        return \"Failed or interrupted\"\n\n\ndef demo_simple_threshold():\n    \"\"\"Example 1: Stop using a simple threshold condition\"\"\"\n    print(\"\\n\" + \"=\" * 70)\n    print(\"Example 1: Simple Threshold (x &gt; 0.8)\")\n    print(\"=\" * 70)\n\n    model = '''\ninline:\n[model]\ntype = \"map\"\nname = \"Logistic Map - Simple Threshold\"\n\n[states]\nx = 0.1\n\n[params]\nr = 3.5\n\n[equations.rhs]\nx = \"r * x * (1 - x)\"\n\n[sim]\nt0 = 0.0\ndt = 1.0\nstepper = \"map\"\nrecord = true\nstop = \"x &gt; 0.8\"\n'''\n\n    sim = setup(model, jit=False)\n    sim.run(N=100)\n    res = sim.results()\n\n    print(f\"Exit reason: {get_exit_reason(res)}\")\n    print(f\"Steps executed: {res.step_count_final}\")\n    print(f\"Final state: x = {res['x'][-1]:.6f}\")\n    print(f\"Interpretation: Stopped when x first exceeded 0.8\")\n\n\ndef demo_interval_check():\n    \"\"\"Example 2: Stop using in_interval macro\"\"\"\n    print(\"\\n\" + \"=\" * 70)\n    print(\"Example 2: Interval Check with in_interval()\")\n    print(\"=\" * 70)\n\n    model = '''\ninline:\n[model]\ntype = \"map\"\nname = \"Logistic Map - Interval Check\"\n\n[states]\nx = 0.1\n\n[params]\nr = 3.5\n\n[equations.rhs]\nx = \"r * x * (1 - x)\"\n\n[sim]\nt0 = 0.0\ndt = 1.0\nstepper = \"map\"\nrecord = true\nstop = \"in_interval(x, 0.82, 0.86)\"\n'''\n\n    sim = setup(model, jit=False)\n    sim.run(N=100)\n    res = sim.results()\n\n    print(f\"Exit reason: {get_exit_reason(res)}\")\n    print(f\"Steps executed: {res.step_count_final}\")\n    print(f\"Final state: x = {res['x'][-1]:.6f}\")\n    print(f\"Interpretation: Stopped when x entered the interval [0.82, 0.86]\")\n\n\ndef demo_cross_up():\n    \"\"\"Example 3: Stop using cross_up macro (requires lag)\"\"\"\n    print(\"\\n\" + \"=\" * 70)\n    print(\"Example 3: Threshold Crossing with cross_up()\")\n    print(\"=\" * 70)\n\n    model = '''\ninline:\n[model]\ntype = \"map\"\nname = \"Logistic Map - Cross Up Detection\"\n\n[states]\nx = 0.1\n\n[params]\nr = 3.5\n\n[equations.rhs]\nx = \"r * x * (1 - x)\"\n\n[sim]\nt0 = 0.0\ndt = 1.0\nstepper = \"map\"\nrecord = true\nstop = \"cross_up(x, 0.8)\"\n'''\n\n    sim = setup(model, jit=False)\n    sim.run(N=100)\n    res = sim.results()\n\n    print(f\"Exit reason: {get_exit_reason(res)}\")\n    print(f\"Steps executed: {res.step_count_final}\")\n    print(f\"Final state: x = {res['x'][-1]:.6f}\")\n    if res.n &gt;= 2:\n        print(f\"Previous state: x = {res['x'][-2]:.6f}\")\n        print(f\"Interpretation: Stopped when x crossed 0.8 from below\")\n        print(f\"  (previous: {res['x'][-2]:.6f} &lt;= 0.8, current: {res['x'][-1]:.6f} &gt; 0.8)\")\n\n\ndef demo_decreasing():\n    \"\"\"Example 4: Stop when state starts decreasing\"\"\"\n    print(\"\\n\" + \"=\" * 70)\n    print(\"Example 4: Detect Decreasing Trend with decreasing()\")\n    print(\"=\" * 70)\n\n    model = '''\ninline:\n[model]\ntype = \"map\"\nname = \"Logistic Map - Detect Decrease\"\n\n[states]\nx = 0.1\n\n[params]\nr = 3.5\n\n[equations.rhs]\nx = \"r * x * (1 - x)\"\n\n[sim]\nt0 = 0.0\ndt = 1.0\nstepper = \"map\"\nrecord = true\nstop = \"decreasing(x)\"\n'''\n\n    sim = setup(model, jit=False)\n    sim.run(N=100)\n    res = sim.results()\n\n    print(f\"Exit reason: {get_exit_reason(res)}\")\n    print(f\"Steps executed: {res.step_count_final}\")\n    print(f\"Final state: x = {res['x'][-1]:.6f}\")\n    if res.n &gt;= 2:\n        print(f\"Previous state: x = {res['x'][-2]:.6f}\")\n        print(f\"Interpretation: Stopped when x started decreasing\")\n        print(f\"  (previous: {res['x'][-2]:.6f}, current: {res['x'][-1]:.6f})\")\n\n\nif __name__ == \"__main__\":\n    print(\"\\n\" + \"=\" * 70)\n    print(\"EARLY EXIT FEATURE DEMONSTRATION\")\n    print(\"Using Built-in DSL Macros for Stop Conditions\")\n    print(\"=\" * 70)\n\n    demo_simple_threshold()\n    demo_interval_check()\n    demo_cross_up()\n    demo_decreasing()\n\n    print(\"\\n\" + \"=\" * 70)\n    print(\"Demo Complete!\")\n    print(\"=\" * 70)\n    print(\"\\nKey Takeaways:\")\n    print(\"  \u2022 Use res.exited_early to check if stop condition was triggered\")\n    print(\"  \u2022 res.ok is True for both normal completion and early exit\")\n    print(\"  \u2022 Simple conditions (x &gt; 0.8) work at any step\")\n    print(\"  \u2022 in_interval() checks current state without lag\")\n    print(\"  \u2022 cross_up(), decreasing(), etc. use lag and require prior steps\")\n    print(\"  \u2022 All conditions are evaluated after each simulation step\")\n    print(\"=\" * 70 + \"\\n\")\n</code></pre>"},{"location":"tr/examples/runtime/#olaylar-ile-gecis-tespiti","title":"Olaylar ile ge\u00e7i\u015f tespiti","text":"<p>Bu \u00f6rnek, Lorenz sisteminin <code>x</code> de\u011fi\u015fkeni s\u0131f\u0131r\u0131 a\u015fa\u011f\u0131dan yukar\u0131ya kesti\u011finde tetiklenen bir olay (event) ekler. \u00c7al\u0131\u015ft\u0131rma, her <code>detect</code> olay\u0131n\u0131n zaman damgas\u0131n\u0131 kaydeder, <code>x(t)</code> zaman serisi grafi\u011fine dikey \u00e7izgiler \u00e7izer ve kaotik rejimlerde ek a\u00e7\u0131klamalar yapmak veya ba\u015fka i\u015flemleri y\u00f6nlendirmek i\u00e7in <code>res.event(\"detect\")</code> verisinin nas\u0131l incelenece\u011fini g\u00f6sterir.</p> <pre><code>from dynlib import setup\nfrom dynlib.plot import series, export, theme\n\n\"\"\"\nThis example demonstrate lagging mechanism to detect trasition \nfrom negative to positive value in one of the state variables \nof a chaotic system.\n\"\"\"\n\ndetect_mod = '''\ninline:\n[mod]\nname = \"detect_transition\"\n\n[mod.add.events.detect]\ncond = \"cross_up(x, 0)\"\nphase = \"post\"\nlog = [\"t\"]\n'''\n\nsim = setup(\"builtin://ode/lorenz\", stepper=\"rk4\", jit=False, mods=[detect_mod])\nsim.config(dt=0.01)\nsim.run(T=50.0, transient=10.0)\n\nres = sim.results()\nev = res.event(\"detect\")\n\ntheme.use(\"paper\")\n\nseries.plot(x=res.t,\n            y=res[\"x\"],\n            vlines=ev.t,\n            xlabel='Time',\n            xlabel_fs=11, # Theme override\n            ylabel='x',\n            title='Lorenz system: x variable with transition detection')\n\nexport.show()\n</code></pre>"},{"location":"tr/examples/runtime/#derlenmis-denklemleri-yazdrma","title":"Derlenmi\u015f denklemleri yazd\u0131rma","text":"<p>Bu betik, Henon haritas\u0131n\u0131 ve Lorenz sistemini <code>jit=False</code> se\u00e7ene\u011fi ile olu\u015fturur ve derleyicinin TOML veya yerle\u015fik (builtin) tan\u0131mlardan t\u00fcretti\u011fi Sa\u011f Taraf (RHS) ve Jakobiyen tablolar\u0131n\u0131 yazd\u0131r\u0131r. Bu, maliyetli sim\u00fclasyonlar\u0131 \u00e7al\u0131\u015ft\u0131rmadan \u00f6nce <code>dynlib</code>'in bekledi\u011finiz modeli do\u011fru bir \u015fekilde yorumlay\u0131p yorumlamad\u0131\u011f\u0131n\u0131 do\u011frulamak i\u00e7in kullan\u0131\u015fl\u0131d\u0131r. E\u011fer sim\u00fclasyonun farkl\u0131 sonu\u00e7lar verdi\u011finden \u015f\u00fcpheleniyorsan\u0131z derlenmi\u015f denklemleri kontrol edebilirsiniz.</p> <pre><code># examples/print_equations_demo.py\n\"\"\"\nDemonstrate printing model equations from the DSL spec.\n\nPrints the equations for the built-in Henon map and Lorenz system.\n\"\"\"\n\nfrom dynlib import setup\n\n\ndef main() -&gt; None:\n    print(\"Henon map equations:\")\n    sim_henon = setup(\"builtin://map/henon\", stepper=\"map\", jit=False)\n    sim_henon.model.print_equations()\n\n    print(\"\\nLorenz system equations:\")\n    sim_lorenz = setup(\"builtin://ode/lorenz\", stepper=\"rk4\", jit=False)\n    sim_lorenz.model.print_equations(tables=(\"equations\", \"equations.jacobian\"))\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"tr/examples/state-management/","title":"Durum, URI ve Kaynak Y\u00f6netimi Demolar\u0131","text":""},{"location":"tr/examples/state-management/#genel-baks","title":"Genel Bak\u0131\u015f","text":"<p>Bu betikler, dynlib'de sim\u00fclasyon durumlar\u0131n\u0131n (state) anl\u0131k g\u00f6r\u00fcnt\u00fcler seviyesinde y\u00f6netilmesi, derlenmi\u015f kaynak kodlar\u0131n\u0131n d\u0131\u015fa aktar\u0131lmas\u0131, \u00f6n ayarlar\u0131n kaydedilip geri y\u00fcklenmesi ve URI/\u015fema sisteminin farkl\u0131 yollarla \u00e7\u00f6z\u00fcmlenmesi gibi s\u0131k kullan\u0131lan i\u015f ak\u0131\u015flar\u0131n\u0131 g\u00f6sterir. Burada anlat\u0131lanlar, bir \u00e7al\u0131\u015fmay\u0131 checkpoint'e almak, workspace/sonu\u00e7lar\u0131 yeniden kullanmak ve farkl\u0131 kaynaklardan gelen modelleri tutarl\u0131 bi\u00e7imde y\u00fcklemek istedi\u011finiz senaryolarda ba\u015fvuraca\u011f\u0131n\u0131z \u00f6rneklerdir.</p>"},{"location":"tr/examples/state-management/#ornek-betikler","title":"\u00d6rnek betikler","text":""},{"location":"tr/examples/state-management/#anlk-goruntuler-snapshots-ve-icedsa-aktarma","title":"Anl\u0131k g\u00f6r\u00fcnt\u00fcler (Snapshots) ve i\u00e7e/d\u0131\u015fa aktarma","text":"<p>Bu demo, basit bir \u00fcstel bozunma sim\u00fclasyonu kurar, birka\u00e7 zaman noktas\u0131na kadar \u00e7al\u0131\u015ft\u0131r\u0131r ve bir etiketli snapshot olu\u015fturur. Ard\u0131ndan ge\u00e7ici dizin kullanarak hem kay\u0131tl\u0131 hem de ge\u00e7erli durumlar\u0131 <code>sim.export_snapshot</code> ile diske aktar\u0131r, meta verilerini inceler, <code>sim.import_snapshot</code> ile eski durumu geri y\u00fckler, sonu\u00e7 verilerinin s\u0131f\u0131rland\u0131\u011f\u0131n\u0131 do\u011frular ve workspace bilgisini ba\u015fka bir sim\u00fclasyona aktar\u0131rken yeni oturuma ayn\u0131 durumu geri y\u00fcklemenin m\u00fcmk\u00fcn oldu\u011funu g\u00f6sterir.</p> <pre><code># examples/snapshot_demo.py\n\"\"\"\nDemonstration of snapshot export/import functionality in dynlib.\n\nThis example shows how to:\n1. Export current simulation state to disk (including workspaces)\n2. Export named snapshots to disk\n3. Import snapshots from disk\n4. Inspect snapshot metadata\n5. Demonstrate workspace persistence across sessions\n\"\"\"\n\nfrom pathlib import Path\nimport tempfile\nimport tomllib\nfrom dynlib import setup\n\n\ndef create_model():\n    \"\"\"Create a simple exponential decay model for demonstration.\"\"\"\n    model_uri = \"\"\"\ninline:\n[model]\ntype = \"ode\"\nname = \"Demo Exponential Decay\"\ndtype = \"float64\"\n\n[states]\nx = 1.0\n\n[params]\ndecay_rate = 0.1\n\n[equations.rhs]\nx = \"-decay_rate * x\"\n\n[sim]\nstepper = \"euler\"\ndt = 0.01\nt0 = 0.0\nt_end = 10.0\nrecord = true\n\"\"\"\n\n    return setup(model_uri, jit=True)\ndef main():\n    print(\"=== Dynlib Snapshot Export/Import Demo ===\\n\")\n\n    # Create simulation\n    sim = create_model()\n    print(\"\u2713 Created simulation with exponential decay model\")\n\n    # Run to some intermediate state\n    sim.run(T=2.0)\n    print(f\"\u2713 Ran simulation to t=2.0, current state: x={sim.state_vector()[0]:.4f}\")\n\n    # Create an in-memory snapshot\n    sim.create_snapshot(\"checkpoint_1\", \"After running to t=2.0\")\n    print(\"\u2713 Created in-memory snapshot 'checkpoint_1'\")\n\n    # Continue running\n    sim.run(T=5.0, resume=True)\n    print(f\"\u2713 Continued to t=5.0, current state: x={sim.state_vector()[0]:.4f}\")\n\n    with tempfile.TemporaryDirectory() as tmp_dir:\n        tmp_path = Path(tmp_dir)\n\n        # Export current state\n        current_snap_path = tmp_path / \"current_state.npz\"\n        sim.export_snapshot(current_snap_path, source=\"current\")\n        print(f\"\u2713 Exported current state to {current_snap_path.name}\")\n\n        # Export the named snapshot\n        named_snap_path = tmp_path / \"checkpoint_1.npz\"\n        sim.export_snapshot(named_snap_path, source=\"snapshot\", name=\"checkpoint_1\")\n        print(f\"\u2713 Exported named snapshot to {named_snap_path.name}\")\n\n        # Inspect the snapshots without loading them\n        print(\"\\n--- Snapshot Inspection ---\")\n        for path in [current_snap_path, named_snap_path]:\n            meta = sim.inspect_snapshot(path)\n            print(f\"{path.name}:\")\n            print(f\"  Schema: {meta['schema']}\")\n            print(f\"  Name: {meta['name']}\")\n            print(f\"  Time: {meta['t_curr']:.3f}\")\n            print(f\"  State: x={meta['state_names'][0]}\")\n            print(f\"  Workspace signature: {meta['pins']['workspace_sig']}\")\n            print(f\"  Created: {meta['created_at']}\")\n            print()\n\n        # Continue simulation further\n        sim.run(T=8.0, resume=True)\n        current_x = sim.state_vector()[0]\n        print(f\"\u2713 Continued to t=8.0, current state: x={current_x:.4f}\")\n\n        # Import the earlier snapshot\n        print(\"\\n--- Importing Snapshot ---\")\n        sim.import_snapshot(named_snap_path)\n        restored_x = sim.state_vector()[0]\n        restored_t = sim.session_state_summary()[\"t\"]\n        print(f\"\u2713 Imported snapshot from t=2.0\")\n        print(f\"  Restored state: t={restored_t:.3f}, x={restored_x:.4f}\")\n\n        # Verify results are cleared\n        try:\n            results = sim.raw_results()\n            print(\"\u2717 ERROR: Results should be cleared after import!\")\n        except RuntimeError as e:\n            print(f\"\u2713 Results correctly cleared: {e}\")\n\n        # Can continue from restored state\n        sim.run(T=3.0, resume=True)\n        final_x = sim.state_vector()[0]\n        print(f\"\u2713 Resumed from restored state to t=3.0, x={final_x:.4f}\")\n\n        # Demonstrate workspace persistence\n        print(\"\\n--- Workspace Persistence ---\")\n        # Create a new simulation to show workspace restoration\n        sim2 = create_model()\n        sim2.run(T=1.0)  # Run to different state\n\n        # Export current state with workspace\n        ws_snap_path = tmp_path / \"workspace_demo.npz\"\n        sim.export_snapshot(ws_snap_path, source=\"current\")\n        print(\"\u2713 Exported simulation state with workspace\")\n\n        # Import into new simulation\n        sim2.import_snapshot(ws_snap_path)\n        print(\"\u2713 Imported state with workspace into new simulation\")\n\n        # Verify state was restored\n        restored_state = sim2.session_state_summary()\n        print(f\"  Restored time: {restored_state['t']:.3f}\")\n        print(f\"  Restored state: x={sim2.state_vector()[0]:.4f}\")\n        print(f\"  Can resume: {restored_state['can_resume']}\")\n\n    print(\"\\n=== Demo Complete ===\")\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"tr/examples/state-management/#derlenmis-kaynaklar-dsa-aktarma","title":"Derlenmi\u015f kaynaklar\u0131 d\u0131\u015fa aktarma","text":"<p><code>tests/data/models/decay.toml</code> dosyas\u0131ndan JIT etkin bir sim\u00fclasyon olu\u015fturulur, \u00f6nbellekleme (disk_cache) devre d\u0131\u015f\u0131 b\u0131rak\u0131l\u0131r ve <code>sim.model.export_sources()</code> yard\u0131m\u0131yla RHS, event ve stepper kaynaklar\u0131 ge\u00e7ici bir dizine yaz\u0131l\u0131r. Demo, dosya boyutlar\u0131n\u0131 ve i\u00e7eriklerini raporlayarak hangi bile\u015fenlerin \u00fcretildi\u011fini do\u011frular ve \u00f6zellikle RHS ile stepper fonksiyonlar\u0131n\u0131n sa\u011flanan kaynak kodlar\u0131n\u0131 g\u00f6sterir.</p> <pre><code># examples/export_sources_demo.py\n\"\"\"\nDemonstration of compiled model source code export functionality.\n\nThis example shows how to:\n1. Build a compiled model using setup()\n2. Export the generated Python source code for inspection\n3. Verify the compilation is correct\n\"\"\"\n\nfrom pathlib import Path\nimport tempfile\nfrom dynlib import setup\n\ndef main():\n    # Use an existing test model\n    model_path = Path(__file__).parent.parent / \"tests\" / \"data\" / \"models\" / \"decay.toml\"\n\n    # Setup simulation with JIT compilation\n    print(f\"Building model from: {model_path.name}\")\n    sim = setup(str(model_path), stepper=\"euler\", jit=True, disk_cache=False)\n\n    # Check if source code is available\n    print(f\"\\nSource code availability:\")\n    print(f\"  RHS source: {'\u2713' if sim.model.rhs_source else '\u2717'}\")\n    print(f\"  Events pre source: {'\u2713' if sim.model.events_pre_source else '\u2717'}\")\n    print(f\"  Events post source: {'\u2713' if sim.model.events_post_source else '\u2717'}\")\n    print(f\"  Stepper source: {'\u2713' if sim.model.stepper_source else '\u2717'}\")\n\n    # Export sources to a temporary directory\n    with tempfile.TemporaryDirectory() as tmpdir:\n        export_dir = Path(tmpdir) / \"compiled_model\"\n        print(f\"\\nExporting sources to: {export_dir}\")\n\n        exported_files = sim.model.export_sources(export_dir)\n\n        print(f\"\\nExported files:\")\n        for component, filepath in exported_files.items():\n            size = filepath.stat().st_size if filepath.exists() else 0\n            print(f\"  {component}: {filepath.name} ({size} bytes)\")\n\n        # Display the RHS source code\n        if \"rhs\" in exported_files:\n            print(f\"\\n{'='*60}\")\n            print(\"RHS Function Source Code:\")\n            print('='*60)\n            rhs_content = exported_files[\"rhs\"].read_text()\n            print(rhs_content)\n            print('='*60)\n\n        # Display the stepper source code if available\n        if \"stepper\" in exported_files:\n            print(f\"\\n{'='*60}\")\n            print(\"Stepper Function Source Code:\")\n            print('='*60)\n            stepper_content = exported_files[\"stepper\"].read_text()\n            print(stepper_content)\n            print('='*60)\n\n    print(\"\\n\u2713 Export demo completed successfully!\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"tr/examples/state-management/#on-ayar-preset-is-akslar","title":"\u00d6n ayar (Preset) i\u015f ak\u0131\u015flar\u0131","text":"<p>Sat\u0131r i\u00e7i Izhikevich n\u00f6ronu tan\u0131mlamas\u0131, ortamda yer alan <code>regular_spiking</code>, <code>fast_spiking</code> ve <code>bursting</code> \u00f6n ayarlar\u0131n\u0131n listelenmesi ile ba\u015flar. \u00d6rnek, her bir \u00f6n ayar\u0131 s\u0131ras\u0131yla uygulay\u0131p spike say\u0131lar\u0131n\u0131 <code>results().event.summary()</code> \u00fczerinden rapor eder, daha sonra ge\u00e7ici bir <code>.toml</code> dosyas\u0131na \u00f6n ayarlar\u0131 kaydeder, ba\u015fka bir <code>Sim</code> nesnesinde bunlar\u0131 geri y\u00fckler ve glob deste\u011fiyle \u00f6n ayarlar\u0131 filtreledikten sonra tekrar \u00e7al\u0131\u015ft\u0131rarak davran\u0131\u015flar\u0131n e\u015fle\u015fti\u011fini kan\u0131tlar.</p> <pre><code>#!/usr/bin/env python3\n\"\"\"\nDemo of the presets feature in dynlib v2.\n\nShows:\n- Inline presets defined in the model DSL\n- Listing and applying presets\n- Loading presets from external files\n- Saving presets to files\n- Capturing runtime presets with add_preset\n- Round-trip preservation\n\"\"\"\n\nimport tempfile\nfrom pathlib import Path\nimport tomllib\n\n\nfrom dynlib.dsl.parser import parse_model_v2\nfrom dynlib.dsl.spec import build_spec\nfrom dynlib.compiler.build import build\nfrom dynlib.runtime.sim import Sim\n\n\n# Model with inline presets\nMODEL_TOML = \"\"\"\n[model]\ntype = \"ode\"\nname = \"Izhikevich Neuron (Simple)\"\n\n[states]\nv = -65.0\nu = -13.0\n\n[params]\na = 0.02\nb = 0.2\nc = -65.0\nd = 8.0\nI = 10.0\n\n[equations.rhs]\nv = \"0.04*v*v + 5*v + 140 - u + I\"\nu = \"a*(b*v - u)\"\n\n[events.spike]\nphase = \"post\"\ncond = \"v &gt;= 30\"\nlog = [\"t\"]\n\n[events.spike.action]\nv = \"c\"\nu = \"u + d\"\n\n[sim]\nt0 = 0.0\nt_end = 200.0\ndt = 0.25\nstepper = \"euler\"\nrecord = true\n\n# Inline presets for different neuron behaviors\n[presets.regular_spiking.params]\na = 0.02\nb = 0.2\nc = -65.0\nd = 8.0\nI = 10.0\n\n[presets.fast_spiking.params]\na = 0.1\nb = 0.2\nc = -65.0\nd = 2.0\nI = 10.0\n\n[presets.bursting.params]\na = 0.02\nb = 0.2\nc = -50.0\nd = 2.0\nI = 15.0\n\n[presets.bursting.states]\nv = -70.0\nu = -14.0\n\"\"\"\n\n\ndef main():\n    # Load model\n    print(\"=== Loading model ===\")\n    doc = tomllib.loads(MODEL_TOML)\n    spec = build_spec(parse_model_v2(doc))\n    model = build(spec, stepper=spec.sim.stepper, jit=True)\n    sim = Sim(model)\n\n    # List inline presets\n    print(\"\\n=== Inline presets ===\")\n    presets = sim.list_presets()\n    print(f\"Available presets: {presets}\")\n\n    # Apply a preset and run\n    print(\"\\n=== Applying 'regular_spiking' preset ===\")\n    sim.apply_preset(\"regular_spiking\")\n    sim.run(T=100.0)\n    results = sim.results()\n    event_counts = results.event.summary()\n    n_spikes = event_counts.get('spike', 0)\n    print(f\"Regular spiking: {n_spikes} spikes in 100ms\")\n\n    # Apply different preset\n    print(\"\\n=== Applying 'fast_spiking' preset ===\")\n    sim.reset()  # Reset to initial state\n    sim.apply_preset(\"fast_spiking\")\n    sim.run(T=100.0)\n    results = sim.results()\n    event_counts = results.event.summary()\n    n_spikes = event_counts.get('spike', 0)\n    print(f\"Fast spiking: {n_spikes} spikes in 100ms\")\n\n    # Save presets to file\n    with tempfile.TemporaryDirectory() as tmpdir:\n        preset_file = Path(tmpdir) / \"neuron_presets.toml\"\n\n        print(f\"\\n=== Saving presets to {preset_file.name} ===\")\n        sim.reset()\n        sim.apply_preset(\"regular_spiking\")\n        sim.add_preset(\"regular_spiking\", overwrite=True)\n        sim.save_preset(\"regular_spiking\", preset_file)\n\n        sim.apply_preset(\"fast_spiking\")\n        sim.add_preset(\"fast_spiking\", overwrite=True)\n        sim.save_preset(\"fast_spiking\", preset_file)\n\n        # Check file contents\n        with open(preset_file, \"rb\") as f:\n            doc = tomllib.load(f)\n        print(f\"File contains: {list(doc['presets'].keys())}\")\n\n        # Create a new sim and load from file\n        print(\"\\n=== Loading presets from file ===\")\n        sim2 = Sim(model)\n        count = sim2.load_preset(\"*\", preset_file, on_conflict=\"replace\") # warning should be raised\n        print(f\"Loaded {count} presets\")\n        print(f\"Available: {sim2.list_presets()}\")\n\n        # Verify they work\n        sim2.apply_preset(\"regular_spiking\")\n        sim2.run(T=100.0)\n        results2 = sim2.results()\n        event_counts2 = results2.event.summary()\n        n_spikes2 = event_counts2.get('spike', 0)\n        print(f\"Loaded preset produces {n_spikes2} spikes (should match original)\")\n\n    # Demonstrate glob patterns\n    print(\"\\n=== Glob pattern matching ===\")\n    print(f\"All presets: {sim.list_presets('*')}\")\n    print(f\"Presets starting with 'fast': {sim.list_presets('fast_*')}\")\n    print(f\"Presets ending with 'spiking': {sim.list_presets('*_spiking')}\")\n\n    print(\"\\n=== Demo complete ===\")\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"tr/examples/state-management/#uri-ve-yol-cozumleme","title":"URI ve yol \u00e7\u00f6z\u00fcmleme","text":"<p>Birinci b\u00f6l\u00fcm sat\u0131r i\u00e7i TOML ile <code>inline:</code> \u015femas\u0131n\u0131, ikinci b\u00f6l\u00fcm mutlak ve g\u00f6receli dosya yollar\u0131n\u0131, \u00fc\u00e7\u00fcnc\u00fc b\u00f6l\u00fcm ise desteklenen URI \u015femalar\u0131n\u0131 (<code>proj://</code>, <code>TAG://</code>, uzant\u0131s\u0131z isimler, <code>#mod=</code> par\u00e7alar\u0131 gibi) ve bunlar\u0131n nereden \u00e7\u00f6z\u00fcmlendi\u011fini g\u00f6sterir. Betik ayr\u0131ca Linux/macOS/Windows \u00fczerindeki <code>dynlib</code> konfig\u00fcrasyon dosyalar\u0131n\u0131n yerlerini ve \u00f6nemli ortam de\u011fi\u015fkenlerini hat\u0131rlatarak belirsiz model yollar\u0131nda hata ay\u0131klamay\u0131 kolayla\u015ft\u0131r\u0131r.</p> <pre><code>#!/usr/bin/env python3\n\"\"\"\nThis script demonstrates the new path resolution and URI system,\nshowing various ways to load and run models.\n\"\"\"\nfrom dynlib import setup\n\n\ndef demo_inline_model():\n    \"\"\"Demo 1: Load a model from inline TOML.\"\"\"\n    print(\"=\" * 60)\n    print(\"Demo 1: Inline Model Definition\")\n    print(\"=\" * 60)\n\n    inline_model = \"\"\"\n    inline:\n    [model]\n    type = \"ode\"\n\n    [states]\n    x = 1.0\n\n    [params]\n    a = 1.0\n\n    [equations.rhs]\n    x = \"-a * x\"\n\n    [sim]\n    t0 = 0.0\n    t_end = 2.0\n    dt = 0.1\n    stepper = \"euler\"\n    \"\"\"\n\n    uri = inline_model\n    sim = setup(uri, stepper=\"euler\", jit=False)\n\n    print(f\"Model kind: {sim.model.spec.kind}\")\n    print(f\"States: {sim.model.spec.states}\")\n    print(f\"Stepper: {sim.model.stepper_name}\")\n\n    # Run simulation\n    sim.run(T=2.0)\n    results = sim.results()\n\n    print(f\"Simulation ran {len(results)} steps\")\n    print(f\"Initial x: {results['x'][0]:.6f}\")\n    print(f\"Final x: {results['x'][-1]:.6f}\")\n    print()\n\n\ndef demo_file_loading():\n    \"\"\"Demo 2: Load a model from existing test file.\"\"\"\n    print(\"=\" * 60)\n    print(\"Demo 2: File-based Model Loading\")\n    print(\"=\" * 60)\n\n    from pathlib import Path\n    data_dir = Path(__file__).parent.parent / \"tests\" / \"data\" / \"models\"\n    model_path = data_dir / \"decay.toml\"\n\n    if not model_path.exists():\n        print(f\"Test data not found: {model_path}\")\n        return\n\n    # Load using absolute path\n    sim = setup(str(model_path), stepper=\"euler\", jit=False)\n\n    print(f\"Loaded from: {model_path}\")\n    print(f\"Model kind: {sim.model.spec.kind}\")\n    print(f\"States: {sim.model.spec.states}\")\n    print(f\"Default stepper: {sim.model.stepper_name}\")\n    print()\n\n\ndef demo_uri_schemes():\n    \"\"\"Demo 3: Show different URI schemes.\"\"\"\n    print(\"=\" * 60)\n    print(\"Demo 3: URI Scheme Examples\")\n    print(\"=\" * 60)\n\n    examples = [\n        (\"inline: [model]\\\\ntype='ode'\", \"Inline TOML definition\"),\n        (\"/abs/path/model.toml\", \"Absolute file path\"),\n        (\"relative/model.toml\", \"Relative path from cwd\"),\n        (\"model\", \"Extensionless (tries model.toml)\"),\n        (\"proj://model.toml\", \"TAG resolution from config\"),\n        (\"model.toml#mod=fast\", \"Fragment selector for mods\"),\n        (\"TAG://path/to/model.toml#mod=variant\", \"Combined TAG + fragment\"),\n    ]\n\n    print(\"Supported URI schemes:\")\n    for uri, description in examples:\n        print(f\"  {uri:40s} - {description}\")\n    print()\n\n    print(\"Configuration:\")\n    print(\"  Config file: ~/.config/dynlib/config.toml (Linux)\")\n    print(\"  Or: ~/Library/Application Support/dynlib/config.toml (macOS)\")\n    print(\"  Or: %APPDATA%\\\\dynlib\\\\config.toml (Windows)\")\n    print()\n    print(\"  Environment overrides:\")\n    print(\"    DYNLIB_CONFIG=/custom/config.toml\")\n    print(\"    DYN_MODEL_PATH=proj=/extra/path,/another\")\n    print()\n\n\ndef main():\n    \"\"\"Run all demos.\"\"\"\n    print(\"\\n\")\n    print(\"\u2554\" + \"\u2550\" * 58 + \"\u2557\")\n    print(\"\u2551\" + \" \" * 10 + \"DYNLIB URI System Demo\" + \" \" * 26 + \"\u2551\")\n    print(\"\u255a\" + \"\u2550\" * 58 + \"\u255d\")\n    print()\n\n    demo_inline_model()\n    demo_file_loading()\n    demo_uri_schemes()\n\n    print(\"=\" * 60)\n    print(\"Demo Complete!\")\n    print(\"=\" * 60)\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"tr/getting-started/","title":"Dynlib ile Ba\u015flang\u0131\u00e7","text":"<p>Bu sayfalar, dynlib kullan\u0131m\u0131n\u0131n ilk ad\u0131mlar\u0131nda size rehberlik eder:</p>"},{"location":"tr/getting-started/#yonlendirme","title":"Y\u00f6nlendirme","text":"<ul> <li>Genel Bak\u0131\u015f \u2014 sistem gereksinimleri, sanal ortam \u00f6nerileri ve JIT i\u00e7in Numba gibi destek paketlerin kurulumunu kapsar; ayr\u0131ca H\u0131zl\u0131 Ba\u015flang\u0131\u00e7, \u0130lk Modeliniz ve daha ileri rehberlere nas\u0131l ge\u00e7i\u015f yapaca\u011f\u0131n\u0131z\u0131 a\u00e7\u0131klar.</li> <li>H\u0131zl\u0131 Ba\u015flang\u0131\u00e7 \u2014 paketi ve CLI'y\u0131 kurma/kurulumdan kaynak \u00e7al\u0131\u015ft\u0131rmay\u0131 do\u011frulama ad\u0131mlar\u0131n\u0131, yerle\u015fik <code>builtin://</code> modelleriyle CLI komutlar\u0131n\u0131 kullanarak \u00e7al\u0131\u015ft\u0131rmay\u0131 ve inline ile dosya modellerini ba\u011flamak i\u00e7in gerekli bilgileri i\u00e7erir.</li> <li>\u0130lk Modeliniz \u2014 mant\u0131ksal haritalar ve basit ODE'ler i\u00e7in \u00f6rnek TOML tablolar\u0131, inline tan\u0131m yakla\u015f\u0131m\u0131 ve sonraki sim\u00fclasyon/analiz yollar\u0131n\u0131 anlat\u0131r.</li> </ul>"},{"location":"tr/getting-started/first-model/","title":"\u0130lk Modelinizi Olu\u015fturma","text":"<p>Bu sayfada, basit bir modeli hem ba\u011f\u0131ms\u0131z bir TOML dosyas\u0131 olarak hem de Dynlib'in dosya sistemine yazmadan i\u015fleyebilece\u011finiz bir <code>inline:</code> ifadesiyle nas\u0131l tan\u0131mlayaca\u011f\u0131n\u0131z\u0131 \u00f6\u011freneceksiniz. Daha ileri DSL konular\u0131 i\u00e7in Modelleme rehberlerine g\u00f6z at\u0131n: TOML yap\u0131lar\u0131 i\u00e7in DSL temelleri, inline i\u00e7erikler i\u00e7in inline modeller ve modeli kay\u0131t defterine eklemek isterseniz konfig\u00fcrasyon dosyas\u0131.</p>"},{"location":"tr/getting-started/first-model/#1-temel-toml-tanm","title":"1. Temel TOML tan\u0131m\u0131","text":"<p>K\u00f6\u015feli parantez <code>[]</code> ile yaz\u0131lan TOML ifadelerine tablo denilir. Bir model olu\u015fturmak i\u00e7in en az\u0131ndan <code>[model]</code>, <code>[states]</code> ile birlikte bir denklem tablosu (<code>[equations]</code> vb.) belirtilmelidir. <code>[model]</code> tablosu alt\u0131nda modelin t\u00fcr\u00fcne g\u00f6re <code>type = \"map\"</code> veya <code>type = \"ode\"</code> kullan\u0131n. <code>name</code> ifadesi ile modelin ismini; <code>dtype</code> (ing. data type k\u0131saltmas\u0131) ifadesi ile veri t\u00fcr\u00fcn\u00fc belirleyebilirsiniz. </p> <p><code>[params]</code> (ing. prameters k\u0131slatmas\u0131) tablosu alt\u0131na parametreleri ve bunlar\u0131n de\u011ferlerini alt alta yazabilirsiniz. Benzer \u015fekilde <code>[states]</code> (ing. state variables k\u0131saltmas\u0131) tablosu alt\u0131na durum de\u011fi\u015fkenlerini ve bunlar\u0131n ba\u015flang\u0131\u00e7 de\u011ferlerini alt alta yazabilirsiniz.</p> <p><code>[equations]</code> veya <code>[equations.rhs]</code> tablosu alt\u0131na ise sistemin denklemleri yaz\u0131l\u0131r. \u0130kisi aras\u0131ndaki fark \u015fu \u015fekildedir:</p> <pre><code>[equations]\nexpr = \"\"\"\nx = r * x * (1 - x)\n\"\"\"\n</code></pre> <p>Buradaki <code>expr</code> ifadesi \u0130ngilizce expression ifadesinin k\u0131saltmas\u0131d\u0131r.</p> <pre><code>[equations.rhs]\nx = \"r * x * (1 - x)\"\n</code></pre> <p>A\u015fa\u011f\u0131daki \u00f6rne\u011fi proje klas\u00f6r\u00fcn\u00fcze <code>first-model.toml</code> (veya benzeri bir yol ad\u0131) olarak kaydedin:</p> <pre><code>[model]\ntype = \"map\"\nname = \"Simple Logistic Map\"\ndtype = \"float64\"\n\n[params]\nr = 3.9\n\n[states]\nx = 0.2\n\n[equations.rhs]\nx = \"r * x * (1 - x)\"\n</code></pre> <p>DSL temelleri, ekleyebilece\u011finiz sabitler, yard\u0131mc\u0131 de\u011fi\u015fkenler, olaylar, Jacobian tablolar\u0131 gibi di\u011fer tablolar\u0131 ve Dynlib'in bu ifadelerin hepsini nas\u0131l yorumlad\u0131\u011f\u0131n\u0131 anlat\u0131r. Tan\u0131m\u0131n\u0131z\u0131n s\u00f6zdiziminin (syntax) ge\u00e7erli olup olmad\u0131\u011f\u0131n\u0131 do\u011frulamak i\u00e7in <code>dynlib model validate first-model.toml</code> (veya <code>python -m dynlib.cli model validate ...</code>) komutunu \u00e7al\u0131\u015ft\u0131r\u0131n.</p>"},{"location":"tr/getting-started/first-model/#2-inline-satr-ici-tanmlarla-hzl-prototiplendirme","title":"2. Inline (sat\u0131r i\u00e7i) tan\u0131mlarla h\u0131zl\u0131 prototiplendirme","text":"<p>E\u011fer farkl\u0131 bir model dosyas\u0131 olu\u015fturmadan h\u0131zl\u0131ca bir model tan\u0131mlay\u0131p hemen sim\u00fclasyon yapmak isterseniz bir python dosyas\u0131 i\u00e7erisinde sat\u0131r i\u00e7i (inline) bir model tan\u0131mlayabilirsiniz. Sat\u0131r i\u00e7i model tan\u0131m\u0131 \u00fc\u00e7 adet tek t\u0131rnak aras\u0131na ayn\u0131 TOML modelinin yaz\u0131lmas\u0131yla olu\u015fturulur. <code>setup()</code> veya <code>build()</code> ara\u00e7lar\u0131n\u0131n modelin sat\u0131r i\u00e7i oldu\u011funu anlayabilmesi i\u00e7in model tablosunun \u00fcst\u00fcne <code>inline:</code> ifadesi eklenmelidir.</p> <pre><code>from dynlib import setup\n\nspec = '''\ninline:\n[model]\ntype = \"map\"\nname = \"Inline Logistic\"\ndtype = \"float64\"\n\n[params]\nr = 3.9\n\n[states]\nx = 0.3\n\n[equations.rhs]\nx = \"r * x * (1 - x)\"\n'''\n\nsim = setup(spec)\nsim.run(N=30)\n</code></pre> <p>Sat\u0131r i\u00e7i modeller, kabul edilen URI bi\u00e7imlerini ve <code>inline:</code> kullan\u0131m senaryolar\u0131n\u0131 listeler. Detaylar i\u00e7in ilgili d\u00f6k\u00fcmantasyonu inceleyebilirsiniz.</p>"},{"location":"tr/getting-started/first-model/#3-basit-bir-ode-ornegi","title":"3. Basit bir ODE \u00f6rne\u011fi","text":"<p>S\u00fcrekli zamanl\u0131 bir sistemi modellemek i\u00e7in <code>type = \"ode\"</code> se\u00e7ip durum denklemlerini <code>[equations.rhs]</code> alt\u0131nda tan\u0131mlay\u0131n. Di\u011fer tablolar\u0131n kullan\u0131m\u0131 yukar\u0131daki modellemeyle ayn\u0131d\u0131r. Tek fark denklemlerin art\u0131k zamana g\u00f6re t\u00fcrevi temsil etmesidir:</p> <pre><code>[model]\ntype = \"ode\"\nname = \"Simple Harmonic Oscillator\"\ndtype = \"float64\"\n\n[params]\nomega = 1.0\n\n[states]\nx = 1.0\nv = 0.0\n\n[equations.rhs]\nx = \"v\"\nv = \"-omega ** 2 * x\"\n</code></pre> <p>Bu dosyay\u0131 <code>dynlib model validate harmonic.toml</code> ile do\u011frulayabilir veya sat\u0131r i\u00e7i (inline) tan\u0131mlayarak \u00e7al\u0131\u015ft\u0131rabilirsiniz:</p> <pre><code>sim = setup(\"path/to/harmonic.toml\")\nsim.run(T=30)\n</code></pre>"},{"location":"tr/getting-started/first-model/#4-sonraki-admlar","title":"4. Sonraki ad\u0131mlar","text":"<p>Tan\u0131m\u0131n\u0131z\u0131 do\u011frulad\u0131ktan sonra modeli \u00e7al\u0131\u015ft\u0131rmak ve yeniden kullanmak i\u00e7in \u015fu ad\u0131mlar\u0131 izleyin:</p> <ul> <li><code>setup(\"first-model.toml\", ...)</code> ile bir <code>Sim</code> nesnesi olu\u015fturup sim\u00fclasyonlar veya analizler yap\u0131n.</li> <li>Bir yap\u0131land\u0131rma dosyas\u0131yla klas\u00f6r\u00fc kaydederek <code>proj://first-model.toml</code> gibi etiketlerle modeli bilgisayar\u0131n\u0131zdaki herhangi bir konumda tekrar tekrar kullan\u0131n. Konfig\u00fcrasyon dosyas\u0131yla hangi dosyan\u0131n hangi etikete denk gelece\u011fini ve Dynlib\u2019in kay\u0131t defterini nerede tuttu\u011funu netle\u015ftirmek i\u00e7in konfig\u00fcrasyon rehberini okuyun.</li> <li>Sim\u00fclasyon sonu\u00e7lar\u0131n\u0131 elde etmek ve kullanmak i\u00e7in sonu\u00e7lar sayfas\u0131n\u0131 inceleyin.</li> <li>Sonu\u00e7lar\u0131 \u00e7izdirmek i\u00e7in \u00e7izim sayfas\u0131n\u0131 inceleyin.</li> </ul>"},{"location":"tr/getting-started/overview/","title":"Genel Bak\u0131\u015f","text":"<p>E\u011fer dynlib ile yeni tan\u0131\u015f\u0131yorsan\u0131z, temel bilgiler i\u00e7in ana sayfa'y\u0131 incelemeyi ihmal etmeyin.</p>"},{"location":"tr/getting-started/overview/#gereksinimler","title":"Gereksinimler","text":"<ul> <li>\u00c7al\u0131\u015fan bir Python ortam\u0131 (3.10+ \u00f6nerilir). </li> <li>Zorunlu olmasa da kurulum i\u00e7in bir sanal ortam (virtualenv) veya benzeri bir izolasyon katman\u0131.</li> <li>Numerik hesaplamalar i\u00e7in Numpy paketi (<code>python -m pip install numpy</code>).</li> <li>\u00c7izim i\u00e7in Matplotlib paketi (<code>python -m pip install matplotlib</code>).</li> <li>Paketin kendisi (<code>python -m pip install dynlib</code>). Kurulum detaylar\u0131 i\u00e7in H\u0131zl\u0131 Ba\u015flang\u0131\u00e7 rehberine bakabilirsiniz.</li> </ul> <p>Y\u00fcksek performansl\u0131 sim\u00fclasyon ve analiz yapabilmek i\u00e7in Numba paketi \u015fiddetle tavsiye edilir (<code>python -m pip install numba</code>).</p>"},{"location":"tr/getting-started/overview/#bu-bolum-nasl-kullanlr","title":"Bu b\u00f6l\u00fcm nas\u0131l kullan\u0131l\u0131r","text":"<ol> <li>dynlib'i kurmak, CLI sa\u011flamas\u0131n\u0131 yapmak (<code>dynlib --version</code>, <code>dynlib model validate</code> vb.) ve yerle\u015fik modellerden birini Python \u00fczerinden \u00e7al\u0131\u015ft\u0131rmak i\u00e7in H\u0131zl\u0131 Ba\u015flang\u0131\u00e7 k\u0131lavuzunu takip edin.</li> <li>Bir TOML modeli yazmak, onu do\u011frulamak (<code>dynlib model validate first-model.toml</code>) ve \"inline\" (sat\u0131r i\u00e7i) metinlerle denemeler yapmak i\u00e7in \u0130lk Modeliniz b\u00f6l\u00fcm\u00fcne ge\u00e7in.</li> <li>Stepper'lar, kaydediciler (recorders) ve di\u011fer DSL \u00f6zellikleriyle \u00e7al\u0131\u015fman\u0131z gerekti\u011finde Modelleme rehberi ile Sim\u00fclasyon rehberi'ni ke\u015ffedin. </li> <li>Sim\u00fclasyon sonu\u00e7lar\u0131n\u0131 kullanmak ve \u00e7izim yapmak i\u00e7in Sim\u00fclasyon Sonu\u00e7lar\u0131 ve \u00c7izim rehberlerine g\u00f6z at\u0131n.</li> <li>\u00c7atallanma (bifurcation) diyagramlar\u0131ndan n\u00f6ron modellerine kadar tam i\u015f ak\u0131\u015flar\u0131n\u0131 g\u00f6rmek i\u00e7in \u00d6rnekler ve Analiz rehberi b\u00f6l\u00fcmlerine bak\u0131n.</li> </ol>"},{"location":"tr/getting-started/quickstart/","title":"H\u0131zl\u0131 Ba\u015flang\u0131\u00e7","text":"<p>Bu sayfa, her dynlib kullan\u0131c\u0131s\u0131n\u0131n yapt\u0131\u011f\u0131 ilk \u00fc\u00e7 i\u015flemde size yol g\u00f6sterir: paketi kurmak, CLI sa\u011flamas\u0131n\u0131 yapmak ve Dynlib i\u00e7inde tan\u0131ml\u0131 yerle\u015fik (built-in) bir modeli \u00e7al\u0131\u015ft\u0131rmak. Bundan sonra, kendi kendinize ilk modelinizi tan\u0131mlamak ve kendi model katalo\u011funuzu olu\u015fturman\u0131z i\u00e7in sizi \u0130lk Modeliniz rehberine y\u00f6nlendirece\u011fiz.</p>"},{"location":"tr/getting-started/quickstart/#kurulum","title":"Kurulum","text":"<p>Yeni bir \u00e7al\u0131\u015fma alan\u0131 olu\u015fturuyorsan\u0131z \u00f6nce uygun bir sanal ortam kurup etkinle\u015ftirin (<code>python -m venv .venv</code> ard\u0131ndan Linux/macOS'ta <code>source .venv/bin/activate</code>, Windows PowerShell'de <code>.\\.venv\\Scripts\\Activate.ps1</code>). Sanal ortam aktifken paket payla\u015f\u0131m\u0131n\u0131 ve komut sat\u0131r\u0131 giri\u015f noktalar\u0131n\u0131 y\u00fcklemek i\u00e7in:</p> <pre><code>python -m pip install dynlib\n</code></pre> <p>E\u011fer kaynak kodu de\u011fi\u015ftirip geli\u015ftirmeye katk\u0131da bulunmak isterseniz paketi github \u00fczerinden indirip kurabilirsiniz:</p> <pre><code>git clone https://github.com/ismoz/dynlib.git\ncd dynlib\npython -m pip install -e .\n</code></pre> <p>\u0130\u015flem boyunca sanal ortam\u0131 a\u00e7\u0131k tutun; b\u00f6ylece dynlib ve ba\u011f\u0131ml\u0131l\u0131klar\u0131 di\u011fer projelerden izole kal\u0131r.</p>"},{"location":"tr/getting-started/quickstart/#cli-dogrulama","title":"CLI Do\u011frulama","text":"<p>Paketle gelen CLI, kurulumun ba\u015far\u0131l\u0131 olup olmad\u0131\u011f\u0131n\u0131 test etmek i\u00e7in kullan\u0131labilir. Daha fazla \u00f6rnek ve a\u00e7\u0131klama i\u00e7in CLI rehberi'ne bak\u0131n.</p> <ul> <li><code>dynlib --version</code> veya <code>python -m dynlib.cli --version</code> kurulu paket s\u00fcr\u00fcm\u00fcn\u00fc g\u00f6sterir ve giri\u015f noktalar\u0131n\u0131n \u00e7al\u0131\u015ft\u0131\u011f\u0131n\u0131 do\u011frular.</li> <li><code>dynlib model validate builtin://ode/lorenz.toml</code> yerle\u015fik Lorenz modelini derler ve do\u011frular. Di\u011fer yerle\u015fik modellere de <code>builtin://ode/</code> veya <code>builtin://map/</code> URI ifadeleri ile eri\u015filebilir.</li> <li><code>dynlib steppers list --kind ode --jit_capable</code> JIT destekli stepper'lar\u0131 listeler, <code>--stiff</code> veya <code>--jacobian optional</code> gibi filtrelerle listelenecek stepper'lar\u0131 s\u0131n\u0131rlayabilirsiniz.</li> <li><code>dynlib cache path</code> derlenmi\u015f runner'lar\u0131n yerini s\u00f6yler; \u00f6nbelle\u011fi incelemek i\u00e7in <code>dynlib cache list</code>, temizlemek i\u00e7in <code>dynlib cache clear --dry_run</code> komutunu kullan\u0131n.</li> </ul> <p>Her komut <code>--help</code> se\u00e7ene\u011fiyle ek bayraklar\u0131 ve parametreleri g\u00f6sterir (\u00f6rne\u011fin <code>dynlib steppers list --help</code>), b\u00f6ylece \u00e7al\u0131\u015fma zaman\u0131 komutlar\u0131n\u0131 kaynak koduna girmeden ke\u015ffedebilirsiniz.</p>"},{"location":"tr/getting-started/quickstart/#pythondan-yerlesik-bir-modeli-calstrma","title":"Python'dan yerle\u015fik bir modeli \u00e7al\u0131\u015ft\u0131rma","text":"<p><code>dynlib.setup</code> bir modeli derlerken stepper se\u00e7imini, JIT kullan\u0131m\u0131n\u0131 ve veri kay\u0131t stratejilerini tek yerden y\u00f6netmenizi sa\u011flar. A\u015fa\u011f\u0131daki \u00f6rnek Lorenz sistemini y\u00fckler, runner'\u0131 derler, 15 zaman birimi boyunca sim\u00fclasyonu y\u00fcr\u00fct\u00fcr ve <code>x</code>/<code>z</code> durumlar\u0131n\u0131 \u00e7izim yard\u0131mc\u0131lar\u0131yla grafik olarak \u00e7izdirir:</p> <pre><code>from dynlib import setup\nfrom dynlib.plot import fig, series, export\n\nsim = setup(\n    \"builtin://ode/lorenz.toml\",\n    stepper=\"rk4\",\n)\n\nsim.run(T=15.0, dt=0.01)\nres = sim.results()\n\nprint(\"Recorded states:\", res.state_names)\nprint(\"Recorded steps:\", len(res))\nprint(\"Final z value:\", res[\"z\"][-1])\n\nax = fig.single()\nseries.plot(x=res.t, y=res[\"x\"], ax=ax, label=\"x\")\nseries.plot(x=res.t, y=res[\"z\"], ax=ax, label=\"z\", xlabel=\"time\")\nexport.show()\n</code></pre> <p><code>res</code> bir <code>ResultsView</code> nesnesidir. <code>res.t</code>, <code>res[\"state_name\"]</code>, <code>res.event_names()</code> ve <code>res.to_pandas()</code> (pandas gerektirir) gibi yard\u0131mc\u0131lar veri kopyalamadan altta yatan bellek alanlar\u0131n\u0131 (buffers) okur. Sim\u00fclasyona devam etmek i\u00e7in <code>resume=True</code> se\u00e7ene\u011fiyle tekrar <code>run()</code> komutu \u00e7al\u0131\u015ft\u0131r\u0131labilir. <code>assign()</code> komutu ile sim\u00fclasyon ve model parametreleri de\u011fi\u015ftirilebilir. </p>"},{"location":"tr/getting-started/quickstart/#kendi-modellerinizi-kullanma","title":"Kendi modellerinizi kullanma","text":"<p><code>builtin://</code> URI'leri paketle gelen ODE'leri (<code>lorenz</code>, <code>vanderpol</code>, <code>izhikevich</code> vb.) ve haritalar\u0131 (<code>logistic</code>, <code>henon</code>, <code>standard</code> vb.) ke\u015ffetmeyi kolayla\u015ft\u0131r\u0131r. Kendi TOML dosyalar\u0131n\u0131z\u0131 kullanmak i\u00e7in dynlib'in sundu\u011fu URI \u00e7\u00f6z\u00fcmleme se\u00e7eneklerine bak\u0131n:</p> <ol> <li>Inline (sat\u0131r i\u00e7i) TOML metinleri ile model olu\u015fturma: Inline (sat\u0131r i\u00e7i) modelleme</li> <li>Mutlak veya g\u00f6reli yollar (<code>/path/model.toml</code>, <code>my_model.toml</code>).</li> </ol> <p>.toml uzant\u0131s\u0131 ihmal edilebilir.</p> <ol> <li><code>proj://my_model.toml</code> gibi etiket tabanl\u0131 URI'ler: Konfig\u00fcrasyon ve Kay\u0131t Defteri.</li> <li>Konfig\u00fcrasyon dosyas\u0131n\u0131 d\u00fczenlemeden yeni URI etiketleri eklemek i\u00e7in <code>DYN_MODEL_PATH=proj=/extra/models:/more</code> (Windows'ta <code>;</code> ile ay\u0131r\u0131n) gibi bir ortam de\u011fi\u015fkeni tan\u0131mlay\u0131n. <code>=</code> i\u015faretinden \u00f6nceki dize etiket ad\u0131n\u0131, virg\u00fclle ayr\u0131lan yollar\u0131 arama k\u00f6k\u00fc olarak kullan\u0131r.</li> </ol> <p>Konfig\u00fcrasyon dosyan\u0131z \u015f\u00f6yle g\u00f6r\u00fcnebilir:</p> <pre><code>[tags]\nproj = [\"/Users/you/dynlib-models\", \"~/projects/other-models\"]\ntests = [\"~/src/dynlib/tests/data/models\"]\n\n[cache]\ncache_root = \"/tmp/dynlib-cache\"\n</code></pre> <p><code>proj</code> etiketi tan\u0131mland\u0131\u011f\u0131nda art\u0131k <code>setup(\"proj://decay.toml\")</code>, <code>dynlib model validate proj://decay.toml</code> komutlar\u0131n\u0131 \u00e7al\u0131\u015ft\u0131rabilir veya di\u011fer tan\u0131mlarda bu URI'yi referans verebilirsiniz.</p>"},{"location":"tr/getting-started/quickstart/#sonraki-admlar","title":"Sonraki ad\u0131mlar","text":"<ol> <li>\u0130lk Modeliniz ile kendi DSL tan\u0131m\u0131n\u0131z\u0131 yazmaya devam edin ve do\u011frulama ak\u0131\u015f\u0131n\u0131 peki\u015ftirin.</li> <li>Rehberler \u2192 Modelleme ve Rehberler \u2192 Sim\u00fclasyon \u00fczerinden stepper'lar, kay\u0131t se\u00e7enekleri ve runner yap\u0131land\u0131rmalar\u0131 hakk\u0131nda detayl\u0131 bilgi edinin.</li> <li>Rehberler \u2192 Analiz ve \u00d6rnekler sayfalar\u0131nda \u00e7izim, sabit nokta analizi, Lyapunov \u00fcsteli hesaplay\u0131c\u0131lar\u0131 gibi ek ara\u00e7lar\u0131 ke\u015ffedin.</li> <li><code>dynlib cache list</code>, <code>dynlib cache clear --dry_run</code> ve <code>dynlib model validate</code> gibi CLI komutlar\u0131yla cache ve model do\u011frulamas\u0131n\u0131 pratik edin; detayl\u0131 CLI kullan\u0131m\u0131 i\u00e7in CLI rehberi'ni inceleyin.</li> </ol>"},{"location":"tr/guides/","title":"Rehberler","text":"<p>Dynlib\u2019in rehberleri, h\u0131zl\u0131 ba\u015flang\u0131\u00e7 materyalinin daha derinine iner: her b\u00f6l\u00fcm temel bir alt sistemi \u201ca\u00e7\u0131p\u201d netle\u015ftirir. B\u00f6ylece modelleri, steppers\u2019\u0131, analiz yard\u0131mc\u0131lar\u0131n\u0131 veya \u00e7izim (plot) katman\u0131n\u0131; da\u011f\u0131n\u0131k notlar aras\u0131nda kaybolmadan \u00f6zelle\u015ftirebilirsiniz.</p>"},{"location":"tr/guides/#rehberlere-hzl-baks","title":"Rehberlere h\u0131zl\u0131 bak\u0131\u015f","text":"<ul> <li>Komut sat\u0131r\u0131 rehberi \u2014 model do\u011frulama, stepper inceleme ve cache y\u00f6netimi i\u00e7in <code>dynlib</code> (ve <code>python -m dynlib.cli</code>) komutlar\u0131n\u0131 a\u00e7\u0131klar.</li> <li>Modelleme rehberi \u2014 TOML DSL\u2019i, aux yard\u0131mc\u0131lar\u0131n\u0131, mods, presets ve spesifikasyonlar\u0131 okunur/yeniden kullan\u0131labilir tutan yaz\u0131m kolayl\u0131klar\u0131n\u0131 kapsar.</li> <li>Sim\u00fclasyon rehberi \u2014 steppers, wrappers, snapshots, results ve solver davran\u0131\u015f\u0131n\u0131 kontrol eden yap\u0131land\u0131rma ayarlar\u0131 gibi runtime kavramlar\u0131n\u0131 tarar.</li> <li>\u00c7izim rehberi \u2014 dinamik sistemler i\u00e7in ayarlanm\u0131\u015f Matplotlib tabanl\u0131 yard\u0131mc\u0131lar\u0131 (<code>plot.series</code>, <code>plot.phase</code>, <code>plot.manifold</code>, decorations, exports, themes) \u00f6zetler.</li> <li>Analiz rehberi \u2014 <code>Sim</code> sonu\u00e7lar\u0131n\u0131 bilimsel i\u00e7g\u00f6r\u00fclere d\u00f6n\u00fc\u015ft\u00fcren runtime observers, sweep yard\u0131mc\u0131lar\u0131, basins, Lyapunov tan\u0131lar\u0131 ve manifold bulucular\u0131 a\u00e7\u0131klar.</li> </ul>"},{"location":"tr/guides/analysis/","title":"Analiz rehberi","text":"<p>Dynlib temel analiz ara\u00e7lar\u0131n\u0131 sunar. Zamanla bu analiz ara\u00e7lar\u0131 daha da geni\u015fletilecektir. Mevcut analiz ara\u00e7lar\u0131 i\u00e7in d\u00f6k\u00fcmanlara a\u015fa\u011f\u0131daki ba\u011flant\u0131lardan ula\u015fabilirsiniz.</p>"},{"location":"tr/guides/analysis/#konular","title":"Konular","text":"<ul> <li>Havzalar (Basins) \u2014 \u0131zgara yap\u0131land\u0131rmas\u0131, alg\u0131lama e\u015fikleri ve \u00e7izim ipu\u00e7lar\u0131 ile otomatik veya bilinen \u00e7eker havzas\u0131 hesaplay\u0131c\u0131lar\u0131 (<code>basin_auto</code>, <code>basin_known</code>).</li> <li>Sabit noktalar (Fixed points) \u2014  <code>find_fixed_points</code> ve <code>FullModel.fixed_points</code> arac\u0131l\u0131\u011f\u0131yla sunulan Newton \u00e7\u00f6z\u00fcc\u00fcleri.</li> <li>\u00c7al\u0131\u015fma zaman\u0131 g\u00f6zlemcileri \u2014 g\u00f6zlemci \u00e7er\u00e7evesi, ad\u0131m \u00f6ncesi/sonras\u0131 kancalar\u0131 (hooks), iz (trace) tamponlar\u0131 ve do\u011frudan <code>Sim.run</code> i\u00e7ine tak\u0131lan <code>lyapunov_*</code> g\u00f6zlemci (observer) fabrikalar\u0131.</li> <li>Lyapunov analizi \u2014 Maksimum Lyapunov \u00fcsteli (MLE) ve Lyapunov spektrum hesab\u0131.</li> <li>Tarama ara\u00e7lar\u0131 (Sweep utilities) \u2014 de\u011fi\u015fen parametre de\u011ferleri i\u00e7in pratikle\u015ftirilmi\u015f sim\u00fclasyonlar ve analizler.</li> <li>\u00c7atallanma diyagramlar\u0131 \u2014 post-analiz ile bif\u00fcrkasyon (\u00e7atallanma) verisi elde etme.</li> <li>Son analiz (Post-analysis) \u2014 elde edilen simulasyon sonu\u00e7lar\u0131 \u00fczerinde kullanabileceiniz \u00e7e\u015fitli post-analiz ara\u00e7lar\u0131.</li> <li>Manifold analizi \u2014 1B manifold izleme, heteroklinik/homoklinik y\u00f6r\u00fcnge arama ve izleme. </li> </ul>"},{"location":"tr/guides/analysis/basin/","title":"\u00c7ekim havzas\u0131 analizi: bilinen ve otomatik y\u00f6ntemler","text":"<p>Bu sayfa, dynlib\u2019de \u00e7ekim havzas\u0131 (basin of attraction) \u00e7\u0131karmak i\u00e7in iki arac\u0131 a\u00e7\u0131klar:</p> <ul> <li><code>basin_known</code>: \u00d6nceden tan\u0131mlad\u0131\u011f\u0131n\u0131z (bilinen) \u00e7ekicilere g\u00f6re s\u0131n\u0131fland\u0131r\u0131r (FixedPoint ve/veya ReferenceRun).</li> <li><code>basin_auto</code>: \u00c7ekicileri otomatik ke\u015ffeder ve \u00e7ekim havzas\u0131n\u0131 PCR-BM (Persistent Cell-Recurrence Basin Mapping) ile haritalar.</li> </ul> <p>Not: Sonu\u00e7 etiketleri (labels) \u015fu anlamlara gelir:</p> <ul> <li><code>&gt;= 0</code>: \u00e7ekici kimli\u011fi (attractor ID)</li> <li><code>BLOWUP</code>: NaN/Inf veya <code>b_max</code> e\u015fi\u011fi ile ta\u015fma (divergence)</li> <li><code>OUTSIDE</code>: g\u00f6zlem b\u00f6lgesinin d\u0131\u015f\u0131na ka\u00e7\u0131\u015f</li> <li><code>UNRESOLVED</code>: s\u0131n\u0131fland\u0131r\u0131lamad\u0131</li> </ul>"},{"location":"tr/guides/analysis/basin/#basin_known-bilinen-cekicilere-gore-snflandrma","title":"<code>basin_known</code>: Bilinen \u00e7ekicilere g\u00f6re s\u0131n\u0131fland\u0131rma","text":"<p><code>basin_known</code>, ba\u015flang\u0131\u00e7 ko\u015fullar\u0131n\u0131 (IC) sizin verdi\u011finiz \u00e7ekicilere g\u00f6re etiketler. \u0130ki \u00e7ekici t\u00fcr\u00fcn\u00fc destekler:</p> <ul> <li><code>FixedPoint</code>: sabit nokta. H\u0131zl\u0131 yol (fast-path) ile s\u0131n\u0131fland\u0131r\u0131l\u0131r: y\u00f6r\u00fcnge, sabit noktan\u0131n yar\u0131\u00e7ap\u0131 i\u00e7inde art arda <code>fixed_point_settle_steps</code> ad\u0131m kal\u0131rsa an\u0131nda atan\u0131r.</li> <li><code>ReferenceRun</code>: referans ko\u015fu. Bu \u00e7ekiciler i\u00e7in \u00e7evrimi\u00e7i PSC tabanl\u0131 bir imza/kan\u0131tlama yakla\u015f\u0131m\u0131 kullan\u0131l\u0131r (g\u00f6zlem uzay\u0131 h\u00fccrelerine kuantalama + log-olas\u0131l\u0131k skorlama). Kaotik ve \u00e7evrimsel \u00e7ekicilerde daha dayan\u0131kl\u0131d\u0131r.</li> </ul>"},{"location":"tr/guides/analysis/basin/#ne-zaman-tercih-edilmeli","title":"Ne zaman tercih edilmeli?","text":"<ul> <li>\u00c7ekicileri zaten biliyorsan\u0131z (sabit noktalar, belirli periyot \u00e7evrimleri, bilinen kaotik \u00e7ekiciler).</li> <li>\u201c\u015eu \u00e7ekiciler var, bunlara g\u00f6re havzay\u0131 boya\u201d i\u015f ak\u0131\u015f\u0131 istiyorsan\u0131z.</li> </ul>"},{"location":"tr/guides/analysis/basin/#parametreler-ozet","title":"Parametreler (\u00f6zet)","text":"<p>A\u015fa\u011f\u0131daki isimler API\u2019deki anahtarlard\u0131r; aynen kullan\u0131n:</p> <ul> <li> <p><code>sim: Sim</code>   Sim\u00fclasyon nesnesi.</p> </li> <li> <p><code>attractors: Sequence[FixedPoint | ReferenceRun]</code>   Bilinen \u00e7ekiciler listesi.</p> </li> <li> <p><code>ic</code> veya <code>ic_grid</code> </p> </li> <li><code>ic: np.ndarray</code>: Do\u011frudan IC matrisi (<code>(n_points, n_states)</code>).</li> <li> <p><code>ic_grid: Sequence[int]</code> + <code>ic_bounds: Sequence[(min,max)]</code>: IC \u0131zgaras\u0131 \u00fcretir.</p> </li> <li> <p><code>observe_vars: Sequence[str|int] | None</code>   E\u015fle\u015ftirme/kuantalama i\u00e7in g\u00f6zlenen durum de\u011fi\u015fkenleri. <code>None</code> ise varsay\u0131lan se\u00e7im kullan\u0131l\u0131r.</p> </li> <li> <p><code>escape_bounds: Sequence[(min,max)] | None</code>   Ka\u00e7\u0131\u015f denetimi i\u00e7in s\u0131n\u0131rlar. Y\u00f6r\u00fcnge bu b\u00f6lgenin d\u0131\u015f\u0131nda art arda belirli say\u0131da \u00f6rnek g\u00f6r\u00fcrse <code>OUTSIDE</code> say\u0131l\u0131r.</p> </li> <li> <p><code>max_samples</code>, <code>transient_samples</code> </p> </li> <li><code>max_samples</code>: S\u0131n\u0131fland\u0131rma i\u00e7in en fazla \u00f6rnek/ad\u0131m.</li> <li> <p><code>transient_samples</code>: \u0130lk ge\u00e7i\u015f (transient) \u00f6rneklerini yok sayma.</p> </li> <li> <p><code>dt_obs</code> </p> </li> <li>ODE modunda zorunlu \u00f6rnekleme aral\u0131\u011f\u0131.</li> <li> <p>map modunda varsay\u0131lan olarak modelin <code>dt</code>\u2019si kullan\u0131l\u0131r.</p> </li> <li> <p><code>tolerance</code> / <code>tolerance_absolute</code>   Kod i\u00e7inde bir mesafe e\u015fi\u011fi (<code>dist_threshold</code>) hesaplamak i\u00e7in kullan\u0131l\u0131r. <code>tolerance_absolute</code> verilirse do\u011frudan o kullan\u0131l\u0131r; verilmezse <code>tolerance * mean(obs_range)</code> ile t\u00fcretilir.</p> </li> <li> <p><code>b_max</code>, <code>blowup_vars</code> <code>b_max</code> verilirse se\u00e7ili de\u011fi\u015fkenlerde <code>abs(value) &gt; b_max</code> ta\u015fma say\u0131l\u0131r ve <code>BLOWUP</code> d\u00f6ner. <code>b_max=None</code> ise yaln\u0131zca NaN/Inf denetimi ile ta\u015fma yakalan\u0131r.</p> </li> <li> <p><code>parallel_mode: {\"auto\",\"threads\",\"process\",\"none\"}</code> ve <code>max_workers</code>   B\u00fcy\u00fck grid\u2019lerde process tabanl\u0131 paralellik devreye girebilir.</p> </li> <li> <p>Coarse-to-fine iyile\u015ftirme (refinement):</p> </li> <li><code>refine: bool</code>: \u00f6nce kaba grid, sonra yaln\u0131zca s\u0131n\u0131r b\u00f6lgelerinde tam \u00e7\u00f6z\u00fcn\u00fcrl\u00fck.</li> <li><code>coarse_factor: int</code>: kaba grid \u00f6l\u00e7ek oran\u0131.</li> <li> <p><code>boundary_dilation: int</code>: s\u0131n\u0131r maskesini g\u00fcvenlik pay\u0131 i\u00e7in geni\u015fletme.</p> </li> <li> <p>Sabit nokta h\u0131zl\u0131 yolu:</p> </li> <li><code>fixed_point_settle_steps: int</code>: sabit nokta yar\u0131\u00e7ap\u0131 i\u00e7inde art arda ka\u00e7 ad\u0131m kal\u0131nca \u201cyak\u0131nsad\u0131\u201d kabul edilece\u011fi.</li> </ul>"},{"location":"tr/guides/analysis/basin/#ckt","title":"\u00c7\u0131kt\u0131","text":"<p><code>BasinResult</code> d\u00f6ner:</p> <ul> <li><code>labels</code>: her IC i\u00e7in \u00e7ekici kimli\u011fi veya \u00f6zel kodlar (<code>BLOWUP/OUTSIDE/UNRESOLVED</code>)</li> <li><code>registry</code>: <code>Attractor</code> listesi (bu fonksiyonda \u00e7ekici say\u0131s\u0131 bilindi\u011fi i\u00e7in id\u2019ler 0..n_attr-1)</li> <li><code>meta</code>: kullan\u0131lan ayarlar ve (varsa) grid/refine metadatas\u0131</li> </ul>"},{"location":"tr/guides/analysis/basin/#ksa-ornek","title":"K\u0131sa \u00f6rnek","text":"<pre><code>from dynlib.runtime.sim import Sim\nfrom dynlib.analysis.basin import FixedPoint, ReferenceRun\nfrom dynlib.analysis.basin_known import basin_known\nimport numpy as np\n\n# IC grid\nic_grid = [400, 400]\nic_bounds = [(-2.0, 2.0), (-2.0, 2.0)]\n\n# Bilinen \u00e7ekiciler (\u00f6rnek)\nattractors = [\n    FixedPoint(label=\"fp0\", ic=[0.0, 0.0], radius=1e-3),\n    ReferenceRun(label=\"attr1\", ic=[0.1, 0.1]),\n]\n\nresult = basin_known(\n    sim,\n    attractors,\n    ic_grid=ic_grid,\n    ic_bounds=ic_bounds,\n    mode=\"map\",\n    max_samples=2000,\n    transient_samples=200,\n    dt_obs=None,\n    refine=True,\n    coarse_factor=8,\n    boundary_dilation=1,\n)\nlabels_2d = result.labels.reshape(*ic_grid)\n</code></pre>"},{"location":"tr/guides/analysis/basin/#basin_auto-pcr-bm-ile-otomatik-cekim-havzas","title":"<code>basin_auto</code>: PCR-BM ile otomatik \u00e7ekim havzas\u0131","text":"<p><code>basin_auto</code>, \u00e7ekicileri \u00f6nceden tan\u0131mlaman\u0131z\u0131 gerektirmeden ke\u015ffeder. Yakla\u015f\u0131m:</p> <ol> <li>Y\u00f6r\u00fcngeleri g\u00f6zlem uzay\u0131nda bir h\u00fccre \u0131zgaras\u0131na kuantalar (<code>grid_res</code>, <code>obs_min/obs_max</code>).</li> <li>Zaman penceresi i\u00e7inde ziyaret edilen benzersiz h\u00fccre oran\u0131 k\u00fc\u00e7\u00fckse tekrarl\u0131l\u0131k (recurrence) tespit eder (<code>window</code>, <code>u_th</code>, <code>recur_windows</code>).</li> <li>Tespit edilen par\u00e7alardan bir parmak izi (fingerprint) \u00e7\u0131kar\u0131r ve benzerlerini birle\u015ftirir (<code>s_merge</code>, <code>merge_downsample</code>).</li> <li>Y\u00f6r\u00fcngeleri \u00e7ekicilere s\u00fcreklilik/persistans ile atar: bir \u00e7ekiciye ait h\u00fccre setinde art arda <code>p_in</code> isabet (hit) g\u00f6r\u00fcrse etiketler.</li> </ol>"},{"location":"tr/guides/analysis/basin/#online-offline","title":"Online / Offline","text":"<ul> <li><code>online=True</code> (\u00f6nerilen): Entegrasyon s\u0131ras\u0131nda analiz yapar; tam y\u00f6r\u00fcnge saklamaz. B\u00fcy\u00fck batch\u2019lerde bellek a\u00e7\u0131s\u0131ndan \u00e7ok daha iyidir.</li> <li><code>online=False</code>: Tam y\u00f6r\u00fcngeleri saklay\u0131p sonra i\u015fler; hata ay\u0131klama/deney i\u00e7in yararl\u0131 ama bellek t\u00fcketir. Bu modda <code>max_memory_bytes</code> ile koruma devreye girebilir.</li> </ul>"},{"location":"tr/guides/analysis/basin/#parametreler-ozet_1","title":"Parametreler (\u00f6zet)","text":"<ul> <li> <p><code>ic</code> veya <code>ic_grid</code> (+ <code>ic_bounds</code>)   IC\u2019leri do\u011frudan verin ya da uniform grid \u00fcretin.</p> </li> <li> <p><code>observe_vars</code>   G\u00f6zlem uzay\u0131 de\u011fi\u015fkenleri (isim veya indeks). Boyut <code>d</code>, <code>grid_res/obs_min/obs_max</code> ile uyumlu olmal\u0131d\u0131r.</p> </li> <li> <p><code>obs_min</code>, <code>obs_max</code>   G\u00f6zlem uzay\u0131n\u0131n alt/\u00fcst s\u0131n\u0131rlar\u0131. <code>None</code> ise <code>ic_bounds</code>\u2019tan t\u00fcretilebilir.</p> </li> <li> <p><code>grid_res</code>   Her g\u00f6zlem boyutu i\u00e7in h\u00fccre say\u0131s\u0131. Toplam h\u00fccre say\u0131s\u0131 <code>product(grid_res)</code>.</p> </li> <li> <p><code>max_samples</code>, <code>transient_samples</code> </p> </li> <li><code>max_samples</code>: her IC i\u00e7in en fazla \u00f6rnek/ad\u0131m</li> <li> <p><code>transient_samples</code>: tekrarl\u0131l\u0131k tespiti ba\u015flamadan \u00f6nce yok say\u0131lacak \u00f6rnek say\u0131s\u0131</p> </li> <li> <p><code>window</code>, <code>u_th</code>, <code>recur_windows</code>   Tekrarl\u0131l\u0131k (recurrence) tespiti ayarlar\u0131:</p> </li> <li><code>window</code>: kayan pencere boyu</li> <li><code>u_th</code>: <code>unique_cells/window &lt;= u_th</code> ko\u015fulu sa\u011flan\u0131rsa \u201ctekrarl\u0131yor\u201d say</li> <li> <p><code>recur_windows</code>: bu ko\u015fulun art arda ka\u00e7 pencerede sa\u011flanmas\u0131 gerekti\u011fi</p> </li> <li> <p><code>p_in</code>   Persistans e\u015fi\u011fi: bir \u00e7ekici h\u00fccre setinde art arda ka\u00e7 isabetle atanaca\u011f\u0131. <code>0</code> verilirse persistansla atama kapat\u0131l\u0131r.</p> </li> <li> <p><code>s_merge</code>   Parmak izi benzerli\u011fi (Jaccard) bu e\u015fi\u011fin \u00fcst\u00fcndeyse \u00e7ekiciler birle\u015ftirilir.</p> </li> <li> <p><code>merge_downsample</code>   Parmak izi \u00e7\u0131kar\u0131rken daha kaba bir \u0131zgaraya indirgeme (robust birle\u015ftirme i\u00e7in).</p> </li> <li> <p><code>b_max</code>, <code>blowup_vars</code>, <code>outside_limit</code> </p> </li> <li><code>b_max</code>: ta\u015fma e\u015fi\u011fi</li> <li> <p><code>outside_limit</code>: art arda ka\u00e7 \u00f6rnek <code>obs_min/obs_max</code> d\u0131\u015f\u0131nda kal\u0131nca <code>OUTSIDE</code></p> </li> <li> <p><code>parallel_mode</code>, <code>max_workers</code>   B\u00fcy\u00fck batch\u2019lerde process paralelli\u011fi kullan\u0131labilir (<code>parallel_mode=\"process\"</code> veya <code>\"auto\"</code>).</p> </li> <li> <p><code>post_detect_samples</code>   Tekrarl\u0131l\u0131k tespitinden sonra kan\u0131t segmentine eklenecek ek \u00f6rnek say\u0131s\u0131.</p> </li> <li> <p><code>refine_unresolved</code> (online mod)   \u0130lk ge\u00e7i\u015fte <code>UNRESOLVED</code> kalan noktalar\u0131, \u00e7ekici kayd\u0131 (registry) tamamland\u0131ktan sonra yeniden persistans taramas\u0131yla atamay\u0131 dener.</p> </li> <li> <p><code>online_max_attr</code>, <code>online_max_cells</code>   Online modda persistans taramas\u0131 i\u00e7in belle\u011fi s\u0131n\u0131rlamak \u00fczere:</p> </li> <li>izlenecek maksimum \u00e7ekici say\u0131s\u0131</li> <li>\u00e7ekici ba\u015f\u0131na saklanacak maksimum h\u00fccre say\u0131s\u0131</li> </ul>"},{"location":"tr/guides/analysis/basin/#ckt_1","title":"\u00c7\u0131kt\u0131","text":"<p><code>BasinResult</code> d\u00f6ner:</p> <ul> <li><code>labels</code>: her IC i\u00e7in \u00e7ekici kimli\u011fi veya <code>BLOWUP/OUTSIDE/UNRESOLVED</code></li> <li><code>registry</code>: ke\u015ffedilen \u00e7ekiciler (parmak izi + h\u00fccre setleri)</li> <li><code>meta</code>: algoritma parametreleri ve y\u00fcr\u00fctme metadatas\u0131</li> </ul>"},{"location":"tr/guides/analysis/basin/#ksa-ornek_1","title":"K\u0131sa \u00f6rnek","text":"<pre><code>from dynlib.analysis.basin_auto import basin_auto\nimport numpy as np\n\nresult = basin_auto(\n    sim,\n    ic_grid=[300, 300],\n    ic_bounds=[(-2.0, 2.0), (-2.0, 2.0)],\n    mode=\"map\",\n    observe_vars=(\"x\", \"y\"),\n    obs_min=[-2.0, -2.0],\n    obs_max=[2.0, 2.0],\n    grid_res=64,\n    max_samples=1500,\n    transient_samples=100,\n    window=64,\n    u_th=0.6,\n    recur_windows=3,\n    p_in=8,\n    online=True,\n)\n\nlabels_2d = result.labels.reshape(300, 300)\n</code></pre>"},{"location":"tr/guides/analysis/basin/#ayar-onerileri-pratik","title":"Ayar \u00f6nerileri (pratik)","text":"<ul> <li>Basit periyodik \u00e7ekiciler: <code>u_th</code> daha k\u00fc\u00e7\u00fck (0.3\u20130.5), <code>window</code> daha k\u00fc\u00e7\u00fck (32\u201364).</li> <li>Kaotik \u00e7ekiciler: <code>u_th</code> daha b\u00fcy\u00fck (0.6\u20130.8), <code>window</code> daha b\u00fcy\u00fck (64\u2013256).</li> <li>\u00c7ok <code>UNRESOLVED</code>: <code>max_samples</code> art\u0131r\u0131n; <code>u_th</code> d\u00fc\u015f\u00fcr\u00fcn; <code>window</code> art\u0131r\u0131n.</li> <li>\u00c7ekiciler gereksiz birle\u015fiyor: <code>s_merge</code> art\u0131r\u0131n veya <code>merge_downsample</code> d\u00fc\u015f\u00fcr\u00fcn.</li> <li>Birle\u015fmesi gerekenler birle\u015fmiyor: <code>s_merge</code> d\u00fc\u015f\u00fcr\u00fcn veya <code>merge_downsample</code> art\u0131r\u0131n.</li> </ul>"},{"location":"tr/guides/analysis/bifurcation/","title":"\u00c7atallanma (Bifurcation) diyagramlar\u0131","text":"<p>\u00c7atallanma diyagram\u0131, bir parametre taramas\u0131n\u0131n \u00e7\u0131kt\u0131s\u0131n\u0131 sonradan i\u015fleyerek \u00fcretilir: <code>dynlib.analysis.sweep</code> i\u00e7indeki tarama yard\u0131mc\u0131lar\u0131 (\u00f6r. <code>traj_sweep</code>, <code>lyapunov_mle_sweep</code>, <code>lyapunov_spectrum_sweep</code>) her parametre de\u011feri i\u00e7in bir y\u00f6r\u00fcnge (veya te\u015fhis dizisi) kaydeder. Ard\u0131ndan <code>SweepResult.bifurcation(var)</code> bu kay\u0131tlar\u0131 al\u0131r ve diyagramda g\u00f6r\u00fcnen sa\u00e7\u0131l\u0131m noktalar\u0131na (x-ekseni: parametre, y-ekseni: se\u00e7ilen de\u011fi\u015fken) d\u00f6n\u00fc\u015ft\u00fcr\u00fcr.</p>"},{"location":"tr/guides/analysis/bifurcation/#is-aks","title":"\u0130\u015f ak\u0131\u015f\u0131","text":"<ol> <li> <p>Taramay\u0131 \u00e7al\u0131\u015ft\u0131r\u0131n: \u0130nceledi\u011finiz parametre i\u00e7in <code>dynlib.analysis.sweep.traj_sweep</code> (veya ba\u015fka bir tarama yard\u0131mc\u0131s\u0131) ile tarama yap\u0131n. Diyagramda kullanaca\u011f\u0131n\u0131z de\u011fi\u015fkenleri <code>record_vars</code> ile kaydedin. Ba\u015flang\u0131\u00e7taki ge\u00e7ici rejimi (transient) atmak istiyorsan\u0131z tarama taraf\u0131nda <code>transient</code>/kay\u0131t aral\u0131\u011f\u0131 ayarlar\u0131n\u0131 kullan\u0131n; ayr\u0131ca \u00e7\u0131kar\u0131m a\u015famas\u0131nda <code>tail</code> gibi se\u00e7eneklerle yaln\u0131zca son k\u0131s\u0131mlar\u0131 alabilirsiniz.</p> </li> <li> <p>\u00c7atallanma noktalar\u0131n\u0131 \u00e7\u0131kar\u0131n: <code>result.bifurcation(\"x\")</code> bir <code>BifurcationExtractor</code> d\u00f6nd\u00fcr\u00fcr. Bu nesne, farkl\u0131 \u00e7\u0131kar\u0131m stratejileri i\u00e7in a\u015fa\u011f\u0131daki y\u00f6ntemleri sa\u011flar:</p> </li> <li><code>.all()</code> : Kaydedilmi\u015f t\u00fcm noktalar\u0131 kullan\u0131r (filtre yok).</li> <li><code>.tail(n)</code> : Her parametre de\u011feri i\u00e7in kayd\u0131n son n \u00f6rne\u011fini al\u0131r.</li> <li><code>.final()</code> : Her parametre de\u011feri i\u00e7in son tek noktay\u0131 al\u0131r.</li> <li><code>.extrema(...)</code> : Yerel maksimum/minimum noktalar\u0131n\u0131 (veya ikisini birden) \u00e7\u0131kar\u0131r. \u0130ste\u011fe ba\u011fl\u0131 <code>tail=...</code> ile yaln\u0131zca son b\u00f6l\u00fcmde arama yapar; <code>min_peak_distance</code> ile art arda tepe/\u00e7ukur se\u00e7iminde mesafe k\u0131s\u0131t\u0131 uygular.</li> <li> <p><code>.poincare(...)</code> : Se\u00e7ilen <code>section_var</code> serisinin <code>level</code> d\u00fczeyini belirli y\u00f6nde (<code>direction</code>) kesti\u011fi anlarda, hedef de\u011fi\u015fkenin kesit de\u011ferlerini (do\u011frusal enterpolasyonla) \u00fcretir.</p> </li> <li> <p>Sonucu \u00e7izin: <code>dynlib.plot.bifurcation_diagram(extractor)</code> ile do\u011frudan \u00e7izebilir veya \u00e7\u0131kar\u0131c\u0131n\u0131n <code>p</code>/<code>y</code> dizilerini kendi \u00e7izim rutinlerinize verebilirsiniz. \u00dcretilen <code>BifurcationResult</code>, eksen etiketleri ve tarama \u0131zgaras\u0131 i\u00e7in gerekli bilgileri (<code>param_name</code>, <code>values</code>, <code>meta</code>) birlikte ta\u015f\u0131r.</p> </li> </ol> <p>Bif\u00fcrkasyon diyagram\u0131 hesaplama ve \u00e7izdirme i\u00e7in a\u015fa\u011f\u0131daki \u00f6rneklere bakabilirsiniz: - Bif\u00fcrkasyon \u00d6rnekleri</p>"},{"location":"tr/guides/analysis/bifurcation/#notlar","title":"Notlar","text":"<ul> <li>Tarama s\u0131ras\u0131nda baz\u0131 parametre noktalar\u0131nda hi\u00e7 \u00f6rnek kaydedilmediyse, <code>.tail()</code>/<code>.final()</code> gibi modlar hata verir (\u00f6r. <code>No samples recorded; ...</code>). B\u00f6yle bir durumda <code>T/N</code> de\u011ferlerini art\u0131r\u0131n veya <code>record_interval</code> ayar\u0131n\u0131 g\u00f6zden ge\u00e7irin.</li> <li>\u00c7\u0131kar\u0131c\u0131, parametre noktalar\u0131 aras\u0131nda farkl\u0131 uzunlukta y\u00f6r\u00fcngeler olsa bile \u00e7al\u0131\u015facak \u015fekilde tasarlanm\u0131\u015ft\u0131r; her parametre de\u011feri i\u00e7in ilgili seriyi ayr\u0131 i\u015fler ve sonu\u00e7lar\u0131 birle\u015ftirir.</li> <li>Bir\u00e7ok tarama yard\u0131mc\u0131s\u0131 <code>meta</code> i\u00e7ine stepper ayarlar\u0131n\u0131 (<code>dt</code>, <code>record_interval</code> vb.) ekler. Bu sayede diyagramdaki noktalar\u0131n ayn\u0131 ko\u015fullarda \u00fcretilip \u00fcretilmedi\u011fini sonradan denetleyebilirsiniz.</li> <li>Yay\u0131n kalitesinde fig\u00fcrler i\u00e7in, \u00e7atallanma \u00e7\u0131kt\u0131s\u0131n\u0131 kendi d\u00fczeninizde kullanmak \u00fczere <code>p</code>/<code>y</code> dizilerini al\u0131p <code>series.plot</code>, <code>phase.xy</code> veya <code>fig.grid</code> gibi \u00e7izim yard\u0131mc\u0131lar\u0131yla birle\u015ftirmek genellikle daha esnektir.</li> </ul>"},{"location":"tr/guides/analysis/fixed-points/","title":"Sabit noktalar ve dengeler","text":"<p>Sabit noktalar (haritalar i\u00e7in) ya da denge noktalar\u0131 (ODE modelleri i\u00e7in), k\u00f6k bulma diliyle <code>g(x) = 0</code> ko\u015fulunu sa\u011flayan durum vekt\u00f6rleridir.</p> <ul> <li>ODE\u2019lerde bu genellikle <code>f(x, p) = 0</code> (vekt\u00f6r alan\u0131 s\u0131f\u0131r).</li> <li>Haritalarda ise sabit nokta, <code>x_{n+1} = F(x_n, p)</code> i\u00e7in <code>F(x, p) - x = 0</code> demektir.</li> </ul> <p>Dynlib bunu bulmak i\u00e7in iki giri\u015f noktas\u0131 sunar:</p> <ol> <li> <p><code>dynlib.analysis.fixed_points</code> i\u00e7indeki ba\u011f\u0131ms\u0131z yard\u0131mc\u0131: <code>find_fixed_points(...)</code>    Kullan\u0131c\u0131 taraf\u0131ndan sa\u011flanan <code>f(x, params)</code> (ve iste\u011fe ba\u011fl\u0131 <code>jac(x, params)</code>) \u00fczerinden \u00e7al\u0131\u015f\u0131r.</p> </li> <li> <p>Derlenmi\u015f model \u00fczerinde kolay y\u00f6ntem: <code>FullModel.fixed_points(...)</code>    Derlenmi\u015f modelin parametre varsay\u0131lanlar\u0131n\u0131, \u00e7al\u0131\u015fma zaman\u0131 \u00e7al\u0131\u015fma alan\u0131n\u0131 ve (varsa) analitik Jacobian\u2019\u0131n\u0131 otomatik ba\u011flayarak ayn\u0131 \u00e7\u00f6z\u00fcc\u00fcy\u00fc kullan\u0131r.</p> </li> </ol> <p>Her iki yol da \u00f6z\u00fcnde ayn\u0131 Newton tabanl\u0131 \u00e7\u00f6z\u00fcc\u00fcy\u00fc \u00e7al\u0131\u015ft\u0131r\u0131r (yak\u0131nsama \u00f6l\u00e7\u00fctleri, \u00e7\u00f6z\u00fcm birle\u015ftirme ve kararl\u0131l\u0131k te\u015fhisleri dahil). Pratikte \u00e7o\u011fu kullan\u0131c\u0131 i\u00e7in tercih edilen yol <code>FullModel.fixed_points(...)</code> olur; \u00e7\u00fcnk\u00fc parametreleri/tohumlar\u0131/Jacobian\u2019\u0131 derlenmi\u015f modelden do\u011fru bi\u00e7imde ba\u011flar.</p> <p>Not: API sade kals\u0131n diye dok\u00fcmantasyonda \u201cfixed point\u201d terimi kullan\u0131l\u0131r. ODE ba\u011flam\u0131nda bu, \u201cdenge noktas\u0131 (equilibrium)\u201d ile ayn\u0131 \u015feydir.</p>"},{"location":"tr/guides/analysis/fixed-points/#hzl-baslangc","title":"H\u0131zl\u0131 ba\u015flang\u0131\u00e7","text":"<p>Sabit nokta bulmak i\u00e7in tipik olarak \u015funlar gerekir:</p> <ul> <li>Bir model (<code>FullModel.fixed_points(...)</code> i\u00e7in) veya bir sa\u011f taraf fonksiyonu (<code>find_fixed_points(...)</code> i\u00e7in),</li> <li>Beklenen \u00e7\u00f6z\u00fcmlere yak\u0131n ba\u015flang\u0131\u00e7 tahminleri (tohumlar / seeds),</li> <li>\u0130ste\u011fe ba\u011fl\u0131 parametreler ve \u00e7\u00f6z\u00fcc\u00fc ayarlar\u0131.</li> </ul> <p>Derlenmi\u015f bir model ile:</p> <pre><code>from dynlib.analysis import FixedPointConfig\n\n# Modelinizi olu\u015fturun veya y\u00fckleyin\nmodel = ...  # \u00f6rn: from dynlib import build; model = build(\"model.toml\")\n\n# \u00c7\u00f6z\u00fcc\u00fcy\u00fc yap\u0131land\u0131r\u0131n\ncfg = FixedPointConfig(tol=1e-10, classify=True)\n\n# Sabit noktalar\u0131 bulun\nresult = model.fixed_points(\n    params={\"param_name\": value},  # iste\u011fe ba\u011fl\u0131: parametre ge\u00e7ersiz k\u0131lmalar\u0131\n    seeds=[[x1, y1], [x2, y2]],    # ba\u015flang\u0131\u00e7 tahminleri (n_seeds, n_state)\n    cfg=cfg,\n)\n\nprint(\"Fixed points:\", result.points)\nprint(\"Stability:\", result.stability)\n</code></pre> <p>Bu \u00e7a\u011fr\u0131, \u00e7\u00f6z\u00fcmleri ve tan\u0131lama bilgilerini i\u00e7eren bir <code>FixedPointResult</code> d\u00f6nd\u00fcr\u00fcr.</p>"},{"location":"tr/guides/analysis/fixed-points/#find_fixed_points","title":"<code>find_fixed_points(...)</code>","text":"<p>Bu yard\u0131mc\u0131, verilen bir veya daha fazla tohumdan ba\u015flayarak <code>f(x, params) = 0</code> denklemini Newton y\u00f6ntemiyle \u00e7\u00f6zer.</p>"},{"location":"tr/guides/analysis/fixed-points/#girdi-sozlesmeleri","title":"Girdi s\u00f6zle\u015fmeleri","text":"<ul> <li>Fonksiyon imzas\u0131: <code>f(x, params)</code> NumPy dizileri al\u0131r ve <code>x</code> ile ayn\u0131 \u015fekle sahip bir \u00e7\u0131kt\u0131 d\u00f6nd\u00fcrmelidir.  </li> <li>Jacobian (iste\u011fe ba\u011fl\u0131): <code>jac(x, params)</code> sa\u011flan\u0131rsa, \u00e7\u0131kt\u0131s\u0131 \u00e7\u00f6z\u00fcm s\u0131ras\u0131nda <code>(n_state, n_state)</code> \u015fekline zorlan\u0131r/do\u011frulan\u0131r.</li> </ul>"},{"location":"tr/guides/analysis/fixed-points/#tohum-ve-parametre-bicimleri","title":"Tohum ve parametre bi\u00e7imleri","text":"<ul> <li><code>seeds</code>, tek bir vekt\u00f6r (<code>(n_state,)</code>) ya da bir parti (<code>(n_seeds, n_state)</code>) olabilir. Tek vekt\u00f6r verilirse otomatik olarak tek tohumluk partiye \u00e7evrilir.</li> <li>\u015eekil uyu\u015fmazsa yard\u0131mc\u0131 hata verir (sessizce d\u00fczeltmeye \u00e7al\u0131\u015fmaz).</li> <li><code>params</code>, 1-boyutlu bir vekt\u00f6r olmal\u0131d\u0131r. Parametre yoksa <code>None</code> ge\u00e7ebilirsiniz; bu durumda s\u0131f\u0131r uzunluklu vekt\u00f6r kullan\u0131l\u0131r.</li> </ul>"},{"location":"tr/guides/analysis/fixed-points/#newton-ayarlar","title":"Newton ayarlar\u0131","text":"<p><code>cfg</code> (a\u015fa\u011f\u0131daki <code>FixedPointConfig</code>) \u015fu davran\u0131\u015flar\u0131 belirler:</p> <ul> <li>yak\u0131nsama tolerans\u0131 (<code>tol</code>)</li> <li>tohum ba\u015f\u0131na azami iterasyon (<code>max_iter</code>)</li> <li>sonlu fark Jacobian ad\u0131m\u0131 (<code>fd_eps</code>)</li> <li>\u00f6zde\u011fer tabanl\u0131 kararl\u0131l\u0131k etiketlemesi (<code>classify</code>)</li> <li>problemin t\u00fcr\u00fc (<code>kind</code>: <code>\"ode\"</code> veya <code>\"map\"</code>)</li> </ul> <p>\u00c7\u00f6z\u00fcc\u00fc, art\u0131k normu <code>tol</code> alt\u0131na d\u00fc\u015fer d\u00fc\u015fmez ilgili tohum i\u00e7in yak\u0131nsam\u0131\u015f sayar.</p>"},{"location":"tr/guides/analysis/fixed-points/#yinelenen-cozumleri-birlestirme-de-duplication","title":"Yinelenen \u00e7\u00f6z\u00fcmleri birle\u015ftirme (de-duplication)","text":"<p>\u00c7\u00f6z\u00fcmler bulundu\u011funda, yak\u0131n olan k\u00f6kler birle\u015ftirilir:</p> <ul> <li><code>unique_tol &gt; 0</code> ise, birbirine <code>unique_tol</code> mesafesinden yak\u0131n \u00e7\u00f6z\u00fcmler ayn\u0131 kabul edilir.</li> <li>Birle\u015ftirme s\u0131ras\u0131nda, ayn\u0131 k\u00fcmeye d\u00fc\u015fen adaylardan art\u0131\u011f\u0131 daha k\u00fc\u00e7\u00fck olan korunur.</li> <li><code>unique_tol</code> de\u011ferini <code>None</code> veya <code>\u2264 0</code> yapmak birle\u015ftirmeyi kapat\u0131r (yak\u0131nsayan her tohum ayr\u0131 ayr\u0131 tutulur).</li> </ul>"},{"location":"tr/guides/analysis/fixed-points/#kararllk-snflandrmas","title":"Kararl\u0131l\u0131k s\u0131n\u0131fland\u0131rmas\u0131","text":"<p><code>cfg.classify=True</code> ise her benzersiz \u00e7\u00f6z\u00fcm i\u00e7in \u00f6zde\u011ferler hesaplan\u0131r ve <code>cfg.stability_tol</code> marj\u0131na g\u00f6re etiket verilir:</p> <ul> <li>Etiketler: <code>stable</code>, <code>unstable</code>, <code>neutral</code>, <code>saddle</code></li> <li>ODE\u2019lerde \u00f6l\u00e7\u00fct: \u00f6zde\u011ferlerin ger\u00e7el k\u0131s\u0131mlar\u0131 (tamam\u0131 &lt; 0 ise kararl\u0131 vb.)</li> <li>Haritalarda \u00f6l\u00e7\u00fct: \u00f6zde\u011ferlerin mutlak de\u011feri (tamam\u0131 &lt; 1 ise kararl\u0131 vb.)</li> </ul> <p>Haritalar i\u00e7in not: \u00c7\u00f6z\u00fcc\u00fc k\u00f6k fonksiyonunu <code>g(x)=F(x)-x</code> bi\u00e7iminde ele ald\u0131\u011f\u0131 i\u00e7in, kararl\u0131l\u0131k analizi s\u0131ras\u0131nda \u00f6zde\u011ferler \u201charitan\u0131n t\u00fcrevi\u201d \u00fczerinden de\u011ferlendirilir (bu ama\u00e7la gerekli d\u00f6n\u00fc\u015f\u00fcm i\u00e7erde yap\u0131l\u0131r).</p>"},{"location":"tr/guides/analysis/fixed-points/#tanlama-meta","title":"Tan\u0131lama (meta)","text":"<p>Her \u00e7al\u0131\u015ft\u0131rma, tohum baz\u0131nda ve benzersiz \u00e7\u00f6z\u00fcm baz\u0131nda te\u015fhis bilgilerini kaydeder. <code>FixedPointResult.meta</code> i\u00e7inde \u015funlar bulunur:</p> <ul> <li><code>seed_points</code>: Her tohumdan \u00e7\u0131kan son iterat (yak\u0131nsamasa bile).</li> <li><code>seed_residuals</code>: Her tohum i\u00e7in son art\u0131k normu.</li> <li><code>seed_converged</code>: Her tohumun yak\u0131nsay\u0131p yak\u0131nsamad\u0131\u011f\u0131.</li> <li><code>seed_iterations</code>: Tohum ba\u015f\u0131na iterasyon say\u0131s\u0131.</li> <li><code>seed_to_unique</code>: Tohum indeksinden benzersiz \u00e7\u00f6z\u00fcm indeksine e\u015fleme (<code>-1</code>: yak\u0131nsamad\u0131).</li> <li><code>unique_seed_indices</code>: Benzersiz \u00e7\u00f6z\u00fcmleri temsil eden kaynak tohum indeksleri.</li> <li><code>params</code>: Kullan\u0131lan parametre vekt\u00f6r\u00fc.</li> <li><code>config</code>: Kullan\u0131lan <code>FixedPointConfig</code> nesnesi.</li> </ul>"},{"location":"tr/guides/analysis/fixed-points/#fixedpointconfig","title":"<code>FixedPointConfig</code>","text":"Alan A\u00e7\u0131klama <code>method</code> \u00c7\u00f6z\u00fcc\u00fc y\u00f6ntemi ad\u0131 (\u015fimdilik yaln\u0131zca <code>\"newton\"</code>). <code>tol</code> Yak\u0131nsama i\u00e7in art\u0131k (residual) tolerans\u0131 (varsay\u0131lan <code>1e-10</code>). <code>max_iter</code> Tohum ba\u015f\u0131na en fazla Newton iterasyonu (varsay\u0131lan <code>50</code>). <code>unique_tol</code> \u00c7\u00f6z\u00fcmleri birle\u015ftirmek i\u00e7in mesafe e\u015fi\u011fi (varsay\u0131lan <code>1e-6</code>). Birle\u015ftirmeyi kapatmak i\u00e7in <code>None</code> veya <code>\u2264 0</code>. <code>jac</code> Jacobian modu: <code>\"auto\"</code> (varsa sa\u011flanan/analitik, yoksa sonlu fark), <code>\"fd\"</code> (sonlu fark\u0131 zorla), <code>\"provided\"</code> (mutlaka <code>jac</code> verilmi\u015f olmal\u0131). <code>fd_eps</code> Sonlu fark Jacobian\u2019\u0131 i\u00e7in ad\u0131m boyu (varsay\u0131lan <code>1e-6</code>). <code>classify</code> \u00d6zde\u011ferleri hesaplay\u0131p kararl\u0131l\u0131k etiketi \u00fcret (varsay\u0131lan <code>True</code>). <code>kind</code> <code>\"ode\"</code> veya <code>\"map\"</code>. <code>find_fixed_points</code> bunu do\u011frular ve s\u0131n\u0131fland\u0131rmada kullan\u0131r. <code>stability_tol</code> N\u00f6trl\u00fck marj\u0131 (ODE: sanal eksen civar\u0131; harita: birim \u00e7ember civar\u0131), varsay\u0131lan <code>1e-6</code>."},{"location":"tr/guides/analysis/fixed-points/#fixedpointresult-nasl-yorumlanr","title":"<code>FixedPointResult</code> nas\u0131l yorumlan\u0131r?","text":"<p><code>FixedPointResult</code> bulunan sabit noktalar\u0131 ve ilgili \u00e7\u0131kt\u0131lar\u0131n\u0131 ta\u015f\u0131r:</p> <ul> <li><code>points</code>: (n_points, n_state) bi\u00e7iminde NumPy dizisi. (Birle\u015ftirme a\u00e7\u0131ksa <code>unique_tol</code> ile tekille\u015ftirilmi\u015ftir.)</li> <li><code>residuals</code>: Her benzersiz noktan\u0131n art\u0131k normu (yak\u0131nsayan \u00e7\u00f6z\u00fcmlerde \u00e7ok k\u00fc\u00e7\u00fck olmal\u0131d\u0131r; \u00f6r. <code>~1e-10</code> ve alt\u0131).</li> <li><code>jacobians</code>: Her benzersiz noktada kullan\u0131lan Jacobian matrisleri listesi veya <code>None</code>.  </li> <li>Haritalarda burada tutulan Jacobian, k\u00f6k fonksiyonuna (<code>F(x)-x</code>) aittir.</li> <li><code>eigvals</code>: Her nokta i\u00e7in \u00f6zde\u011fer dizileri listesi veya <code>None</code> (yaln\u0131zca <code>classify=True</code> iken).</li> <li><code>stability</code>: Her nokta i\u00e7in kararl\u0131l\u0131k etiketi listesi veya <code>None</code>.</li> <li><code>meta</code>: Ayr\u0131nt\u0131l\u0131 tan\u0131lama s\u00f6zl\u00fc\u011f\u00fc (bkz. \u00fcstteki \u201cTan\u0131lama\u201d).</li> </ul> <p>Bir tohum yak\u0131nsamazsa, \u00f6nce <code>result.meta[\"seed_converged\"]</code> ve <code>result.meta[\"seed_residuals\"]</code> alanlar\u0131na bak\u0131n; \u00e7o\u011fu durumda daha iyi tohumlar, daha uygun <code>max_iter</code> veya <code>tol</code> se\u00e7imi gerekir.</p>"},{"location":"tr/guides/analysis/fixed-points/#fullmodelfixed_points","title":"<code>FullModel.fixed_points(...)</code>","text":"<p>Derlenmi\u015f bir <code>FullModel</code> \u00fczerinde bu y\u00f6ntemi \u00e7a\u011f\u0131rmak, k\u00f6k bulmay\u0131 modelin \u00e7al\u0131\u015fma zaman\u0131 \u00fczerinden y\u00fcr\u00fct\u00fcr; b\u00f6ylece tutarl\u0131 varsay\u0131lanlar ve (varsa) analitik Jacobian kullan\u0131m\u0131 otomatikle\u015fir:</p> <ul> <li><code>params</code> ve <code>seeds</code>:</li> <li>do\u011frudan dizi/vekt\u00f6r verebilirsiniz,</li> <li>ya da ad \u2192 de\u011fer e\u015flemesi vererek modelin varsay\u0131lan parametre/durum vekt\u00f6r\u00fcn\u00fc \u201cse\u00e7erek\u201d g\u00fcncelleyebilirsiniz.</li> <li><code>cfg</code> vermezseniz varsay\u0131lan <code>FixedPointConfig()</code> kullan\u0131l\u0131r; tek tek <code>tol</code>, <code>max_iter</code>, <code>unique_tol</code>, <code>classify</code> gibi alanlar\u0131 ayr\u0131ca ge\u00e7erseniz <code>cfg</code> \u00fczerinde ilgili alanlar ge\u00e7ersiz k\u0131l\u0131n\u0131r.</li> <li><code>jac</code> se\u00e7ene\u011fi:</li> <li><code>\"auto\"</code>: model Jacobian\u2019\u0131 varsa kullan, yoksa sonlu farka d\u00fc\u015f</li> <li><code>\"fd\"</code>: sonlu fark\u0131 zorla</li> <li><code>\"analytic\"</code>: model Jacobian\u2019\u0131n\u0131 zorla (model Jacobian sunmuyorsa hata)</li> <li><code>t</code>: otonom olmayan sistemlerde de\u011ferlendirme zaman\u0131. Varsay\u0131lan <code>spec.sim.t0</code>\u2019d\u0131r.</li> </ul> <p>Haritalar i\u00e7in: y\u00f6ntemin i\u00e7erde kurdu\u011fu k\u00f6k fonksiyonu <code>F(x)-x</code> bi\u00e7imindedir; bu nedenle Newton \u00e7\u00f6z\u00fcm\u00fc ve Jacobian i\u015flemleri bu k\u00f6k fonksiyonuna g\u00f6re y\u00fcr\u00fct\u00fcl\u00fcr. Kararl\u0131l\u0131k analizi ise uygun d\u00f6n\u00fc\u015f\u00fcmle haritan\u0131n t\u00fcrevi \u00fczerinden yap\u0131l\u0131r.</p>"},{"location":"tr/guides/analysis/fixed-points/#ornek","title":"\u00d6rnek","text":"<p>Lojistik harita i\u00e7in bir \u00f6rnek: <code>x_{n+1} = r * x_n * (1 - x_n)</code>. <code>r=3.8</code> civar\u0131nda sabit noktalar yakla\u015f\u0131k <code>0.0</code> ve <code>0.7368</code> olur.</p> <pre><code>from dynlib.analysis import FixedPointConfig\n\ntop_cfg = FixedPointConfig(unique_tol=1e-8, classify=True)\nresult = model.fixed_points(\n    params={\"r\": 3.8},\n    seeds=[[-0.5], [0.4]],  # 1D durum i\u00e7in tohumlar (n_seeds, 1)\n    cfg=top_cfg,\n)\n\nprint(\"Number of fixed points found:\", len(result.points))\nprint(\"Fixed points:\")\nfor i, point in enumerate(result.points):\n    print(f\"  Point {i}: {point}\")\nprint(\"Stability labels:\", result.stability)\nprint(\"Residuals (should be near 0):\", result.residuals)\n</code></pre> <p>Bu \u00f6rnek, birden fazla tohumdan ba\u015flay\u0131p benzersiz sabit noktalara nas\u0131l yak\u0131nsand\u0131\u011f\u0131n\u0131 ve kararl\u0131l\u0131\u011f\u0131n \u00f6zde\u011ferlerle nas\u0131l etiketlendi\u011fini g\u00f6sterir.</p>"},{"location":"tr/guides/analysis/fixed-points/#ipuclar-ve-yaygn-sorunlar","title":"\u0130pu\u00e7lar\u0131 ve yayg\u0131n sorunlar","text":"<ul> <li>Tohum se\u00e7imi: Rastgele atmak yerine, k\u0131sa sim\u00fclasyonlar \u00e7al\u0131\u015ft\u0131r\u0131p y\u00f6r\u00fcngenin \u201cyak\u0131n\u0131ndan ge\u00e7ti\u011fi\u201d b\u00f6lgeleri tohum olarak kullan\u0131n. Gerekirse vekt\u00f6r alan\u0131n\u0131/harita iterasyonlar\u0131n\u0131 kaba bir \u0131zgarada taray\u0131n.</li> <li>Yak\u0131nsam\u0131yor: </li> <li><code>max_iter</code> art\u0131r\u0131n,  </li> <li><code>tol</code> de\u011ferini \u00e7ok agresif se\u00e7meyin (a\u015f\u0131r\u0131 k\u00fc\u00e7\u00fck tol bazen gereksiz iterasyon do\u011furur),  </li> <li>daha iyi tohumlar kullan\u0131n,  </li> <li>m\u00fcmk\u00fcnse analitik Jacobian sa\u011flay\u0131n.</li> <li>Ayn\u0131 \u00e7\u00f6z\u00fcm tekrar tekrar geliyor: <code>unique_tol</code> de\u011ferini b\u00fcy\u00fctmeyi deneyin (\u00e7ok b\u00fcy\u00fck se\u00e7mek farkl\u0131 \u00e7\u00f6z\u00fcmleri de birle\u015ftirebilir).</li> <li>Kararl\u0131l\u0131k etiketleri bekledi\u011finiz gibi de\u011fil: Harita/ODE ayr\u0131m\u0131n\u0131n do\u011fru oldu\u011fundan emin olun; <code>FullModel.fixed_points(...)</code> bunu modelden otomatik ayarlar. <code>find_fixed_points(...)</code> kullan\u0131yorsan\u0131z <code>cfg.kind</code> de\u011ferini do\u011fru verin.</li> <li>Performans: Analitik Jacobian, hem h\u0131z hem de do\u011fruluk a\u00e7\u0131s\u0131ndan genellikle sonlu farka g\u00f6re daha iyidir.</li> <li>\u015eekil hatalar\u0131: <code>seeds</code> boyutunun <code>(n_seeds, n_state)</code> ile, <code>params</code> boyutunun <code>(n_params,)</code> ile uyumlu oldu\u011fundan emin olun (\u00f6zellikle <code>find_fixed_points(...)</code> kullan\u0131rken).</li> </ul>"},{"location":"tr/guides/analysis/lyapunov/","title":"Lyapunov analizi","text":"<p>Dynlib, maksimum Lyapunov \u00fcss\u00fcn\u00fc (MLE) ve tam Lyapunov spektrumunu hesaplamak i\u00e7in \u00e7al\u0131\u015fma zaman\u0131na entegre \u201cobserver\u201d (g\u00f6zlemci) mod\u00fclleri sa\u011flar. Bu g\u00f6zlemciler, <code>dynlib.runtime.observers</code> alt\u0131nda factory (g\u00f6zlemci fabrikas\u0131) olarak sunulur. Observer\u2019lar\u0131n \u00e7al\u0131\u015fma zaman\u0131 taraf\u0131ndaki ayr\u0131nt\u0131lar\u0131 genel olarak observers rehberinde anlat\u0131l\u0131r; bu sayfa ise \u00f6zellikle <code>lyapunov_mle_observer</code> ve <code>lyapunov_spectrum_observer</code>\u2019\u0131, ister tek ba\u015f\u0131na ister ba\u015fka observer\u2019larla birlikte, pratikte nas\u0131l kullanaca\u011f\u0131n\u0131z\u0131 \u00f6zetler.</p>"},{"location":"tr/guides/analysis/lyapunov/#lyapunov-tanlamalar-ne-zaman-kullanlr","title":"Lyapunov tan\u0131lamalar\u0131 ne zaman kullan\u0131l\u0131r?","text":"<p>Lyapunov \u00fcsleri, y\u00f6r\u00fcnge boyunca sonsuz k\u00fc\u00e7\u00fck pert\u00fcrbasyonlar\u0131n ortalama olarak nas\u0131l b\u00fcy\u00fcy\u00fcp k\u00fc\u00e7\u00fcld\u00fc\u011f\u00fcn\u00fc nicelendirir:</p> <ul> <li>Pozitif MLE, ba\u015flang\u0131\u00e7 ko\u015fullar\u0131na hassas ba\u011f\u0131ml\u0131l\u0131\u011f\u0131 ve kaotik rejimleri i\u015faret eder.</li> <li>S\u0131f\u0131r veya s\u0131f\u0131ra yak\u0131n MLE, \u00e7o\u011funlukla periyodik ya da yar\u0131-periyodik hareketle ili\u015fkilidir.</li> <li>Negatif MLE, kararl\u0131 \u00e7ekicileri (\u00f6zellikle kararl\u0131 sabit noktalar / \u201csink\u201d) g\u00f6sterir.</li> </ul> <p>Lyapunov spektrumu ise tek bir \u00fcsle yetinmeyip birden fazla y\u00f6ndeki geni\u015fleme/daralma oranlar\u0131n\u0131 birlikte verir. Birden \u00e7ok karars\u0131z/kararl\u0131 y\u00f6n\u00fcn \u00f6nemli oldu\u011fu sistemlerde (\u00f6r. daha y\u00fcksek boyutlu ak\u0131\u015flar ya da baz\u0131 haritalar) daha b\u00fct\u00fcnl\u00fckl\u00fc bir kararl\u0131l\u0131k resmi sa\u011flar.</p>"},{"location":"tr/guides/analysis/lyapunov/#observer-factoryleri","title":"Observer factory\u2019leri","text":"<p>\u0130ki factory de <code>dynlib.runtime.observers</code> i\u00e7indedir ve ayn\u0131 genel kullan\u0131m desenini payla\u015f\u0131r:</p> <pre><code>from dynlib.runtime.observers import lyapunov_mle_observer, lyapunov_spectrum_observer\n\nfactory = lyapunov_mle_observer(model=sim.model, record_interval=record_every)\n</code></pre>"},{"location":"tr/guides/analysis/lyapunov/#ortak-argumanlar","title":"Ortak arg\u00fcmanlar","text":"<ul> <li><code>model</code>: Derlenmi\u015f <code>Model</code>. Do\u011frudan <code>model=...</code> verebilir ya da factory modunda b\u0131rak\u0131p <code>Sim.run(...)</code> s\u0131ras\u0131nda modelin enjekte edilmesini sa\u011flayabilirsiniz.</li> <li><code>mode</code>: <code>\"flow\"</code>, <code>\"map\"</code> veya <code>\"auto\"</code>.  </li> <li><code>\"auto\"</code> se\u00e7ilirse <code>model.spec.kind</code> \u00fczerinden t\u00fcretilir (<code>\"ode\" -&gt; \"flow\"</code>, <code>\"map\" -&gt; \"map\"</code>).  </li> <li><code>\"flow\"</code>: payda (denominator) zamand\u0131r.  </li> <li><code>\"map\"</code>: payda iterasyon/ad\u0131m say\u0131s\u0131d\u0131r.</li> <li><code>record_interval</code> / <code>trace_plan</code>: Yak\u0131nsama izinin (trace) hangi aral\u0131kla \u00f6rneklenece\u011fini belirler. Uygulamada izleme, bu observer\u2019lar\u0131n standart \u00e7\u0131kt\u0131s\u0131n\u0131n bir par\u00e7as\u0131d\u0131r; bellek kullan\u0131m\u0131n\u0131 azaltmak i\u00e7in daha b\u00fcy\u00fck bir <code>record_interval</code> veya uygun bir <code>trace_plan</code> se\u00e7in.</li> <li><code>prefer_variational_combined</code> (MLE i\u00e7in): Stepper destekliyorsa, durum + tanjant vekt\u00f6r\u00fcn\u00fcn birle\u015fik entegrasyonunu (combined variational stepping) tercih eder; destek yoksa stepper\u2019\u0131n tanjant-ad\u0131m\u0131 yoluna (tangent-only variational stepping) d\u00fc\u015fer.</li> </ul>"},{"location":"tr/guides/analysis/lyapunov/#spektruma-ozgu-argumanlar","title":"Spektruma \u00f6zg\u00fc arg\u00fcmanlar","text":"<ul> <li><code>k</code>: Hesaplanacak \u00f6nde gelen \u00fcs say\u0131s\u0131. \u0130lk \u00fcs MLE\u2019dir. (<code>1 &lt;= k &lt;= n_state</code> olmal\u0131.)</li> <li><code>init_basis</code>: \u0130sterseniz ba\u015flang\u0131\u00e7 i\u00e7in <code>(n_state, k)</code> boyutlu bir ba\u015flang\u0131\u00e7 taban\u0131 verebilirsiniz; verilmezse kanonik taban kullan\u0131l\u0131r.</li> </ul>"},{"location":"tr/guides/analysis/lyapunov/#calstrcstepper-gereksinimleri","title":"\u00c7al\u0131\u015ft\u0131r\u0131c\u0131/stepper gereksinimleri","text":"<p>Her iki observer da <code>ObserverRequirements</code> \u00fczerinden gereksinimlerini beyan eder (\u00f6zellikle <code>need_jvp=True</code>). Ayr\u0131ca:</p> <ul> <li><code>\"flow\"</code> modunda, say\u0131sal olarak tutarl\u0131 sonu\u00e7lar i\u00e7in stepper\u2019\u0131n varyasyonel ad\u0131mlama deste\u011fi gerekir. Bu destek yoksa observer hata verir ve uyumlu stepper\u2019lara y\u00f6nlendirir.</li> <li><code>\"map\"</code> modunda, tanjant evrimi <code>J*v</code> (Jacobian\u2013vekt\u00f6r \u00e7arp\u0131m\u0131, JVP) ile y\u00fcr\u00fct\u00fcld\u00fc\u011f\u00fcnden stepper\u2019\u0131n varyasyonel ad\u0131m deste\u011fi zorunlu de\u011fildir; ancak modelin <code>jvp</code> sa\u011flamas\u0131 gerekir.</li> </ul>"},{"location":"tr/guides/analysis/lyapunov/#tipik-is-aks","title":"Tipik i\u015f ak\u0131\u015f\u0131","text":"<ol> <li><code>Sim.run(...)</code> \u00e7a\u011fr\u0131s\u0131nda observer\u2019lar\u0131 ekleyin.</li> <li>Yak\u0131nsama e\u011frisini izlemek istiyorsan\u0131z <code>record_interval</code> veya <code>trace_plan</code> ile iz \u00f6rneklemesini ayarlay\u0131n.</li> <li>\u00c7al\u0131\u015ft\u0131rma bitti\u011finde <code>sim.results()</code> \u00fczerinden observer \u00e7\u0131kt\u0131lar\u0131 ve izlerini okuyun.</li> </ol>"},{"location":"tr/guides/analysis/lyapunov/#ornek-lojistik-harita","title":"\u00d6rnek (lojistik harita)","text":"<p>Lojistik harita demosu (<code>examples/analysis/lyapunov_logistic_map_demo.py</code>) tipik bir kurulum g\u00f6sterir:</p> <pre><code>sim.assign(x=0.4, r=4.0)\nsim.run(\n    N=5000,\n    dt=1.0,\n    record_interval=1,\n    observers=[\n        lyapunov_mle_observer(record_interval=1),\n        lyapunov_spectrum_observer(k=1, record_interval=1),\n    ],\n)\nresult = sim.results()\n</code></pre>"},{"location":"tr/guides/analysis/lyapunov/#cktlar-okuma","title":"\u00c7\u0131kt\u0131lar\u0131 okuma","text":"<p>Her Lyapunov observer\u2019\u0131 iki t\u00fcr veri \u00fcretir:</p> <ol> <li>\u00c7\u0131k\u0131\u015f alanlar\u0131 (output): \u00c7al\u0131\u015fma sonunda biriken/nihai istatistikler.</li> <li>\u0130z (trace): \u00c7al\u0131\u015fma boyunca \u00f6rneklenen \u201canl\u0131k tahminler\u201d (yak\u0131nsama e\u011frisi).</li> </ol>"},{"location":"tr/guides/analysis/lyapunov/#mle-observer-cktlar","title":"MLE observer \u00e7\u0131kt\u0131lar\u0131","text":"<p><code>lyapunov_mle_observer</code> mod\u00fcl\u00fc a\u015fa\u011f\u0131daki output alanlar\u0131n\u0131 \u00fcretir:</p> <ul> <li><code>log_growth</code>: Biriken <code>log(||v||)</code> toplam\u0131</li> <li><code>denom</code>: <code>\"flow\"</code> i\u00e7in toplam zaman, <code>\"map\"</code> i\u00e7in toplam ad\u0131m say\u0131s\u0131</li> <li><code>steps</code>: ad\u0131m sayac\u0131</li> <li><code>variational_mode</code>: kullan\u0131lan varyasyonel yolun meta bilgisi (0: basit/Euler, 1: combined, 2: tangent-only)</li> </ul> <p>Trace taraf\u0131nda ise:</p> <ul> <li><code>mle</code>: <code>log_growth / denom</code> olarak \u00f6rneklenen MLE yak\u0131nsama izi</li> </ul>"},{"location":"tr/guides/analysis/lyapunov/#spektrum-observer-cktlar","title":"Spektrum observer \u00e7\u0131kt\u0131lar\u0131","text":"<p><code>lyapunov_spectrum_observer</code> mod\u00fcl\u00fc:</p> <ul> <li><code>log_r0 ... log_r{k-1}</code>: QR (Modified Gram\u2013Schmidt) ad\u0131m\u0131nda biriken <code>log(diag(R))</code> toplamlar\u0131</li> <li><code>denom</code>, <code>steps</code>, <code>variational_mode</code></li> </ul> <p>Trace taraf\u0131nda:</p> <ul> <li><code>lyap0 ... lyap{k-1}</code>: her bir \u00fcs i\u00e7in <code>log_rj / denom</code> yak\u0131nsama izleri</li> </ul> <p><code>ResultView.observers</code> s\u00f6zl\u00fc\u011f\u00fc \u00fczerinden ilgili anahtarla eri\u015fip (\u00f6r. <code>\"lyapunov_mle\"</code>, <code>\"lyapunov_spectrum\"</code>), \u00e7\u0131kt\u0131 alanlar\u0131n\u0131 ve izleri inceleyebilirsiniz. \u0130zleri, kaydedilen y\u00f6r\u00fcnge ile hizalamak i\u00e7in <code>trace_steps</code>, <code>trace_time</code> gibi yard\u0131mc\u0131lar ve do\u011frudan indeksleme (\u00f6rn. <code>result[\"...\"]</code>) kullan\u0131labilir.</p>"},{"location":"tr/guides/analysis/lyapunov/#ipuclar","title":"\u0130pu\u00e7lar\u0131","text":"<ul> <li>MLE\u2019yi ba\u015fka tan\u0131lamalarla birlikte \u00e7al\u0131\u015ft\u0131racaksan\u0131z, m\u00fcmk\u00fcnse ayn\u0131 <code>trace_plan</code> / <code>record_interval</code> d\u00fczenini kullan\u0131n; b\u00f6ylece izler ayn\u0131 \u00f6rnekleme \u0131zgaras\u0131na oturur.</li> <li>Bellek kullan\u0131m\u0131n\u0131 d\u00fc\u015f\u00fcrmek i\u00e7in <code>record_interval</code> de\u011ferini b\u00fcy\u00fct\u00fcn. Yak\u0131nsama e\u011frisini \u201cyakla\u015f\u0131k\u201d g\u00f6rmek \u00e7o\u011fu zaman yeterlidir.</li> <li>Spektrum izlerinde <code>k</code>\u2019yi gereksiz b\u00fcy\u00fck se\u00e7meyin: \u00e7al\u0131\u015fma alan\u0131 ve hesap maliyeti <code>k</code> ile birlikte artar.</li> <li><code>\"flow\"</code> modunda hata al\u0131yorsan\u0131z, se\u00e7ti\u011finiz stepper\u2019\u0131n varyasyonel ad\u0131mlamay\u0131 desteklemedi\u011fi anlam\u0131na gelir. Bu durumda ya uyumlu bir stepper se\u00e7in ya da model t\u00fcr\u00fcne uygunsa <code>\"map\"</code> modunu tercih edin.</li> <li>Yaln\u0131zca nihai de\u011fere odaklan\u0131yorsan\u0131z, izleri \u00e7izmek yerine output alanlar\u0131ndan (<code>log_growth/denom</code> veya <code>log_rj/denom</code>) nihai sonucu t\u00fcretin; trace\u2019i sadece gerekti\u011finde inceleyin.</li> </ul>"},{"location":"tr/guides/analysis/manifold/","title":"Manifold analizi","text":"<p>Dynlib \u015fu anda hem ayr\u0131k haritalar (discrete maps) hem de ODE'ler i\u00e7in 1D manifold izlemeyi, ayr\u0131ca ODE modellerinin heteroklinik ve homoklinik y\u00f6r\u00fcngeleri i\u00e7in arama/izleme yard\u0131mc\u0131lar\u0131n\u0131 desteklemektedir. Manifoldlar\u0131 (kararl\u0131/karars\u0131z dallar veya ba\u011flant\u0131 y\u00f6r\u00fcngeleri) \u00e7\u0131kard\u0131ktan sonra, sonu\u00e7lar\u0131 do\u011frudan <code>dynlib.plot.manifold</code>'a veya manifold grafikleri i\u00e7indeki \u00e7izim rehberine besleyebilirsiniz.</p>"},{"location":"tr/guides/analysis/manifold/#1d-manifold-izleme-tracing","title":"1D manifold izleme (tracing)","text":"<p><code>dynlib.analysis.manifold</code> i\u00e7inde iki yard\u0131mc\u0131 bulunur:</p> <ul> <li><code>trace_manifold_1d_map(...)</code>: Kararl\u0131 veya karars\u0131z alt uzay\u0131 1D olan otonom haritalar i\u00e7in. Kararl\u0131 dallar, modelin analitik bir ters harita (<code>model.inv_rhs</code>) sunmas\u0131n\u0131 gerektirirken, karars\u0131z dallar yaln\u0131zca ileri haritaya (<code>model.rhs</code>) ihtiya\u00e7 duyar.</li> <li><code>trace_manifold_1d_ode(...)</code>: ODE sistemleri i\u00e7in; her zaman dahili bir RK4 entegrat\u00f6r\u00fc (Sim stepper'\u0131ndan ba\u011f\u0131ms\u0131z) kullan\u0131r ve bir denge noktas\u0131ndan zamanda ileri (karars\u0131z) veya geri (kararl\u0131) izleme yapar.</li> </ul>"},{"location":"tr/guides/analysis/manifold/#harita-manifoldlar-trace_manifold_1d_map","title":"Harita manifoldlar\u0131 (<code>trace_manifold_1d_map</code>)","text":"<p>Temel arg\u00fcmanlar ve i\u015f ak\u0131\u015f\u0131:</p> <ul> <li><code>sim</code>, <code>fp</code>: Derlenmi\u015f modeli bir harita olan bir <code>Sim</code> ve geni\u015fletmek istedi\u011finiz denge noktas\u0131n\u0131 (s\u00f6zl\u00fck veya dizi kabul edilir) sa\u011flay\u0131n.</li> <li><code>kind=\"stable\"</code> veya <code>\"unstable\"</code> dal\u0131 se\u00e7er. Kararl\u0131 mod ek olarak <code>model.inv_rhs</code> gerektirir.</li> <li><code>params</code> ekstra parametreleri ge\u00e7ersiz k\u0131lar ve <code>bounds</code>, izlemenin bu kutudan \u00e7\u0131kt\u0131\u011f\u0131nda durmas\u0131 i\u00e7in bir <code>(n_state, 2)</code> g\u00f6zlem kutusu tan\u0131mlar.</li> <li><code>clip_margin</code> entegrasyon s\u0131ras\u0131nda kesirli bir tampon ekler; <code>seed_delta</code> sabit noktay\u0131 se\u00e7ilen \u00f6zvekt\u00f6r boyunca bozar (perturb).</li> <li><code>steps</code>, <code>hmax</code>, <code>max_points_per_segment</code> ve <code>max_segments</code>, \u00f6rnekleyicinin ne kadar y\u00fcr\u00fcyece\u011fini ve ka\u00e7 segment saklayaca\u011f\u0131n\u0131 kontrol eder.</li> <li><code>eig_rank</code>, <code>strict_1d</code>, <code>eig_unit_tol</code> ve <code>eig_imag_tol</code>, \u00f6zde\u011fer se\u00e7imini ayarlar; b\u00f6ylece belirli bir k\u00f6k\u00fc zorlayabilir veya kat\u0131-1D varsay\u0131m\u0131n\u0131 gev\u015fetebilirsiniz.</li> <li><code>jac=\"auto\" | \"fd\" | \"analytic\"</code>, Jacobian stratejisini se\u00e7er; <code>fd_eps</code> sonlu fark ad\u0131m\u0131n\u0131 ayarlar.</li> <li><code>fp_check_tol</code>, sa\u011flanan parametrelerde <code>fp</code>'nin hala bir sabit nokta olup olmad\u0131\u011f\u0131n\u0131 iste\u011fe ba\u011fl\u0131 olarak do\u011frular.</li> </ul> <p>Numba/JIT mevcutsa ve model <code>jit=True</code> ile derlenmi\u015fse, yard\u0131mc\u0131 h\u0131zl\u0131 toplu de\u011ferlendirme veya \u00f6nceden ayr\u0131lm\u0131\u015f h\u0131zl\u0131 yollar\u0131 (fastpaths) kullan\u0131r; aksi takdirde bir uyar\u0131 ile g\u00fcvenli Python d\u00f6ng\u00fclerine geri d\u00f6ner.</p>"},{"location":"tr/guides/analysis/manifold/#ode-manifoldlar-trace_manifold_1d_ode","title":"ODE manifoldlar\u0131 (<code>trace_manifold_1d_ode</code>)","text":"<p>Temel ayarlar:</p> <ul> <li><code>sim</code>, <code>fp</code>, <code>params</code> ve <code>bounds</code> yukar\u0131daki gibi \u00e7al\u0131\u015f\u0131r. <code>bounds</code> kutusu entegrasyon s\u0131ras\u0131nda dikkate al\u0131n\u0131r ve <code>clip_margin</code> ile tamponlanabilir; <code>strict_1d</code> ise se\u00e7ilen \u00f6zvekt\u00f6r\u00fcn ger\u00e7ekten 1D bir manifoldu kapsad\u0131\u011f\u0131ndan emin olur.</li> <li><code>dt</code>, <code>max_time</code> ve <code>max_points</code> dahili RK4 entegrasyonunu s\u0131n\u0131rlar. <code>resample_h</code> (<code>None</code> de\u011filse), daha temiz \u00e7izim i\u00e7in her dal\u0131 kabaca e\u015fit yay uzunlu\u011fu aral\u0131\u011f\u0131nda yeniden \u00f6rnekler.</li> <li><code>seed_delta</code>, dal\u0131 normalle\u015ftirilmi\u015f \u00f6zvekt\u00f6r boyunca tohumlar (dal erken ayr\u0131lmad\u0131\u011f\u0131 s\u00fcrece hem pozitif hem de negatif y\u00f6nler izlenir).</li> <li>Jacobian y\u00f6netimi harita yard\u0131mc\u0131s\u0131n\u0131 yans\u0131t\u0131r (<code>jac</code>, <code>fd_eps</code>, <code>eig_real_tol</code>, <code>eig_imag_tol</code>). Birden fazla kararl\u0131/karars\u0131z \u00f6zde\u011fer mevcut oldu\u011funda <code>eig_rank</code> kullan\u0131n.</li> <li><code>fp_check_tol</code>, <code>fp</code> art\u0131k kararl\u0131 bir durum de\u011filse (\u00f6rne\u011fin parametre ge\u00e7ersiz k\u0131lmalar\u0131 nedeniyle) izlemeyi reddetmenizi sa\u011flar.</li> </ul> <p>Harita yard\u0131mc\u0131s\u0131 gibi, ODE izleyici de JIT derlenmi\u015f bir modeli tercih eder ancak Numba olmadan da \u00e7al\u0131\u015f\u0131r (geri d\u00f6n\u00fc\u015f/fallback uyar\u0131s\u0131 ile).</p>"},{"location":"tr/guides/analysis/manifold/#manifoldtraceresult","title":"<code>ManifoldTraceResult</code>","text":"<p>Her iki izleme arac\u0131 da \u015fu niteliklere sahip bir <code>ManifoldTraceResult</code> d\u00f6nd\u00fcr\u00fcr:</p> <ul> <li><code>kind</code>: <code>\"stable\"</code> veya <code>\"unstable\"</code>.</li> <li><code>fixed_point</code>: Dallar\u0131 tohumlayan denge noktas\u0131.</li> <li><code>branches</code>: <code>(positive_side, negative_side)</code> demeti (tuple); her bir taraf bir nokta dizileri listesidir (<code>(n_points, n_state)</code> \u015feklinde <code>np.ndarray</code>).</li> <li><code>branch_pos</code> / <code>branch_neg</code>: Yukar\u0131daki demetin kullan\u0131\u015fl\u0131 g\u00f6r\u00fcn\u00fcmleri.</li> <li><code>eigenvalue</code>, <code>eigenvector</code>, <code>eig_index</code>, <code>step_mul</code>: \u0130zleme s\u0131ras\u0131nda kullan\u0131lan spektral bilgiler.</li> <li><code>meta</code>: Sonucu \u00fcreten yap\u0131land\u0131rmay\u0131 kaydeden s\u00f6zl\u00fck (bounds, params, dt, clip margins vb.).</li> </ul> <p>Bu sonu\u00e7lar do\u011frudan <code>dynlib.plot.manifold</code> taraf\u0131ndan t\u00fcketilebilir ve <code>branches</code>'\u0131 d\u0131\u015fa a\u00e7ar, b\u00f6ylece bunlar\u0131 heteroklinik izler, zaman serileri veya di\u011fer s\u00fcslemelerle \u00fcst \u00fcste bindirebilirsiniz (bkz. \u00e7izim rehberi).</p> <p>Somut \u00f6rnekler:</p> <ul> <li><code>examples/analysis/manifold_henon.py</code>, Henon haritas\u0131 kararl\u0131/karars\u0131z manifoldlar\u0131n\u0131 izler ve <code>plot.manifold</code> ile olu\u015fturur.</li> <li><code>examples/analysis/manifold_ode_saddle.py</code>, analitik bir eyeri (saddle) ele alarak her iki taraf\u0131n nas\u0131l tohumlanaca\u011f\u0131n\u0131, izlenen e\u011frinin kapal\u0131 form ifadelere kar\u015f\u0131 nas\u0131l kontrol edilece\u011fini ve sonucun nas\u0131l \u00e7izilece\u011fini g\u00f6sterir.</li> </ul>"},{"location":"tr/guides/analysis/manifold/#heteroklinik-ve-homoklinik-bulucuizleyici-findertracer","title":"Heteroklinik ve homoklinik bulucu/izleyici (finder/tracer)","text":"<p>ODE modelleri i\u00e7in, at\u0131\u015f (shooting) segmentlerini manuel olarak ayarlamadan ba\u011flant\u0131 y\u00f6r\u00fcngelerini arayabilir veya izleyebilirsiniz. \u0130\u015f ak\u0131\u015f\u0131 tipik olarak \u015f\u00f6yledir:</p> <ol> <li>Bir ba\u011flant\u0131 sa\u011flayan parametre de\u011ferini (ve denge \u00e7iftini) bulmak i\u00e7in bir bulucu (finder) \u00e7a\u011f\u0131r\u0131n.</li> <li>Y\u00f6r\u00fcngeyi kaydetmek i\u00e7in do\u011frulanan parametrede bir izleyici (tracer) kullan\u0131n.</li> <li>Ortaya \u00e7\u0131kan izi, <code>dynlib.plot.manifold</code> kullanarak kaynak/hedef manifoldlar\u0131yla birlikte \u00e7izin.</li> </ol>"},{"location":"tr/guides/analysis/manifold/#heteroklinik-araclar","title":"Heteroklinik ara\u00e7lar","text":"<ul> <li><code>heteroclinic_finder(...)</code>: <code>source_eq_guess</code>'ten gelen karars\u0131z manifoldun <code>target_eq_guess</code>'in kararl\u0131 manifolduna yak\u0131n bir yere d\u00fc\u015ft\u00fc\u011f\u00fc <code>[param_min, param_max]</code> aral\u0131\u011f\u0131nda bir <code>param</code> parametresi arar. Basitle\u015ftirilmi\u015f API; <code>preset</code> (<code>\"fast\"</code>, <code>\"default\"</code>, <code>\"precise\"</code>), aramay\u0131 k\u0131s\u0131tlamak i\u00e7in bir <code>window</code> ve <code>gap_tol</code> (\u0131skalama mesafesi) ve <code>x_tol</code> (parametre hassasiyeti) gibi yak\u0131nsama toleranslar\u0131n\u0131 kabul eder. D\u00f6n\u00fc\u015f de\u011feri <code>HeteroclinicFinderResult</code> \u015funlar\u0131 i\u00e7erir:</li> <li><code>success</code>: Ge\u00e7erli bir y\u00f6r\u00fcngenin bulunup bulunmad\u0131\u011f\u0131.</li> <li><code>param_found</code>: Iskalamay\u0131 en aza indiren parametre de\u011feri.</li> <li><code>miss</code>: Kesi\u015fme noktalar\u0131, bo\u015fluk metrikleri ve \u00e7\u00f6z\u00fcc\u00fc durumunu i\u00e7eren tan\u0131sal yap\u0131 (<code>HeteroclinicMissResult2D</code> veya <code>HeteroclinicMissResultND</code>).</li> <li><code>info</code>: Yard\u0131mc\u0131 tan\u0131lar (\u00f6n ayar ad\u0131, tarama say\u0131s\u0131 vb.).</li> <li>Bulucu ba\u015far\u0131l\u0131 olduktan sonra, <code>heteroclinic_tracer(...)</code> ger\u00e7ek ba\u011flant\u0131y\u0131 <code>param_value</code> de\u011ferinde kaydeder. Hem denge noktalar\u0131n\u0131 (<code>source_eq</code>, <code>target_eq</code>) hem de karars\u0131z y\u00f6n i\u015faretini (<code>sign_u</code>) belirtmelisiniz. \u0130zleyici \u015funlar\u0131 sunar:</li> <li><code>t</code>, <code>X</code>, <code>meta</code>, <code>branches</code> alanlar\u0131na ve bir <code>success</code> boolean \u00f6zelli\u011fine sahip <code>HeteroclinicTraceResult</code>.</li> <li><code>hit_radius</code>: Karars\u0131z segmentin durmadan \u00f6nce hedefe ne kadar yakla\u015fmas\u0131 gerekti\u011fini kontrol eder (varsay\u0131lan <code>1e-2</code>).</li> <li>Ayn\u0131 <code>preset</code>/<code>window</code>/<code>t_max</code>/<code>r_blow</code> k\u0131sayollar\u0131 ve daha ince kontrol gerekiyorsa tam <code>HeteroclinicBranchConfig</code>.</li> </ul>"},{"location":"tr/guides/analysis/manifold/#yaplandrma-veri-snflar-configuration-dataclasses","title":"Yap\u0131land\u0131rma veri s\u0131n\u0131flar\u0131 (Configuration dataclasses)","text":"<p>Bulucu/izleyici \u00e7iftleri, deterministik kontrole ihtiya\u00e7 duydu\u011funuzda <code>dynlib.analysis.manifold</code>'dan yap\u0131land\u0131r\u0131lm\u0131\u015f veri s\u0131n\u0131flar\u0131n\u0131 (dataclasses) da kabul eder. <code>heteroclinic_finder</code> bir <code>cfg</code> (<code>HeteroclinicFinderConfig2D</code> veya <code>HeteroclinicFinderConfigND</code>) alabilirken, <code>heteroclinic_tracer</code> <code>cfg_u</code> kabul eder; her ikisi de yukar\u0131da a\u00e7\u0131klanan basitle\u015ftirilmi\u015f <code>preset</code>, <code>trace_cfg</code> ve anahtar kelime arg\u00fcmanlar\u0131yla ge\u00e7ersiz k\u0131l\u0131nabilir.</p> <ul> <li><code>HeteroclinicRK45Config</code>: Dahili RK45 entegrat\u00f6r\u00fcn\u00fc (<code>dt0</code>, <code>min_step</code>, <code>dt_max</code>, <code>atol</code>, <code>rtol</code>, <code>safety</code>, <code>max_steps</code>) ayarlar; bu, her dal yap\u0131land\u0131rmas\u0131nda saklan\u0131r.</li> <li><code>HeteroclinicBranchConfig</code>: Tek bir manifold izlemesi i\u00e7in ayarlar\u0131 paketler: denge iyile\u015ftirme (<code>eq_tol</code>, <code>eq_max_iter</code>, iste\u011fe ba\u011fl\u0131 <code>eq_track_max_dist</code>), ayr\u0131lma yar\u0131\u00e7ap\u0131 (<code>eps_mode</code>, <code>eps</code>, <code>eps_min</code>, <code>eps_max</code>, <code>r_leave</code>, <code>t_leave_target</code>), entegrasyon s\u0131n\u0131rlar\u0131 (<code>t_max</code>, <code>s_max</code>, <code>r_blow</code>), iste\u011fe ba\u011fl\u0131 b\u00f6l\u00fcmler/pencereli \u00e7\u0131k\u0131\u015f ko\u015fullar\u0131 (<code>window_min</code>, <code>window_max</code>, <code>t_min_event</code>, <code>require_leave_before_event</code>), spektral toleranslar (<code>eig_real_tol</code>, <code>eig_imag_tol</code>, <code>strict_1d</code>), Jacobian y\u00f6netimi (<code>jac</code>, <code>fd_eps</code>) ve bir <code>HeteroclinicRK45Config</code>'e i\u015faret eden <code>rk</code> alan\u0131.</li> <li><code>HeteroclinicFinderConfig2D</code>/<code>HeteroclinicFinderConfigND</code>: \u0130ki dal yap\u0131land\u0131rmas\u0131n\u0131 (<code>trace_u</code>, <code>trace_s</code>) arama davran\u0131\u015f\u0131yla (<code>scan_n</code>, <code>max_bisect</code>, <code>x_tol</code>, <code>gap_tol</code>, <code>gap_fac</code>, <code>branch_mode</code>, <code>sign_u</code>, <code>sign_s</code>, <code>r_sec</code>, <code>r_sec_mult</code>, <code>r_sec_min_mult</code>, art\u0131 ND i\u00e7in <code>tau_min</code>) ve iste\u011fe ba\u011fl\u0131 <code>eq_tol</code>/<code>eq_max_iter</code> ge\u00e7ersiz k\u0131lmalar\u0131yla e\u015fle\u015ftirir. Bu tam yap\u0131land\u0131rma <code>cfg</code> \u00fczerinden ge\u00e7irilir ve mevcut oldu\u011funda basitle\u015ftirilmi\u015f kwargs'\u0131 atlar.</li> <li><code>HeteroclinicPreset</code>: Bir dal yap\u0131land\u0131rmas\u0131n\u0131, RK ayarlar\u0131n\u0131 ve tarama parametrelerini paketler, b\u00f6ylece her alan\u0131 manuel olarak ayarlamak yerine <code>\"fast\"</code>, <code>\"default\"</code> veya <code>\"precise\"</code> (veya veri s\u0131n\u0131f\u0131n\u0131 kendiniz ba\u015flatarak \u00f6zel bir \u00f6n ayar) isteyebilirsiniz.</li> </ul> <p>Tam bir heteroklinik av\u0131 + \u00e7izim rutini i\u00e7in <code>examples/analysis/heteroclinic_finder_tracer.py</code>'ye bak\u0131n.</p>"},{"location":"tr/guides/analysis/manifold/#homoklinik-araclar","title":"Homoklinik ara\u00e7lar","text":"<ul> <li><code>homoclinic_finder(...)</code>: Ayn\u0131 eyer (saddle) denge noktas\u0131n\u0131n karars\u0131z ve kararl\u0131 manifoldlar\u0131n\u0131n yeniden ba\u011fland\u0131\u011f\u0131 bir parametre arar. Ayn\u0131 <code>preset</code> adlar\u0131n\u0131 ve basitle\u015ftirilmi\u015f ge\u00e7ersiz k\u0131lmalar\u0131 (<code>window</code>, <code>scan_n</code>, <code>max_bisect</code>, <code>gap_tol</code>, <code>x_tol</code>, <code>t_max</code>, <code>r_blow</code>, <code>r_sec</code>, <code>t_min_event</code>) veya tam bir <code>HomoclinicFinderConfig</code> kabul eder. D\u00f6nd\u00fcr\u00fclen <code>HomoclinicFinderResult</code>, heteroklinik bulucuyu yans\u0131t\u0131r (en yak\u0131n vuru\u015fu tan\u0131mlayan bir <code>HomoclinicMissResult</code> ile).</li> <li><code>homoclinic_tracer(...)</code>: \u0130\u015faretle tan\u0131mlanm\u0131\u015f tek bir karars\u0131z dal\u0131 eyer noktas\u0131na geri d\u00f6nene kadar takip eder; <code>branches</code> niteli\u011fi <code>plot.manifold</code>'a g\u00f6nderilebilen bir <code>HomoclinicTraceResult</code> d\u00f6nd\u00fcr\u00fcr. \u0130zleyici, RK45 toleranslar\u0131n\u0131, ayr\u0131lma/d\u00f6n\u00fc\u015f yar\u0131\u00e7aplar\u0131n\u0131 ve olay alg\u0131lama korumalar\u0131n\u0131 ayarlaman\u0131za olanak tan\u0131yan <code>HomoclinicBranchConfig</code> kullan\u0131r.</li> </ul>"},{"location":"tr/guides/analysis/manifold/#yaplandrma-veri-snflar","title":"Yap\u0131land\u0131rma veri s\u0131n\u0131flar\u0131","text":"<p>Bulucu/izleyici \u00e7ifti, geli\u015fmi\u015f ayarlama i\u00e7in yap\u0131land\u0131r\u0131lm\u0131\u015f veri s\u0131n\u0131flar\u0131 sunar. <code>homoclinic_finder</code> bir <code>cfg: HomoclinicFinderConfig</code> kabul ederken, <code>homoclinic_tracer</code> bir <code>cfg_u: HomoclinicBranchConfig</code> alabilir; bu nesneleri sa\u011flamak basitle\u015ftirilmi\u015f <code>preset</code>, <code>trace_cfg</code> ve anahtar kelime arg\u00fcmanlar\u0131n\u0131 atlar.</p> <ul> <li><code>HomoclinicRK45Config</code>: RK45 parametrelerine (<code>dt0</code>, <code>min_step</code>, <code>dt_max</code>, <code>atol</code>, <code>rtol</code>, <code>safety</code>, <code>max_steps</code>) sahiptir.</li> <li><code>HomoclinicBranchConfig</code>: Denge iyile\u015ftirme (<code>eq_tol</code>, <code>eq_max_iter</code>, <code>eq_track_max_dist</code>), ayr\u0131lma-olay\u0131 kontrol\u00fc (<code>eps_mode</code>, <code>eps</code>, <code>eps_min</code>, <code>eps_max</code>, <code>r_leave</code>, <code>t_leave_target</code>, <code>r_sec</code>, <code>t_min_event</code>, <code>require_leave_before_event</code>), entegrasyon s\u0131n\u0131rlar\u0131 (<code>t_max</code>, <code>s_max</code>, <code>r_blow</code>), iste\u011fe ba\u011fl\u0131 pencere k\u0131s\u0131tlamalar\u0131, spektral e\u015fikler (<code>eig_real_tol</code>, <code>eig_imag_tol</code>, <code>strict_1d</code>), Jacobian y\u00f6netimi (<code>jac</code>, <code>fd_eps</code>) ve bir <code>HomoclinicRK45Config</code>'e referans veren <code>rk</code> alan\u0131n\u0131 katmanlar.</li> <li><code>HomoclinicFinderConfig</code>: Bir <code>trace</code> dal yap\u0131land\u0131rmas\u0131n\u0131 arama-\u00f6zel d\u00fc\u011fmelerle (<code>scan_n</code>, <code>max_bisect</code>, <code>gap_tol</code>, <code>x_tol</code>, <code>branch_mode</code>, <code>sign_u</code>) sarar, b\u00f6ylece hem izleme hem de parametre ikiye b\u00f6lme (bisection) davran\u0131\u015f\u0131n\u0131 kontrol edebilirsiniz.</li> <li><code>HomoclinicPreset</code>: Bir dal yap\u0131land\u0131rmas\u0131n\u0131, RK ayarlar\u0131n\u0131 ve tarama toleranslar\u0131n\u0131 paketler, b\u00f6ylece <code>\"fast\"</code>, <code>\"default\"</code> veya <code>\"precise\"</code> do\u011frudan <code>preset</code> arg\u00fcman\u0131 olarak ge\u00e7irilebilir; bu varsay\u0131lanlar yeterince agresif de\u011filse kendi \u00f6n ayar\u0131n\u0131z\u0131 da olu\u015fturabilirsiniz.</li> </ul> <p>\u00d6n Ayar \u00d6zeti:</p> \u0130sim A\u00e7\u0131klama <code>fast</code> Ke\u015fif i\u00e7in daha gev\u015fek toleranslarla h\u0131zl\u0131 tarama. <code>default</code> Standart kullan\u0131m durumlar\u0131 i\u00e7in h\u0131z ve sa\u011flaml\u0131k dengesi. <code>precise</code> Zorlu y\u00f6r\u00fcngeler i\u00e7in s\u0131k\u0131 toleranslar, daha k\u00fc\u00e7\u00fck ad\u0131mlar ve daha uzun entegrasyonlar. <p>Her iki bulucu/izleyici de sonu\u00e7 <code>meta</code> nesnelerine <code>diag</code> meta verilerini kaydeder, b\u00f6ylece bir \u00e7al\u0131\u015fma ba\u015far\u0131s\u0131z olursa veya yaln\u0131zca zar zor ba\u015far\u0131l\u0131 olursa ODE ad\u0131m say\u0131lar\u0131n\u0131, RK ayarlamalar\u0131n\u0131 ve olay tetikleyicilerini inceleyebilirsiniz.</p>"},{"location":"tr/guides/analysis/manifold/#sonraki-admlar","title":"Sonraki ad\u0131mlar","text":"<ul> <li>Hedef denge noktas\u0131n\u0131 bildi\u011finizde ve kararl\u0131/karars\u0131z dallar\u0131n\u0131 g\u00f6rselle\u015ftirmek istedi\u011finizde <code>trace_manifold_1d_map</code> veya <code>trace_manifold_1d_ode</code> kullan\u0131n. <code>ManifoldTraceResult</code> sonu\u00e7lar\u0131n\u0131 manifold grafikleri i\u00e7indeki referans \u00e7izimlerle birle\u015ftirin.</li> <li>Parametre de\u011ferlerini avlamak i\u00e7in <code>examples/analysis/{heteroclinic_,homoclinic_}finder_tracer.py</code> i\u00e7indeki heteroklinik/homoklinik bulucu betiklerini \u00e7al\u0131\u015ft\u0131r\u0131n, ard\u0131ndan yay\u0131na haz\u0131r g\u00f6rseller olu\u015fturmak i\u00e7in ke\u015ffedilen parametrede y\u00f6r\u00fcngeyi izleyin (trace).</li> </ul>"},{"location":"tr/guides/analysis/observers/","title":"\u00c7al\u0131\u015fma zaman\u0131 g\u00f6zlemcileri (Runtime observers)","text":"<p>Dynlib, her <code>Sim.run()</code> \u00e7a\u011fr\u0131s\u0131yla birlikte \u00e7al\u0131\u015fan k\u00fc\u00e7\u00fck bir analiz alt sistemi i\u00e7erir. Observer (g\u00f6zlemci) mod\u00fclleri ad\u0131m \u00f6ncesi/sonras\u0131 kancalar\u0131 (hooks) enjekte eder, \u00e7al\u0131\u015fma alan\u0131 tamponlar\u0131n\u0131 (workspace buffers) ta\u015f\u0131r ve iste\u011fe ba\u011fl\u0131 olarak izleri (traces) payla\u015f\u0131lan bir <code>Results</code> nesnesine kaydeder; b\u00f6ylece kaydedilen y\u00f6r\u00fcngeleri sonradan i\u015flemeye gerek kalmadan tan\u0131lamalar\u0131 (Lyapunov \u00fcsleri, spektrumlar, yak\u0131nsama izleri vb.) hesaplayabilirsiniz.</p>"},{"location":"tr/guides/analysis/observers/#observerlar-simrun-ile-kaydetme","title":"Observer'lar\u0131 <code>Sim.run</code> ile kaydetme","text":"<ul> <li><code>Sim.run(..., observers=\u2026)</code> \u015funlar\u0131 kabul eder:</li> <li>Bir <code>ObserverModule</code> \u00f6rne\u011fi.</li> <li>Bir Observer factory (g\u00f6zlemci fabrikas\u0131) (<code>(model, sim, record_interval)</code> imzas\u0131na ve <code>__observer_factory__</code> bayra\u011f\u0131na sahip \u00e7a\u011fr\u0131labilir nesne). <code>lyapunov_mle_observer</code> gibi Dynlib yap\u0131m\u0131 factory'ler bu bayra\u011f\u0131 ayarlar, b\u00f6ylece <code>Sim</code> derlenmi\u015f modeli otomatik olarak enjekte edebilir.</li> <li>Bir <code>ObserverModule</code> dizisi. <code>Sim</code>, birden fazla mod\u00fcl\u00fc tek bir ge\u00e7i\u015fte \u00e7al\u0131\u015facak \u015fekilde bir <code>CombinedObserver</code> (Birle\u015fik G\u00f6zlemci) i\u00e7inde sarmalar.</li> <li><code>record_interval</code> (kay\u0131t aral\u0131\u011f\u0131) factory'lere iletilir; izleri ad\u0131m boyutundan daha kaba bir tempoda \u00f6rneklemek istiyorsan\u0131z bunu <code>Sim.run</code> \u00e7a\u011fr\u0131s\u0131nda sa\u011flay\u0131n.</li> <li>T\u00fcm observer'lar, \u00e7al\u0131\u015fma ba\u015flamadan \u00f6nce mevcut stepper'a kar\u015f\u0131 do\u011frulan\u0131r (<code>ObserverModule.validate_stepper</code>); uyumsuz kombinasyonlar (\u00f6rne\u011fin, uyarlamal\u0131 bir stepper \u00fczerinde sabit ad\u0131ml\u0131 bir observer) hemen hata verir.</li> <li><code>CombinedObserver</code>, benzersiz anahtarlar\u0131 zorunlu k\u0131lar, durumu (state) de\u011fi\u015ftiren observer'lar\u0131 reddeder ve ad\u0131m ba\u015f\u0131na en fazla bir varyasyonel entegrat\u00f6re izin verir; bu nedenle ya tek bir mod\u00fcl ya da dikkatlice olu\u015fturulmu\u015f bir kombinasyon se\u00e7in.</li> <li>\u00c7al\u0131\u015ft\u0131r\u0131c\u0131 (runner) ge\u00e7i\u015f ba\u015f\u0131na yaln\u0131zca bir varyasyonel stepper yayabildi\u011finden ve observer'lar ayn\u0131 iz tamponlar\u0131n\u0131/saya\u00e7lar\u0131n\u0131 payla\u015ft\u0131\u011f\u0131ndan, birden fazla varyasyonel observer'\u0131 kar\u0131\u015ft\u0131ramaz veya tek bir \u00e7al\u0131\u015fmada birden fazla observer'\u0131n model durumunu de\u011fi\u015ftirmesine izin veremezsiniz. Her observer ayr\u0131ca izleme plan\u0131 (trace plan) \u00fczerinde anla\u015fmal\u0131d\u0131r (ayn\u0131 <code>TracePlan</code> veya <code>record_interval</code>), b\u00f6ylece kaydedilen izler hizal\u0131 kal\u0131r; h\u0131zl\u0131 yol (fast-path) ile uyumlu olmayan \u00f6zellikler (olay g\u00fcnl\u00fckleri, kabul/ret kancalar\u0131, sabit ad\u0131m zorunlulu\u011fu) gerektiren herhangi bir observer, h\u0131zl\u0131 \u00e7al\u0131\u015ft\u0131r\u0131c\u0131y\u0131 talep etmi\u015f olsan\u0131z bile \u00e7al\u0131\u015fmay\u0131 sarmalay\u0131c\u0131 (wrapper) yoluna geri zorlayabilir.</li> </ul>"},{"location":"tr/guides/analysis/observers/#temel-observer-yap-taslar","title":"Temel observer yap\u0131 ta\u015flar\u0131","text":"<ul> <li><code>ObserverModule</code> \u015funlar\u0131 ta\u015f\u0131r:</li> <li>Sabit ad\u0131m y\u00fcr\u00fctme, Jacobian-vekt\u00f6r \u00fcr\u00fcnleri (<code>need_jvp</code>), yo\u011fun Jacobianlar, olay g\u00fcnl\u00fckleri veya varyasyonel ad\u0131mlama kancalar\u0131 gibi ihtiya\u00e7lar\u0131 beyan eden <code>requirements</code> (<code>ObserverRequirements</code>).</li> <li>\u00c7al\u0131\u015ft\u0131r\u0131c\u0131n\u0131n ne kadar \u00e7al\u0131\u015fma zaman\u0131 depolama alan\u0131 ay\u0131raca\u011f\u0131n\u0131 belirleyen <code>workspace_size</code>, <code>output_size</code>, <code>output_names</code> ve iste\u011fe ba\u011fl\u0131 <code>trace</code> meta verileri (<code>TraceSpec</code>).</li> <li>Her entegrasyon ad\u0131m\u0131nda \u00e7al\u0131\u015fan <code>pre_step</code>/<code>post_step</code> geri \u00e7a\u011fr\u0131lar\u0131na sahip <code>hooks</code> (<code>ObserverHooks</code>); bu kancalar ge\u00e7erli <code>t</code>, <code>dt</code>, durumlar, parametreler, \u00e7al\u0131\u015fma zaman\u0131 \u00e7al\u0131\u015fma alan\u0131, analiz \u00e7al\u0131\u015fma alan\u0131, \u00e7\u0131kt\u0131 tamponlar\u0131 ve iz tamponlar\u0131n\u0131 al\u0131r.</li> <li><code>TraceSpec</code>, kaydedilen iz d\u00fczenini tan\u0131mlar ve geni\u015flik &gt; 0 oldu\u011funda bir <code>TracePlan</code> gerektirir. \u00c7o\u011fu observer i\u00e7in bir <code>FixedTracePlan(record_interval=K)</code> ge\u00e7irebilir veya sadece factory'ye sa\u011flad\u0131\u011f\u0131n\u0131z <code>record_interval</code>'a g\u00fcvenebilirsiniz.</li> <li>Observer'lar <code>needs_trace</code>, <code>trace_stride</code> ve <code>trace_capacity(total_steps=...)</code> gibi yard\u0131mc\u0131 y\u00f6ntemleri d\u0131\u015fa a\u00e7ar, b\u00f6ylece <code>Sim</code> tampon boyutlar\u0131n\u0131 ayarlayabilir ve ta\u015fmay\u0131 alg\u0131layabilir; <code>build_observer_metadata(...)</code> bu bilgileri nihai <code>Results</code> y\u00fck\u00fcnde toplar.</li> <li>Ad\u0131m ba\u015f\u0131na kancalar\u0131 Numba ile derlemeyi planl\u0131yorsan\u0131z (h\u0131zl\u0131 yol \u00e7al\u0131\u015ft\u0131r\u0131c\u0131lar\u0131), <code>ObserverModule.resolve_hooks(jit=True, dtype=...)</code> bunlar\u0131 talep \u00fczerine derlerken, <code>observer_noop_hook()</code> kanca kurulu olmad\u0131\u011f\u0131nda \u00e7al\u0131\u015fma zamanlar\u0131n\u0131 tip kararl\u0131 (type-stable) tutar.</li> </ul>"},{"location":"tr/guides/analysis/observers/#referans-lyapunov-observerlar","title":"Referans Lyapunov observer'lar\u0131","text":"<p>Yerle\u015fik <code>dynlib.runtime.observers</code> paketi iki observer factory sa\u011flar:</p> <ol> <li><code>lyapunov_mle_observer(...)</code></li> <li><code>lyapunov_spectrum_observer(...)</code></li> </ol> <p>Her iki factory de sa\u011flanan modelden gerekli <code>jvp</code> ve <code>n_state</code>'i otomatik olarak alg\u0131lar (veya bunlar\u0131 a\u00e7\u0131k\u00e7a ge\u00e7irmenizi gerektirir). Stepper'\u0131n birle\u015fik varyasyonel ad\u0131m\u0131na dayanan veya manuel olarak tanjant entegrat\u00f6r\u00fcn\u00fc \u00e7a\u011f\u0131ran varyasyonel kancalar olu\u015ftururlar, bu nedenle:</p> <ul> <li>Ak\u0131\u015f ve Harita modu: <code>mode=\"flow\"</code> paydalar\u0131 zaman birimlerinde tutar, <code>mode=\"map\"</code> iterasyon say\u0131lar\u0131n\u0131 toplar ve <code>mode=\"auto\"</code>, <code>model.spec.kind</code>'dan do\u011fru davran\u0131\u015f\u0131 \u00e7\u0131kar\u0131r.</li> <li>Trace \u00f6rneklemesi: Yak\u0131nsama izlerini yakalamak i\u00e7in <code>record_interval</code> (veya <code>trace_plan=FixedTracePlan(record_interval=K)</code>) belirtin; bir trace plan\u0131 olmadan observer yaln\u0131zca \u00e7\u0131kt\u0131 kay\u0131tlar\u0131n\u0131 g\u00fcnceller.</li> <li>Varyasyonel ad\u0131mlama: Ak\u0131\u015f modu observer'lar\u0131, <code>caps.variational_stepping</code> \u00f6zelli\u011fi etkinle\u015ftirilmi\u015f bir stepper gerektirir. <code>prefer_variational_combined=True</code>, stepper'\u0131n birle\u015fik durum+tanjant entegrat\u00f6r\u00fcn\u00fc yeniden kullanmaya \u00e7al\u0131\u015f\u0131r; aksi takdirde observer <code>stepper_spec.emit_tangent_step(...)</code> taraf\u0131ndan olu\u015fturulan yaln\u0131zca tanjant geri \u00e7a\u011fr\u0131s\u0131na geri d\u00f6ner.</li> <li>Analiz t\u00fcr\u00fc: Mod\u00fcl\u00fc a\u015fa\u011f\u0131 ak\u0131\u015f meta verileri veya \u00f6nbellekleme i\u00e7in etiketlemek \u00fczere <code>analysis_kind=1</code> veya ba\u015fka bir tamsay\u0131 ge\u00e7irin; de\u011fer <code>build_observer_metadata</code> ve \u00e7al\u0131\u015ft\u0131r\u0131c\u0131 \u00f6nbellekleri (runner caches) \u00fczerinden ta\u015f\u0131n\u0131r.</li> </ul> <p>Factory kullan\u0131m\u0131 deyimseldir:</p> <pre><code>from dynlib.runtime.observers import lyapunov_mle_observer, lyapunov_spectrum_observer\n\nsim.run(\n    N=5000,\n    dt=1.0,\n    record_interval=1,\n    observers=[\n        lyapunov_mle_observer(model=sim.model, record_interval=1),\n        lyapunov_spectrum_observer(model=sim.model, k=1, record_interval=1),\n    ],\n)\nres = sim.results()\n</code></pre> <p><code>examples/analysis/lyapunov_logistic_map_demo.py</code> i\u00e7indeki lojistik harita demosu, daha sonra <code>res.observers</code>'\u0131n nas\u0131l okunaca\u011f\u0131 da dahil olmak \u00fczere tam olarak bu deseni g\u00f6sterir.</p>"},{"location":"tr/guides/analysis/observers/#observer-cktlarn-inceleme","title":"Observer \u00e7\u0131kt\u0131lar\u0131n\u0131 inceleme","text":"<ul> <li><code>ResultsView.observers</code>, her observer'\u0131n <code>key</code>'i (anahtar\u0131) ile anahtarlanm\u0131\u015f <code>ObserverResult</code> nesnelerinden olu\u015fan bir s\u00f6zl\u00fck d\u00f6nd\u00fcr\u00fcr. Her <code>ObserverResult</code> \u015funlar\u0131 sunar:</li> <li>Geriye d\u00f6n\u00fck uyumluluk i\u00e7in e\u015fleme eri\u015fimi (<code>result[\"out\"]</code>, <code>result[\"trace\"]</code>).</li> <li><code>output_names</code> ve <code>trace_names</code>'den t\u00fcretilen otomatik olu\u015fturulmu\u015f nitelik eri\u015fimi (<code>result.log_growth</code>, <code>result.steps</code> vb.).</li> <li>Ke\u015fif yard\u0131mc\u0131lar\u0131 (<code>result.output_names</code>, <code>result.trace_names</code>, <code>list(result)</code>).</li> <li>\u00c7al\u0131\u015ft\u0131r\u0131c\u0131 bunlar\u0131 her kaydetti\u011finde iz sat\u0131rlar\u0131n\u0131 ad\u0131m/zaman indeksleriyle hizalayan iz yard\u0131mc\u0131lar\u0131 (<code>result.trace</code>, <code>result.trace_steps</code>, <code>result.trace_time</code>).</li> <li>\u00d6rnek:</li> </ul> <pre><code>lyap = res.observers[\"lyapunov_mle\"]\nmle = lyap.mle          # nihai yak\u0131nsanm\u0131\u015f \u00fcs\nlog_growth = lyap.log_growth\nn_steps = int(lyap.steps)\ntrace = lyap[\"mle\"]     # tam yak\u0131nsama izi (record_interval aral\u0131kl\u0131)\n</code></pre> <ul> <li>\u00c7al\u0131\u015fma zaman\u0131 meta verileri <code>res.observer_metadata</code> (veya ham <code>Results.observer_metadata</code>) arac\u0131l\u0131\u011f\u0131yla son i\u015flemden sonra da korunur, b\u00f6ylece \u00e7al\u0131\u015fma alan\u0131 boyutlar\u0131n\u0131, iz ad\u0131mlar\u0131n\u0131 veya bir izin ta\u015f\u0131p ta\u015fmad\u0131\u011f\u0131n\u0131 inceleyebilirsiniz.</li> </ul>"},{"location":"tr/guides/analysis/observers/#hzl-yol-fast-path-ve-pratik-notlar","title":"H\u0131zl\u0131 yol (Fast-path) ve pratik notlar","text":"<ul> <li>Observer'lar mevcut oldu\u011funda, \u00e7al\u0131\u015ft\u0131r\u0131c\u0131 analize duyarl\u0131 varyantlara (<code>RunnerVariant.ANALYSIS</code> / <code>FASTPATH_ANALYSIS</code>) ge\u00e7er. <code>CombinedObserver.supports_fastpath(...)</code>, bir h\u0131zl\u0131 yol \u00e7al\u0131\u015ft\u0131r\u0131c\u0131s\u0131n\u0131n uyumlu olup olmad\u0131\u011f\u0131n\u0131 kontrol eder; \u00f6rne\u011fin, olay g\u00fcnl\u00fckleri, kabul/ret kancalar\u0131 veya durum mutasyonu gerektiren observer'lar h\u0131zl\u0131 yol y\u00fcr\u00fctmeyi devre d\u0131\u015f\u0131 b\u0131rak\u0131r.</li> <li><code>trace</code> verisi olmayan observer'lar yine de \u00e7\u0131kt\u0131 yuvalar\u0131na katk\u0131da bulunur, bu nedenle <code>Sim.results().observers</code>, <code>trace_plan</code> <code>None</code> olsa bile <code>ObserverResult</code>'lar\u0131 d\u00f6nd\u00fcrecektir.</li> <li>\u00d6zel observer'lar olu\u015fturursan\u0131z ayn\u0131 deseni izleyin: gereksinimleri bildirin, bir <code>ObserverModule</code> d\u00f6nd\u00fcr\u00fcn ve <code>workspace_size</code>/<code>output_names</code>/<code>trace_names</code> de\u011ferlerini ayarlay\u0131n, b\u00f6ylece a\u015fa\u011f\u0131 ak\u0131\u015f kodu (\u00e7al\u0131\u015ft\u0131r\u0131c\u0131 \u00f6nbellekleri, meta veri olu\u015fturucular\u0131) tamponlar\u0131 otomatik olarak hizalayabilir.</li> </ul> <p>\u00c7al\u0131\u015fma zaman\u0131 tan\u0131lamalar\u0131n\u0131 (Lyapunov \u00fcsleri, spektrumlar, b\u00fcy\u00fcme oranlar\u0131) ekstra son i\u015flem olmadan izlemek i\u00e7in observer altyap\u0131s\u0131n\u0131 kullan\u0131n ve tan\u0131lamalar\u0131n sim\u00fclasyon \u00e7al\u0131\u015fman\u0131zla anahtarlanm\u0131\u015f ve zaman hizal\u0131 kalmas\u0131 i\u00e7in <code>ResultsView.observers</code>'a g\u00fcvenin.</p>"},{"location":"tr/guides/analysis/post-analysis/","title":"Analiz Sonras\u0131 (Post-analysis)","text":"<p>Son-i\u015fleme (post-processing), ham sim\u00fclasyon veya tarama sonu\u00e7lar\u0131n\u0131 \u00f6nemsedi\u011finiz i\u00e7g\u00f6r\u00fclere d\u00f6n\u00fc\u015ft\u00fcrme y\u00f6ntemidir: \u00f6zet istatistikler, y\u00fckselme/d\u00fc\u015fme s\u00fcreleri, e\u015fik ge\u00e7i\u015fleri ve \u00e7atallanma (bifurcation) sa\u00e7\u0131l\u0131m bulutlar\u0131 gibi. Dynlib, kaydedilen y\u00f6r\u00fcngeleri (trajectories) yerinde tutar, b\u00f6ylece analiz yard\u0131mc\u0131lar\u0131n\u0131 (helpers) zaten \u00e7izdirdi\u011finiz veya d\u0131\u015fa aktard\u0131\u011f\u0131n\u0131z zaman ekseniyle ayn\u0131 hizada kullanabilirsiniz.</p>"},{"location":"tr/guides/analysis/post-analysis/#resultsview-uzerinden-yorunge-analizcilerine","title":"<code>ResultsView</code> \u00fczerinden y\u00f6r\u00fcnge analizcilerine","text":"<p>Bir \u00e7al\u0131\u015ft\u0131rmadan sonra normalde <code>res = sim.results()</code> \u00e7a\u011fr\u0131s\u0131 yapars\u0131n\u0131z (tam API i\u00e7in Sim\u00fclasyon sonu\u00e7lar\u0131 rehberine bak\u0131n). <code>res.analyze(...)</code> ihtiyac\u0131n\u0131z olan analizciyi (analyzer) olu\u015fturur:</p> <ul> <li><code>res.analyze(\"x\")</code>, tek bir de\u011fi\u015fken i\u00e7in <code>TrajectoryAnalyzer</code> d\u00f6nd\u00fcr\u00fcr.</li> <li><code>res.analyze([\"x\", \"y\"])</code> veya herhangi bir a\u00e7\u0131k demet (tuple), istenen s\u00fctunlar i\u00e7in <code>MultiVarAnalyzer</code> d\u00f6nd\u00fcr\u00fcr.</li> <li>Arg\u00fcmans\u0131z <code>res.analyze()</code>, kaydedilen durumlar\u0131 tercih eder (e\u011fer durum kaydedilmediyse kaydedilen yard\u0131mc\u0131 de\u011fi\u015fkenlere, yani aux de\u011fi\u015fkenlerine ba\u015fvurur) ve <code>MultiVarAnalyzer</code> d\u00f6nd\u00fcr\u00fcr.</li> </ul> <p>Her iki analizci de kaydedilen NumPy g\u00f6r\u00fcn\u00fcmlerini (views) sarmalar, bu nedenle t\u00fcm istatistikler ve zamansal yard\u0131mc\u0131lar <code>res.t</code> i\u00e7inde g\u00f6rd\u00fc\u011f\u00fcn\u00fcz ayn\u0131 \u0131zgara (grid) \u00fczerinde \u00e7al\u0131\u015f\u0131r.</p> <pre><code>res = sim.results()\nxa = res.analyze(\"x\")\npeak_time, peak_value = xa.argmax()\nsummary = res.analyze().summary()  # de\u011fi\u015fken ba\u015f\u0131na istatistik s\u00f6zl\u00fc\u011f\u00fc\n</code></pre> <p><code>TrajectoryAnalyzer</code> \u015funlar\u0131 sunar:</p> <ul> <li>temel istatistikler: <code>min()</code>, <code>max()</code>, <code>mean()</code> (ortalama), <code>std()</code> (standart sapma), <code>variance()</code> (varyans), <code>median()</code> (medyan), <code>percentile(q)</code>, <code>summary()</code>.</li> <li>u\u00e7 de\u011fer zamanlamas\u0131: <code>argmin()</code>, <code>argmax()</code>, <code>range()</code>.</li> <li>zamansal yard\u0131mc\u0131lar: <code>initial()</code>, <code>final()</code>, <code>crossing_times(threshold, direction)</code> (e\u015fik ge\u00e7i\u015f zamanlar\u0131), <code>zero_crossings(direction)</code> (s\u0131f\u0131r ge\u00e7i\u015fleri), <code>time_above(threshold)</code> (e\u015fik \u00fcst\u00fc s\u00fcre), <code>time_below(threshold)</code> (e\u015fik alt\u0131 s\u00fcre).</li> </ul> <p><code>MultiVarAnalyzer</code> ayn\u0131 y\u00f6ntemleri yans\u0131t\u0131r ancak de\u011fi\u015fken ad\u0131na g\u00f6re anahtarlanm\u0131\u015f s\u00f6zl\u00fckler d\u00f6nd\u00fcr\u00fcr (ve yeniden olu\u015fturmay\u0131 \u00f6nlemek i\u00e7in de\u011fi\u015fken ba\u015f\u0131na <code>TrajectoryAnalyzer</code> \u00f6rneklerini \"lazy\" olarak \u00f6nbelle\u011fe al\u0131r). Birden fazla kaydedilen de\u011fi\u015fken i\u00e7in yan yana istatistikler istedi\u011finizde bunu kullan\u0131n.</p>"},{"location":"tr/guides/analysis/post-analysis/#parametre-taramalar-catallanma-verisi","title":"Parametre taramalar\u0131 \u2192 \u00e7atallanma verisi","text":"<p><code>dynlib.analysis.sweep.traj_sweep(...)</code> arac\u0131l\u0131\u011f\u0131yla bir tarama \u00e7al\u0131\u015ft\u0131rd\u0131\u011f\u0131n\u0131zda, d\u00f6nen <code>SweepResult</code>; \u0131zgaray\u0131, \u00e7al\u0131\u015ft\u0131rma ba\u015f\u0131na y\u00fck\u00fc (payload) ve kaydedilen istatistikleri bir araya getirir. O de\u011fi\u015fken i\u00e7in bir <code>BifurcationExtractor</code> almak \u00fczere <code>sweep_result.bifurcation(\"x\")</code> \u00e7a\u011fr\u0131s\u0131 yap\u0131n; bu yard\u0131mc\u0131, y\u00f6r\u00fcngeleri \u00e7atallanma diyagramlar\u0131 i\u00e7in gereken sa\u00e7\u0131l\u0131m noktalar\u0131na \"lazy\" (ihtiya\u00e7 an\u0131nda) bir \u015fekilde d\u00f6n\u00fc\u015ft\u00fcr\u00fcr.</p> <pre><code>from dynlib.analysis import sweep\nfrom dynlib.plot import bifurcation_diagram\n\nsweep_result = sweep.traj_sweep(sim, param=\"r\", values=r_values, record_vars=[\"x\",\"y\"], N=2000)\nextrema = sweep_result.bifurcation(\"x\").extrema(kind=\"max\", tail=500, max_points=80)\nbifurcation_diagram(extrema)\n</code></pre> <p><code>BifurcationExtractor</code>, ince bir <code>BifurcationResult</code> art\u0131 baz\u0131 yard\u0131mc\u0131lar gibi davran\u0131r:</p> <ul> <li><code>.all()</code> (e\u011fer \u00e7\u0131kar\u0131c\u0131y\u0131 do\u011frudan bir \u00e7izim yard\u0131mc\u0131s\u0131na verirseniz varsay\u0131lan moddur), ge\u00e7ici (transient) ve kararl\u0131 durum (steady-state) verilerini birlikte inceleyebilmeniz i\u00e7in kaydedilen her noktay\u0131 birle\u015ftirir.</li> <li><code>.tail(n)</code>, parametre ba\u015f\u0131na son <code>n</code> \u00f6rne\u011fi tutar (limit d\u00f6ng\u00fcs\u00fc stabilize oldu\u011funda kullan\u0131\u015fl\u0131d\u0131r).</li> <li><code>.final()</code>, her tarama de\u011feri i\u00e7in yaln\u0131zca son \u00f6rne\u011fi tutar, bu da denge noktalar\u0131n\u0131 ve yava\u015f s\u00fcr\u00fcklenmeleri fark etmenize yard\u0131mc\u0131 olur.</li> <li><code>.extrema(...)</code>, yo\u011fun k\u00fcmelerden ka\u00e7\u0131nmak i\u00e7in <code>max_points</code> ve <code>min_peak_distance</code> parametreleriyle birlikte, (iste\u011fe ba\u011fl\u0131) kuyruk (tail) i\u00e7indeki maksimum/minimum (veya her ikisini) tespit eder.</li> <li><code>.poincare(section_var=..., level=..., direction=..., tail=..., max_points=..., min_section_distance=...)</code>, ge\u00e7i\u015f zamanlar\u0131n\u0131 ve hedef de\u011fi\u015fkenin kar\u015f\u0131l\u0131k gelen de\u011ferini enterpole ederek kesit ge\u00e7i\u015fleri olu\u015fturur.</li> </ul> <p>Her y\u00f6ntem \u015funlar\u0131 i\u00e7eren bir <code>BifurcationResult</code> veri s\u0131n\u0131f\u0131 (dataclass) d\u00f6nd\u00fcr\u00fcr:</p> <ul> <li><code>param_name</code>: taranan parametre (otomatik eksen etiketleme i\u00e7in kullan\u0131l\u0131r).</li> <li><code>values</code>: tam tarama \u0131zgaras\u0131 (<code>(M,)</code> \u015feklinde).</li> <li><code>p</code>, <code>y</code>: sa\u00e7\u0131l\u0131m grafikleri (scatter plots) i\u00e7in uygun d\u00fczle\u015ftirilmi\u015f parametre/de\u011fer \u00e7iftleri dizileri.</li> <li><code>mode</code>: veriyi hangi \u00e7\u0131karma stratejisinin \u00fcretti\u011fi.</li> <li><code>meta</code>: <code>SweepResult.meta</code>'n\u0131n bir kopyas\u0131 art\u0131 sonucu olu\u015fturan analizci ayarlar\u0131.</li> </ul> <p>Eksen etiketlerini ve meta verileri yeniden kullanmak i\u00e7in sonucu veya \u00e7\u0131kar\u0131c\u0131y\u0131 do\u011frudan <code>dynlib.plot.bifurcation_diagram()</code> fonksiyonuna iletin veya kendi \u00e7izim ara\u00e7lar\u0131n\u0131za <code>.p</code>/<code>.y</code> dizilerini verin.</p>"},{"location":"tr/guides/analysis/post-analysis/#guvenilir-son-analiz-icin-ipuclar","title":"G\u00fcvenilir son-analiz i\u00e7in ipu\u00e7lar\u0131","text":"<ul> <li>Analiz etti\u011finiz de\u011fi\u015fken ad\u0131n\u0131n ger\u00e7ekten <code>res.state_names</code>/<code>res.aux_names</code> veya <code>SweepResult.record_vars</code> i\u00e7inde g\u00f6r\u00fcnd\u00fc\u011f\u00fcn\u00fc do\u011frulay\u0131n; aksi takdirde <code>res.analyze(...)</code> veya <code>sweep_result.bifurcation(...)</code> hemen hata verir.</li> <li>Yaln\u0131zca uzun vadeli davran\u0131\u015fla ilgileniyorsan\u0131z, analizden \u00f6nce ge\u00e7ici durumlar\u0131 (transients) <code>.tail(n)</code> ile k\u0131rp\u0131n veya <code>res.segment[...]</code> ile dilimleyin.</li> <li>De\u011fi\u015fkenleri kar\u015f\u0131la\u015ft\u0131rmak i\u00e7in <code>MultiVarAnalyzer</code> \u00f6zetlerini kullan\u0131n (<code>mean()</code>, <code>{\"x\": ..., \"y\": ...}</code> d\u00f6nd\u00fcr\u00fcr) ve belirli bir de\u011fi\u015fken sal\u0131n\u0131m yap\u0131yorsa <code>.crossing_times(...)</code> ile bireysel bile\u015fenlerin detay\u0131na inin.</li> <li>Bulgular\u0131n\u0131za a\u00e7\u0131klama eklemek i\u00e7in analizci meta verilerini \u00e7izim yard\u0131mc\u0131lar\u0131yla birle\u015ftirin (\u00f6rne\u011fin, <code>xa.argmax()</code> ve <code>res.t</code> kullanarak k\u00fcresel maksimum zaman\u0131n\u0131 etiketleyin).</li> </ul>"},{"location":"tr/guides/analysis/sweep/","title":"Tarama (Sweep) analizi ara\u00e7lar\u0131","text":"<p>Dynlib, \u00f6ny\u00fckleme mant\u0131\u011f\u0131n\u0131 kopyalamadan veya \u00e7al\u0131\u015ft\u0131rmalar\u0131 manuel olarak yinelemeden sistem davran\u0131\u015f\u0131n\u0131n bir parametre \u0131zgaras\u0131 (grid) boyunca nas\u0131l de\u011fi\u015fti\u011fini ke\u015ffedebilmeniz i\u00e7in \u00f6zel bir <code>dynlib.analysis.sweep</code> mod\u00fcl\u00fc bar\u0131nd\u0131r\u0131r. Her yard\u0131mc\u0131 (helper), mevcut sim\u00fclasyon oturumunu (<code>sim.state_vector(source=\"session\")</code> ve <code>sim.param_vector(source=\"session\")</code>) temel olarak okur, bir parametreyi de\u011fi\u015ftirir ve i\u00e7eri\u011fi kaydettiklerinizle e\u015fle\u015fen bir <code>SweepResult</code> d\u00f6nd\u00fcr\u00fcr.</p>"},{"location":"tr/guides/analysis/sweep/#temel-sonuc-yardmclar","title":"Temel sonu\u00e7 yard\u0131mc\u0131lar\u0131","text":""},{"location":"tr/guides/analysis/sweep/#sweepresult","title":"<code>SweepResult</code>","text":"<p><code>SweepResult</code>, bekledi\u011finiz meta verileri (<code>param_name</code>, <code>values</code>, <code>kind</code>, <code>meta</code>) normalle\u015ftirir ve as\u0131l veriyi e\u015fleme ve \u00f6znitelik eri\u015fimi yoluyla sunar. Skaler taramalar <code>outputs</code> k\u0131sm\u0131n\u0131 doldurur, Lyapunov taramalar\u0131 <code>traces</code> ekler ve y\u00f6r\u00fcnge (trajectory) taramalar\u0131 <code>payload</code> i\u00e7ine bir <code>TrajectoryPayload</code> ekler. Yard\u0131mc\u0131, kaydedilen de\u011fi\u015fken adlar\u0131n\u0131 (<code>record_vars</code>) yeniden d\u0131\u015fa aktar\u0131r, <code>t</code>/<code>t_all</code> sa\u011flar ve <code>.runs</code> (de\u011fer ba\u015f\u0131na <code>SweepRun</code> nesneleri) veya t\u00fcm y\u00f6r\u00fcngeler ayn\u0131 uzunlu\u011fu payla\u015ft\u0131\u011f\u0131nda <code>.stack()</code> gibi kolayl\u0131k yard\u0131mc\u0131lar\u0131 sunar. Eksik bir anahtar istendi\u011finde hemen hata verir ve yaz\u0131m hatalar\u0131n\u0131n h\u0131zl\u0131ca fark edilmesi i\u00e7in mevcut alanlar\u0131 listeler.</p>"},{"location":"tr/guides/analysis/sweep/#trajectorypayload-sweeprun-ve-sweeprunsview","title":"<code>TrajectoryPayload</code>, <code>SweepRun</code> ve <code>SweepRunsView</code>","text":"<p><code>TrajectoryPayload</code>, kaydedilen adlar\u0131n demetini (tuple), her \u00e7al\u0131\u015ft\u0131rman\u0131n <code>t_runs</code>/<code>data</code> dizilerini ve tarama \u0131zgaras\u0131 <code>values</code> de\u011ferlerini tutar. Ayr\u0131ca, isimlendirilmi\u015f eri\u015fimi (<code>payload[\"x\"]</code>, <code>payload.series([...])</code>) ve y\u0131\u011f\u0131nlama (<code>payload.stack()</code>) veya varsay\u0131lan zaman eksenini alma (<code>payload.t</code>) yetene\u011fini g\u00fc\u00e7lendiren dahili bir <code>_var_index</code> olu\u015fturur. Farkl\u0131 \u00e7al\u0131\u015ft\u0131rmalar farkl\u0131 uzunluklar kaydetti\u011finde (uyarlanabilir stepper'lar, <code>record_interval</code> vb.), <code>t_all</code> ve <code>data</code> hizal\u0131 kal\u0131r, b\u00f6ylece her \u00e7al\u0131\u015ft\u0131rmay\u0131 manuel olarak i\u015fleyebilirsiniz.</p> <p><code>SweepRunsView</code>, \u00e7al\u0131\u015ft\u0131rma de\u011ferleri \u00fczerinde liste benzeri bir sarmalay\u0131c\u0131d\u0131r; \u00fczerinde gezinmek <code>SweepRun</code> \u00f6rnekleri \u00fcretir. Her <code>SweepRun</code>, <code>param_value</code> de\u011ferini, \u00e7al\u0131\u015ft\u0131rma ba\u015f\u0131na <code>t</code>'yi ve bir de\u011fi\u015fken arama tablosunu saklar, b\u00f6ylece <code>run[\"x\"]</code> veya <code>run[[\"x\",\"y\"]]</code> o parametre de\u011feri i\u00e7in kaydedilen izi (trace) d\u00f6nd\u00fcr\u00fcr.</p>"},{"location":"tr/guides/analysis/sweep/#tarama-yardmclar","title":"Tarama yard\u0131mc\u0131lar\u0131","text":""},{"location":"tr/guides/analysis/sweep/#scalar_sweep","title":"<code>scalar_sweep</code>","text":"<p>Parametre de\u011feri ba\u015f\u0131na tek say\u0131l\u0131k \u00f6zetler (denge noktalar\u0131, ortalama e\u011filimler, min/max zarflar\u0131) i\u00e7in <code>scalar_sweep</code> kullan\u0131n. Tek bir <code>var</code> kaydedersiniz ve bir indirgeme <code>mode</code> (modu) se\u00e7ersiniz:</p> <ul> <li><code>\"final\"</code> (varsay\u0131lan): kaydedilen son \u00f6rnek</li> <li><code>\"mean\"</code>: kaydedilen pencere \u00fczerindeki aritmetik ortalama</li> <li><code>\"max\"</code>/<code>\"min\"</code>: u\u00e7 de\u011ferler</li> </ul> <p>Yard\u0131mc\u0131, uygun konfig\u00fcrasyonlar i\u00e7in h\u0131zl\u0131 bir toplu \u00e7al\u0131\u015ft\u0131rma (<code>fastpath_batch_for_sim</code>) dener. H\u0131zl\u0131 yol (fast path) kullan\u0131lamazsa uyar\u0131r (<code>_warn_fastpath_fallback</code>) ve normal <code>Sim.run()</code> \u00e7a\u011fr\u0131lar\u0131na geri d\u00f6ner. Sonu\u00e7, <code>outputs['y']</code> i\u00e7inde indirgenmi\u015f diziyi (<code>(M,)</code> \u015feklinde) tutan ve <code>meta</code> i\u00e7inde entegrasyon ayarlar\u0131n\u0131, stepper t\u00fcr\u00fcn\u00fc ve indirgeme modunu kaydeden bir <code>SweepResult(kind=\"scalar\")</code> olur.</p> <pre><code>from dynlib.plot import series\n\nres = sweep.scalar_sweep(\n    sim,\n    param=\"r\",\n    values=np.linspace(2.5, 4.0, 4000),\n    var=\"x\",\n    mode=\"final\",\n    N=2000,\n    transient=1000,\n)\nseries.plot(x=res.values, y=res.y, xlabel=\"r\", ylabel=\"x*\")\n</code></pre>"},{"location":"tr/guides/analysis/sweep/#traj_sweep","title":"<code>traj_sweep</code>","text":"<p><code>traj_sweep</code>, herhangi bir <code>record_vars</code> kombinasyonu (\u00f6r. <code>\"x\"</code>, <code>\"y\"</code>, <code>\"z\"</code>) i\u00e7in tam y\u00f6r\u00fcngeleri kaydeder. Her \u00e7al\u0131\u015ft\u0131rman\u0131n zaman serisi bir <code>TrajectoryPayload</code> i\u00e7inde ya\u015far, b\u00f6ylece parametre ba\u015f\u0131na \u00e7izim yapmak i\u00e7in <code>res[\"x\"]</code>, <code>res.series([\"x\",\"y\"])</code>, <code>res.stack()</code> \u00e7a\u011f\u0131rabilir veya <code>res.runs</code> \u00fczerinde gezinebilirsiniz. Tarama, hem h\u0131zl\u0131 toplu \u00e7al\u0131\u015ft\u0131rmay\u0131 hem de <code>values</code> &gt; 1000 oldu\u011funda <code>ProcessPoolExecutor</code>'\u0131 destekler. <code>parallel_mode</code> arg\u00fcman\u0131, bu toplu \u00e7al\u0131\u015ft\u0131rman\u0131n nas\u0131l y\u00fcr\u00fct\u00fclece\u011fini kontrol eder (<code>\"auto\"</code>, <code>\"threads\"</code>, <code>\"process\"</code>, <code>\"none\"</code>); <code>max_workers</code> i\u015f\u00e7i (worker) havuzu boyutunu ayarlar. \u0130\u015f\u00e7i say\u0131s\u0131 bir oldu\u011funda veya <code>process</code> modu verimli olmad\u0131\u011f\u0131nda, yard\u0131mc\u0131 \u015feffaf bir \u015fekilde s\u0131ral\u0131 y\u00fcr\u00fctmeye d\u00fc\u015fer.</p> <p><code>record_interval</code>, bellek tasarrufu i\u00e7in kayd\u0131 seyreltmenize (decimate) olanak tan\u0131r ve tarama bu aral\u0131\u011f\u0131 <code>meta</code> i\u00e7inde hat\u0131rlar. Ayr\u0131ca sabit bir <code>dt</code>, <code>t0</code>, <code>T</code> veya ayr\u0131k iterasyon say\u0131s\u0131 <code>N</code> (haritalar/maps i\u00e7in kullan\u0131\u015fl\u0131d\u0131r) talep edebilirsiniz.</p> <pre><code>from dynlib.plot import phase\n\nres = sweep.traj_sweep(\n    sim,\n    param=\"A\",\n    values=[0.5, 1.0, 1.5],\n    record_vars=[\"x\", \"y\"],\n    dt=0.01,\n    T=20.0,\n    record_interval=5,\n)\nfor run in res.runs:\n    phase.xy(x=run[\"x\"], y=run[\"y\"], label=f\"A={run.param_value}\")\n</code></pre>"},{"location":"tr/guides/analysis/sweep/#lyapunov_mle_sweep","title":"<code>lyapunov_mle_sweep</code>","text":"<p>Bu yard\u0131mc\u0131, maksimum Lyapunov \u00fcss\u00fc (MLE) g\u00f6zlemcisi ile bir parametre taramas\u0131n\u0131 birle\u015ftirir. H\u0131zl\u0131 toplu \u00e7al\u0131\u015ft\u0131rma (ve Lyapunov g\u00f6zlemcilerinin kendileri) i\u00e7in, sabit ad\u0131ml\u0131 bir stepper ve a\u00e7\u0131k bir <code>dt</code> ile JIT-derlenmi\u015f bir sim\u00fclasyon kullanmal\u0131s\u0131n\u0131z, ancak h\u0131zl\u0131 yol deste\u011fi yoksa yard\u0131mc\u0131, g\u00f6zlemciler eklenmi\u015f s\u0131ral\u0131 <code>Sim.run()</code> i\u015flemine nazik\u00e7e geri d\u00f6ner. Fonksiyon, <code>mle</code>, <code>log_growth</code> ve <code>steps</code> i\u00e7in <code>outputs</code> d\u00f6nd\u00fcr\u00fcr ve e\u011fer <code>record_interval</code> sa\u011flad\u0131ysan\u0131z, her \u00fcss\u00fcn nas\u0131l yak\u0131nsad\u0131\u011f\u0131n\u0131 inceleyebilmeniz i\u00e7in <code>traces['mle']</code> (yak\u0131nsama dizileri listesi) de d\u00f6nd\u00fcr\u00fcr. <code>analysis_kind</code>, algoritma varyantlar\u0131 aras\u0131nda se\u00e7im yapman\u0131z\u0131 sa\u011flar.</p> <p>Tarama, iste\u011fe ba\u011fl\u0131 <code>ProcessPoolExecutor</code> h\u0131zland\u0131rmas\u0131yla (de\u011fer listesinin par\u00e7alar\u0131 halinde) h\u0131zl\u0131 toplu \u00e7al\u0131\u015ft\u0131rmalar dener. H\u0131zl\u0131 yol veya h\u0131zl\u0131 paralel i\u015f\u00e7i ba\u015flatma ba\u015far\u0131s\u0131z olursa, uyar\u0131r ve Lyapunov g\u00f6zlemcisi eklenmi\u015f s\u0131ral\u0131 <code>Sim.run()</code> \u00e7a\u011fr\u0131lar\u0131na geri d\u00f6ner.</p> <pre><code>from dynlib.plot import series\n\nres = sweep.lyapunov_mle_sweep(\n    sim,\n    param=\"r\",\n    values=np.linspace(3.0, 4.0, 400),\n    N=5000,\n    transient=1000,\n    record_interval=10,\n)\nseries.plot(x=res.values, y=res.mle, xlabel=\"r\", ylabel=\"\u03bb_max\")\n</code></pre>"},{"location":"tr/guides/analysis/sweep/#lyapunov_spectrum_sweep","title":"<code>lyapunov_spectrum_sweep</code>","text":"<p>Bir parametre \u0131zgaras\u0131 boyunca ilk <code>k</code> Lyapunov \u00fcss\u00fcn\u00fc hesaplay\u0131n. MLE taramas\u0131 gibi, bu da JIT + sabit <code>dt</code> h\u0131zl\u0131 yol y\u00fcr\u00fctmesi i\u00e7in ayarlanm\u0131\u015ft\u0131r (ve te\u011fet uzay\u0131 i\u00e7in iste\u011fe ba\u011fl\u0131 bir <code>init_basis</code> kabul eder), ancak toplu h\u0131zl\u0131 yol veya i\u015flem paralelli\u011fi mevcut olmad\u0131\u011f\u0131nda g\u00f6zlemci eklenmi\u015f s\u0131ral\u0131 <code>Sim.run()</code> i\u015flemine de geri d\u00f6ner. <code>outputs</code> s\u00f6zl\u00fc\u011f\u00fc her zaman \u015funlar\u0131 i\u00e7erir:</p> <ul> <li><code>spectrum</code>: normalle\u015ftirilmi\u015f \u00fcsleri i\u00e7eren <code>(M, k)</code> \u015feklindeki dizi</li> <li><code>log_r</code>: ham logaritmik b\u00fcy\u00fcme de\u011ferleri (<code>(M, k)</code> \u015feklinde)</li> <li><code>steps</code>: de\u011fer ba\u015f\u0131na algoritma ad\u0131mlar\u0131n\u0131n son say\u0131s\u0131</li> <li><code>lyap0</code>, <code>lyap1</code>, \u2026 <code>lyap{k-1}</code>: her \u00fcs s\u00fctunu i\u00e7in uygun takma adlar</li> </ul> <p><code>traces</code> yoktur, \u00e7\u00fcnk\u00fc altta yatan g\u00f6zlemci yaln\u0131zca en son spektrumu yayar. <code>parallel_mode</code>/<code>max_workers</code> ve <code>record_interval</code> kullan\u0131m\u0131n\u0131 t\u0131pk\u0131 MLE taramas\u0131ndaki gibi yap\u0131n; yard\u0131mc\u0131 gerekti\u011finde s\u0131ral\u0131 y\u00fcr\u00fctmeye de geri d\u00f6ner.</p>"},{"location":"tr/guides/analysis/sweep/#pratik-notlar","title":"Pratik notlar","text":"<ul> <li>H\u0131zl\u0131 yol kapal\u0131ysa (<code>fastpath_batch_for_sim</code>, <code>None</code> d\u00f6nd\u00fcr\u00fcrse), taraman\u0131n <code>Sim.run()</code>'a geri d\u00f6nd\u00fc\u011f\u00fcne dair bir uyar\u0131 g\u00f6r\u00fcrs\u00fcn\u00fcz. <code>jit=True</code> sa\u011flamak, sabit ad\u0131ml\u0131 stepper'lar kullanmak ve a\u00e7\u0131k <code>dt</code>/<code>N</code> de\u011ferleri kaydetmek h\u0131zl\u0131 yolu sa\u011fl\u0131kl\u0131 tutar.</li> <li>Y\u00f6r\u00fcnge (trajectory) taramalar\u0131 i\u00e7in <code>record_interval</code> ve <code>max_steps</code>, bellek/i\u015flemci takas\u0131 yapman\u0131za olanak tan\u0131r. Y\u00f6r\u00fcngeler tam olarak \u00fcretildi\u011fi gibi saklan\u0131r, b\u00f6ylece sa\u00e7\u0131l\u0131m bulutlar\u0131, u\u00e7 de\u011ferler veya k\u0131rp\u0131lm\u0131\u015f \u00f6rnek setleri olu\u015fturmak \u00fczere <code>res.bifurcation(\"x\")</code> arac\u0131l\u0131\u011f\u0131yla <code>dynlib.analysis.post.bifurcation.BifurcationExtractor</code> ile bunlar\u0131 tekrar kullanabilirsiniz.</li> <li>Lyapunov yard\u0131mc\u0131lar\u0131 <code>analysis_kind</code> (varsay\u0131lan <code>1</code>) kabul eder, b\u00f6ylece sisteminize en uygun varyant\u0131 se\u00e7ebilirsiniz. <code>max_workers</code>, <code>_resolve_process_workers</code> arac\u0131l\u0131\u011f\u0131yla makine \u00e7ekirdeklerine (maksimum 8 ile s\u0131n\u0131rl\u0131) varsay\u0131lan olarak ayarlan\u0131r.</li> <li><code>traj_sweep</code> \u00e7al\u0131\u015ft\u0131ran, <code>res.bifurcation(\"x\")</code> \u00e7\u0131karan ve sonucu <code>dynlib.plot.bifurcation_diagram</code>'a besleyen u\u00e7tan uca bir senaryo i\u00e7in <code>examples/bifurcation_logistic_map.py</code> \u00f6rne\u011fine bak\u0131n.</li> <li>T\u00fcm taramalar, verilerin nas\u0131l olu\u015fturuldu\u011funu izleyebilmeniz i\u00e7in stepper ayarlar\u0131n\u0131, zaman damgalar\u0131n\u0131 ve herhangi bir paralel \u00e7al\u0131\u015ft\u0131rma yap\u0131land\u0131rmas\u0131n\u0131 i\u00e7eren <code>meta</code> verilerini d\u00f6nd\u00fcr\u00fcr.</li> </ul>"},{"location":"tr/guides/cli/cli/","title":"Komut sat\u0131r\u0131 rehberi","text":"<p>Dynlib, iki giri\u015f noktas\u0131 olarak hafif bir komut sat\u0131r\u0131 aray\u00fcz\u00fc sunar: paketle birlikte y\u00fcklenen <code>dynlib</code> konsol beti\u011fi ve <code>python -m dynlib.cli</code>. CLI (Komut Sat\u0131r\u0131 Aray\u00fcz\u00fc), bir Python beti\u011fi yazmadan modelleri do\u011frulayabilmeniz, stepper kayd\u0131n\u0131 inceleyebilmeniz ve disk \u00fczerindeki JIT \u00f6nbelle\u011fini y\u00f6netebilmeniz i\u00e7in bir avu\u00e7 \u00e7al\u0131\u015fma zaman\u0131 arac\u0131n\u0131 aynalar. Her fiil/isim ayr\u0131\u015ft\u0131r\u0131c\u0131 katman\u0131 <code>--help</code> se\u00e7ene\u011fini destekler, bu nedenle mevcut se\u00e7enekleri hat\u0131rlaman\u0131z gerekti\u011finde <code>dynlib &lt;komut&gt; --help</code> veya <code>python -m dynlib.cli &lt;komut&gt; --help</code> komutunu \u00e7al\u0131\u015ft\u0131r\u0131n.</p>"},{"location":"tr/guides/cli/cli/#genel-bayraklar","title":"Genel bayraklar","text":"<ul> <li><code>--version</code>   \u015eu anda y\u00fckl\u00fc olan dynlib s\u00fcr\u00fcm\u00fcn\u00fc yazd\u0131r\u0131r. CLI, s\u00fcr\u00fcm\u00fc \u00f6nce <code>importlib.metadata</code> arac\u0131l\u0131\u011f\u0131yla ke\u015ffeder, bu ba\u015far\u0131s\u0131z oldu\u011funda ise (d\u00fczenlenebilir kurulumlar, kaynak kod kontrolleri vb.) <code>pyproject.toml</code> dosyas\u0131n\u0131 okumaya ge\u00e7er.</li> </ul>"},{"location":"tr/guides/cli/cli/#model-araclar","title":"Model ara\u00e7lar\u0131","text":"<p><code>dynlib model validate &lt;uri&gt;</code></p> <ul> <li>Ama\u00e7: Dynlib'in TOML tabanl\u0131 DSL'inde tan\u0131mlanm\u0131\u015f bir modeli ayr\u0131\u015ft\u0131r\u0131r ve do\u011frular. CLI, i\u015flemi <code>load_model_from_uri</code> i\u015flevine devreder, bu nedenle projenin geri kalan\u0131nda kullan\u0131lan <code>builtin://</code> URI'lerini, dosya sistemi yollar\u0131n\u0131 ve di\u011fer kay\u0131tl\u0131 y\u00fckleyicileri destekler.</li> <li>Ba\u015far\u0131 mesaj\u0131: DSL ge\u00e7erli oldu\u011funda, komut <code>Model OK</code> mesaj\u0131yla birlikte model t\u00fcr\u00fcn\u00fc (<code>ode</code> veya <code>map</code>), veri tipini (dtype), durum (state) say\u0131s\u0131n\u0131 ve <code>spec.sim.stepper</code> i\u00e7inde kay\u0131tl\u0131 varsay\u0131lan stepper'\u0131 yazd\u0131r\u0131r.</li> <li>Hata y\u00f6netimi: S\u00f6zdizimi ihlalleri, eksik alanlar veya \u00e7al\u0131\u015fma zaman\u0131 do\u011frulama sorunlar\u0131, <code>stderr</code> \u00fczerinde a\u00e7\u0131klay\u0131c\u0131 bir mesaj ve s\u0131f\u0131r olmayan bir \u00e7\u0131k\u0131\u015f kodu ile <code>DynlibError</code> arac\u0131l\u0131\u011f\u0131yla g\u00f6sterilir.</li> </ul> <p>Bu komutu, bir sim\u00fclasyonu \u00e7al\u0131\u015ft\u0131rmadan, bir modeli payla\u015fmadan veya spesifikasyonu ba\u015fka bir ara\u00e7 zincirine dahil etmeden \u00f6nce h\u0131zl\u0131 bir sa\u011flaml\u0131k kontrol\u00fc olarak kullan\u0131n.</p>"},{"location":"tr/guides/cli/cli/#stepper-kayd","title":"Stepper kayd\u0131","text":"<p><code>dynlib steppers list [--kind &lt;t\u00fcr&gt;] [--&lt;kapasite&gt;] [--jacobian &lt;politika&gt;]</code></p> <ul> <li>Ama\u00e7: Kay\u0131tl\u0131 her <code>StepperMeta</code>/<code>StepperCaps</code> \u00e7iftini inceleyin. CLI, yan etki olarak <code>dynlib.steppers</code> mod\u00fcl\u00fcn\u00fc i\u00e7e aktard\u0131\u011f\u0131 i\u00e7in, t\u00fcm yerle\u015fik ve kay\u0131tl\u0131 \u00fc\u00e7\u00fcnc\u00fc taraf stepper'lar listede g\u00f6r\u00fcn\u00fcr.</li> <li>G\u00f6r\u00fcnt\u00fclenen s\u00fctunlar: Her sat\u0131r; stepper ad\u0131n\u0131, <code>kind</code> (t\u00fcr), <code>scheme</code> (\u015fema), <code>order</code> (derece), <code>stiff</code> (sertlik) ipucunu ve her <code>StepperCaps</code> alan\u0131n\u0131 g\u00f6sterir, b\u00f6ylece kaynak kodunu okumadan \u00f6zellikleri h\u0131zl\u0131ca kar\u015f\u0131la\u015ft\u0131rabilirsiniz.</li> <li>T\u00fcr (Kind) filtresi: Listeyi sadece ODE \u00e7\u00f6z\u00fcc\u00fcler veya ayr\u0131k haritalarla (\u00e7al\u0131\u015fma zaman\u0131 taraf\u0131ndan kullan\u0131lan ayn\u0131 <code>Kind</code> numaraland\u0131rmas\u0131) s\u0131n\u0131rlamak i\u00e7in <code>--kind ode</code> veya <code>--kind map</code> kullan\u0131n.</li> <li>Kapasite filtreleri: CLI, her <code>StepperCaps</code> alan\u0131 i\u00e7in dinamik olarak bir bayrak sunar.</li> <li>Boolean (Mant\u0131ksal) bayraklar (<code>--dense_output</code>, <code>--jit_capable</code>, <code>--requires_scipy</code>, <code>--variational_stepping</code>) birer gereksinimdir. Sa\u011fland\u0131\u011f\u0131nda, yaln\u0131zca <code>StepperCaps</code> ayar\u0131 o alan\u0131 <code>True</code> (Do\u011fru) olarak ayarlayan stepper'lar \u00e7\u0131kt\u0131da kal\u0131r.</li> <li>De\u011fer bayraklar\u0131 \u015fu anda <code>--jacobian</code> se\u00e7ene\u011fini i\u00e7erir (<code>JacobianPolicy</code> de\u011fi\u015fmeziyle e\u015fle\u015fir: <code>none</code>, <code>internal</code>, <code>optional</code>, <code>required</code>). O Jacobian davran\u0131\u015f\u0131n\u0131 bildiren stepper'lar\u0131 filtrelemek i\u00e7in tam politika dizesini sa\u011flay\u0131n.</li> <li>Kullan\u0131m durumlar\u0131: Bu komut, hangi stepper'lar\u0131n yo\u011fun \u00e7\u0131kt\u0131y\u0131 (dense output) destekledi\u011fini do\u011frulamak (\u00f6rne\u011fin, animasyon veya de\u011fi\u015fken ad\u0131ml\u0131 enterpolasyon i\u00e7in temel olu\u015fturup olu\u015fturmad\u0131\u011f\u0131), JIT ile derlenebilen alt k\u00fcmeyi belirlemek veya \u00fc\u00e7\u00fcnc\u00fc taraf bir stepper'\u0131n bekledi\u011finiz yetenekleri kaydetti\u011fini h\u0131zl\u0131ca kontrol etmek i\u00e7in kullan\u0131\u015fl\u0131d\u0131r.</li> </ul>"},{"location":"tr/guides/cli/cli/#onbellek-cache-yonetimi","title":"\u00d6nbellek (Cache) y\u00f6netimi","text":"<p>T\u00fcm \u00f6nbellek komutlar\u0131 <code>resolve_cache_root()</code> i\u015flevine devreder, b\u00f6ylece yap\u0131land\u0131rma dosyas\u0131nda a\u00e7\u0131klanan <code>[cache]</code> ge\u00e7ersiz k\u0131lmalar\u0131n\u0131za, <code>DYN_MODEL_PATH</code> etiket haritas\u0131 uzant\u0131lar\u0131n\u0131za veya <code>DYNLIB_CONFIG</code> ortam de\u011fi\u015fkeninize sayg\u0131 duyarlar.</p>"},{"location":"tr/guides/cli/cli/#dynlib-cache-path","title":"<code>dynlib cache path</code>","text":"<ul> <li>\u00d6nbellek k\u00f6k dizinini yazd\u0131r\u0131r. Diskteki dosyalar\u0131 incelemek, dizini bir konteyner i\u00e7ine ba\u011flamak (mount) veya izin sorunlar\u0131n\u0131 gidermek istedi\u011finizde kullan\u0131\u015fl\u0131d\u0131r.</li> </ul>"},{"location":"tr/guides/cli/cli/#dynlib-cache-list-stepper-isim-dtype-belirtec-hash-onek","title":"<code>dynlib cache list [--stepper &lt;isim&gt;] [--dtype &lt;belirte\u00e7&gt;] [--hash &lt;\u00f6nek&gt;]</code>","text":"<ul> <li>Ama\u00e7: <code>cache_root/jit/{triplets,steppers,runners}</code> alt\u0131ndaki her girdiyi numaraland\u0131r\u0131r.</li> <li>\u00c7\u0131kt\u0131 format\u0131: Her girdi; aileyi (<code>triplets</code>, <code>steppers</code> veya <code>runners</code>), stepper ad\u0131n\u0131, dtype'\u0131, spec \u00f6zetini (hash), digest'i, boyutu (okunabilir formatta) ve dosya yolu bilgisini yazd\u0131r\u0131r. Derleme zaman\u0131 bile\u015fenlerini kaydeden girdiler ayr\u0131ca <code>components=...</code> bilgisini de ekler.</li> <li>Filtreler:</li> <li><code>--stepper</code> stepper ad\u0131yla e\u015fle\u015fir (b\u00fcy\u00fck/k\u00fc\u00e7\u00fck harf duyars\u0131z).</li> <li><code>--dtype</code> dtype belirteciyle e\u015fle\u015fir (b\u00fcy\u00fck/k\u00fc\u00e7\u00fck harf duyars\u0131z).</li> <li><code>--hash</code>, belirli bir spesifikasyonla ili\u015fkili yap\u0131lar\u0131 \u00e7ekmek i\u00e7in model spec \u00f6zetinin (hash) bir \u00f6nekiyle e\u015fle\u015fir.</li> <li>S\u0131ralama: Sonu\u00e7lar aile, stepper, dtype ve digest'e g\u00f6re s\u0131ralan\u0131r, b\u00f6ylece ili\u015fkili yap\u0131lar bir arada g\u00f6r\u00fcn\u00fcr.</li> <li>Kullan\u0131m durumlar\u0131: Dtype veya stepper de\u011fi\u015ftirdikten sonra \u00f6nbelle\u011fe al\u0131nm\u0131\u015f \u00e7ekirdeklerin (kernels) var olup olmad\u0131\u011f\u0131n\u0131 do\u011frulamak veya <code>disk_cache</code> bayra\u011f\u0131n\u0131n geride hangi \u00e7al\u0131\u015ft\u0131r\u0131c\u0131lar\u0131 (runners) b\u0131rakt\u0131\u011f\u0131n\u0131 kontrol etmek i\u00e7in bunu \u00e7al\u0131\u015ft\u0131r\u0131n. <code>--hash</code> ile filtreleme, bir model \u00f6zeti (hash) i\u00e7in derlenmi\u015f yap\u0131y\u0131 bulman\u0131n en h\u0131zl\u0131 yoludur ve <code>--dtype</code> kar\u0131\u015f\u0131k hassasiyet kulland\u0131\u011f\u0131n\u0131zda yard\u0131mc\u0131 olur.</li> </ul>"},{"location":"tr/guides/cli/cli/#dynlib-cache-clear-all-stepper-isim-dtype-belirtec-hash-onek-dry_run","title":"<code>dynlib cache clear (--all | --stepper &lt;isim&gt; | --dtype &lt;belirte\u00e7&gt; | --hash &lt;\u00f6nek&gt;) [--dry_run]</code>","text":"<ul> <li>Ama\u00e7: Art\u0131k ihtiya\u00e7 duymad\u0131\u011f\u0131n\u0131z \u00f6nbelle\u011fe al\u0131nm\u0131\u015f JIT yap\u0131lar\u0131n\u0131 silmek veya kod de\u011fi\u015fikliklerinden sonra \u00f6nbellek bozulmas\u0131n\u0131 d\u00fczeltmek.</li> <li>G\u00fcvenlik \u00f6nlemi: <code>--all</code> veya filtre bayraklar\u0131ndan en az birini belirtmelisiniz. Bir filtre olmadan CLI, bir mesaj ve <code>2</code> hata kodu ile \u00e7\u0131kar.</li> <li><code>--all</code>: <code>shutil.rmtree</code> arac\u0131l\u0131\u011f\u0131yla t\u00fcm \u00f6nbellek k\u00f6k dizinini kald\u0131r\u0131r. Temiz bir sayfa istedi\u011finizde (\u00f6rne\u011fin, dynlib'i g\u00fcncelledikten veya <code>cache_root</code> de\u011fi\u015ftirdikten sonra) bunu kullan\u0131n. Dizin eksikse komut hi\u00e7bir \u015fey yapmaz.</li> <li>Se\u00e7ici silme: Yaln\u0131zca e\u015fle\u015fen \u00f6nbellek girdilerini silmek i\u00e7in <code>--stepper</code>, <code>--dtype</code> ve/veya <code>--hash</code> se\u00e7eneklerini birle\u015ftirin. E\u015fle\u015ftirme b\u00fcy\u00fck/k\u00fc\u00e7\u00fck harfe duyarl\u0131 de\u011fildir ve <code>--hash</code> \u00f6nek e\u015fle\u015fmeleri \u00fczerinde \u00e7al\u0131\u015f\u0131r, b\u00f6ylece \u00f6zetin (hash) yaln\u0131zca bir k\u0131sm\u0131n\u0131 hat\u0131rlasan\u0131z bile bir commit'i veya spec s\u00fcr\u00fcm\u00fcn\u00fc hedefleyebilirsiniz.</li> <li><code>--dry_run</code>: Diske dokunmadan silinecek dosya ve dizinleri yazd\u0131r\u0131r. Y\u0131k\u0131c\u0131 bir i\u015flemden \u00f6nce hedef listesini iki kez kontrol etmek i\u00e7in bunu \u00e7al\u0131\u015ft\u0131r\u0131n.</li> <li>Geri bildirim: Silinen her \u00f6nbellek bir onay sat\u0131r\u0131 yazd\u0131r\u0131r ve herhangi bir silme i\u015flemi ba\u015far\u0131s\u0131z olursa komut s\u0131f\u0131r olmayan bir \u00e7\u0131k\u0131\u015f kodu d\u00f6nd\u00fcr\u00fcr.</li> </ul>"},{"location":"tr/guides/cli/cli/#ornekler","title":"\u00d6rnekler","text":"<pre><code>dynlib model validate docs/models/lorenz.toml\ndynlib steppers list --kind ode --jit_capable --variational_stepping\ndynlib cache list --hash 9c8a --dtype float64\ndynlib cache clear --stepper rk4 --dry_run\n</code></pre>"},{"location":"tr/guides/cli/cli/#sorun-giderme","title":"Sorun Giderme","text":"<ul> <li>\u00d6nbellek sorunlar\u0131n\u0131 incelerken, hangi dizini kontrol etti\u011finizi bilmek i\u00e7in <code>dynlib cache list</code> komutunu <code>dynlib cache path</code> ile e\u015fle\u015ftirin.</li> <li>CLI bekledi\u011finiz bir stepper'\u0131 bulamazsa, onu tan\u0131mlayan mod\u00fcl\u00fcn i\u00e7e aktar\u0131ld\u0131\u011f\u0131ndan emin olun (\u00e7al\u0131\u015fma zaman\u0131 ba\u015flang\u0131\u00e7ta <code>dynlib.steppers</code> mod\u00fcl\u00fcn\u00fc otomatik olarak i\u00e7e aktar\u0131r, ancak \u00fc\u00e7\u00fcnc\u00fc taraf stepper'lar CLI \u00e7al\u0131\u015ft\u0131r\u0131lmadan \u00f6nce kendilerini kaydettirmelidir).</li> <li><code>model validate</code> komutu herhangi bir DSL ayr\u0131\u015ft\u0131rma sorunu i\u00e7in <code>DynlibError</code> y\u00fckseltir; hata \u00e7\u0131kt\u0131s\u0131n\u0131 ba\u015fka bir ara\u00e7la i\u015flemek istedi\u011finizde bunu bir kabuk (shell) boru hatt\u0131nda \u00e7al\u0131\u015ft\u0131r\u0131n (<code>dynlib model validate ... || true</code>).</li> </ul>"},{"location":"tr/guides/modeling/","title":"Modelleme rehberi","text":"<p>Bu rehber; TOML DSL'ini ve spesifikasyonlar\u0131 yap\u0131land\u0131r\u0131lm\u0131\u015f, okunabilir ve yeniden \u00fcretilebilir tutan yard\u0131mc\u0131 ara\u00e7lar\u0131 kullanarak dynlib modellerini nas\u0131l bildirece\u011finizi, geni\u015fletece\u011finizi ve ince ayar yapaca\u011f\u0131n\u0131z\u0131 a\u00e7\u0131klar. DSL genel bak\u0131\u015f\u0131 ile ba\u015flay\u0131n, ard\u0131ndan yeniden kullan\u0131labilir bile\u015fenleri ve bir spesifikasyonu \u00e7al\u0131\u015fma zaman\u0131na ba\u011flayan i\u015f ak\u0131\u015f\u0131 yard\u0131mc\u0131lar\u0131n\u0131 ke\u015ffedin.</p>"},{"location":"tr/guides/modeling/#model-yapsnn-temelleri","title":"Model yap\u0131s\u0131n\u0131n temelleri","text":"<ul> <li>DSL temelleri \u2014 yazabilece\u011finiz her tabloyu listeleyen kurall\u0131 TOML \u015fablonu (<code>[model]</code>, <code>[states]</code>, <code>[params]</code>, <code>[constants]</code>, <code>[equations]</code>, <code>[aux]</code>, <code>[functions]</code>, <code>[events]</code>, <code>[sim]</code>, vb.).</li> <li>Denklemler \u2014 <code>rhs</code> (sa\u011f taraf), blok, ters ve Jacobian formlar\u0131n\u0131 kar\u015f\u0131la\u015ft\u0131r\u0131r, her birini hangi ba\u011flamlar\u0131n kabul etti\u011fini a\u00e7\u0131klar ve sa\u011f taraflar\u0131n\u0131z\u0131 d\u00fczenli tutmak i\u00e7in en iyi uygulamalar\u0131 ana hatlar\u0131yla belirtir.</li> <li>Matematik ve makrolar \u2014 her ifadenin i\u00e7inde bulunan yerle\u015fik matematik fonksiyonlar\u0131n\u0131, skaler makrolar\u0131 (<code>clip</code>, <code>approx</code>, <code>relu</code>, vb.), \u00fcrete\u00e7 ifadelerini ve olay yard\u0131mc\u0131 programlar\u0131n\u0131 listeler.</li> <li>\u00dc\u00e7l\u00fc (Ternary) <code>if</code> \u2014 Python tarz\u0131 \u00fc\u00e7l\u00fc ifadenin, sizi tam <code>if</code>/<code>else</code> bloklar\u0131na \u00e7ekmeden k\u00fc\u00e7\u00fck dallanmalar\u0131 nas\u0131l kolayla\u015ft\u0131rd\u0131\u011f\u0131n\u0131 g\u00f6sterir.</li> <li>Model kay\u0131t defteri \u2014 etiket URI'lerini (<code>builtin://</code>, \u00f6zel etiketler, sat\u0131r i\u00e7i modeller), <code>DYNLIB_CONFIG</code>/<code>DYN_MODEL_PATH</code> davran\u0131\u015f\u0131n\u0131 ve kay\u0131t yollar\u0131n\u0131 do\u011frulayan veya ge\u00e7ersiz k\u0131lan CLI yard\u0131mc\u0131lar\u0131n\u0131 tan\u0131mlar.</li> </ul>"},{"location":"tr/guides/modeling/#yeniden-kullanlabilir-yap-taslar","title":"Yeniden kullan\u0131labilir yap\u0131 ta\u015flar\u0131","text":"<ul> <li>Auxiliary (Yard\u0131mc\u0131) de\u011fi\u015fkenler \u2014 t\u00fcretilmi\u015f ifadeleri isimlendirin, b\u00f6ylece matemati\u011fi tekrarlamadan denklemler, olaylar veya Jacobian'lar aras\u0131nda payla\u015fabilirsiniz.</li> <li>DSL fonksiyonlar\u0131 \u2014 arg\u00fcmanlar\u0131, ifade g\u00f6vdeleri ve DSL'i bildirimsel tutan temiz \u00e7a\u011fr\u0131 yerleri olan yeniden kullan\u0131labilir fonksiyonlar tan\u0131mlay\u0131n.</li> <li>Olaylar (Events) \u2014 <code>cond</code> (ko\u015ful), <code>action</code> (eylem) ve g\u00fcnl\u00fckleme meta verilerini <code>pre</code>/<code>post</code> a\u015famalar\u0131na ba\u011flay\u0131n, olay makrolar\u0131n\u0131 kullan\u0131n ve h\u0131zl\u0131 yol \u00e7al\u0131\u015ft\u0131r\u0131c\u0131lar\u0131n\u0131 karars\u0131zla\u015ft\u0131rmadan olay g\u00fcnl\u00fcklerini y\u00f6netin.</li> <li>Gecikme (Lagging) \u2014 <code>lag_&lt;state&gt;(k)</code> yard\u0131mc\u0131lar\u0131n\u0131 etkinle\u015ftirin, tampon derinli\u011fini kontrol edin ve gecikmeli durumlar\u0131n ODE'ler, haritalar ve NumPy uyumlu \u00e7al\u0131\u015fma zamanlar\u0131 ile nas\u0131l etkile\u015fime girdi\u011fini anlay\u0131n.</li> <li>Sat\u0131r i\u00e7i (Inline) modeller \u2014 modelleri tamamen testlerin veya not defterlerinin (notebooks) i\u00e7inde prototiplemek i\u00e7in bir Python dizesine bir TOML par\u00e7as\u0131 g\u00f6m\u00fcn.</li> </ul>"},{"location":"tr/guides/modeling/#is-aks-yardmclar","title":"\u0130\u015f ak\u0131\u015f\u0131 yard\u0131mc\u0131lar\u0131","text":"<ul> <li>Yap\u0131land\u0131rma dosyas\u0131 \u2014 kay\u0131t yollar\u0131n\u0131, \u00f6nbellek k\u00f6klerini ve eklenti davran\u0131\u015f\u0131n\u0131 <code>~/.config/dynlib/config.toml</code> veya <code>DYNLIB_CONFIG</code> ortam de\u011fi\u015fkeni arac\u0131l\u0131\u011f\u0131yla \u00f6zelle\u015ftirin.</li> <li>Modlar (Mods) \u2014 <code>remove</code>, <code>replace</code>, <code>add</code> ve <code>set</code> eylemleriyle modelleri dinamik olarak yamalay\u0131n; b\u00f6ylece temel spesifikasyonu klonlamadan varyantlar olu\u015fturabilir, parametreleri ge\u00e7ersiz k\u0131labilir veya yeni olaylar ekleyebilirsiniz.</li> <li>\u00d6n ayarlar (Presets) \u2014 yeniden kullan\u0131labilir durum/parametre anl\u0131k g\u00f6r\u00fcnt\u00fclerini yakalay\u0131n, bunlar\u0131 diskten y\u00fckleyin/kaydedin ve sim\u00fclasyon bankas\u0131 arac\u0131l\u0131\u011f\u0131yla yeniden oynat\u0131n.</li> <li>Sim\u00fclasyon varsay\u0131lanlar\u0131 \u2014 <code>[sim]</code> tablosunu belgeleyin, <code>Sim.run</code> ge\u00e7ersiz k\u0131lmalar\u0131yla nas\u0131l birle\u015fti\u011fini a\u00e7\u0131klay\u0131n ve erken \u00e7\u0131k\u0131\u015f, kay\u0131t ve tolerans ayarlar\u0131n\u0131 vurgulay\u0131n.</li> </ul>"},{"location":"tr/guides/modeling/aux/","title":"Yard\u0131mc\u0131 (Aux) De\u011fi\u015fkenler","text":"<p>Yard\u0131mc\u0131 de\u011fi\u015fkenler (DSL dosyalar\u0131nda <code>[aux]</code>), ara veya t\u00fcretilmi\u015f ifadeleri isimlendirmenizi sa\u011flar; b\u00f6ylece mant\u0131klar\u0131n\u0131 tekrarlamadan denklemler, olaylar ve fonksiyonlar boyunca yeniden kullanabilirsiniz. Her ad\u0131mdan (step) sonra durum g\u00fcncellemelerinin ard\u0131ndan de\u011ferlendirilirler ve her ifade model \u00e7al\u0131\u015fmadan \u00f6nce Python'a derlenir.</p>"},{"location":"tr/guides/modeling/aux/#sozdizimi-sentaks","title":"S\u00f6zdizimi (Sentaks)","text":"<pre><code>[aux]\nenergy = \"0.5 * mass * velocity^2\"\ngain = \"baseline_gain * exp(-t / tau)\"\n# D\u00f6ng\u00fc olmad\u0131\u011f\u0131 s\u00fcrece \u00f6nceden tan\u0131mlanm\u0131\u015f herhangi bir aux'u referans alabilirsiniz.\n</code></pre> <ul> <li>Her de\u011fer bir dize (string) sabiti olmal\u0131d\u0131r \u00e7\u00fcnk\u00fc bir ifade olarak ayr\u0131\u015ft\u0131r\u0131l\u0131r ve t\u00fcr kontrol\u00fc yap\u0131l\u0131r. \u0130fade <code>^</code> i\u00e7erdi\u011finde, derleyici Python uyumlulu\u011fu i\u00e7in bunu <code>**</code> olarak yeniden yazar.</li> <li>Aux ifadeleri; durumlara (states), parametrelere, zamana (<code>t</code>), di\u011fer aux de\u011fi\u015fkenlerine (d\u00f6ng\u00fc olmamal\u0131), kullan\u0131c\u0131 tan\u0131ml\u0131 fonksiyonlara, matematik makrolar\u0131na ve \u00fcrete\u00e7 (generator) ifadelerine ba\u015fvurabilir. Olay (event) ba\u011flamlar\u0131nda \u00e7al\u0131\u015fmad\u0131klar\u0131 i\u00e7in olay makrolar\u0131n\u0131 kullanamazlar.</li> <li><code>t</code> (zaman), denklemlerde oldu\u011fu gibi kullan\u0131labilir, bu nedenle zamana ba\u011fl\u0131 aux de\u011fi\u015fkenleri yazmak kolayd\u0131r.</li> </ul>"},{"location":"tr/guides/modeling/aux/#ifade-baglam","title":"\u0130fade Ba\u011flam\u0131","text":"<ul> <li>Durumlar (States): Yaln\u0131zca mevcut de\u011ferler (gecikme/lag notasyonu durumlar\u0131 a\u00e7\u0131k\u00e7a referans almal\u0131d\u0131r).</li> <li>Parametreler: <code>[params]</code> i\u00e7inde tan\u0131mlanan say\u0131sal sabitler.</li> <li>Yard\u0131mc\u0131 (Auxiliary) de\u011fi\u015fkenler: Dosyan\u0131n daha \u00f6nceki k\u0131s\u0131mlar\u0131nda tan\u0131mlanm\u0131\u015f ba\u015fka bir aux kullanabilirsiniz.</li> <li>Yerle\u015fik matematik fonksiyonlar\u0131 ve skaler makrolar: <code>dynlib</code>'in DSL k\u00fct\u00fcphanesindeki her \u015fey (<code>sin</code>, <code>cos</code>, <code>clip</code>, <code>approx</code>, \u00fcrete\u00e7 ifadeleri vb.).</li> <li>Kullan\u0131c\u0131 tan\u0131ml\u0131 fonksiyonlar: <code>[functions]</code> i\u00e7inde beyan edildikten sonra isimleriyle \u00e7a\u011fr\u0131labilirler (\u00f6zyineleme/recursion yoktur).</li> <li>Zaman (<code>t</code>): T\u0131pk\u0131 denklemlerde oldu\u011fu gibi ifadelerde her zaman mevcuttur.</li> <li>Gecikme (Lag) notasyonu: Yaln\u0131zca referans verilen sembol bir durum (state) ise kullan\u0131labilir; aux de\u011fi\u015fkenleri do\u011frudan gecikmeli (lagged) olamaz.</li> </ul>"},{"location":"tr/guides/modeling/aux/#ornek-kullanm","title":"\u00d6rnek Kullan\u0131m","text":"<ul> <li>Enerji, kuvvetler veya kay\u0131t (logging) yard\u0131mc\u0131lar\u0131 gibi payla\u015f\u0131lan ifadeleri hesaplamak i\u00e7in aux kullan\u0131n, b\u00f6ylece uzun hesaplamalar\u0131 tekrarlamazs\u0131n\u0131z.</li> <li>\u0130fadeleri yeniden yazmak yerine <code>cond</code>, <code>action</code> veya <code>log</code> listelerinde referans vererek aux'lar\u0131 olaylarla (events) e\u015fle\u015ftirin.</li> <li>Aux, ayn\u0131 alt ifade birden fazla denklemde g\u00f6r\u00fcnd\u00fc\u011f\u00fcnde Jacobian girdilerini veya \u00fcrete\u00e7 ifadelerini basitle\u015ftirebilir.</li> </ul>"},{"location":"tr/guides/modeling/aux/#modlar-mods-ile-etkilesim","title":"Mod'lar (Mods) ile Etkile\u015fim","text":"<p>Mod'lar; <code>remove</code> (kald\u0131r), <code>replace</code> (de\u011fi\u015ftir), <code>add</code> (ekle) ve <code>set</code> (ayarla) fiillerini kullanarak yard\u0131mc\u0131 de\u011fi\u015fkenleri manip\u00fcle edebilir.</p> <ul> <li><code>mod.remove.aux</code>, aux'un var olmas\u0131n\u0131 gerektirir ve onu modelden basit\u00e7e d\u00fc\u015f\u00fcr\u00fcr.</li> <li><code>mod.replace.aux</code>, ayn\u0131 ismi koruyarak tan\u0131m\u0131 de\u011fi\u015ftirmenize olanak tan\u0131r.</li> <li><code>mod.add.aux</code>, yeni bir yard\u0131mc\u0131 de\u011fi\u015fken ekler (isim zaten varsa hata verir).</li> <li><code>mod.set.aux</code>, ifadeyi ekler veya g\u00fcnceller (eksikse olu\u015fturur, varsa g\u00fcnceller).</li> </ul> <p>Bu fiiller mod fiil s\u0131ras\u0131na (<code>remove \u2192 replace \u2192 add \u2192 set</code>) sayg\u0131 duyar, b\u00f6ylece ayn\u0131 mod i\u00e7inde bir aux'u kald\u0131rabilir ve daha sonra ayn\u0131 isimle yeni bir tan\u0131m ekleyebilirsiniz.</p>"},{"location":"tr/guides/modeling/aux/#en-iyi-uygulamalar","title":"En \u0130yi Uygulamalar","text":"<ol> <li>Okunabilirli\u011fe \u00f6ncelik verin: Aux isimlerini niceli\u011fi tan\u0131mlayacak \u015fekilde verin (<code>kinetic_energy</code>, <code>normalized_voltage</code>), b\u00f6ylece karma\u015f\u0131kl\u0131\u011f\u0131 gizlemek yerine yard\u0131mc\u0131 olsunlar.</li> <li>D\u00f6ng\u00fclerden ka\u00e7\u0131n\u0131n: Aux de\u011fi\u015fkenleri aras\u0131nda kar\u015f\u0131l\u0131kl\u0131 ba\u011f\u0131ml\u0131l\u0131klar olu\u015fturmay\u0131n; derleyici y\u00f6nl\u00fc d\u00f6ng\u00fcs\u00fcz bir yap\u0131y\u0131 (DAG) zorunlu k\u0131lar.</li> <li>\u0130fadeleri odakl\u0131 tutun: Gecikmeli (lagged) de\u011ferlere veya t\u00fcrevsel davran\u0131\u015flara ihtiya\u00e7 duymaya ba\u015flarsan\u0131z, niceli\u011fi aux mant\u0131\u011f\u0131na a\u015f\u0131r\u0131 y\u00fcklemek yerine bir duruma (state) terfi ettirmeyi d\u00fc\u015f\u00fcn\u00fcn.</li> <li>Niyeti belgeleyin: Aux tan\u0131m\u0131n\u0131n yan\u0131ndaki k\u0131sa bir TOML yorumu, gelecekteki okuyuculara t\u00fcretilen niceli\u011fin neden var oldu\u011funu hat\u0131rlatmak i\u00e7in yeterlidir.</li> <li>Dikkatli yeniden kullan\u0131m: Aux, tekrarlanan matematik i\u00e7in harikad\u0131r, ancak matemati\u011fi sadece karma\u015f\u0131kla\u015ft\u0131ran \u00f6nemsiz takma adlarla modeli a\u015f\u0131r\u0131 doldurmay\u0131n.</li> </ol>"},{"location":"tr/guides/modeling/config-file/","title":"Model kay\u0131t yap\u0131land\u0131rmas\u0131","text":"<p>Dynlib, model kay\u0131t defteri detaylar\u0131n\u0131 k\u00fc\u00e7\u00fck bir TOML dosyas\u0131nda tutar; b\u00f6ylece dizinlere etiketler atayabilir, yerle\u015fik modelleri ge\u00e7ersiz k\u0131labilir (override) ve JIT \u00f6nbelle\u011finin nerede ya\u015fayaca\u011f\u0131n\u0131 kontrol edebilirsiniz. <code>load_config()</code>, dosyay\u0131 <code>DYN_MODEL_PATH</code> giri\u015fleri ile birle\u015ftirir ve nihai <code>PathConfig</code> (etiket haritas\u0131 + iste\u011fe ba\u011fl\u0131 \u00f6nbellek k\u00f6k\u00fc) nesnesini her \u00e7\u00f6z\u00fcmleyiciye teslim eder.</p>"},{"location":"tr/guides/modeling/config-file/#yaplandrma-dosyas-nerede-bulunur","title":"Yap\u0131land\u0131rma dosyas\u0131 nerede bulunur","text":"<ul> <li>Varsay\u0131lan yol (<code>DYNLIB_CONFIG</code> ayarlanmad\u0131\u011f\u0131nda):</li> <li>Linux/Unix: <code>${XDG_CONFIG_HOME:-~/.config}/dynlib/config.toml</code></li> <li>macOS: <code>~/Library/Application Support/dynlib/config.toml</code></li> <li>Windows: <code>%APPDATA%/dynlib/config.toml</code></li> <li>Ge\u00e7ersiz K\u0131lma (Override): <code>DYNLIB_CONFIG</code> de\u011fi\u015fkenini \u00f6zel bir TOML dosyas\u0131na ayarlay\u0131n, dynlib bunun yerine o dosyay\u0131 y\u00fckler.</li> <li>Eksik dosya: <code>load_config()</code> sessizce bo\u015f bir yap\u0131land\u0131rma d\u00f6nd\u00fcr\u00fcr, b\u00f6ylece dynlib <code>DYNLIB_CONFIG</code> veya <code>DYN_MODEL_PATH</code> ge\u00e7ersiz k\u0131lmalar\u0131yla \u00e7al\u0131\u015fmaya devam eder.</li> </ul>"},{"location":"tr/guides/modeling/config-file/#dosya-format","title":"Dosya format\u0131","text":"<pre><code>[paths]\ncustom = [\"~/repos/dynlib-models\", \"/opt/dynlib/models\"]\nbuiltin = [\"~/custom/builtin\"] # Bu, yerle\u015fik model yolunu geni\u015fletir, yerini almaz.\n\ncache_root = \"~/Library/Caches/dynlib\"\n# veya alternatif form\n[cache]\nroot = \"~/Library/Caches/dynlib\"\n</code></pre> <ul> <li><code>[paths]</code>, bir etiket ad\u0131n\u0131 (<code>builtin</code> veya <code>custom</code> gibi) bir veya daha fazla dizin k\u00f6k\u00fcne e\u015fler. Her giri\u015f bir dize veya dizeler listesi olabilir. Dynlib, <code>custom://circuit/srn</code> gibi bir URI'yi her k\u00f6k\u00fc s\u0131rayla arayarak \u00e7\u00f6z\u00fcmler.</li> <li><code>[cache]</code> tablosu (veya \u00fcst d\u00fczey <code>cache_root</code>), <code>resolve_cache_root()</code> i\u015flevine iletilen JIT \u00f6nbellek konumunu sabitlemenizi sa\u011flar. Mutlak veya <code>~/</code> ile geni\u015fletilmi\u015f bir yol sa\u011flay\u0131n; dynlib kullanmadan \u00f6nce yaz\u0131labilirli\u011fini do\u011frular.</li> <li>Dosya; TOML bozuksa, <code>[paths]</code> dize olmayan giri\u015fler i\u00e7eriyorsa veya gerekli bir de\u011fer eksikse <code>ConfigError</code> ile korunur.</li> </ul>"},{"location":"tr/guides/modeling/config-file/#ortam-degiskeni-gecersiz-klmalar-environment-overrides","title":"Ortam de\u011fi\u015fkeni ge\u00e7ersiz k\u0131lmalar\u0131 (Environment overrides)","text":"<ul> <li><code>DYN_MODEL_PATH</code>, dosyay\u0131 d\u00fczenlemeden etiket k\u00f6klerini ba\u015fa eklemenizi sa\u011flar. S\u00f6zdizimi POSIX \u00fczerinde <code>TAG=/path/one:/path/two</code> ve Windows \u00fczerinde <code>TAG=C:\\path1;TAG2=C:\\path2</code> \u015feklindedir.</li> <li>Giri\u015fler bir haritaya ayr\u0131\u015ft\u0131r\u0131l\u0131r ve yap\u0131land\u0131rma dosyas\u0131nda beyan edilenlerden \u00f6nce eklenir, b\u00f6ylece birden fazla dizin ayn\u0131 etiketi payla\u015ft\u0131\u011f\u0131nda ortam yollar\u0131 kazan\u0131r.</li> <li>Dynlib, etiketi yeniden tan\u0131mlasan\u0131z bile <code>builtin://</code> URI'lerinin her zaman \u00e7\u00f6z\u00fcmlenmesini sa\u011flamak i\u00e7in yerle\u015fik modeller klas\u00f6r\u00fcn\u00fc t\u00fcm ge\u00e7ersiz k\u0131lmalardan sonra <code>builtin</code> etiket listesine ekler.</li> </ul>"},{"location":"tr/guides/modeling/config-file/#cozumleme-sras-ve-davrans","title":"\u00c7\u00f6z\u00fcmleme s\u0131ras\u0131 ve davran\u0131\u015f\u0131","text":"<ol> <li><code>load_config()</code> TOML dosyas\u0131n\u0131 (varsa) y\u00fckler ve etiket haritas\u0131n\u0131 olu\u015fturur.</li> <li><code>DYN_MODEL_PATH</code> giri\u015fleri her etiketin ba\u015f\u0131na eklenir, b\u00f6ylece ge\u00e7ici ge\u00e7ersiz k\u0131lmalar\u0131n dosya destekli k\u00f6kleri g\u00f6lgelemesine izin verilir.</li> <li>Yerle\u015fik modeller dizini, etiketi yeniden tan\u0131mlad\u0131\u011f\u0131n\u0131zda bile <code>builtin://</code> URI'lerinin mevcut olmas\u0131n\u0131 garanti etmek i\u00e7in <code>builtin</code> etiketine eklenir.</li> <li>Sonu\u00e7ta ortaya \u00e7\u0131kan <code>PathConfig</code>, \u00e7\u00f6z\u00fcmleyici yard\u0131mc\u0131lar\u0131 taraf\u0131ndan \u00f6nbelle\u011fe al\u0131n\u0131r, b\u00f6ylece CLI'y\u0131 veya i\u015flemi yeniden ba\u015flatmak disk \u00fczerindeki de\u011fi\u015fiklikleri yeniden okur.</li> </ol> <p>Dynlib bir etiketi veya istenen model yolunu bulamad\u0131\u011f\u0131nda, denedi\u011fi adaylar\u0131 listeleyerek bir <code>ConfigError</code> (bilinmeyen etiket) veya <code>ModelNotFoundError</code> (dosya aramas\u0131 ba\u015far\u0131s\u0131z) hatas\u0131 y\u00fckseltir.</p>"},{"location":"tr/guides/modeling/config-file/#sorun-giderme-ipuclar","title":"Sorun giderme ipu\u00e7lar\u0131","text":"<ul> <li>Bir sim\u00fclasyonu \u00e7al\u0131\u015ft\u0131rmadan \u00f6nce kayd\u0131n bir modeli \u00e7\u00f6z\u00fcmledi\u011fini do\u011frulamak i\u00e7in <code>dynlib model validate &lt;uri&gt;</code> komutunu \u00e7al\u0131\u015ft\u0131r\u0131n.</li> <li>Yaz\u0131labilir dizinleri i\u015faret ettiklerinden emin olmak i\u00e7in <code>DYNLIB_CONFIG</code> ve <code>DYN_MODEL_PATH</code> de\u011fi\u015fkenlerini inceleyin.</li> <li>Yap\u0131land\u0131rmadaki \u00f6nbellek k\u00f6k\u00fc yaz\u0131lamaz durumdaysa, dynlib platform varsay\u0131lan\u0131na geri d\u00f6ner (Linux: <code>~/.cache/dynlib</code>, macOS: <code>~/Library/Caches/dynlib</code>, Windows: <code>%LOCALAPPDATA%/dynlib/Cache</code>). Bu ger\u00e7ekle\u015fti\u011finde bir <code>RuntimeWarning</code> yayar.</li> </ul>"},{"location":"tr/guides/modeling/dsl-basics/","title":"DSL Model Dosyas\u0131 \u015eablonu","text":"<p>Bu, TOML format\u0131nda DSL model dosyalar\u0131 olu\u015fturmak i\u00e7in h\u0131zl\u0131 bir ba\u015fvuru \u015fablonudur. Mevcut t\u00fcm tablolar\u0131 ve anahtarlar\u0131n\u0131 listeler.</p>"},{"location":"tr/guides/modeling/dsl-basics/#gerekli-tablolar","title":"Gerekli Tablolar","text":""},{"location":"tr/guides/modeling/dsl-basics/#model","title":"[model]","text":"<ul> <li><code>type</code> (gerekli): \"ode\" | \"map\"</li> <li><code>name</code> (iste\u011fe ba\u011fl\u0131): string (dize)</li> <li><code>dtype</code> (iste\u011fe ba\u011fl\u0131): veri tipi, varsay\u0131lan \"float64\"</li> </ul>"},{"location":"tr/guides/modeling/dsl-basics/#states","title":"[states]","text":"<ul> <li><code>state_name = initial_value</code> (s\u0131ralama, yetkili durum vekt\u00f6r\u00fc s\u0131ras\u0131n\u0131 belirler)</li> <li>8/3 gibi de\u011fer ifadeleri i\u00e7in t\u0131rnak i\u015fareti kullan\u0131n: \"8/3\".</li> </ul>"},{"location":"tr/guides/modeling/dsl-basics/#istege-bagl-tablolar","title":"\u0130ste\u011fe Ba\u011fl\u0131 Tablolar","text":""},{"location":"tr/guides/modeling/dsl-basics/#constants","title":"[constants]","text":"<ul> <li><code>constant_name = value</code> (skalerler, say\u0131sal ifadelere izin verilir, \u00f6nceki sabitlere referans verebilir)</li> <li>Sabitlere atama yap\u0131lamaz ve bunlar salt okunur de\u011fi\u015fmezlerdir (literals).</li> </ul>"},{"location":"tr/guides/modeling/dsl-basics/#params","title":"[params]","text":"<ul> <li><code>param_name = value</code> (skalerler veya diziler, model veri tipine d\u00f6n\u00fc\u015ft\u00fcr\u00fcl\u00fcr)</li> </ul>"},{"location":"tr/guides/modeling/dsl-basics/#denklemler-bir-form-secin-veya-karstrn","title":"Denklemler (bir form se\u00e7in veya kar\u0131\u015ft\u0131r\u0131n)","text":""},{"location":"tr/guides/modeling/dsl-basics/#equationsrhs-durum-basna-form","title":"[equations.rhs] (durum-ba\u015f\u0131na form)","text":"<ul> <li><code>state_name = \"expression\"</code></li> </ul>"},{"location":"tr/guides/modeling/dsl-basics/#equations-blok-form","title":"[equations] (blok form)","text":"<ul> <li>`expr = \"\"\"dx = expression   dy = expression\"\"\"</li> </ul>"},{"location":"tr/guides/modeling/dsl-basics/#equationsjacobian-istege-bagl-yogun-jacobian","title":"[equations.jacobian] (iste\u011fe ba\u011fl\u0131 yo\u011fun Jacobian)","text":"<ul> <li><code>expr = [[ \"...\", \"...\", ... ], [...], ...]</code> (ifadelerin n \u00d7 n matrisi)</li> <li>Durum vekt\u00f6r\u00fc s\u0131ras\u0131, [states] bildirim s\u0131ras\u0131d\u0131r (mod'lardan sonra). <code>state_names = (s0, s1, ...)</code> i\u00e7in, <code>expr[i][j]</code>, \u2202f_state_names[i]/\u2202state_names[j] anlam\u0131na gelir. [states] s\u0131ras\u0131n\u0131 de\u011fi\u015ftirmek anlamsal bir de\u011fi\u015fikliktir ve matris de\u011fi\u015fmezlerinin nas\u0131l yorumlanaca\u011f\u0131n\u0131 de\u011fi\u015ftirir.</li> </ul>"},{"location":"tr/guides/modeling/dsl-basics/#eventsevent_name","title":"[events.event_name]","text":"<ul> <li><code>phase</code> (iste\u011fe ba\u011fl\u0131): \"pre\" | \"post\" | \"both\" (varsay\u0131lan \"post\")</li> <li>`cond = \"expression\"</li> <li><code>action = \"expression\"</code> veya `action.state_name = \"expression\"</li> <li><code>tags</code> (iste\u011fe ba\u011fl\u0131): [\"tag1\", \"tag2\", ...]</li> <li><code>log</code> (iste\u011fe ba\u011fl\u0131): [\"var1\", \"var2\", ...]</li> </ul>"},{"location":"tr/guides/modeling/dsl-basics/#sim","title":"[sim]","text":"<ul> <li><code>t0 = value</code></li> <li><code>t_end = value</code></li> <li><code>dt = value</code></li> <li><code>stepper = \"euler\" | \"rk4\" | ...</code></li> <li><code>record = true/false</code></li> <li><code>stepper_config = value (stepper'a \u00f6zg\u00fc yap\u0131land\u0131rma de\u011ferleri)</code></li> </ul>"},{"location":"tr/guides/modeling/dsl-basics/#meta","title":"[meta]","text":"<ul> <li>`title = \"string\"</li> <li>Meta tablosu \u015fu anda yoksay\u0131l\u0131r. [meta] i\u00e7ine her \u015fey yaz\u0131labilir.</li> </ul>"},{"location":"tr/guides/modeling/dsl-basics/#ozel-degiskenler","title":"\u00d6zel De\u011fi\u015fkenler","text":"<ul> <li><code>t</code> - \u015eimdiki zaman (t\u00fcm ifadelerde kullan\u0131labilir)</li> </ul>"},{"location":"tr/guides/modeling/equations/","title":"Denklemler","text":"<p><code>[equations]</code> tablosu, durumlar\u0131n (states) her ad\u0131mda nas\u0131l de\u011fi\u015fti\u011fini tan\u0131mlad\u0131\u011f\u0131n\u0131z yerdir. Modelinize uygun stili se\u00e7ebilmeniz i\u00e7in birbirinin yerine kullan\u0131labilen birka\u00e7 alt formu kabul eder.</p>"},{"location":"tr/guides/modeling/equations/#temel-formlar","title":"Temel formlar","text":"<ul> <li><code>[equations.rhs]</code> (durum-ba\u015f\u0131na) \u2013 <code>state = \"expr\"</code> giri\u015flerinden olu\u015fan bir TOML tablosu. Her ifade bir dize (string) olmal\u0131d\u0131r, b\u00f6ylece DSL, o durum i\u00e7in sa\u011f taraf\u0131 de\u011ferlendirmeden \u00f6nce makrolar\u0131 ayr\u0131\u015ft\u0131rabilir.</li> <li><code>[equations].expr</code> (blok) \u2013 Her sat\u0131r\u0131n bir duruma atama yapt\u0131\u011f\u0131 (<code>x = ...</code>) veya ODE modelleri i\u00e7in t\u00fcrev notasyonu kulland\u0131\u011f\u0131 (<code>dx = ...</code> veya <code>d(x) = ...</code>) \u00e7ok sat\u0131rl\u0131 tek bir dize. Cebirinizi d\u00fczenli tutan stili kullan\u0131n, ancak ayn\u0131 durumu her iki yerde de tan\u0131mlamay\u0131n (y\u00fckleyici bunu zorunlu k\u0131lar).</li> <li><code>[equations.inverse]</code> \u2013 Yaln\u0131zca <code>map</code> modelleri i\u00e7in mevcuttur; ana denklem formunu yans\u0131t\u0131r ve \u00e7a\u011fr\u0131labilir bir ters g\u00fcncelleme sa\u011flar. Bu tablo i\u00e7inde <code>rhs</code> veya <code>expr</code> tan\u0131mlayabilirsiniz, ancak ayn\u0131 durum i\u00e7in ikisini birden tan\u0131mlayamazs\u0131n\u0131z.</li> <li><code>[equations.jacobian]</code> \u2013 Yo\u011fun (dense) Jacobian'\u0131 tan\u0131mlayan kare bir liste-i\u00e7inde-liste (list-of-list) de\u011fi\u015fmezi i\u00e7eren tek bir <code>expr</code> anahtar\u0131na sahip iste\u011fe ba\u011fl\u0131 meta veriler (her giri\u015f bir dize veya say\u0131sal de\u011fi\u015fmez olabilir). Bu tablo yaln\u0131zca derleyici i\u00e7in \u00f6zel t\u00fcrevler sa\u011flad\u0131\u011f\u0131n\u0131zda kullan\u0131l\u0131r (\u00f6rne\u011fin, stiff (sert) \u00e7\u00f6z\u00fcc\u00fcler veya implicit stepper'lar i\u00e7in).</li> </ul>"},{"location":"tr/guides/modeling/equations/#ornek","title":"\u00d6rnek","text":"<pre><code>[equations.rhs]\nx = \"speed * cos(theta)\"\ntheta = \"speed * sin(theta)\"\n\n[equations.inverse]\nexpr = \"\"\"\nx = x - speed * cos(theta)\ntheta = theta - speed * sin(theta)\n\"\"\"\n\n[equations.jacobian]\nexpr = [\n  [\"0\", \"-speed * sin(theta)\"],\n  [\"speed * cos(theta)\", \"0\"]\n]\n</code></pre>"},{"location":"tr/guides/modeling/equations/#ifade-baglam","title":"\u0130fade ba\u011flam\u0131","text":"<p>Denklem ifadeleri, ba\u015fka yerlerde mevcut olan ayn\u0131 tan\u0131mlay\u0131c\u0131lar\u0131 payla\u015f\u0131r: states, parameters, constants, aux, functions, makrolar (<code>sin</code>, <code>clip</code>, <code>approx</code>, generator kapsamalar\u0131) ve <code>t</code>. ODE bloklar\u0131 ayr\u0131ca t\u00fcrev hedeflerini (<code>dx</code>, <code>d(x)</code>) kabul eder, ancak map modelleri <code>state = expr</code> atamalar\u0131na ba\u011fl\u0131 kalmal\u0131d\u0131r.</p>"},{"location":"tr/guides/modeling/equations/#ters-inverse-denklemler","title":"Ters (Inverse) denklemler","text":"<ul> <li><code>inverse</code> tablosu yaln\u0131zca map modelleri i\u00e7in vard\u0131r ve tersine \u00e7evirme ara\u00e7lar\u0131 ve te\u015fhisleri taraf\u0131ndan kullan\u0131lan bir <code>inv_rhs</code> \u00e7a\u011fr\u0131labilir \u00f6\u011fesi sa\u011flar.</li> <li>Bunu bir durum-ba\u015f\u0131na tablo (<code>[equations.inverse.rhs]</code>) veya bir blok dizesi (<code>[equations.inverse].expr</code>) olarak yazabilir ve birincil denklem formunu yans\u0131tabilirsiniz.</li> <li>Her durum, ters formlar aras\u0131nda yaln\u0131zca bir kez g\u00f6r\u00fcnebilir; ayn\u0131 durum i\u00e7in <code>rhs</code> ve <code>expr</code> kar\u0131\u015ft\u0131rmak bir hataya neden olur.</li> <li>Ters g\u00fcncelleme, ileri denklemlerle ayn\u0131 tan\u0131mlay\u0131c\u0131 k\u00fcmelerini (states, params, aux vb.) \u00e7\u00f6z\u00fcmlemelidir.</li> </ul>"},{"location":"tr/guides/modeling/equations/#jacobian-tablosu","title":"Jacobian tablosu","text":"<ul> <li><code>[equations.jacobian].expr</code> bir sat\u0131r listesidir; sat\u0131r ve s\u00fctun say\u0131s\u0131, bildirilen durumlar\u0131n (states) say\u0131s\u0131yla e\u015fle\u015fmelidir (kare matris).</li> <li>Her matris giri\u015fi bir dize ifadesi veya say\u0131sal bir de\u011fi\u015fmez (tamsay\u0131lar/float'lar) olabilir. Derleyici bunu, \u00e7\u00f6z\u00fcc\u00fc deste\u011fi i\u00e7in kullan\u0131lan a\u00e7\u0131k Jacobian'a d\u00fczle\u015ftirir.</li> <li>Yo\u011fun bir Jacobian'a ihtiyac\u0131n\u0131z varsa ancak bunu d\u00fczenli tutmay\u0131 tercih ediyorsan\u0131z, payla\u015f\u0131lan ifadeleri aux de\u011fi\u015fkenleri ile \u00f6nceden hesaplayabilir ve bunlara matris giri\u015fleri i\u00e7inde referans verebilirsiniz.</li> </ul>"},{"location":"tr/guides/modeling/equations/#dogrulama-ipuclar","title":"Do\u011frulama ipu\u00e7lar\u0131","text":"<ul> <li>Ayr\u0131\u015ft\u0131r\u0131c\u0131, <code>[equations]</code>, <code>[equations.inverse]</code> ve <code>[equations.jacobian]</code> i\u00e7indeki bilinmeyen anahtarlar\u0131 yasaklar, b\u00f6ylece yaz\u0131m hatalar\u0131 erken yakalan\u0131r.</li> <li>Durumlar, <code>[equations.rhs]</code> ve <code>[equations].expr</code> aras\u0131nda yaln\u0131zca bir kez tan\u0131mlanabilir; ters tablo i\u00e7in de ayn\u0131s\u0131 ge\u00e7erlidir.</li> <li>Map modelleri t\u00fcrev notasyonu kullanamaz (y\u00fckleyici, map'ler i\u00e7in <code>[equations].expr</code> i\u00e7indeki <code>d(x)</code> ifadesini a\u00e7\u0131k\u00e7a reddeder).</li> <li><code>[equations.jacobian].expr</code> bir sat\u0131r listesi olarak sa\u011flanmal\u0131d\u0131r; \u00e7o\u011ful <code>exprs</code> kullanmak veya tabloyu atlamak bir hataya neden olur.</li> </ul>"},{"location":"tr/guides/modeling/equations/#en-iyi-uygulamalar","title":"En iyi uygulamalar","text":"<ol> <li>Durum ba\u015f\u0131na tek bir stile ba\u011fl\u0131 kal\u0131n (ya <code>rhs</code> ya da blok), b\u00f6ylece gereksiz (tekrarlayan) mant\u0131ktan ka\u00e7\u0131n\u0131rs\u0131n\u0131z.</li> <li>Aux/functions kullan\u0131n, karma\u015f\u0131k sa\u011f taraf ifadelerini \u00e7arpanlar\u0131na ay\u0131rarak denklem tablolar\u0131n\u0131n okunabilir kalmas\u0131n\u0131 sa\u011flay\u0131n.</li> <li>Ters tablolar\u0131 net bir \u015fekilde belgeleyin\u2014neden var olduklar\u0131n\u0131 belirtin (\u00f6rne\u011fin, geriye do\u011fru ad\u0131m atmak veya te\u015fhis i\u00e7in), \u00e7\u00fcnk\u00fc bunlar normal \u00e7\u00f6z\u00fcc\u00fc yolunun d\u0131\u015f\u0131nda \u00e7al\u0131\u015f\u0131r.</li> <li>Yaln\u0131zca gerekti\u011finde bir Jacobian sa\u011flay\u0131n (implicit \u00e7\u00f6z\u00fcc\u00fcler, stiffness); aksi takdirde, derleyicinin t\u00fcrevleri say\u0131sal olarak tahmin etmesine izin verin.</li> </ol>"},{"location":"tr/guides/modeling/events/","title":"Olay Y\u00f6netimi (Event Handling)","text":"<p>Olaylar (events), sim\u00fclasyon s\u0131ras\u0131nda <code>cond</code> (ko\u015ful) ifadesi do\u011fru oldu\u011funda eylemleri \u00e7al\u0131\u015ft\u0131rarak ve g\u00fcnl\u00fck (log) tutarak model ko\u015fullar\u0131na tepki vermenizi sa\u011flar. Olaylar ad\u0131mdan \u00f6nce (<code>phase = \"pre\"</code>), sonra (<code>phase = \"post\"</code>) veya her ikisinde de \u00e7al\u0131\u015f\u0131r ve hata ay\u0131klama veya analiz i\u00e7in te\u015fhisleri yakalamak \u00fczere g\u00fcnl\u00fck kayd\u0131 ekleyebilirsiniz.</p> <p>NOT: Analiz i\u00e7in baz\u0131 h\u0131zl\u0131 yol (fast-path) \u00e7al\u0131\u015ft\u0131r\u0131c\u0131lar\u0131, olay\u0131 olmayan modelleri tercih eder.</p>"},{"location":"tr/guides/modeling/events/#temel-sablon","title":"Temel \u015eablon","text":"<pre><code>[events.reset_on_threshold]\nphase = \"post\"\ncond = \"x &gt; threshold\"\naction = \"x = 0; spike_count = spike_count + 1\"\nlog = [\"t\", \"x\", \"spike_count\"]\n</code></pre> <ul> <li><code>phase</code>, ko\u015fulun ne zaman de\u011ferlendirilece\u011fini kontrol eder (varsay\u0131lan <code>post</code>).</li> <li><code>cond</code>, boolean d\u00f6nd\u00fcren bir dize olmal\u0131d\u0131r. Her zaman ad\u0131m\u0131nda yeniden de\u011ferlendirilir.</li> <li><code>action</code>, atama ifadelerinden olu\u015fan bir dizedir; netlik i\u00e7in atamalar\u0131 <code>action.var = \"expr\"</code> \u015feklinde de kapsamland\u0131rabilirsiniz.</li> <li><code>log</code> iste\u011fe ba\u011fl\u0131d\u0131r ve olay tetiklendi\u011finde de\u011ferleri kaydedilen de\u011fi\u015fkenleri listeler.</li> </ul>"},{"location":"tr/guides/modeling/events/#kosul-baglam","title":"Ko\u015ful Ba\u011flam\u0131","text":"<ul> <li>States/parameters: Bildirilen herhangi bir duruma veya parametreye referans verin.</li> <li>Aux de\u011fi\u015fkenleri: Ko\u015fullar\u0131 okunabilir tutmak i\u00e7in <code>[aux]</code>'tan t\u00fcretilmi\u015f ifadeleri yeniden kullan\u0131n.</li> <li>Zaman (<code>t</code>): Zaman tabanl\u0131 tetikleyiciler i\u00e7in her zaman mevcuttur.</li> <li>Kullan\u0131c\u0131 tan\u0131ml\u0131 fonksiyonlar: Bunlar\u0131 t\u0131pk\u0131 denklemlerde veya aux tan\u0131mlar\u0131nda oldu\u011fu gibi \u00e7a\u011f\u0131r\u0131n.</li> <li>Yerle\u015fik matematik &amp; skaler makrolar: <code>sin</code>, <code>cos</code>, <code>clip</code>, <code>approx</code> vb.</li> <li>Generator (\u00dcrete\u00e7) kapsamalar\u0131: \u0130ndirgemelere (reductions) ihtiyac\u0131n\u0131z oldu\u011funda <code>sum(...)</code> veya <code>prod(...)</code> kullan\u0131n.</li> <li>Olay makrolar\u0131: <code>cross_up</code>, <code>cross_down</code>, <code>changed</code>, <code>in_interval</code>, <code>enters_interval</code>, <code>leaves_interval</code>, <code>increasing</code>, <code>decreasing</code> ve <code>cross_either</code> gecikmeli durum de\u011ferlerini otomatik olarak kar\u015f\u0131la\u015ft\u0131r\u0131r, b\u00f6ylece manuel <code>lag_</code> ifadeleri yazman\u0131za gerek kalmaz.</li> <li>Lag (Gecikme) notasyonu: Ko\u015fullar i\u00e7inde <code>lag_state(k)</code> \u00e7a\u011f\u0131rabilirsiniz, ancak bu yaln\u0131zca ger\u00e7ek durum de\u011fi\u015fkenleri (states) i\u00e7indir, asla aux i\u00e7in kullan\u0131lamaz.</li> </ul>"},{"location":"tr/guides/modeling/events/#olay-makrolar-ornegi","title":"Olay Makrolar\u0131 \u00d6rne\u011fi","text":"<pre><code>[events.detect_spike]\nphase = \"pre\"\ncond = \"cross_up(v, 1.0)\"\naction = \"spike_count += 1\"\n</code></pre> <p>Makro, gecikmeli eri\u015fimi sizin i\u00e7in halleder, b\u00f6ylece ko\u015ful, <code>v</code> e\u015fi\u011fi a\u015fa\u011f\u0131dan yukar\u0131ya ge\u00e7ti\u011fi anda ekstra kay\u0131t tutmaya gerek kalmadan tetiklenir.</p>"},{"location":"tr/guides/modeling/events/#eylem-action-detaylar","title":"Eylem (Action) Detaylar\u0131","text":"<ul> <li>Eylemler; durumlar\u0131, parametreleri (izin veriliyorsa), aux veya izleyici (tracker) de\u011fi\u015fkenlerini yeni ifadeler atayarak de\u011fi\u015ftirebilir.</li> <li>Birden fazla ifadeyi ay\u0131rmak i\u00e7in noktal\u0131 virg\u00fcl kullan\u0131n veya <code>action.var = \"expr\"</code> s\u00f6zdizimi ile bireysel atamalar tan\u0131mlay\u0131n.</li> <li>Eylemler, ko\u015ful de\u011ferlendirildikten sonra atomik (b\u00fct\u00fcnsel) olarak \u00e7al\u0131\u015ft\u0131r\u0131l\u0131r; yan etkiler bir sonraki zaman ad\u0131m\u0131 i\u00e7in model durumunun bir par\u00e7as\u0131 olur.</li> <li>Eylemleri k\u0131sa tutun; a\u011f\u0131r hesaplamalar aux de\u011fi\u015fkenlerine veya yard\u0131mc\u0131 fonksiyonlara aittir.</li> </ul>"},{"location":"tr/guides/modeling/events/#gunluk-kayd-logging","title":"G\u00fcnl\u00fck Kayd\u0131 (Logging)","text":"<ul> <li><code>log</code>, olay her tetiklendi\u011finde listelenen ifadeleri yakalar.</li> <li>G\u00fcnl\u00fckler; durumlar\u0131, aux veya hesaplanan ifadeleri i\u00e7erebilir (<code>log = [\"t\", \"energy\", \"debug_flag\"]</code>).</li> <li>Olay zamanlamas\u0131n\u0131 incelemek, sahte tetikleyicileri tespit etmek veya analiz i\u00e7in saya\u00e7lar\u0131 kaydetmek amac\u0131yla g\u00fcnl\u00fck kayd\u0131n\u0131 kullan\u0131n.</li> </ul>"},{"location":"tr/guides/modeling/events/#modlar-ile-olay-yasam-dongusu","title":"Mod'lar ile Olay Ya\u015fam D\u00f6ng\u00fcs\u00fc","text":"<p>Mod'lar, ba\u015fka yerlerde mevcut olan ayn\u0131 fiilleri kullanarak olaylar\u0131 manip\u00fcle edebilir:</p> <ul> <li><code>mod.remove.events</code>, mevcut olaylar\u0131 isme g\u00f6re siler.</li> <li><code>mod.replace.events.name</code>, zaten var olan bir olay\u0131n phase/cond/action/log de\u011ferlerini yeniden tan\u0131mlar.</li> <li><code>mod.add.events.new_name</code>, yeni bir olay ekler (isim zaten varsa hata verir).</li> <li><code>mod.set.events</code> desteklenmez; bunun yerine <code>add</code> veya <code>replace</code> kullan\u0131n.</li> </ul> <p>Her zaman k\u00fcresel fiil s\u0131ras\u0131n\u0131 hat\u0131rlay\u0131n: remove \u2192 replace \u2192 add \u2192 set; b\u00f6ylece ayn\u0131 tan\u0131mlay\u0131c\u0131ya sahip ba\u015fka bir olay eklemeden \u00f6nce bir olay\u0131 kald\u0131rabilir veya de\u011fi\u015ftirebilirsiniz.</p>"},{"location":"tr/guides/modeling/events/#en-iyi-uygulamalar","title":"En iyi uygulamalar","text":"<ol> <li>Olaylar\u0131 a\u00e7\u0131klay\u0131c\u0131 bir \u015fekilde isimlendirin (<code>events.detect_refractory_start</code>), b\u00f6ylece niyetleri a\u00e7\u0131k olur.</li> <li>Karma\u015f\u0131k y\u00fcklemleri (predicates) aux de\u011fi\u015fkenlerine veya fonksiyonlara \u00e7\u0131kar\u0131n, b\u00f6ylece ko\u015fullar\u0131 okunabilir tutars\u0131n\u0131z.</li> <li>Eylemleri k\u00fc\u00e7\u00fck ve belirlenimci (deterministik) tutun ve t\u00fcretilmi\u015f miktarlar\u0131 sat\u0131r i\u00e7i (inlined) ifadeler yerine aux arac\u0131l\u0131\u011f\u0131yla g\u00fcncellemeyi tercih edin.</li> <li>Ge\u00e7i\u015fleri veya de\u011fi\u015fiklikleri izlerken olay makrolar\u0131n\u0131 kullan\u0131n, b\u00f6ylece manuel lag (gecikme) kayd\u0131 tutmaktan ka\u00e7\u0131n\u0131rs\u0131n\u0131z.</li> <li>Bilin\u00e7li g\u00fcnl\u00fck tutun\u2014\u00e7ok fazla g\u00fcnl\u00fck giri\u015fi performans\u0131 d\u00fc\u015f\u00fcrebilir, bu nedenle yaln\u0131zca hata ay\u0131klama veya analiz ba\u011flamlar\u0131 i\u00e7in ihtiyac\u0131n\u0131z olan\u0131 kaydedin.</li> </ol>"},{"location":"tr/guides/modeling/functions/","title":"DSL Fonksiyonlar\u0131","text":"<p>Kullan\u0131c\u0131 tan\u0131ml\u0131 fonksiyonlar, tekrar kullan\u0131labilir mant\u0131\u011f\u0131 bir kez kaps\u00fclleyip; denklemlerden, aux (yard\u0131mc\u0131) de\u011fi\u015fkenlerden, olaylardan (events) ve di\u011fer fonksiyonlardan (\u00f6zyineleme olmadan) \u00e7a\u011f\u0131rman\u0131za olanak tan\u0131r. \u0130fadelerin y\u00f6netilebilir kalmas\u0131n\u0131 sa\u011flar ve yayg\u0131n hesaplamalar\u0131 parametrelerle kullanman\u0131za izin verir.</p>"},{"location":"tr/guides/modeling/functions/#sozdizimi-syntax","title":"S\u00f6zdizimi (Syntax)","text":"<pre><code>[functions.sigmoid]\nargs = [\"x\", \"gain\", \"offset\"]\nexpr = \"gain / (1 + exp(-x)) + offset\"\n</code></pre> <ul> <li><code>args</code> parametre adlar\u0131n\u0131n bulundu\u011fu bir dizidir; yaln\u0131zca basit tan\u0131mlay\u0131c\u0131lar kullan\u0131n.</li> <li><code>expr</code>, di\u011fer ifadelerle ayn\u0131 makro geni\u015fletmeli DSL/Python kurallar\u0131 kullan\u0131larak de\u011ferlendirilen bir dize ifadesidir (<code>^</code> \u2192 <code>**</code>, d\u00f6ng\u00fclere derlenen \u00fcrete\u00e7 ifadeleri vb.).</li> <li>Fonksiyonlar bir d\u00f6n\u00fc\u015f tipi bildirmez; ifadenin de\u011feri d\u00f6n\u00fc\u015f de\u011feridir.</li> </ul>"},{"location":"tr/guides/modeling/functions/#fonksiyonlarn-icindeki-baglam","title":"Fonksiyonlar\u0131n \u0130\u00e7indeki Ba\u011flam","text":"<ul> <li>Arg\u00fcmanlar: Fonksiyonlar kendi parametrelerini de\u011fi\u015fken olarak kullanabilir (<code>x</code>, <code>gain</code>).</li> <li>Zaman (<code>t</code>): Yaln\u0131zca \u00e7evreleyen ba\u011flam zaman\u0131 sa\u011fl\u0131yorsa kullan\u0131labilir (\u00f6rne\u011fin, saf bir matematik yard\u0131mc\u0131s\u0131ndan de\u011fil, bir denklemden veya aux'tan \u00e7a\u011fr\u0131ld\u0131\u011f\u0131nda).</li> <li>Durumlar ve parametreler (States &amp; parameters): Modelde mevcutlarsa isimleriyle referans verilebilir.</li> <li>Aux de\u011fi\u015fkenleri: <code>[aux]</code> i\u00e7inde tan\u0131mlanan aux de\u011fi\u015fkenlerini \u00e7a\u011f\u0131rabilir, ancak ba\u011f\u0131ml\u0131l\u0131k d\u00f6ng\u00fcleri olu\u015fturmad\u0131\u011f\u0131n\u0131zdan emin olun.</li> <li>Di\u011fer kullan\u0131c\u0131 tan\u0131ml\u0131 fonksiyonlar: Normal \u015fekilde \u00e7a\u011f\u0131rabilirsiniz, ancak \u00f6zyinelemeyi (recursion) \u00f6nleyin.</li> <li>Yerle\u015fik matematik ve makrolar: <code>sin</code>, <code>cos</code>, <code>clip</code>, <code>approx</code>, \u00fcrete\u00e7 ifadeleri vb. kullan\u0131n.</li> <li>Gecikme (Lag) notasyonu: Fonksiyon, <code>lag_</code> eri\u015fiminin ge\u00e7erli oldu\u011fu bir yerde \u00e7a\u011fr\u0131l\u0131rsa izin verilir (yaln\u0131zca durumlar i\u00e7in).</li> <li>Olay (Event) makrolar\u0131: Fonksiyonlar\u0131n i\u00e7inde do\u011frudan eri\u015filemez; bunlar\u0131 bunun yerine olay ko\u015fullar\u0131nda kullan\u0131n.</li> </ul>"},{"location":"tr/guides/modeling/functions/#fonksiyonlar-cagrma","title":"Fonksiyonlar\u0131 \u00c7a\u011f\u0131rma","text":"<ul> <li>Fonksiyonlara t\u0131pk\u0131 yerle\u015fikler gibi ad\u0131yla referans verin: <code>sigmoid(x, gain, offset)</code>.</li> <li>Arg\u00fcman olarak ifadeler, durumlar, aux veya sabit de\u011ferler (literals) ge\u00e7irebilirsiniz.</li> <li>Fonksiyonlar; denklemler veya olaylar aras\u0131nda kullan\u0131lan tekrarlanan matemati\u011fi, ko\u015fullu mant\u0131\u011f\u0131 veya karma\u015f\u0131k d\u00f6n\u00fc\u015f\u00fcmleri basitle\u015ftirebilir.</li> <li>Jacobian'lar, g\u00fcnl\u00fckleme (logging) ifadeleri veya \u00f6zel aktivasyon \u015fekilleri i\u00e7in ara\u00e7lar\u0131 ay\u0131rmak ad\u0131na yard\u0131mc\u0131 fonksiyonlar kullan\u0131n.</li> </ul>"},{"location":"tr/guides/modeling/functions/#modlar-ve-fonksiyonlar","title":"Modlar ve Fonksiyonlar","text":"<p>Fonksiyon tan\u0131mlar\u0131 modlar arac\u0131l\u0131\u011f\u0131yla de\u011fi\u015ftirilebilir:</p> <ul> <li><code>mod.remove.functions</code> adland\u0131r\u0131lm\u0131\u015f fonksiyonlar\u0131 siler (bile\u015fen zaten mevcut olmal\u0131d\u0131r).</li> <li><code>mod.replace.functions.name</code> tan\u0131mlay\u0131c\u0131y\u0131 korurken g\u00f6vdeyi \u00fczerine yazar.</li> <li><code>mod.add.functions.name</code> yeni bir fonksiyon ekler (zaten varsa ba\u015far\u0131s\u0131z olur).</li> <li><code>mod.set.functions.name</code> fonksiyon tan\u0131m\u0131n\u0131 ekler veya g\u00fcnceller (olu\u015fturur veya g\u00fcnceller).</li> </ul> <p>Bu eylemler k\u00fcresel sil/de\u011fi\u015ftir/ekle/ayarla (rem/replace/add/set) s\u0131ras\u0131na uyar, b\u00f6ylece ba\u015fka bir s\u00fcr\u00fcm eklemeden \u00f6nce kald\u0131rabilir veya de\u011fi\u015ftirebilirsiniz.</p>"},{"location":"tr/guides/modeling/functions/#en-iyi-uygulamalar","title":"En \u0130yi Uygulamalar","text":"<ol> <li>Yard\u0131mc\u0131lar\u0131 a\u00e7\u0131klay\u0131c\u0131 bir \u015fekilde adland\u0131r\u0131n (<code>functions.normalize_input</code>), b\u00f6ylece sonraki denklemler niyeti a\u00e7\u0131k\u00e7a belli eder.</li> <li>Arg\u00fcman listelerini k\u0131sa tutun; \u00e7ok fazla arg\u00fcman, fonksiyonun bunun yerine aux veya durum demetleri \u00fczerinde \u00e7al\u0131\u015fmas\u0131 gerekti\u011fini g\u00f6sterir.</li> <li>Yan etkilerden ka\u00e7\u0131n\u0131n\u2014fonksiyonlar yaln\u0131zca de\u011fer d\u00f6nd\u00fcrmeli ve durumlar\u0131 veya aux de\u011fi\u015fkenlerini de\u011fi\u015ftirmemelidir.</li> <li>Varsay\u0131mlar\u0131 belgeleyin (\u00f6rne\u011fin, beklenen aral\u0131klar); entegrat\u00f6rlerin k\u0131s\u0131tlamalardan haberdar olmas\u0131 i\u00e7in yak\u0131nlardaki yorumlarda veya belgelerde belirtin.</li> <li>Mant\u0131kl\u0131 bir \u015fekilde yeniden kullan\u0131n: Okunabilirli\u011fe yard\u0131mc\u0131 olmad\u0131k\u00e7a veya karma\u015f\u0131k matemati\u011fi gizlemedik\u00e7e basit ifadeleri sarmalamay\u0131n.</li> </ol>"},{"location":"tr/guides/modeling/inline-models/","title":"Sat\u0131r \u0130\u00e7i (Inline) Modeller","text":"<p>Modellerin ayr\u0131 bir toml dosyas\u0131nda tan\u0131mlanmas\u0131 gerekmez. <code>inline:</code> anahtar kelimesini kullanarak modelleri ayn\u0131 python dosyas\u0131nda tan\u0131mlayabilirsiniz.</p>"},{"location":"tr/guides/modeling/inline-models/#ornek","title":"\u00d6rnek","text":"<pre><code>model = '''\ninline:\n[model]\ntype = \"map\"\ndtype = \"int64\"\nname = \"Collatz Conjecture\" # Collatz San\u0131s\u0131\n\n[states]\nn = 27\n\n[equations.rhs]\n# n \u00e7ift ise n//2, de\u011filse 3*n + 1\nn = \"n//2 if n % 2 == 0 else 3*n + 1\"\n\n'''\n</code></pre>"},{"location":"tr/guides/modeling/lagging/","title":"Lag Sistem Tasar\u0131m\u0131 &amp; Uygulamas\u0131","text":""},{"location":"tr/guides/modeling/lagging/#genel-baks","title":"Genel Bak\u0131\u015f","text":"<p>Lag sistemi (gecikme sistemi), dynlib modellerinde ge\u00e7mi\u015f durum (state) de\u011ferlerine \u015fu notasyonla eri\u015fim sa\u011flar: - <code>lag_&lt;isim&gt;()</code> - <code>&lt;isim&gt;</code> adl\u0131 durumun bir ad\u0131m \u00f6nceki de\u011ferine eri\u015fir - <code>lag_&lt;isim&gt;(k)</code> - <code>&lt;isim&gt;</code> adl\u0131 durumun k ad\u0131m \u00f6nceki de\u011ferine eri\u015fir</p> <p>Temel \u00d6zellikler: - \u0130ste\u011fe ba\u011fl\u0131 aktivasyon (sadece lag uygulanan durumlar haf\u0131za t\u00fcketir) - O(1) dairesel tampon (circular buffer) eri\u015fimi (Numba uyumlu) - Sadece ba\u015far\u0131l\u0131 ve onaylanm\u0131\u015f (committed) ad\u0131mlardan sonra say\u0131l\u0131r (tampon b\u00fcy\u00fcmesinden, erken kesilmelerden ve devam etme/resume i\u015flemlerinden etkilenmez) - Hem ODE hem de map modelleriyle \u00e7al\u0131\u015f\u0131r - \u00d6zel ayr\u0131lm\u0131\u015f runtime \u00e7al\u0131\u015fma alan\u0131 (stepper ABI'si <code>runtime_ws</code> parametresi ile geni\u015fletilmi\u015ftir)</p>"},{"location":"tr/guides/modeling/lagging/#dsl-sozdizimi","title":"DSL S\u00f6zdizimi","text":""},{"location":"tr/guides/modeling/lagging/#desteklenen-kullanm","title":"Desteklenen Kullan\u0131m","text":"<pre><code>[model]\ntype = \"map\"\n\n[states]\nx = 0.1\n\n[params]\nr = 3.5\nalpha = 0.3\n\n[equations.rhs]\n# Mevcut ve lag (gecikmeli) uygulanm\u0131\u015f durumlar\u0131 kar\u0131\u015ft\u0131r\nx = \"r * (alpha * x + (1 - alpha) * lag_x(1)) * (1 - x)\"\n\n# Bir ad\u0131m geri gitmek i\u00e7in arg\u00fcmans\u0131z k\u0131sa yaz\u0131m kullan\u0131m\u0131\nx = \"r * (alpha * x + (1 - alpha) * lag_x()) * (1 - x)\"\n</code></pre>"},{"location":"tr/guides/modeling/lagging/#lag-derinlikleri","title":"Lag Derinlikleri","text":"<pre><code>[aux]\n# Birden fazla lag derinli\u011fi kullan\u0131m\u0131 - maksimum de\u011fer otomatik alg\u0131lan\u0131r\ndelayed_diff = \"x - lag_x(5)\"\n\n[equations.rhs]\nx = \"v + 0.1 * lag_x(2)\"  # x i\u00e7in maksimum lag = 5 (aux k\u0131sm\u0131ndan gelir)\nv = \"-x - lag_v(3)\"       # v i\u00e7in maksimum lag = 3\n</code></pre>"},{"location":"tr/guides/modeling/lagging/#kstlamalar","title":"K\u0131s\u0131tlamalar","text":"<p>Sadece durum (state) de\u011fi\u015fkenleri i\u00e7in: <pre><code>[states]\nx = 0.1\n\n[params]\na = 2.0\n\n[equations.rhs]\nx = \"lag_x(1)\"   # Ge\u00e7erli - x bir durum de\u011fi\u015fkenidir\nx = \"lag_a(1)\"   # Hata - a bir parametredir, durum de\u011fi\u015fkeni de\u011fildir\n</code></pre></p> <p>Lag arg\u00fcman\u0131 bir tamsay\u0131 sabiti olmal\u0131d\u0131r: <pre><code> x = \"lag_x(2)\"       # Ge\u00e7erli\n x = \"lag_x(k)\"       # Hata - k bir sabit say\u0131 de\u011fil\n x = \"lag_x(2 + 1)\"   # Hata - ifade kullan\u0131m\u0131na izin verilmez\n</code></pre></p> <p>Mant\u0131k s\u0131n\u0131r\u0131: <pre><code>x = \"lag_x(1000)\"    # Hata - mant\u0131k s\u0131n\u0131r\u0131n\u0131 (1000) a\u015f\u0131yor\n</code></pre></p>"},{"location":"tr/guides/modeling/lagging/#yardmc-aux-degiskenlere-lag-uygulama","title":"Yard\u0131mc\u0131 (Aux) De\u011fi\u015fkenlere Lag Uygulama","text":"<p>Yard\u0131mc\u0131 de\u011fi\u015fkenlere (aux) do\u011frudan lag UYGULANAMAZ. Bunun yerine, ifadelerin i\u00e7inde lag uygulanm\u0131\u015f durumlar\u0131 (lagged states) kullan\u0131n:</p>"},{"location":"tr/guides/modeling/lagging/#desteklenmeyen-yontem","title":"Desteklenmeyen Y\u00f6ntem:","text":"<pre><code>[aux]\nenergy = \"0.5 * v^2 + 0.5 * k * x^2\"\n\n[equations.rhs]\nv = \"-x - 0.1 * lag_energy(1)\"  # HATA: energy bir aux de\u011fi\u015fkenidir, state de\u011fildir\n</code></pre>"},{"location":"tr/guides/modeling/lagging/#dogru-yaklasm","title":"Do\u011fru Yakla\u015f\u0131m:","text":"<pre><code>[aux]\nenergy = \"0.5 * v^2 + 0.5 * k * x^2\"  # Mevcut enerji (iste\u011fe ba\u011fl\u0131)\n\n[equations.rhs]\n# Lag uygulanm\u0131\u015f enerjiyi lag uygulanm\u0131\u015f durumlardan hesapla\nv = \"-x - 0.1 * (0.5 * lag_v(1)^2 + 0.5 * k * lag_x(1)^2)\"\n</code></pre> <p>Mant\u0131k: Aux de\u011fi\u015fkenleri ge\u00e7ici ve t\u00fcretilmi\u015f de\u011ferlerdir. <code>energy</code> de\u011fi\u015fkenine lag uygulamak matematiksel olarak <code>energy</code> de\u011ferini ge\u00e7mi\u015f durum (state) verilerinden hesaplamakla ayn\u0131d\u0131r.</p>"},{"location":"tr/guides/modeling/lagging/#alternatif-auxu-statee-yukseltme","title":"Alternatif: Aux'u State'e Y\u00fckseltme","text":"<p>E\u011fer t\u00fcretilmi\u015f bir niceli\u011fe s\u0131k s\u0131k lag uygulanmas\u0131 gerekiyorsa:</p> <pre><code>[states]\nx = 0.1\nv = 0.0\nenergy = 0.005  # Aux'tan state'e y\u00fckseltildi\n\n[params]\nk = 2.0\n\n[equations.rhs]\nx = \"v\"\nv = \"-k * x - 0.1 * lag_energy(1)\"  # Temiz eri\u015fim\nenergy = \"0.5 * v^2 + 0.5 * k * x^2\"  # ODE olarak takip edilir\n</code></pre> <p>Takas: Sistemin boyutunu 1 art\u0131r\u0131r.</p>"},{"location":"tr/guides/modeling/lagging/#depolama-mimarisi","title":"Depolama Mimarisi","text":""},{"location":"tr/guides/modeling/lagging/#runtimeworkspace-yaps","title":"RuntimeWorkspace Yap\u0131s\u0131","text":"<p>Lag tamponlar\u0131 (buffers) \u00f6zel bir <code>RuntimeWorkspace</code> NamedTuple i\u00e7inde saklan\u0131r:</p> <pre><code>RuntimeWorkspace = namedtuple(\n    \"RuntimeWorkspace\",\n    [\"lag_ring\", \"lag_head\", \"lag_info\"],\n)\n</code></pre> <p>Bile\u015fenler: - <code>lag_ring</code>: T\u00fcm dairesel tamponlar\u0131 saklayan biti\u015fik dizi (veri tipi modelle e\u015fle\u015fir) - <code>lag_head</code>: Her bir lag uygulanm\u0131\u015f durum i\u00e7in mevcut ba\u015f (head) indekslerinin dizisi (int32) - <code>lag_info</code>: (state_idx, depth, offset) bilgisini i\u00e7eren (n_lagged_states, 3) boyutunda meta veri dizisi</p>"},{"location":"tr/guides/modeling/lagging/#dairesel-tampon-duzeni","title":"Dairesel Tampon D\u00fczeni","text":"<p>Her lag uygulanm\u0131\u015f durum <code>lag_ring</code> i\u00e7inde biti\u015fik bir segment al\u0131r:</p> <pre><code>lag_ring d\u00fczeni (biti\u015fik):\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 x i\u00e7in lag tamp. \u2502 y i\u00e7in lag tamp. \u2502 (kullan\u0131m-  \u2502\n\u2502  (derinlik 5)    \u2502  (derinlik 3)    \u2502   d\u0131\u015f\u0131)     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n   offset=0           offset=5          son\n</code></pre> <p>Tahsisat: - <code>k</code> derinli\u011fine sahip her lag uygulanm\u0131\u015f durum, <code>lag_ring</code> i\u00e7inde <code>k</code> adet ard\u0131\u015f\u0131k eleman al\u0131r - Toplam <code>lag_ring</code> boyutu = t\u00fcm lag derinliklerinin toplam\u0131 - <code>lag_head</code> her lag uygulanm\u0131\u015f durum i\u00e7in bir girdiye sahiptir - <code>j</code> numaral\u0131 lag durumu i\u00e7in <code>lag_info[j] = (state_idx, depth, offset)</code></p>"},{"location":"tr/guides/modeling/lagging/#dairesel-tampon-mekanigi","title":"Dairesel Tampon Mekani\u011fi","text":""},{"location":"tr/guides/modeling/lagging/#erisim-modeli","title":"Eri\u015fim Modeli","text":"<p><code>x</code> durumu i\u00e7in <code>lag_x(k)</code> \u00f6rne\u011finde: - <code>depth = 5</code> (maksimum lag) - <code>offset = 0</code> (lag_ring[0]'dan ba\u015flar) - <code>head_index = 0</code> (ba\u015f k\u0131sm\u0131 lag_head[0]'da)</p> <p>\u0130ndirgenmi\u015f ifade: <pre><code>runtime_ws.lag_ring[offset + ((runtime_ws.lag_head[head_index] - k) % depth)]\n#  runtime_ws.lag_ring[0 + ((runtime_ws.lag_head[0] - k) % 5)]\n</code></pre></p>"},{"location":"tr/guides/modeling/lagging/#baslatma-tt0-annda","title":"Ba\u015flatma (t=t0 an\u0131nda)","text":"<pre><code># Her lag uygulanm\u0131\u015f durumu ba\u015flang\u0131\u00e7 ko\u015fulu (IC) ile doldur\nfor j, (state_idx, depth, offset) in enumerate(lag_info):\n    value = y_curr[state_idx]\n    runtime_ws.lag_ring[offset : offset + depth] = value\n    runtime_ws.lag_head[j] = depth - 1  # ba\u015f son pozisyonda\n</code></pre> <p>Neden depth-1? B\u00f6ylece ilk ad\u0131m onayland\u0131ktan (commit) sonra ba\u015f (head) 0'a d\u00f6ner.</p>"},{"location":"tr/guides/modeling/lagging/#onaylanms-adm-sonras-guncelleme","title":"Onaylanm\u0131\u015f Ad\u0131m Sonras\u0131 G\u00fcncelleme","text":"<p>KR\u0130T\u0130K: G\u00fcncellemeler rededilen ad\u0131mlardan veya tampon b\u00fcy\u00fcmelerinden sonra de\u011fil, SADECE ba\u015far\u0131l\u0131 ad\u0131m onaylar\u0131ndan (commits) sonra ger\u00e7ekle\u015fir.</p> <pre><code># runner.py i\u00e7inde, commit i\u015fleminden sonra:\nfor j in range(n_lagged_states):\n    state_idx, depth, offset = lag_info[j]\n    head = int(lag_head[j]) + 1\n    if head &gt;= depth:\n        head = 0\n    lag_head[j] = head\n    lag_ring[offset + head] = y_curr[state_idx]\n</code></pre> <p>x i\u00e7in derinlik=3 ile \u00f6rnek izleme:</p> <pre><code>Ad\u0131m 0 (IC=0.1):\nlag_ring = [0.1, 0.1, 0.1], head=2\n\nAd\u0131m 1 (y_curr=0.2):\nhead = (2+1) % 3 = 0\nlag_ring[0] = 0.2 \u2192 lag_ring = [0.2, 0.1, 0.1], head=0\n\nAd\u0131m 2 (y_curr=0.3):\nhead = (0+1) % 3 = 1\nlag_ring[1] = 0.3 \u2192 lag_ring = [0.2, 0.3, 0.1], head=1\n\nAd\u0131m 3 (y_curr=0.4):\nhead = (1+1) % 3 = 2\nlag_ring[2] = 0.4 \u2192 lag_ring = [0.2, 0.3, 0.4], head=2\n\nAd\u0131m 3'te lag_x(1) eri\u015fimi:\nlag_ring[0 + ((2 - 1) % 3)] = lag_ring[1] = 0.3 \u2713 (ad\u0131m 2 de\u011feri)\n\nAd\u0131m 3'te lag_x(2) eri\u015fimi:\nlag_ring[0 + ((2 - 2) % 3)] = lag_ring[0] = 0.2 \u2713 (ad\u0131m 1 de\u011feri)\n</code></pre>"},{"location":"tr/guides/modeling/lagging/#guvenlik-dogruluk","title":"G\u00fcvenlik &amp; Do\u011fruluk","text":""},{"location":"tr/guides/modeling/lagging/#tampon-buyumesi-grow_rec-grow_evt","title":"Tampon B\u00fcy\u00fcmesi (GROW_REC, GROW_EVT)","text":"<p>Lag tamponlar\u0131 kay\u0131t/olay tamponu b\u00fcy\u00fcmesi s\u0131ras\u0131nda yeniden tahsis ED\u0130LMEZ: - Runtime \u00e7al\u0131\u015fma alan\u0131 boyutlar\u0131 lag derinliklerine g\u00f6re belirlenir (modele \u00f6zg\u00fcd\u00fcr, y\u00f6r\u00fcngeye ba\u011fl\u0131 de\u011fildir) - Wrapper (sarmalay\u0131c\u0131) <code>rec</code>/<code>ev</code> tamponlar\u0131n\u0131 iki kat\u0131na \u00e7\u0131kar\u0131r ama runtime \u00e7al\u0131\u015fma alan\u0131n\u0131 oldu\u011fu gibi b\u0131rak\u0131r - Lag durumu, sisteme yeniden giri\u015flerde (re-entry) korunur</p>"},{"location":"tr/guides/modeling/lagging/#erken-kesilmeler-stepfail-nan_detected-user_break","title":"Erken Kesilmeler (STEPFAIL, NAN_DETECTED, USER_BREAK)","text":"<ul> <li>Runner, kesilmeden \u00f6nce durumu commit eder (onaylar)</li> <li>Lag tamponlar\u0131 son ba\u015far\u0131l\u0131 commit i\u015flemine kadar olan de\u011ferleri i\u00e7erir</li> <li>Devam etme (Resume) i\u015flemi, tam lag durumunu geri y\u00fcklemek i\u00e7in <code>workspace_seed</code> kullan\u0131r</li> </ul>"},{"location":"tr/guides/modeling/lagging/#devam-etme-resume-anlk-goruntuler-snapshots","title":"Devam Etme (Resume) &amp; Anl\u0131k G\u00f6r\u00fcnt\u00fcler (Snapshots)","text":"<ul> <li><code>RuntimeWorkspace</code>, <code>snapshot_workspace()</code> ve <code>restore_workspace()</code> i\u015flevlerini destekler</li> <li>Lag tamponlar\u0131 otomatik olarak \u00e7al\u0131\u015fma alan\u0131 anl\u0131k g\u00f6r\u00fcnt\u00fclerine dahil edilir</li> <li>\u00d6zel bir i\u015flem yap\u0131lmas\u0131na gerek yoktur</li> </ul> <p>Do\u011fruluk garantisi: Lag'ler sadece onaylanm\u0131\u015f (committed) ad\u0131mlardan sonra say\u0131l\u0131r.</p>"},{"location":"tr/guides/modeling/lagging/#ornek-gecikmeli-lojistik-map","title":"\u00d6rnek: Gecikmeli Lojistik Map","text":"<pre><code>[model]\ntype = \"map\"\nname = \"Delayed Logistic Map\"\n\n[states]\nx = 0.1\n\n[params]\nr = 3.8\nalpha = 0.7  # Mevcut ve gecikmeli geri beslemenin kar\u0131\u015f\u0131m\u0131\n\n[equations.rhs]\n# Gecikme-ba\u011fla\u015f\u0131ml\u0131 lojistik map\nx = \"r * (alpha * x + (1 - alpha) * lag_x()) * (1 - x)\"\n\n[sim]\nt0 = 0.0\ndt = 1.0\nstepper = \"map\"\n</code></pre> <p>Y\u00fcr\u00fctme izi: <pre><code>n=0: x=0.1, lag_x(1)=0.1 (IC - Ba\u015flang\u0131\u00e7 Ko\u015fulu)\nn=1: x = 3.8*(0.7*0.1 + 0.3*0.1)*(1-0.1) = 0.342\n     lag_x(1)=0.1\nn=2: x = 3.8*(0.7*0.342 + 0.3*0.1)*(1-0.342) = 0.627\n     lag_x(1)=0.342\nn=3: x = 3.8*(0.7*0.627 + 0.3*0.342)*(1-0.627) = 0.788\n     lag_x(1)=0.627\n...\n</code></pre></p>"},{"location":"tr/guides/modeling/lagging/#performans","title":"Performans","text":""},{"location":"tr/guides/modeling/lagging/#hafza-maliyeti","title":"Haf\u0131za Maliyeti","text":"<p><code>k</code> derinli\u011fine sahip her lag uygulanm\u0131\u015f durum i\u00e7in: - Depolama: <code>RuntimeWorkspace.lag_ring</code> i\u00e7inde <code>k * sizeof(dtype)</code> bayt - Ba\u015f (Head) indeksleri: <code>RuntimeWorkspace.lag_head</code> i\u00e7inde her durum i\u00e7in 1 int32 - Meta veri: <code>RuntimeWorkspace.lag_info</code> i\u00e7inde her durum i\u00e7in 3 int32 - \u00d6rnek: 3 durum, derinlik 10, float64 \u2192 3 * 10 * 8 = 240 bayt + ek y\u00fck</p>"},{"location":"tr/guides/modeling/lagging/#islem-maliyeti","title":"\u0130\u015flem Maliyeti","text":"<ul> <li>Ad\u0131m ba\u015f\u0131na: Dairesel tampona O(n_lagged_states) yazma i\u015flemi</li> <li>Lag eri\u015fimi: O(1) modulo + dizi indeksi</li> <li>Numba, e\u011fer derinlik 2'nin kuvvetiyse <code>(x - k) % depth</code> i\u015flemini bitwise AND i\u015flemine optimize eder</li> </ul>"},{"location":"tr/guides/modeling/lagging/#referanslar","title":"Referanslar","text":"<ul> <li>Runtime Workspace: <code>runtime/workspace.py</code></li> <li>DSL Spec: <code>dsl/spec.py</code></li> <li>\u0130fade \u0130ndirgeme (Lowering): <code>compiler/codegen/rewrite.py</code></li> <li>Runner ABI: <code>runtime/runner_api.py</code></li> <li>Stepper Base: <code>steppers/base.py</code></li> </ul>"},{"location":"tr/guides/modeling/math-and-macros/","title":"Matematik Fonksiyonlar\u0131, Skaler Makrolar ve Generator Comprehension'lar","text":""},{"location":"tr/guides/modeling/math-and-macros/#yerlesik-matematik-fonksiyonlar","title":"Yerle\u015fik Matematik Fonksiyonlar\u0131","text":"<p>A\u015fa\u011f\u0131daki matematiksel fonksiyonlar kullan\u0131ma haz\u0131rd\u0131r ve do\u011frudan Python'un <code>math</code> mod\u00fcl\u00fcne veya yerle\u015fik fonksiyonlar\u0131na e\u015flenir:</p>"},{"location":"tr/guides/modeling/math-and-macros/#temel-fonksiyonlar","title":"Temel Fonksiyonlar","text":"<ul> <li><code>abs(x)</code> - Mutlak de\u011fer</li> <li><code>min(x, y, ...)</code> - Arg\u00fcmanlar\u0131n en k\u00fc\u00e7\u00fc\u011f\u00fc</li> <li><code>max(x, y, ...)</code> - Arg\u00fcmanlar\u0131n en b\u00fcy\u00fc\u011f\u00fc</li> <li><code>round(x)</code> - En yak\u0131n tamsay\u0131ya yuvarlama</li> </ul>"},{"location":"tr/guides/modeling/math-and-macros/#ustel-ve-logaritmik-fonksiyonlar","title":"\u00dcstel ve Logaritmik Fonksiyonlar","text":"<ul> <li><code>exp(x)</code> - \u00dcstel fonksiyon (e^x)</li> <li><code>expm1(x)</code> - exp(x) - 1 (k\u00fc\u00e7\u00fck x de\u011ferleri i\u00e7in daha hassas)</li> <li><code>log(x)</code> - Do\u011fal logaritma</li> <li><code>log10(x)</code> - 10 taban\u0131nda logaritma</li> <li><code>log2(x)</code> - 2 taban\u0131nda logaritma</li> <li><code>log1p(x)</code> - log(1 + x) (k\u00fc\u00e7\u00fck x de\u011ferleri i\u00e7in daha hassas)</li> <li><code>sqrt(x)</code> - Karek\u00f6k</li> </ul>"},{"location":"tr/guides/modeling/math-and-macros/#trigonometrik-fonksiyonlar","title":"Trigonometrik Fonksiyonlar","text":"<ul> <li><code>sin(x)</code> - Sin\u00fcs</li> <li><code>cos(x)</code> - Kosin\u00fcs</li> <li><code>tan(x)</code> - Tanjant</li> <li><code>asin(x)</code> - Ters sin\u00fcs (arksin\u00fcs)</li> <li><code>acos(x)</code> - Ters kosin\u00fcs (arkkosin\u00fcs)</li> <li><code>atan(x)</code> - Ters tanjant (arktanjant)</li> <li><code>atan2(y, x)</code> - \u0130ki arg\u00fcmanl\u0131 ters tanjant</li> </ul>"},{"location":"tr/guides/modeling/math-and-macros/#hiperbolik-fonksiyonlar","title":"Hiperbolik Fonksiyonlar","text":"<ul> <li><code>sinh(x)</code> - Hiperbolik sin\u00fcs</li> <li><code>cosh(x)</code> - Hiperbolik kosin\u00fcs</li> <li><code>tanh(x)</code> - Hiperbolik tanjant</li> <li><code>asinh(x)</code> - Ters hiperbolik sin\u00fcs</li> <li><code>acosh(x)</code> - Ters hiperbolik kosin\u00fcs</li> <li><code>atanh(x)</code> - Ters hiperbolik tanjant</li> </ul>"},{"location":"tr/guides/modeling/math-and-macros/#yuvarlama-fonksiyonlar","title":"Yuvarlama Fonksiyonlar\u0131","text":"<ul> <li><code>floor(x)</code> - Taban (bir alt tamsay\u0131ya yuvarlar)</li> <li><code>ceil(x)</code> - Tavan (bir \u00fcst tamsay\u0131ya yuvarlar)</li> <li><code>trunc(x)</code> - K\u0131rpma (kesirli k\u0131sm\u0131 atar)</li> </ul>"},{"location":"tr/guides/modeling/math-and-macros/#ozel-fonksiyonlar","title":"\u00d6zel Fonksiyonlar","text":"<ul> <li><code>hypot(x, y)</code> - \u00d6klid uzakl\u0131\u011f\u0131 (sqrt(x^2 + y^2))</li> <li><code>copysign(x, y)</code> - y'nin i\u015faretini x'in b\u00fcy\u00fckl\u00fc\u011f\u00fcne kopyalar</li> <li><code>erf(x)</code> - Hata fonksiyonu</li> <li><code>erfc(x)</code> - Tamamlay\u0131c\u0131 hata fonksiyonu</li> </ul>"},{"location":"tr/guides/modeling/math-and-macros/#skaler-makrolar","title":"Skaler Makrolar","text":"<p>Skaler makrolar, yayg\u0131n matematiksel i\u015flemleri ger\u00e7ekle\u015ftiren \u00f6zel fonksiyonlard\u0131r:</p> <ul> <li><code>sign(x)</code> - \u0130\u015faret fonksiyonu: negatif i\u00e7in -1, s\u0131f\u0131r i\u00e7in 0, pozitif i\u00e7in 1 d\u00f6nd\u00fcr\u00fcr</li> <li><code>heaviside(x)</code> - Heaviside basamak fonksiyonu: x &lt; 0 i\u00e7in 0, x &gt;= 0 i\u00e7in 1 d\u00f6nd\u00fcr\u00fcr</li> <li><code>step(x)</code> - heaviside ile ayn\u0131 (takma ad/alias)</li> <li><code>relu(x)</code> - Rectified Linear Unit: max(0, x) d\u00f6nd\u00fcr\u00fcr</li> <li><code>clip(x, min, max)</code> - x de\u011ferini [min, max] aral\u0131\u011f\u0131na s\u0131k\u0131\u015ft\u0131r\u0131r/s\u0131n\u0131rlar</li> <li><code>approx(x, y, tol)</code> - |x - y| &lt;= tol kontrol\u00fc yapar (boolean d\u00f6nd\u00fcr\u00fcr)</li> </ul>"},{"location":"tr/guides/modeling/math-and-macros/#generator-comprehensionlar","title":"Generator Comprehension'lar","text":"<p>DSL, aral\u0131klar \u00fczerinde verimli toplama ve \u00e7arpma i\u015flemleri i\u00e7in \"generator comprehension\" yap\u0131lar\u0131n\u0131 destekler:</p> <ul> <li><code>sum(expr for var in range(start, stop[, step]) [if condition])</code> - Bir aral\u0131ktaki ifadelerin toplam\u0131</li> <li><code>prod(expr for var in range(start, stop[, step]) [if condition])</code> - Bir aral\u0131ktaki ifadelerin \u00e7arp\u0131m\u0131</li> </ul> <p>Bu yap\u0131lar optimize edilmi\u015f for d\u00f6ng\u00fclerine derlenir. Yineleyici (iterator) olarak sadece <code>range()</code> desteklenir ve sadece tek bir \u00fcrete\u00e7 (generator) kullan\u0131labilir. <code>if</code> ile ko\u015fullu filtreleme desteklenir.</p> <p>\u00d6rnekler: - <code>sum(i*i for i in range(10))</code> - 0'dan 9'a kadar karelerin toplam\u0131 (0+1+4+...+81) - <code>prod((i+1) for i in range(1, 5))</code> - \u00c7arp\u0131m 2\u00d73\u00d74\u00d75 = 120 - <code>sum(x[i] for i in range(N) if i % 2 == 0)</code> - \u00c7ift indeksli elemanlar\u0131n toplam\u0131 (x'in bir dizi oldu\u011fu varsay\u0131larak)</p>"},{"location":"tr/guides/modeling/math-and-macros/#olay-event-makrolar","title":"Olay (Event) Makrolar\u0131","text":"<p>Olay makrolar\u0131, olay ko\u015fullar\u0131nda durum de\u011fi\u015fikliklerini ve ge\u00e7i\u015fleri alg\u0131lamak i\u00e7in kullan\u0131l\u0131r. Bu makrolar kar\u015f\u0131la\u015ft\u0131rma i\u00e7in otomatik olarak ge\u00e7mi\u015f (lag uygulanm\u0131\u015f) durum de\u011ferlerini kullan\u0131r:</p> <ul> <li><code>cross_up(state, threshold)</code> - Durum, e\u015fi\u011fi a\u015fa\u011f\u0131dan yukar\u0131ya kesti\u011finde Do\u011fru (True) olur</li> <li><code>cross_down(state, threshold)</code> - Durum, e\u015fi\u011fi yukar\u0131dan a\u015fa\u011f\u0131ya kesti\u011finde Do\u011fru (True) olur</li> <li><code>cross_either(state, threshold)</code> - Durum, e\u015fi\u011fi herhangi bir y\u00f6nde kesti\u011finde Do\u011fru (True) olur</li> <li><code>changed(state)</code> - Durum de\u011feri \u00f6nceki ad\u0131ma g\u00f6re de\u011fi\u015fti\u011finde Do\u011fru (True) olur</li> <li><code>in_interval(state, lower, upper)</code> - Durum \u015fu anda [lower, upper] aral\u0131\u011f\u0131ndaysa Do\u011fru (True) olur</li> <li><code>enters_interval(state, lower, upper)</code> - Durum [lower, upper] aral\u0131\u011f\u0131na girdi\u011finde Do\u011fru (True) olur</li> <li><code>leaves_interval(state, lower, upper)</code> - Durum [lower, upper] aral\u0131\u011f\u0131ndan \u00e7\u0131kt\u0131\u011f\u0131nda Do\u011fru (True) olur</li> <li><code>increasing(state)</code> - Durum art\u0131yorsa (mevcut &gt; \u00f6nceki) Do\u011fru (True) olur</li> <li><code>decreasing(state)</code> - Durum azal\u0131yorsa (mevcut &lt; \u00f6nceki) Do\u011fru (True) olur</li> </ul>"},{"location":"tr/guides/modeling/model-registry/","title":"Model Registry","text":"<p>Model dosyalar\u0131 disk \u00fczerinde bulunur, ancak dynlib bu dosyalara mutlak yollarla (absolute paths) u\u011fra\u015fmak yerine sabit bir URI ile referans vermenizi sa\u011flayan k\u00fc\u00e7\u00fck bir registry (kay\u0131t sistemi) arac\u0131l\u0131\u011f\u0131yla eri\u015fim sunar. Registry, dynlib ile birlikte gelen yerle\u015fik (builtin) modelleri y\u00f6netir, kendi etiketlerinizi (tags) tan\u0131mlaman\u0131za izin verir; ayr\u0131ca g\u00f6reli yollar\u0131, par\u00e7alar\u0131 (fragments) ve sat\u0131r i\u00e7i (inline) modelleri \u015feffaf bir \u015fekilde \u00e7\u00f6z\u00fcmler.</p>"},{"location":"tr/guides/modeling/model-registry/#yerlesik-built-in-modeller","title":"Yerle\u015fik (Built-in) Modeller","text":"<p>Dynlib, <code>src/dynlib/models</code> paketini \u00f6nceden y\u00fckler, b\u00f6ylece her zaman bir <code>builtin://</code> etiketi mevcuttur. Bu sayede, a\u015fa\u011f\u0131daki modellerden herhangi birini <code>setup(...)</code>, <code>dynlib model validate</code> veya ba\u015fka bir giri\u015f noktas\u0131na, herhangi bir yap\u0131land\u0131rma dosyas\u0131 yazmadan ekleyebilirsiniz.</p>"},{"location":"tr/guides/modeling/model-registry/#map-modelleri","title":"Map modelleri","text":"<ul> <li><code>builtin://map/logistic</code></li> <li><code>builtin://map/henon</code></li> <li><code>builtin://map/henon2</code></li> <li><code>builtin://map/ikeda</code></li> <li><code>builtin://map/lozi</code></li> <li><code>builtin://map/sine</code></li> <li><code>builtin://map/standard</code></li> </ul>"},{"location":"tr/guides/modeling/model-registry/#ode-modelleri","title":"ODE modelleri","text":"<ul> <li><code>builtin://ode/duffing</code></li> <li><code>builtin://ode/eto-circular</code></li> <li><code>builtin://ode/expdecay</code></li> <li><code>builtin://ode/exp-if</code></li> <li><code>builtin://ode/fitzhugh-nagumo</code></li> <li><code>builtin://ode/hodgkin-huxley</code></li> <li><code>builtin://ode/izhikevich</code></li> <li><code>builtin://ode/leaky-if</code></li> <li><code>builtin://ode/lorenz</code></li> <li><code>builtin://ode/quadratic-if</code></li> <li><code>builtin://ode/resonate-if</code></li> <li><code>builtin://ode/vanderpol</code></li> </ul> <p>Registry, bu builtin dizinini otomatik olarak ekler (kesin mant\u0131k i\u00e7in <code>dynlib/compiler/paths.py</code> dosyas\u0131na bak\u0131n\u0131z), bu nedenle <code>builtin://</code> alt\u0131ndaki yollar hakk\u0131nda endi\u015felenmenize nadiren gerek kal\u0131r \u2014 sadece <code>builtin://ode/vanderpol</code> (<code>.toml</code> olmadan) yaz\u0131n; dynlib dosyay\u0131 kontrol eder ve bulamazsa yararl\u0131 bir <code>ModelNotFoundError</code> hatas\u0131 verir.</p> <p>Bir builtin modeli incelemeniz veya do\u011frulaman\u0131z gerekti\u011finde CLI'\u0131 kullan\u0131n:</p> <pre><code>dynlib model validate builtin://ode/expdecay\n</code></pre> <p>Bu komut URI'yi ayr\u0131\u015ft\u0131r\u0131r, dosyay\u0131 \u00e7\u00f6zer, DSL'i do\u011frular ve bir sim\u00fclasyon \u00e7al\u0131\u015ft\u0131rmadan \u00f6nce herhangi bir ayr\u0131\u015ft\u0131rma hatas\u0131n\u0131 rapor eder.</p>"},{"location":"tr/guides/modeling/model-registry/#uri-kullanm","title":"URI Kullan\u0131m\u0131","text":"<p><code>resolve_uri</code> (CLI ve <code>setup(...)</code> arkas\u0131ndaki ayn\u0131 mant\u0131k) \u00e7e\u015fitli URI bi\u00e7imlerini anlar:</p> <ol> <li>Sat\u0131r i\u00e7i (Inline) bildirimler: Bir dizeye <code>inline:</code> ile ba\u015flarsan\u0131z, dynlib DSL par\u00e7as\u0131n\u0131 haf\u0131zada tutar. Notebook'lar veya testlerdeki \"kullan-at\" modeller i\u00e7in kullan\u0131\u015fl\u0131d\u0131r.</li> <li>Etiket (Tag) URI'leri: <code>TAG://relative/path</code>, <code>TAG</code> i\u00e7in kaydedilmi\u015f herhangi bir k\u00f6k dizin alt\u0131nda modeli arar. Builtin modeller <code>TAG=builtin</code> kullan\u0131r, ancak kendi etiketlerinizi \u00f6zel dizinlerle ekleyebilirsiniz (bir sonraki b\u00f6l\u00fcme bak\u0131n).</li> <li>Mutlak veya g\u00f6reli yollar: Ger\u00e7ek bir dosya yolu da \u00e7al\u0131\u015f\u0131r ve dynlib bunu normalize eder (<code>~</code>, ortam de\u011fi\u015fkenleri ve <code>.toml</code> uzant\u0131s\u0131n\u0131 geni\u015fletir; mutlak yolu <code>cwd</code>'ye g\u00f6re \u00e7\u00f6zer).</li> </ol> <p>Etiket URI'leri, bir dosya i\u00e7indeki modlar\u0131 veya b\u00f6l\u00fcmleri se\u00e7mek i\u00e7in par\u00e7alar (fragments) da ta\u015f\u0131yabilir:</p> <pre><code>builtin://ode/duffing#mod=odd\n</code></pre> <p>Ayr\u0131\u015ft\u0131r\u0131c\u0131 (parser), dosyay\u0131 \u00e7\u00f6z\u00fcmlemeden \u00f6nce <code>#mod=...</code> k\u0131sm\u0131n\u0131 ay\u0131r\u0131r ve par\u00e7ay\u0131 geri verir; b\u00f6ylece derleyici <code>build(..., mods=[...])</code> \u00e7a\u011fr\u0131s\u0131 yaparken bunu kullanabilir.</p> <p><code>resolve_uri</code>, sa\u011flanan yolun bir soneki yoksa <code>.toml</code> eklemeyi de dener, bu nedenle hem <code>builtin://ode/vanderpol</code> hem de <code>builtin://ode/vanderpol.toml</code> kabul edilir. G\u00fcvenlik kontrolleri, kay\u0131tl\u0131 k\u00f6k\u00fcn d\u0131\u015f\u0131na \u00e7\u0131k\u0131lmas\u0131n\u0131 engeller, yani <code>TAG://../foo.toml</code>, herhangi bir dosya okunmadan \u00f6nce bir <code>PathTraversalError</code> hatas\u0131 verir.</p>"},{"location":"tr/guides/modeling/model-registry/#etiket-koklerini-tag-roots-yaplandrma","title":"Etiket K\u00f6klerini (Tag Roots) Yap\u0131land\u0131rma","text":"<p>Dynlib, registry yap\u0131land\u0131rmas\u0131n\u0131 k\u00fc\u00e7\u00fck bir TOML dosyas\u0131nda tutar ve bunu ortam de\u011fi\u015fkenleri ile destekler:</p> <ul> <li><code>DYNLIB_CONFIG</code> yap\u0131land\u0131rma yolunu ge\u00e7ersiz k\u0131lar (varsay\u0131lan: Linux'ta <code>~/.config/dynlib/config.toml</code>, macOS'ta <code>~/Library/Application Support/dynlib/config.toml</code>, Windows'ta <code>%APPDATA%/dynlib/config.toml</code>).</li> <li><code>DYN_MODEL_PATH</code>, etiket k\u00f6klerini an\u0131nda (on-the-fly) kabuk dostu bir s\u00f6zdizimiyle eklemenizi sa\u011flar. POSIX sistemlerinde <code>TAG=/yol/bir,/yol/iki:DIGER=/yol/uc</code> kullan\u0131n, Windows'ta etiketler aras\u0131nda <code>;</code> kullan\u0131n.</li> </ul> <p>Bir <code>config.toml</code> \u015funa benzer:</p> <pre><code>[paths]\nmyproj = [\"~/repos/dynlib-models\", \"/opt/models\"]\nbuiltin = [\"/custom/builtin/overrides\"]  # dynlib builtin'lerini eri\u015filebilir tut\ncache_root = \"~/Library/Caches/dynlib\"\n</code></pre> <p><code>load_config()</code> bu dosyay\u0131 ayr\u0131\u015ft\u0131r\u0131r, ard\u0131ndan <code>DYN_MODEL_PATH</code> girdilerini ba\u015fa ekler; b\u00f6ylece birden fazla dizin ayn\u0131 etiketi payla\u015ft\u0131\u011f\u0131nda ortam de\u011fi\u015fkeni k\u00f6kleri kazan\u0131r. Bundan sonra, <code>builtin://</code> URI'lerinin ba\u015fka bir yerde ge\u00e7ersiz k\u0131lsan\u0131z bile \u00e7\u00f6z\u00fcmlenmesini garanti etmek i\u00e7in builtin modeller klas\u00f6r\u00fc <code>builtin</code> etiket listesine eklenir.</p>"},{"location":"tr/guides/modeling/model-registry/#kendi-yollarnz-ekleme","title":"Kendi Yollar\u0131n\u0131z\u0131 Ekleme","text":"<ol> <li>Bir etiket se\u00e7in (\u00f6rne\u011fin <code>myproj</code>) ve etiket URI yap\u0131s\u0131n\u0131 yans\u0131tan bir dizin a\u011fac\u0131 olu\u015fturun. \u00d6rne\u011fin, <code>myproj://circuit/srn.toml</code>, <code>.../&lt;root&gt;/circuit/srn.toml</code> yoluna \u00e7\u00f6z\u00fcmlenir.</li> <li>K\u00f6k\u00fc <code>DYNLIB_CONFIG</code> i\u00e7indeki <code>[paths]</code> tablosuna ekleyin veya ge\u00e7ici ge\u00e7ersiz k\u0131lmalar i\u00e7in kabu\u011funuzda <code>DYN_MODEL_PATH=\"myproj=~/models/myproj\"</code> ayarlay\u0131n.</li> <li>Kurulumu <code>dynlib model validate myproj://circuit/srn</code> ile do\u011frulay\u0131n.</li> <li>URI'yi betikler, <code>setup(...)</code> veya kendi ara\u00e7lar\u0131n\u0131z i\u00e7inde kullan\u0131n \u2014 dynlib etiketleri \u00e7\u00f6zer, <code>.toml</code> dener ve eksik dosyalar\u0131 aday listesiyle birlikte rapor eder.</li> </ol> <p>Birden fazla registry y\u00f6netiyorsan\u0131z, <code>DYN_MODEL_PATH</code> girdilerinin yap\u0131land\u0131rma dosyas\u0131 girdilerine g\u00f6re \u00f6nceli\u011fi oldu\u011funu ve bunlar\u0131n her ikisinin de builtin klas\u00f6r\u00fcnden \u00f6nce arand\u0131\u011f\u0131n\u0131 unutmay\u0131n. Bu s\u0131ralama, <code>builtin</code> etiket listesinde daha \u00f6nceye ayn\u0131 yap\u0131ya sahip bir dizin koyarak <code>builtin://</code> modellerini ge\u00e7ersiz k\u0131lman\u0131za (override) olanak tan\u0131r.</p>"},{"location":"tr/guides/modeling/model-registry/#ipuclar","title":"\u0130pu\u00e7lar\u0131","text":"<ul> <li>Bir sim\u00fclasyonu \u00e7al\u0131\u015ft\u0131rmadan \u00f6nce registry'nin dosyay\u0131 ger\u00e7ekten \u00e7\u00f6zd\u00fc\u011f\u00fcnden emin olmak i\u00e7in <code>dynlib model validate &lt;uri&gt;</code> \u00e7al\u0131\u015ft\u0131r\u0131n.</li> <li>Ayr\u0131 <code>[[mods]]</code> tablolar\u0131nda saklanan varyantlara sahip modelleri olu\u015ftururken <code>mytag://path/to/model#mod=variant</code> kullan\u0131n.</li> <li>Yeniden kullan\u0131labilir modelleri bilinen bir etiket dizini alt\u0131nda tutun, b\u00f6ylece i\u015f arkada\u015flar\u0131n\u0131z yerel yap\u0131land\u0131rmalar\u0131n\u0131 d\u00fczenlemeden ayn\u0131 URI'lere g\u00fcvenebilirler.</li> </ul> <p>Bu registry mevcutken, dynlib'in arama semanti\u011fini sizin yerinize halletmesine izin vererek builtin modelleri, payla\u015f\u0131lan k\u00fct\u00fcphaneleri ve projeye \u00f6zg\u00fc dosyalar\u0131 \u00f6zg\u00fcrce kar\u0131\u015ft\u0131rabilirsiniz.</p>"},{"location":"tr/guides/modeling/mods/","title":"Mods: Dynlib'de Model Modifikasyonlar\u0131","text":"<p>Dynlib'deki Mods (modifikasyonlar), orijinal model dosyalar\u0131n\u0131 de\u011fi\u015ftirmeden model spesifikasyonlar\u0131n\u0131 dinamik olarak de\u011fi\u015ftirmenize olanak tan\u0131r. Bu \u00f6zellik \u015fu durumlar i\u00e7in yararl\u0131d\u0131r:</p> <ul> <li>Model varyantlar\u0131 olu\u015fturmak (\u00f6rn. farkl\u0131 parametre setleri, eklenen olaylar)</li> <li>Farkl\u0131 model konfig\u00fcrasyonlar\u0131n\u0131 A/B testine tabi tutmak</li> <li>Mevcut modellere yamalar veya d\u00fczeltmeler uygulamak</li> <li>Daha basit temel modellerden karma\u015f\u0131k modeller olu\u015fturmak</li> </ul>"},{"location":"tr/guides/modeling/mods/#genel-baks","title":"Genel Bak\u0131\u015f","text":"<p>Modlar, TOML tablo s\u00f6zdizimi kullan\u0131larak tan\u0131mlan\u0131r. Temel bir mod \u015f\u00f6yle g\u00f6r\u00fcn\u00fcr:</p> <pre><code>[mod]\nname = \"modifikasyonum\"\ngroup = \"opsiyonel_grup\"\nexclusive = false\n\n[mod.remove.events]\nnames = [\"silinecek_olay\"]\n\n[mod.add.events.yeni_olay]\nphase = \"post\"\ncond = \"x &gt; threshold\"\naction = \"x = 0\"\n\n[mod.set.params]\nalpha = 0.5\nbeta = 2.0\n</code></pre>"},{"location":"tr/guides/modeling/mods/#fiil-verb-islemleri","title":"Fiil (Verb) \u0130\u015flemleri","text":"<p>Modlar, \u015fu s\u0131rayla uygulanan d\u00f6rt ana i\u015flemi (fiilleri) destekler: remove (kald\u0131r) \u2192 replace (de\u011fi\u015ftir) \u2192 add (ekle) \u2192 set (ayarla).</p>"},{"location":"tr/guides/modeling/mods/#1-remove-kaldr","title":"1. Remove (Kald\u0131r)","text":"<p>Modelden mevcut bile\u015fenleri kald\u0131r\u0131r. Yaln\u0131zca halihaz\u0131rda var olan bile\u015fenler \u00fczerinde \u00e7al\u0131\u015f\u0131r.</p> <p>Desteklenen hedefler: <code>events</code>, <code>params</code>, <code>aux</code>, <code>functions</code></p> <pre><code>[mod]\nname = \"temizlik\"\n\n# Belirli olaylar\u0131 kald\u0131r\n[mod.remove.events]\nnames = [\"debug_event\", \"gecici_tetikleyici\"]\n\n# Parametreleri kald\u0131r\n[mod.remove.params]\nnames = [\"kullanilmayan_param\", \"eski_sabit\"]\n\n# Yard\u0131mc\u0131 de\u011fi\u015fkenleri (aux) kald\u0131r\n[mod.remove.aux]\nnames = [\"gecici_degisken\", \"debug_cikti\"]\n\n# Fonksiyonlar\u0131 kald\u0131r\n[mod.remove.functions]\nnames = [\"yardimci_fonk\", \"kullanilmayan_util\"]\n</code></pre> <p>Not: <code>states</code> (durumlar) veya di\u011fer desteklenmeyen hedefleri kald\u0131rmaya \u00e7al\u0131\u015fmak bir hata olu\u015fturur.</p>"},{"location":"tr/guides/modeling/mods/#2-replace-degistir","title":"2. Replace (De\u011fi\u015ftir)","text":"<p>Mevcut bile\u015fenleri yeni tan\u0131mlarla de\u011fi\u015ftirir. Bile\u015fen zaten mevcut olmal\u0131d\u0131r.</p> <p>Desteklenen hedefler: <code>events</code>, <code>aux</code>, <code>functions</code></p> <p>Not: Parametre de\u011ferlerini g\u00fcncellemek i\u00e7in <code>set.params</code> kullan\u0131n. Parametreleri tamamen de\u011fi\u015ftirmek i\u00e7in <code>remove</code> + <code>add</code> kullan\u0131n.</p> <pre><code>[mod]\nname = \"mantik_guncelleme\"\n\n# Bir olay\u0131 (event) de\u011fi\u015ftir\n[mod.replace.events.mevcut_olay]\nphase = \"post\"\ncond = \"x &gt; yeni_esik\"\naction = \"x = 0; counter = counter + 1\"\n\n# Yard\u0131mc\u0131 de\u011fi\u015fkenleri de\u011fi\u015ftir\n[mod.replace.aux]\nenergy = \"0.5 * m * v^2\"  # Yeni ifade\npower = \"force * velocity\"  # Yeni ifade\n\n# Fonksiyonlar\u0131 de\u011fi\u015ftir\n[mod.replace.functions.activation]\nargs = [\"x\", \"gain\", \"offset\"]\nexpr = \"gain * tanh(x) + offset\"\n</code></pre>"},{"location":"tr/guides/modeling/mods/#3-add-ekle","title":"3. Add (Ekle)","text":"<p>Modele yeni bile\u015fenler ekler. Bile\u015fen daha \u00f6nce mevcut olmamal\u0131d\u0131r.</p> <p>Desteklenen hedefler: <code>events</code>, <code>params</code>, <code>aux</code>, <code>functions</code></p> <pre><code>[mod]\nname = \"ozellik_ekle\"\n\n# Yeni olaylar ekle\n[mod.add.events.reset_mechanism]\nphase = \"post\"\ncond = \"x &gt; 10\"\naction = \"x = 0\"\n\n[mod.add.events.spike_detector]\nphase = \"pre\"\ncond = \"v &gt; threshold\"\naction = \"spike_count = spike_count + 1\"\nlog = [\"t\"]  # Spike zamanlar\u0131n\u0131 kaydet\n\n# Yeni parametreler ekle\n[mod.add.params]\ngain = 2.5\noffset = 0.1\n\n# Yeni yard\u0131mc\u0131 de\u011fi\u015fkenler ekle\n[mod.add.aux]\ntotal_energy = \"kinetic + potential\"\nefficiency = \"output_power / input_power\"\n\n# Fonksiyonlar ekle\n[mod.add.functions.sigmoid]\nargs = [\"x\"]\nexpr = \"1 / (1 + exp(-x))\"\n\n[mod.add.functions.relu]\nargs = [\"x\"]\nexpr = \"max(0, x)\"\n</code></pre> <p>Not: <code>states</code> veya di\u011fer desteklenmeyen hedefleri eklemeye \u00e7al\u0131\u015fmak bir hata olu\u015fturur.</p>"},{"location":"tr/guides/modeling/mods/#4-set-ayarla","title":"4. Set (Ayarla)","text":"<p>Bile\u015fen de\u011ferlerini ayarlar veya g\u00fcnceller. Bu bir \"upsert\" (g\u00fcncelle veya ekle) i\u015flemidir - yeni bile\u015fenler olu\u015fturabilir veya mevcut olanlar\u0131 g\u00fcncelleyebilir.</p> <p>Desteklenen hedefler: <code>states</code>, <code>params</code>, <code>aux</code>, <code>functions</code></p> <pre><code>[mod]\nname = \"yapilandir\"\n\n# Durum (state) ba\u015flang\u0131\u00e7 de\u011ferlerini ayarla\n[mod.set.states]\nx = 5.0\ny = -2.5\n\n# Parametre de\u011ferlerini ayarla (zaten mevcut olmal\u0131)\n[mod.set.params]\nalpha = 0.1\nbeta = 2.5\n\n# Yard\u0131mc\u0131 de\u011fi\u015fkenleri ayarla (upsert - olu\u015ftur veya g\u00fcncelle)\n[mod.set.aux]\ndebug = \"t\"  # Yeni olu\u015ftur\nenergy = \"0.5 * k * x^2\"  # Mevcut olan\u0131 g\u00fcncelle\n\n# Fonksiyonlar\u0131 ayarla (upsert - olu\u015ftur veya g\u00fcncelle)\n[mod.set.functions.activation]\nargs = [\"x\"]\nexpr = \"tanh(x)\"  # Mevcut olan\u0131 g\u00fcncelle\n\n[mod.set.functions.new_func]\nargs = [\"a\", \"b\"]\nexpr = \"a + b\"  # Yeni olu\u015ftur\n</code></pre> <p>Not: <code>states</code> ve <code>params</code> i\u00e7in, <code>set</code> yaln\u0131zca mevcut de\u011ferleri g\u00fcnceller ve bile\u015fen yoksa hata verir. Yeni parametreler olu\u015fturmak i\u00e7in <code>add</code> kullan\u0131n.</p>"},{"location":"tr/guides/modeling/mods/#olay-event-tanmlama-format","title":"Olay (Event) Tan\u0131mlama Format\u0131","text":"<p>Modlardaki olaylar, model tan\u0131mlar\u0131yla ayn\u0131 TOML tablo format\u0131n\u0131 kullan\u0131r:</p> <pre><code>[mod.add.events.event_name]\nphase = \"pre\" | \"post\"        # Ko\u015fulun ne zaman kontrol edilece\u011fi\ncond = \"expression\"           # Tetiklenecek ko\u015ful\naction = \"code\"               # Ger\u00e7ekle\u015ftirilecek eylem (string)\nlog = [\"var1\", \"var2\"]        # Tetiklendi\u011finde kaydedilecek de\u011fi\u015fkenler (opsiyonel)\n\n# Alternatif: anahtarl\u0131 eylem atamalar\u0131\n[mod.add.events.event_name]\nphase = \"post\"\ncond = \"x &gt; 5\"\naction.dx = 1.0\naction.dy = -0.5\nlog = [\"t\"]\n</code></pre>"},{"location":"tr/guides/modeling/mods/#fonksiyon-tanmlama-format","title":"Fonksiyon Tan\u0131mlama Format\u0131","text":"<p>Fonksiyonlar <code>args</code> ve <code>expr</code> ile tan\u0131mlan\u0131r:</p> <pre><code>[mod.add.functions.function_name]\nargs = [\"arg1\", \"arg2\", \"arg3\"]  # Arg\u00fcman isimleri dizisi\nexpr = \"expression\"              # Fonksiyon g\u00f6vdesi ifadesi\n</code></pre>"},{"location":"tr/guides/modeling/mods/#grup-ve-dslayclk-exclusivity","title":"Grup ve D\u0131\u015flay\u0131c\u0131l\u0131k (Exclusivity)","text":"<p>\u00c7ak\u0131\u015fan modifikasyonlar\u0131 \u00f6nlemek i\u00e7in modlar grupland\u0131r\u0131labilir:</p> <pre><code># Ayn\u0131 gruptaki birbirini d\u0131\u015flayan (exclusive) modlar\n[mods.fast]\nname = \"fast\"\ngroup = \"speed\"\nexclusive = true\n\n[mods.fast.set.params]\ndt = 0.01\n\n[mods.slow]\nname = \"slow\"\ngroup = \"speed\"\nexclusive = true\n\n[mods.slow.set.params]\ndt = 0.1\n\n# \"speed\" grubundan ayn\u0131 anda sadece bir mod aktif olabilir\n</code></pre>"},{"location":"tr/guides/modeling/mods/#modlar-kullanma","title":"Modlar\u0131 Kullanma","text":""},{"location":"tr/guides/modeling/mods/#dosyalardan-mod-yukleme","title":"Dosyalardan Mod Y\u00fckleme","text":"<p>Modlar genellikle TOML dosyalar\u0131nda saklan\u0131r ve URI arac\u0131l\u0131\u011f\u0131yla y\u00fcklenir:</p> <pre><code>from dynlib import build\n\n# Modlarla birlikte modeli y\u00fckle\nmodel = build(\"model.toml\", mods=[\"mods.toml#mod=variant1\"])\n</code></pre>"},{"location":"tr/guides/modeling/mods/#tek-mod-dosyas","title":"Tek Mod Dosyas\u0131","text":"<pre><code>[mod]\nname = \"parameter_tune\"\ngroup = \"tuning\"\n\n[mod.set.params]\nalpha = 0.5\nbeta = 2.0\n\n[mod.add.events.monitor]\nphase = \"post\"\ncond = \"t % 1.0 == 0\"\naction = \"\"\nlog = [\"x\", \"y\"]\n</code></pre>"},{"location":"tr/guides/modeling/mods/#tek-dosyada-birden-fazla-mod","title":"Tek Dosyada Birden Fazla Mod","text":"<pre><code>[mods.variant1]\nname = \"variant1\"\n\n[mods.variant1.set.params]\ngain = 1.0\n\n[mods.variant2]\nname = \"variant2\"\n\n[mods.variant2.set.params]\ngain = 2.0\n\n[mods.variant2.add.events.noise]\nphase = \"pre\"\ncond = \"true\"\naction = \"x = x + 0.1 * randn()\"\n</code></pre>"},{"location":"tr/guides/modeling/mods/#modlar-icin-uri-desenleri","title":"Modlar i\u00e7in URI Desenleri","text":"<ul> <li><code>\"mods.toml\"</code> - Dosyadan tek bir mod y\u00fckle</li> <li><code>\"mods.toml#mod=variant1\"</code> - Koleksiyondan belirli bir modu y\u00fckle</li> <li><code>\"inline: [mod]\\nname='patch'\\n...\"</code> - Sat\u0131r i\u00e7i (inline) mod tan\u0131m\u0131</li> </ul>"},{"location":"tr/guides/modeling/mods/#programatik-kullanm","title":"Programatik Kullan\u0131m","text":"<p>\u0130leri d\u00fczey kullan\u0131m durumlar\u0131 i\u00e7in, modlar\u0131 programatik olarak olu\u015fturabilirsiniz:</p> <pre><code>from dynlib.compiler.mods import ModSpec, apply_mods_v2\nfrom dynlib.dsl.parser import parse_model_v2\n\n# Modu Python s\u00f6zl\u00fc\u011f\u00fc (dict) olarak tan\u0131mla (yukar\u0131daki TOML'a e\u015fde\u011fer)\nmod = ModSpec(\n    name=\"programmatic_mod\",\n    set={\n        \"params\": {\"alpha\": 0.5},\n        \"aux\": {\"debug\": \"t\"}\n    }\n)\n\n# Ayr\u0131\u015ft\u0131r\u0131lm\u0131\u015f (parsed) modele uygula\nnormal = parse_model_v2(model_toml_string)\nmodified = apply_mods_v2(normal, [mod])\n</code></pre>"},{"location":"tr/guides/modeling/mods/#hata-yonetimi","title":"Hata Y\u00f6netimi","text":"<p>Modlar i\u015flemleri do\u011frular ve \u015funlar i\u00e7in <code>ModelLoadError</code> verir:</p> <ul> <li>Desteklenmeyen hedefler: Desteklenmeyen hedefler \u00fczerinde i\u015flem yapmaya \u00e7al\u0131\u015fmak (\u00f6rn. <code>add.states</code>, <code>remove.states</code>, <code>replace.params</code>)</li> <li>Mevcut olmayan bile\u015fenler: Mevcut olmayan bile\u015fenleri kald\u0131rmaya veya de\u011fi\u015ftirmeye \u00e7al\u0131\u015fmak</li> <li>Yinelenen bile\u015fenler: Zaten mevcut olan bile\u015fenleri eklemeye \u00e7al\u0131\u015fmak</li> <li>Bilinmeyen bile\u015fenler: Mevcut olmayan <code>states</code> veya <code>params</code> i\u00e7in de\u011fer ayarlamaya \u00e7al\u0131\u015fmak</li> <li>Ge\u00e7ersiz veri tipleri: <code>aux</code> de\u011fi\u015fkenleri i\u00e7in string olmayan de\u011ferler kullanmak</li> <li>Hatal\u0131 bi\u00e7imlendirilmi\u015f tan\u0131mlar: Ge\u00e7ersiz fonksiyon tan\u0131mlar\u0131 (eksik args, expr vb.)</li> <li>Grup d\u0131\u015flay\u0131c\u0131l\u0131k ihlalleri: Ayn\u0131 gruptan birden fazla exclusive modu etkinle\u015ftirmek</li> </ul>"},{"location":"tr/guides/modeling/mods/#fiile-gore-desteklenen-hedefler","title":"Fiile G\u00f6re Desteklenen Hedefler","text":"Fiil (Verb) Desteklenen Hedefler Notlar <code>remove</code> <code>events</code>, <code>params</code>, <code>aux</code>, <code>functions</code> Bile\u015fen mevcut olmal\u0131 <code>replace</code> <code>events</code>, <code>aux</code>, <code>functions</code> Bile\u015fen mevcut olmal\u0131 <code>add</code> <code>events</code>, <code>params</code>, <code>aux</code>, <code>functions</code> Bile\u015fen mevcut olmamal\u0131 <code>set</code> <code>states</code>, <code>params</code>, <code>aux</code>, <code>functions</code> States/params mevcut olmal\u0131; aux/functions upsert edilir"},{"location":"tr/guides/modeling/mods/#yaygn-hatalar-ve-cozumler","title":"Yayg\u0131n Hatalar ve \u00c7\u00f6z\u00fcmler","text":"<p>Hata: <code>add.states: unsupported target</code> - Neden: Modlar arac\u0131l\u0131\u011f\u0131yla yeni durum (state) de\u011fi\u015fkenleri eklemeye \u00e7al\u0131\u015fmak. - \u00c7\u00f6z\u00fcm: Durumlar (states) dinamik olarak eklenemez. Bunlar\u0131 temel modelde tan\u0131mlay\u0131n.</p> <p>Hata: <code>remove.states: unsupported target</code> - Neden: Modlar arac\u0131l\u0131\u011f\u0131yla durum de\u011fi\u015fkenlerini kald\u0131rmaya \u00e7al\u0131\u015fmak. - \u00c7\u00f6z\u00fcm: Durumlar kald\u0131r\u0131lamaz. Onlar model yap\u0131s\u0131n\u0131n temelidir.</p> <p>Hata: <code>replace.params: unsupported target</code> - Neden: <code>replace</code> fiilini kullanarak parametreleri de\u011fi\u015ftirmeye \u00e7al\u0131\u015fmak. - \u00c7\u00f6z\u00fcm: De\u011ferleri g\u00fcncellemek i\u00e7in <code>set.params</code> kullan\u0131n veya <code>remove.params</code> + <code>add.params</code> s\u0131ras\u0131n\u0131 kullan\u0131n.</p> <p>Hata: <code>add.params.x: param already exists</code> - Neden: Zaten mevcut olan bir parametreyi eklemeye \u00e7al\u0131\u015fmak. - \u00c7\u00f6z\u00fcm: De\u011feri g\u00fcncellemek i\u00e7in <code>set.params</code> kullan\u0131n veya de\u011fi\u015ftirmek istiyorsan\u0131z \u00f6nce <code>remove.params</code> kullan\u0131n.</p>"},{"location":"tr/guides/modeling/mods/#dogrulama-sessiz-hatalar-onler","title":"Do\u011frulama, Sessiz Hatalar\u0131 \u00d6nler","text":"<p>Do\u011frulama iyile\u015ftirmelerinden \u00f6nce, desteklenmeyen i\u015flemler sessizce ba\u015far\u0131s\u0131z olur ve kullan\u0131c\u0131lar\u0131n modlar\u0131n\u0131n neden \u00e7al\u0131\u015fmad\u0131\u011f\u0131 konusunda kafas\u0131 kar\u0131\u015f\u0131rd\u0131. \u015eimdi, desteklenmeyen hedefleri kullanma giri\u015fimi, desteklenen hedeflerin bir listesiyle birlikte an\u0131nda net bir hata verecektir.</p>"},{"location":"tr/guides/modeling/mods/#en-iyi-uygulamalar","title":"En \u0130yi Uygulamalar","text":"<ol> <li> <p>A\u00e7\u0131klay\u0131c\u0131 isimler kullan\u0131n: Modlara, ama\u00e7lar\u0131n\u0131 belirten a\u00e7\u0131k, a\u00e7\u0131klay\u0131c\u0131 isimler verin.</p> </li> <li> <p>\u0130lgili modlar\u0131 gruplay\u0131n: Kar\u015f\u0131l\u0131kl\u0131 olarak birbirini d\u0131\u015flayan se\u00e7enekler (\u00f6rn. farkl\u0131 parametre setleri) i\u00e7in gruplar\u0131 kullan\u0131n.</p> </li> <li> <p>Kapsaml\u0131 test edin: Modlar model davran\u0131\u015f\u0131n\u0131 \u00f6nemli \u00f6l\u00e7\u00fcde de\u011fi\u015ftirebilir - sonu\u00e7lar\u0131 dikkatlice do\u011frulay\u0131n.</p> </li> <li> <p>Modlar\u0131 belgeleyin: Her modun ne yapt\u0131\u011f\u0131n\u0131 ve nedenini a\u00e7\u0131klayan yorumlar ekleyin.</p> </li> <li> <p>S\u00fcr\u00fcm kontrol\u00fc: Mod dosyalar\u0131n\u0131 modellerinizle birlikte s\u00fcr\u00fcm kontrol\u00fc alt\u0131nda tutun.</p> </li> <li> <p>Basit ba\u015flay\u0131n: Temel <code>set</code> i\u015flemleriyle ba\u015flay\u0131n, ard\u0131ndan daha karma\u015f\u0131k <code>add</code>/<code>replace</code>/<code>remove</code> kombinasyonlar\u0131na ilerleyin.</p> </li> </ol>"},{"location":"tr/guides/modeling/mods/#ornekler","title":"\u00d6rnekler","text":""},{"location":"tr/guides/modeling/mods/#parametre-calsmas-modlar","title":"Parametre \u00c7al\u0131\u015fmas\u0131 Modlar\u0131","text":"<pre><code>[mods.low_gain]\nname = \"low_gain\"\ngroup = \"gain_study\"\nexclusive = true\n\n[mods.low_gain.set.params]\nk = 0.1\n\n[mods.high_gain]\nname = \"high_gain\"\ngroup = \"gain_study\"\nexclusive = true\n\n[mods.high_gain.set.params]\nk = 10.0\n</code></pre>"},{"location":"tr/guides/modeling/mods/#parametreleri-zamanla-degisen-ifadelerle-degistirme","title":"Parametreleri Zamanla De\u011fi\u015fen \u0130fadelerle De\u011fi\u015ftirme","text":"<p>Bu \u00f6rnek, sabit bir parametrenin zamana ba\u011fl\u0131 bir yard\u0131mc\u0131 de\u011fi\u015fkene nas\u0131l d\u00f6n\u00fc\u015ft\u00fcr\u00fclece\u011fini g\u00f6sterir:</p> <pre><code>[mods.sine_drive]\nname = \"sine_drive\"\n\n# Not: Modlar arac\u0131l\u0131\u011f\u0131yla durum (state) eklenemez (hata verir)\n# Bunun yerine, yard\u0131mc\u0131 g\u00fcr\u00fclt\u00fc de\u011fi\u015fkenleri ekleyin\n\n[mods.sine_drive.add.params]\nfreq = 1000.0\nVmax = 4.0\n\n# V'yi zamanla de\u011fi\u015fen bir yard\u0131mc\u0131 de\u011fi\u015fken olarak ekle\n[mods.sine_drive.add.aux]\nV = \"Vmax*sin(2*pi*freq*t)\"\n</code></pre>"},{"location":"tr/guides/modeling/mods/#model-varyantlar","title":"Model Varyantlar\u0131","text":"<pre><code>[mod.stochastic]\nname = \"stochastic\"\n\n# Not: Modlar arac\u0131l\u0131\u011f\u0131yla durum eklenemez (hata verir)\n# Bunun yerine, yard\u0131mc\u0131 g\u00fcr\u00fclt\u00fc de\u011fi\u015fkenleri ekleyin\n\n[mod.stochastic.add.params]\nsigma = 0.1\n\n[mod.stochastic.add.aux]\nnoise = \"sigma * randn()\"\nnoisy_x = \"x + noise\"\n</code></pre>"},{"location":"tr/guides/modeling/mods/#hata-ayklama-debugging-yardmlar","title":"Hata Ay\u0131klama (Debugging) Yard\u0131mlar\u0131","text":"<pre><code>[mod.debug]\nname = \"debug\"\n\n[mod.debug.add.aux]\ndebug_t = \"t\"\ndebug_x = \"x\"\ndebug_dx = \"dx_dt\"\n\n[mod.debug.add.events.log_state]\nphase = \"post\"\ncond = \"t % 1.0 == 0\"  # Saniyede bir kaydet\naction = \"\"  # Eylem yok, sadece kay\u0131t\nlog = [\"debug_t\", \"debug_x\", \"debug_dx\"]\n</code></pre>"},{"location":"tr/guides/modeling/mods/#fonksiyon-varyantlar","title":"Fonksiyon Varyantlar\u0131","text":"<p>A\u015fa\u011f\u0131daki \u00f6rnekte h(phi,N) fonksiyonunun iki varyant\u0131 vard\u0131r. Biri a\u015fa\u011f\u0131daki gibi se\u00e7ilebilir:</p> <pre><code>sim = setup(\"memristive_chua#mod=odd\")\n</code></pre> <pre><code>[model]\ntype=\"ode\"\nname=\"Flux Controlled Memristor\"\n\n[states]\nphi=0.1\n\n[params]\na=0.08\nb=1\nc=0.83\nd=1.8\nN=0\nfreq=1.0\nVmax=4.0\n\n[functions.W]\nargs=[\"phi\"]\nexpr=\"a+b*tanh(phi)**2\"\n\n[aux]\nV = \"Vmax*sin(2*pi*freq*t)\"\nI = \"W(phi)*V\"\n\n[equations.rhs]\nphi=\"c*V-d*h(phi,N)\"\n\n### MODS:\n\n[mods.odd.add.functions]\nh = {args = [\"phi\",\"N\"], expr=\"\"\"\nphi if N==0 else phi-sum(sign(phi+(2*j-1))+sign(phi-(2*j-1)) for j in range(1,N+1))\n\"\"\"}\n\n[mods.even.add.functions]\nh = {args = [\"phi\",\"N\"], expr = \"\"\"\nphi-sign(phi) if N==0 else phi-sign(phi)-sum(sign(phi+2*j)+sign(phi-2*j) for j in range(1,N+1))\n\"\"\"}\n</code></pre>"},{"location":"tr/guides/modeling/mods/#fiil-verb-sras-onemlidir","title":"Fiil (Verb) S\u0131ras\u0131 \u00d6nemlidir","text":"<p>Fiillerin \u015fu sabit s\u0131rayla uyguland\u0131\u011f\u0131n\u0131 unutmay\u0131n:</p> <ol> <li>Remove - \u00d6nce bile\u015fenleri kald\u0131r</li> <li>Replace - Mevcut bile\u015fenleri de\u011fi\u015ftir</li> <li>Add - Yeni bile\u015fenler ekle</li> <li>Set - De\u011ferleri ayarla/g\u00fcncelle</li> </ol> <p>Bu, eski bile\u015feni kald\u0131r \u2192 farkl\u0131 isimle yeni bir tane ekle, veya bile\u015feni de\u011fi\u015ftir \u2192 sonra parametrelerini modifiye et gibi karma\u015f\u0131k d\u00f6n\u00fc\u015f\u00fcmlere olanak tan\u0131r.</p>"},{"location":"tr/guides/modeling/presets/","title":"Presets (\u00d6n Tan\u0131ml\u0131 Ayarlar)","text":"<p>Preset'ler (\u00f6n tan\u0131ml\u0131 ayarlar), bir modelin \"modlar\u0131\" (\u00f6rn. h\u0131zl\u0131 vs. yava\u015f dinamikler, dinlenme vs. aktif) aras\u0131nda h\u0131zl\u0131ca ge\u00e7i\u015f yapabilmeniz i\u00e7in yeniden kullan\u0131labilir durum (state) ve parametre de\u011fer setlerini yakalaman\u0131z\u0131 sa\u011flar. Tan\u0131mland\u0131ktan sonra preset'ler, bir Sim'in bellek i\u00e7i bankas\u0131nda ya\u015far ve \u00e7al\u0131\u015fma zaman\u0131nda uygulanabilir, listelenebilir, kaydedilebilir, y\u00fcklenebilir veya olu\u015fturulabilir.</p>"},{"location":"tr/guides/modeling/presets/#dslde-preset-tanmlama","title":"DSL'de Preset Tan\u0131mlama","text":"<p>Sat\u0131r i\u00e7i (inline) preset'ler, <code>[presets.&lt;isim&gt;]</code> tablolar\u0131 kullan\u0131larak model TOML dosyas\u0131 i\u00e7inde bildirilir. Her preset \u015funlar\u0131 sa\u011flayabilir:</p> <ul> <li>Parametre ge\u00e7ersiz k\u0131lmalar\u0131 (override) i\u00e7in <code>[presets.&lt;isim&gt;.params]</code></li> <li>Durum ba\u015flang\u0131\u00e7 de\u011ferleri i\u00e7in <code>[presets.&lt;isim&gt;.states]</code></li> </ul> <p>\u0130ki b\u00f6l\u00fcmden en az biri bulunmal\u0131d\u0131r ve her de\u011fer bir say\u0131 (tam say\u0131lar ve ondal\u0131kl\u0131 say\u0131lar kabul edilir) olmal\u0131d\u0131r. Bir preset, durumlar\u0131 atlayabilir (sadece parametre), parametreleri atlayabilir (sadece durum) veya her ikisini de sa\u011flayabilir. Bildirilen isimler, modelin <code>states</code> ve <code>params</code> de\u011ferleriyle e\u015fle\u015fmelidir; ge\u00e7ersiz isimler DSL do\u011fruland\u0131\u011f\u0131nda yakalan\u0131r.</p> <pre><code>[presets.fast.params]\nalpha = 2.5\nbeta = 0.1\n\n[presets.fast.states]\nx = 5.0\ny = -1.0\n\n[presets.rest.params]\nalpha = 0.2\nbeta = 0.01\n</code></pre> <p>Sat\u0131r i\u00e7i preset'ler, ba\u015flatma s\u0131ras\u0131nda her <code>Sim</code> \u00f6rne\u011fine (instance) otomatik olarak y\u00fcklenir. Bir preset ad\u0131 birden fazla kez g\u00f6r\u00fcn\u00fcrse, ilk tan\u0131m kazan\u0131r ve bir uyar\u0131 verilir.</p>"},{"location":"tr/guides/modeling/presets/#preset-bankas-ile-calsma","title":"Preset Bankas\u0131 ile \u00c7al\u0131\u015fma","text":"<p>Her <code>Sim</code> \u00f6rne\u011fi, sat\u0131r i\u00e7i tan\u0131mlardan ve \u00e7al\u0131\u015fma zaman\u0131nda eklenen/y\u00fcklenenlerden doldurulan bir preset bankas\u0131 tutar.</p> <ul> <li><code>list_presets(pattern=\"*\")</code>: E\u015fle\u015fen t\u00fcm isimleri (<code>*</code>, <code>?</code>, <code>[]</code> desteklenir) alfabetik olarak s\u0131ralanm\u0131\u015f \u015fekilde d\u00f6nd\u00fcr\u00fcr.</li> <li><code>apply_preset(name)</code>: Yaln\u0131zca preset i\u00e7inde listelenen parametreleri/durumlar\u0131 g\u00fcnceller; zaman, dt, stepper \u00e7al\u0131\u015fma alan\u0131, ad\u0131m say\u0131s\u0131 ve kaydedilen ge\u00e7mi\u015f dokunulmadan kal\u0131r. Uygulamadan \u00f6nce Dynlib, her anahtar\u0131n var oldu\u011funu do\u011frular ve say\u0131sal de\u011ferleri model veri tipine (dtype) d\u00f6n\u00fc\u015ft\u00fcr\u00fcr (hassasiyet kaybolabilirse uyar\u0131 verilir).</li> </ul>"},{"location":"tr/guides/modeling/presets/#annda-yeni-preset-ekleme","title":"An\u0131nda Yeni Preset Ekleme","text":"<p>Mevcut oturumun anl\u0131k g\u00f6r\u00fcnt\u00fcs\u00fcn\u00fc almak veya \u00f6zel de\u011ferleri kaydetmek i\u00e7in <code>add_preset(name, *, states=None, params=None, overwrite=False)</code> kullan\u0131n:</p> <ul> <li>Hem <code>states</code> hem de <code>params</code> <code>None</code> ise, preset mevcut oturumun de\u011ferlerini yakalar.</li> <li>Her arg\u00fcman bir e\u015fleme (<code>{\"x\": 1.0}</code>) veya 1-B NumPy dizisi (bildirim s\u0131ras\u0131na g\u00f6re yorumlan\u0131r) olabilir ve k\u0131smi olabilir (\u00f6rn. durumlar\u0131n sadece bir alt k\u00fcmesi).</li> <li>Metot, <code>overwrite=True</code> olmad\u0131\u011f\u0131 s\u00fcrece isim zaten mevcutsa veya saklanacak hi\u00e7bir \u015fey yoksa <code>ValueError</code> verir.</li> </ul>"},{"location":"tr/guides/modeling/presets/#presetleri-diske-kaydetme-persisting","title":"Preset'leri Diske Kaydetme (Persisting)","text":"<p>Dynlib, <code>dynlib-presets-v1</code> format\u0131n\u0131 izleyen TOML dosyalar\u0131n\u0131 kullanarak preset'leri okuyabilir/yazabilir. Dosya \u015funlar\u0131 i\u00e7ermelidir:</p> <pre><code>[__presets__]\nschema = \"dynlib-presets-v1\"\n\n[presets.example.params]\na = 1.0\nb = 2.0\n\n[presets.example.states]\nx = 0.0\n</code></pre> <ul> <li><code>load_preset(name_or_pattern, path, *, on_conflict=\"error\")</code>: Dosyadaki preset'leri bankaya aktar\u0131r. Tam bir isim veya bir glob deseni (\u00f6rn. <code>\"fast_*\"</code>) ge\u00e7ebilirsiniz. Varsay\u0131lan olarak, mevcut bir banka giri\u015fiyle \u00e7ak\u0131\u015fma bir hata olu\u015fturur, ancak <code>\"keep\"</code>/<code>\"replace\"</code> banka giri\u015fini atlaman\u0131za veya \u00fczerine yazman\u0131za izin verir (uyar\u0131lar eylemi vurgular). Y\u00fckleyici, \u015fema ba\u015fl\u0131\u011f\u0131n\u0131 do\u011frular, say\u0131sal tablolar\u0131 zorunlu k\u0131lar ve referans verilen t\u00fcm isimlerin aktif modelde var oldu\u011fundan emin olur.</li> <li><code>save_preset(name, path, *, overwrite=False)</code>: Bankadan bir preset'i diske ekler veya yazar. <code>[__presets__]</code> ba\u015fl\u0131\u011f\u0131n\u0131 olu\u015fturur veya g\u00fcnceller, mevcut ilgisiz preset'lere dokunmaz ve dosya i\u00e7indeki isim \u00e7ak\u0131\u015fmalar\u0131 i\u00e7in <code>overwrite</code> parametresine sayg\u0131 duyar.</li> </ul> <p>Birlikte bu yard\u0131mc\u0131lar, parametre/durum setlerinden m\u00fcfredatlar olu\u015fturmay\u0131, bunlar\u0131 projeler aras\u0131nda payla\u015fmay\u0131 veya say\u0131sal bir deneyin durumunu daha sonra yeniden kullanmak \u00fczere d\u0131\u015fa aktarmay\u0131 kolayla\u015ft\u0131r\u0131r.</p>"},{"location":"tr/guides/modeling/presets/#ornek","title":"\u00d6rnek","text":"<pre><code>[model]\ntype = \"ode\"\n\n[states]\nv = -65.0\nu = -13.0\n\n[params]\na = 0.02\nb = 0.2\nc = -65.0\nd = 8.0\nI = 10.0\nv_th = 30.0\n\n[equations]\nexpr = \"\"\"\ndv = 0.04 * v * v + 5.0 * v + 140.0 - u + I\ndu = a * (b * v - u)\n\"\"\"\n\n[events.reset]\ncond = \"v &gt;= v_th\"\nphase = \"post\"\naction = \"\"\"\nv = c\nu = u + d\n\"\"\"\n\n# PRESETS:\n[presets.regular_spiking.params]\na = 0.02\nb = 0.2\nc = -65.0\nd = 8.0\n\n[presets.intrinsic_bursting.params]\na = 0.02\nb = 0.2\nc = -55.0\nd = 4.0\n\n[presets.bursting.params]\na = 0.02\nb = 0.2\nc = -50\nd = 2\n\n[presets.fast_spiking.params]\na = 0.1\nb = 0.2\nc = -65\nd = 2\n\n[presets.low_threshold.params]\na = 0.02\nb = 0.25\nc = -65\nd = 2\n\n[presets.resonator.params]\na = 0.1\nb = 0.26\nc = -65\nd = 2\n</code></pre> <p>Sim\u00fclasyon dosyas\u0131nda mevcut preset'lerden birini se\u00e7ebilirsiniz. TOML preset'leri, preset bankas\u0131na otomatik olarak eklenir.</p> <p>Preset'lerin \u00e7al\u0131\u015fma zaman\u0131 kullan\u0131m\u0131 i\u00e7in sim\u00fclasyona bak\u0131n\u0131z.</p>"},{"location":"tr/guides/modeling/sim/","title":"Sim\u00fclasyon ([sim])","text":"<p><code>[sim]</code> tablosu, herhangi bir model i\u00e7in varsay\u0131lan \u00e7al\u0131\u015fma zaman\u0131 ayarlar\u0131n\u0131 (knobs) belirtir. Alanlar\u0131n \u00e7o\u011fu <code>Sim</code> aray\u00fcz\u00fcne (facade) (<code>Sim.run</code>) ve entegrasyonlar\u0131 veya haritalar\u0131 (maps) y\u00fcr\u00fcten runner'a beslenir. Bu tabloyu, modelinizi y\u00fckleyen kullan\u0131c\u0131lar ve ara\u00e7lar i\u00e7in \"\u00f6nerilen varsay\u0131lanlar\" olarak d\u00fc\u015f\u00fcn\u00fcn.</p>"},{"location":"tr/guides/modeling/sim/#bilinen-anahtarlar","title":"Bilinen Anahtarlar","text":"<ul> <li><code>t0</code> \u2013 Ba\u015flang\u0131\u00e7 zaman\u0131. Varsay\u0131lan <code>0.0</code>'d\u0131r. Hem \u00e7al\u0131\u015fma zaman\u0131 saatini hem de t\u00fcretilmi\u015f <code>Nominal dt / T</code> aritmeti\u011fini besler.</li> <li><code>t_end</code> \u2013 S\u00fcrekli (ODE benzeri) modeller i\u00e7in biti\u015f zaman\u0131. Varsay\u0131lan <code>1.0</code>'d\u0131r. <code>Sim.run</code> aray\u00fcz\u00fc, <code>T</code> de\u011ferini ge\u00e7ersiz k\u0131lmad\u0131\u011f\u0131n\u0131zda bunu kullan\u0131r.</li> <li><code>dt</code> \u2013 Nominal zaman ad\u0131m\u0131 (veya ayr\u0131k harita aral\u0131\u011f\u0131). Varsay\u0131lan <code>1e-2</code>'dir. Runner bunu, hem ad\u0131mlama i\u00e7in kullan\u0131lan \"nominal dt\" olarak hem de <code>Sim.run</code> i\u00e7inde <code>dt</code> atland\u0131\u011f\u0131nda geri d\u00f6n\u00fc\u015f de\u011feri olarak \u00f6nbelle\u011fe al\u0131r.</li> <li><code>stepper</code> \u2013 Varsay\u0131lan stepper'\u0131n (ad\u0131may\u0131c\u0131) ad\u0131 (\u00f6rn. ODE'ler i\u00e7in <code>\"rk4\"</code>, map'ler i\u00e7in <code>\"map\"</code>). Derleyici, model t\u00fcr\u00fcne g\u00f6re mant\u0131kl\u0131 bir varsay\u0131lan se\u00e7er ancak belirli bir entegrat\u00f6r\u00fc sabitlemek i\u00e7in bunu buradan ge\u00e7ersiz k\u0131labilirsiniz.</li> <li><code>record</code> \u2013 Varsay\u0131lan kay\u0131t davran\u0131\u015f\u0131n\u0131 kontrol eden boolean de\u011fer. Varsay\u0131lan <code>true</code>'dur. <code>Sim.run</code>, <code>record</code> olmadan \u00e7a\u011fr\u0131ld\u0131\u011f\u0131nda, durum/yard\u0131mc\u0131 \u00f6rneklerinin biriktirilip biriktirilmeyece\u011fine bu de\u011fer karar verir.</li> <li><code>atol</code>, <code>rtol</code> \u2013 Adaptif-stepper toleranslar\u0131 (varsay\u0131lan <code>1e-8</code>/<code>1e-5</code>). Bunlar yaln\u0131zca yap\u0131land\u0131r\u0131lm\u0131\u015f stepper, <code>Config</code> veri s\u0131n\u0131f\u0131 arac\u0131l\u0131\u011f\u0131yla adaptif kontrol sunuyorsa ge\u00e7erlidir.</li> <li><code>max_steps</code> \u2013 Runner durmadan \u00f6nceki maksimum ad\u0131m say\u0131s\u0131 (varsay\u0131lan <code>1_000_000</code>). Ayr\u0131k modeller i\u00e7in, <code>N</code> veya <code>T</code> sa\u011flamad\u0131\u011f\u0131n\u0131zda varsay\u0131lan iterasyon say\u0131s\u0131 (<code>N</code>) olarak da hizmet eder.</li> <li><code>stop</code> \u2013 Genellikle <code>post</code> a\u015famas\u0131nda, her ad\u0131mda de\u011ferlendirilen erken \u00e7\u0131k\u0131\u015f ko\u015fulu. Basit bir string <code>stop = \"x &gt; threshold\"</code> veya bir tablo yazabilirsiniz:   <pre><code>[sim.stop]\ncond = \"max_energy &gt; threshold\"\nphase = \"post\"  # \u015fimdilik sadece \"post\" destekleniyor\n</code></pre>   Ko\u015ful do\u011fru oldu\u011funda runner <code>EARLY_EXIT</code> f\u0131rlat\u0131r ve <code>Results.status</code> bu durumu yans\u0131t\u0131r.</li> <li>Ekstra anahtarlar \u2013 Di\u011fer t\u00fcm giri\u015fler (yukar\u0131da listelenen anahtarlar d\u0131\u015f\u0131ndaki her \u015fey) <code>SimDefaults._stepper_defaults</code> i\u00e7ine iletilir ve otomatik olarak aktif stepper'\u0131n <code>Config</code> alanlar\u0131na e\u015flenir. Bu, kodda stepper ad\u0131n\u0131 tekrarlamadan <code>tol</code>, <code>max_iter</code> veya herhangi bir enum tipli se\u00e7enek gibi <code>stepper-specific</code> (stepper'a \u00f6zg\u00fc) varsay\u0131lanlar\u0131 ge\u00e7irmenize olanak tan\u0131r.</li> </ul>"},{"location":"tr/guides/modeling/sim/#calstrmalar-runs-ile-etkilesim","title":"\u00c7al\u0131\u015ft\u0131rmalar (Runs) ile Etkile\u015fim","text":"<ol> <li>\u00c7al\u0131\u015fma zaman\u0131 ge\u00e7ersiz k\u0131lmalar\u0131 (overrides) kazan\u0131r \u2013 Her halka a\u00e7\u0131k <code>Sim.run</code> arg\u00fcman\u0131 (<code>t0</code>, <code>T</code>/<code>N</code>, <code>dt</code>, <code>max_steps</code>, <code>record</code> vb.) <code>[sim]</code> i\u00e7indeki de\u011ferleri ge\u00e7ersiz k\u0131lar. Buna <code>**stepper_kwargs</code> arac\u0131l\u0131\u011f\u0131yla ge\u00e7irilen ve <code>[sim]</code> ekstralar\u0131na g\u00f6re \u00f6nceli\u011fi olan stepper kwarg'lar\u0131 da dahildir.</li> <li>\u00d6ncelik zinciri \u2013 Stepper yap\u0131land\u0131rma varsay\u0131lanlar\u0131 \u015furadan gelir: Stepper s\u0131n\u0131f\u0131 varsay\u0131lan\u0131 &lt; <code>[sim]</code> ekstra alanlar\u0131 &lt; <code>Sim.run(... stepper_kwargs...)</code>. Bu birle\u015ftirme <code>ConfigMixin.default_config</code> arac\u0131l\u0131\u011f\u0131yla otomatik olarak ger\u00e7ekle\u015fir, bu nedenle anahtarlar\u0131 yaln\u0131zca bir kez bildirmeniz gerekir.</li> <li>Ayr\u0131k vs. S\u00fcrekli \u2013 <code>Sim.run</code>, model t\u00fcr\u00fcne (<code>map</code> vs <code>ode</code>) ba\u011fl\u0131 olarak <code>[sim].t_end</code>/<code>dt</code> de\u011ferlerini farkl\u0131 yorumlar. Map'ler i\u00e7in, <code>N</code>/<code>T</code> atland\u0131\u011f\u0131nda <code>[sim].max_steps</code> varsay\u0131lan iterasyon say\u0131s\u0131 olur; ODE'ler i\u00e7in <code>t_end</code> varsay\u0131lan entegrasyon ufkudur.</li> <li>Durdurma ko\u015fulu de\u011ferlendirmesi \u2013 <code>[sim].stop</code> mevcut oldu\u011funda, derleyici bunu uygun runner'a (<code>phase</code>'e g\u00f6re pre/post) ba\u011flar. Ko\u015ful, ola\u011fan ifade ba\u011flam\u0131n\u0131 (states, params, aux, functions, yerle\u015fik makrolar) payla\u015f\u0131r ve taahh\u00fct edilen her ad\u0131mda kontrol edilir.</li> <li>Kay\u0131t varsay\u0131lanlar\u0131 \u2013 <code>[sim].record</code> yaln\u0131zca varsay\u0131lan\u0131 ayarlar; <code>Sim.run(record=False)</code> o belirli \u00e7a\u011fr\u0131 i\u00e7in loglamay\u0131 yine de devre d\u0131\u015f\u0131 b\u0131rak\u0131r. Se\u00e7ici kay\u0131t (<code>record_vars</code>) kullan\u0131rsan\u0131z, se\u00e7im \u00e7al\u0131\u015fma zaman\u0131na \u00f6zg\u00fc oldu\u011fu i\u00e7in <code>[sim]</code> tablosu de\u011fi\u015fmeden kal\u0131r.</li> </ol>"},{"location":"tr/guides/modeling/sim/#ornekler","title":"\u00d6rnekler","text":"<pre><code>[sim]\nt0 = 0.0\nt_end = 5.0\ndt = 0.01\nstepper = \"rk4\"\nrecord = true\natol = 1e-9\nrtol = 1e-6\nmax_steps = 500_000\ntol = 1e-8        # stepper yap\u0131land\u0131rmas\u0131na iletilen ekstra alan\nstop = \"energy &gt; 100\"  # erken \u00e7\u0131k\u0131\u015f\u0131 tetikler\n</code></pre> <p>E\u011fer stepper <code>tol</code> ad\u0131nda bir alana sahip bir <code>Config</code> sunuyorsa, bu de\u011fer varsay\u0131lan\u0131n\u0131 ge\u00e7ersiz k\u0131lar ancak yine de daha sonra <code>Sim.run(t, dt, tol=acik_deger)</code> yoluyla ge\u00e7ersiz k\u0131l\u0131nabilir.</p>"},{"location":"tr/guides/modeling/sim/#en-iyi-uygulamalar","title":"En \u0130yi Uygulamalar","text":"<ol> <li>Yaln\u0131zca ihtiyac\u0131n\u0131z olan stepper'a \u00f6zg\u00fc anahtarlar\u0131 ekleyin, b\u00f6ylece ekstra listesi odakl\u0131 kal\u0131r.</li> <li>Erken \u00e7\u0131k\u0131\u015f ko\u015fulunuzu belgeleyin; <code>[sim].stop</code> kulland\u0131\u011f\u0131n\u0131zda okuyucular sim\u00fclasyonun ne zaman ve neden iptal edildi\u011fini bilmelidir.</li> <li>Varsay\u0131lanlar\u0131 fiziksel zaman birimleriyle (saniye, iterasyon) tutarl\u0131 tutun, b\u00f6ylece modelinizi kullanan script'lerin s\u00fcrekli olarak <code>t0</code>, <code>dt</code> veya <code>t_end</code> de\u011ferlerini ge\u00e7ersiz k\u0131lmas\u0131 gerekmez.</li> <li><code>[sim]</code>i \u00e7o\u011funlukla g\u00fcvenli varsay\u0131lanlar i\u00e7in kullan\u0131n; deneyleri yeniden \u00fcretirken veya ka\u015fifleri y\u00f6nlendirirken <code>Sim.run</code> arg\u00fcmanlar\u0131na g\u00fcvenin.</li> </ol>"},{"location":"tr/guides/modeling/ternary-if/","title":"\u00dc\u00e7l\u00fc If","text":""},{"location":"tr/guides/modeling/ternary-if/#ternary-uclu-if-ifadeleri","title":"Ternary (\u00dc\u00e7l\u00fc) <code>if</code> ifadeleri","text":"<p>DSL, k\u0131sa, iki y\u00f6nl\u00fc dallanmalar\u0131 sat\u0131r i\u00e7i (inline) tutman\u0131za olanak tan\u0131r \u00e7\u00fcnk\u00fc her sa\u011f taraf ifadesi bir Python ifadesi olarak ayr\u0131\u015ft\u0131r\u0131l\u0131r. Bu, tan\u0131d\u0131k Python ternary (\u00fc\u00e7l\u00fc) formunu yazabilece\u011finiz anlam\u0131na gelir:</p> <pre><code>&lt;do\u011fruysa de\u011fer&gt; if &lt;ko\u015ful&gt; else &lt;yanl\u0131\u015fsa de\u011fer&gt;\n</code></pre> <p>Bu form, ko\u015ful sadece yan etkilere veya ek ifadelere ihtiya\u00e7 duymadan iki hesaplama aras\u0131nda se\u00e7im yapt\u0131\u011f\u0131nda idealdir. Nihai de\u011feri \u00fcretmeden \u00f6nce birden fazla atamaya, loglamaya veya di\u011fer zorunlu ad\u0131mlara ihtiyac\u0131n\u0131z oldu\u011funda tam bir <code>if</code>/<code>else</code> blo\u011fu kullan\u0131n.</p>"},{"location":"tr/guides/modeling/ternary-if/#depodan-ornekler","title":"Depodan \u00f6rnekler","text":"<p>Modlar rehberinun kendisi, eklenen bir yard\u0131mc\u0131 fonksiyon i\u00e7inde ternary bir ifade g\u00f6sterir ve bunu <code>N == 0</code> oldu\u011funda bir form\u00fcl\u00fc, <code>N</code> pozitif oldu\u011funda ba\u015fka bir form\u00fcl\u00fc kullanmak i\u00e7in kullan\u0131r (bkz. <code>docs/guides/modeling/mods.md:483-491</code>):</p> <pre><code>h = {args = [\"phi\",\"N\"], expr=\"\"\"\nphi if N==0 else phi-sum(sign(phi+(2*j-1))+sign(phi-(2*j-1)) for j in range(1,N+1))\n\"\"\"}\n</code></pre> <p>Birim testleri de, RHS'nin (sa\u011f taraf\u0131n) zamana ba\u011fl\u0131 olmas\u0131n\u0131 sa\u011flamak i\u00e7in sat\u0131r i\u00e7i bir modelde ternary bir dala g\u00fcvenir; <code>tests/unit/test_sum_generator_lowering.py:27-110</code> modeli \u015fununla tan\u0131mlar:</p> <pre><code>[equations.rhs]\nx = \"1.0 if t &lt; 0 else sum(i for i in range(N))\"\n</code></pre> <p>ve dal\u0131n her iki taraf\u0131n\u0131 da Python ve JIT backend'lerine kar\u015f\u0131 do\u011frular.</p> <p>Bu \u00f6rnekler, ternary ifadelerin derleyiciye se\u00e7mesi i\u00e7in iki ayr\u0131 yol sunarken ifadeleri nas\u0131l \u00f6zl\u00fc tuttu\u011funu g\u00f6sterir.</p>"},{"location":"tr/guides/modeling/ternary-if/#ic-ice-if-ifadeleri","title":"\u0130\u00e7 i\u00e7e <code>if</code> ifadeleri","text":"<p>Tek bir ifadede birden fazla ko\u015fulu i\u015flemek i\u00e7in ternary <code>if</code> ifadelerini i\u00e7 i\u00e7e yerle\u015ftirebilirsiniz. Bu, mant\u0131k tamamen fonksiyonel kald\u0131\u011f\u0131 s\u00fcrece tam <code>if</code>/<code>else</code> bloklar\u0131na ba\u015fvurmadan daha karma\u015f\u0131k dallanmalara izin verir.</p>"},{"location":"tr/guides/modeling/ternary-if/#sozdizimi","title":"S\u00f6zdizimi","text":"<pre><code>&lt;de\u011fer1&gt; if &lt;ko\u015ful1&gt; else &lt;de\u011fer2&gt; if &lt;ko\u015ful2&gt; else &lt;de\u011fer3&gt; if ... else &lt;varsay\u0131lan_de\u011fer&gt;\n</code></pre> <p>\u0130\u00e7 i\u00e7e yerle\u015ftirmenin okunabilirli\u011fi azaltabilece\u011fini unutmay\u0131n, bu y\u00fczden idareli kullan\u0131n ve gerekirse netlik i\u00e7in parantez kullanmay\u0131 d\u00fc\u015f\u00fcn\u00fcn.</p>"},{"location":"tr/guides/modeling/ternary-if/#ornek","title":"\u00d6rnek","text":"<p>Birden fazla e\u015fi\u011fe dayal\u0131 bir de\u011fer se\u00e7meniz gerekti\u011fini varsayal\u0131m. Bir model denkleminde \u015f\u00f6yle yazabilirsiniz:</p> <pre><code>result = \"0 if x &lt; 0 else 1 if x &lt; 10 else 2\"\n</code></pre> <p>Bu \u015funa de\u011ferlendirilir: - <code>x &lt; 0</code> ise <code>0</code> - <code>0 &lt;= x &lt; 10</code> ise <code>1</code> - Aksi takdirde <code>2</code></p>"},{"location":"tr/guides/plotting/","title":"\u00c7izim Rehberi","text":""},{"location":"tr/guides/plotting/#cizim-rehberi","title":"\u00c7izim rehberi","text":"<ul> <li>\u00c7izim Temelleri: <code>plot.series</code>, <code>plot.phase</code>, <code>plot.utils</code> ve <code>plot.manifold</code> yard\u0131mc\u0131lar\u0131na ve bunlar\u0131n ortak se\u00e7eneklerine h\u0131zl\u0131 bir bak\u0131\u015f.</li> <li>Grafikleri D\u0131\u015fa Aktarma: <code>dynlib.plot.export</code> kullanarak fig\u00fcrlerin nas\u0131l olu\u015fturulaca\u011f\u0131 veya saklanaca\u011f\u0131.</li> <li>\u00d6r\u00fcmcek A\u011f\u0131 Grafikleri: 1B ayr\u0131k haritalar\u0131n iterasyon y\u00f6r\u00fcngelerini ve dinamiklerini g\u00f6rselle\u015ftirme.</li> <li>Havza Grafikleri: Analiz sonu\u00e7lar\u0131ndan \u00e7ekim havzas\u0131 (basin-of-attraction) s\u0131n\u0131fland\u0131rmalar\u0131n\u0131 olu\u015fturma.</li> <li>Vekt\u00f6r Alanlar\u0131: ODE'ler i\u00e7in y\u00f6n alanlar\u0131n\u0131 ve ak\u0131\u015f g\u00f6rselle\u015ftirmelerini \u00e7izme.</li> <li>Temalar &amp; Fasetler: <code>plot.theme</code> ile global stilin nas\u0131l kontrol edilece\u011fi, paletlerin/\u00f6n ayarlar\u0131n nas\u0131l belirlenece\u011fi ve <code>plot.fig</code>/<code>plot.facet</code> ile yeniden kullan\u0131lan \u00e7ok panelli d\u00fczenlerin nas\u0131l olu\u015fturulaca\u011f\u0131.</li> </ul>"},{"location":"tr/guides/plotting/basics/","title":"\u00c7izim Temelleri","text":"<p>Dynlib'in \u00e7izim mod\u00fcl\u00fc (<code>dynlib.plot</code>), dynlib'in analiz i\u015f ak\u0131\u015flar\u0131yla uyumlu olmas\u0131 i\u00e7in Matplotlib'i sarmalayan bir dizi \u00fcst d\u00fczey yard\u0131mc\u0131 ara\u00e7 sa\u011flar. Bu ara\u00e7lar, tutarl\u0131 stil ve d\u00fczen sa\u011flarken zaman serileri, faz portreleri ve manifoldlar gibi dinamik sistemler i\u00e7in yayg\u0131n \u00e7izim g\u00f6revlerini yerine getirir. T\u00fcm yard\u0131mc\u0131lar NumPy dizilerini, listeleri, pandas Series'leri veya <code>Results</code> nesnelerinden al\u0131nan dilimleri kabul eder ve bunlar\u0131 gerekti\u011fi gibi otomatik olarak d\u00f6n\u00fc\u015ft\u00fcr\u00fcr.</p> <p>Bu rehber, \u015fekiller olu\u015fturmaktan \u00e7izimleri \u00f6zelle\u015ftirmeye kadar bu \u00e7izim yard\u0131mc\u0131lar\u0131n\u0131 kullanman\u0131n temellerini kapsar.</p>"},{"location":"tr/guides/plotting/basics/#baslarken","title":"Ba\u015flarken","text":"<p>Dynlib'in \u00e7izim ara\u00e7lar\u0131n\u0131 kullanmak i\u00e7in gerekli mod\u00fclleri i\u00e7e aktar\u0131n:</p> <pre><code>from dynlib.plot import fig, series, phase, utils\n</code></pre> <p>\u0130\u015fte bir alt \u00e7izim (subplot) \u0131zgaras\u0131 olu\u015fturmay\u0131 ve farkl\u0131 t\u00fcrde verileri \u00e7izmeyi g\u00f6steren h\u0131zl\u0131 bir \u00f6rnek:</p> <pre><code># 2x2'lik bir alt \u00e7izim \u0131zgaras\u0131 olu\u015ftur\naxes = fig.grid(rows=2, cols=2, size=(10, 8))\n\n# Bir zaman serisi \u00e7iz\nseries.plot(x=t, y=x_traj, label=\"x(t)\", ax=axes[0, 0])\n\n# Ayr\u0131k verileri stem (\u00e7ubuk) olarak \u00e7iz\nseries.stem(x=k, y=impulse_response, ax=axes[0, 1])\n\n# Denge noktalar\u0131yla birlikte bir faz portresi \u00e7iz\nphase.xy(x=x_traj, y=y_traj, equil=[(x_eq, y_eq)], ax=axes[1, 0])\n\n# Renk \u00e7ubu\u011fu (colorbar) ile 2D bir g\u00f6r\u00fcnt\u00fc sergile\nutils.image(Z, extent=[0, 10, 0, 1], colorbar=True, ax=axes[1, 1])\n</code></pre> <p>Dynlib'in <code>fig</code> yard\u0131mc\u0131lar\u0131 \u015fekil olu\u015fturma ve yerle\u015fim d\u00fczenini otomatik olarak y\u00f6netir, b\u00f6ylece Matplotlib'in basmakal\u0131p kodlar\u0131 yerine verilere odaklanabilirsiniz.</p>"},{"location":"tr/guides/plotting/basics/#sekiller-ve-alt-cizimler-olusturma","title":"\u015eekiller ve Alt \u00c7izimler Olu\u015fturma","text":"<p>Dynlib, tutarl\u0131 stile sahip \u015fekiller ve alt \u00e7izimler olu\u015fturmak i\u00e7in kullan\u0131\u015fl\u0131 fonksiyonlar sa\u011flar:</p> <ul> <li><code>fig.single()</code>: Tek bir alt \u00e7izim olu\u015fturur.</li> <li><code>fig.grid(rows=2, cols=2)</code>: Bir alt \u00e7izim \u0131zgaras\u0131 olu\u015fturur.</li> <li><code>fig.wrap(n=5, cols=3)</code>: Belirli say\u0131daki alt \u00e7izimi s\u00fctunlara saran ve kullan\u0131lmayan eksenleri gizleyen bir \u0131zgara olu\u015fturur.</li> <li><code>fig.single3D()</code>: Tek bir 3D alt \u00e7izim olu\u015fturur.</li> </ul> <p>Bu fonksiyonlar, \u00f6zelle\u015ftirme i\u00e7in <code>title</code>, <code>size</code>, <code>scale</code>, <code>sharex</code> ve <code>sharey</code> gibi parametreleri kabul eder. \u00c7izim yard\u0131mc\u0131lar\u0131na iletebilece\u011finiz Matplotlib eksen nesnelerini d\u00f6nd\u00fcr\u00fcrler.</p> <p>\u00c7izimleri veri kategorilerine g\u00f6re fasetlemek (b\u00f6l\u00fcmlere ay\u0131rmak) i\u00e7in, eksenleri ve yineleme anahtarlar\u0131n\u0131 veren <code>plot.facet.wrap(keys, cols=3)</code> fonksiyonunu kullan\u0131n.</p> <p>\u00d6rnek:</p> <pre><code># Tek bir alt \u00e7izim olu\u015ftur\nax = fig.single(size=(8, 6))\nseries.plot(x=t, y=data, ax=ax)\n\n# Birden fazla \u00e7izim i\u00e7in bir \u0131zgara olu\u015ftur\naxes = fig.grid(rows=1, cols=3)\nfor i, dataset in enumerate(datasets):\n    series.plot(x=t, y=dataset, ax=axes[i])\n</code></pre>"},{"location":"tr/guides/plotting/basics/#stillendirme-ve-suslemeler","title":"Stillendirme ve S\u00fcslemeler","text":"<p>Dynlib'in \u00e7izim yard\u0131mc\u0131lar\u0131, \u00f6n ayarlar ve s\u00fcslemeler arac\u0131l\u0131\u011f\u0131yla tutarl\u0131 stillendirmeyi destekler.</p>"},{"location":"tr/guides/plotting/basics/#stil-on-ayarlar-style-presets","title":"Stil \u00d6n Ayarlar\u0131 (Style Presets)","text":"<p>Stil \u00f6n ayarlar\u0131, verilerin nas\u0131l g\u00f6rselle\u015ftirilece\u011fini tan\u0131mlar (\u00f6rne\u011fin; \u00e7izgiler, i\u015faret\u00e7iler veya her ikisi). Mevcut \u00f6n ayarlar aras\u0131nda <code>\"continuous\"</code>, <code>\"discrete\"</code>, <code>\"line\"</code>, <code>\"scatter\"</code> ve di\u011ferleri bulunur. Bir \u00f6n ayar ad\u0131 veya \u00f6zel bir stil s\u00f6zl\u00fc\u011f\u00fc iletebilirsiniz.</p> <p>\u00d6rnek:</p> <pre><code># Bir \u00f6n ayar kullan\nseries.plot(x=t, y=data, style=\"continuous\", ax=ax)\n\n# Ge\u00e7ersiz k\u0131lmalarla \u00f6zelle\u015ftir\nseries.plot(x=t, y=data, style={\"ls\": \"--\", \"marker\": \"x\"}, color=\"red\", ax=ax)\n</code></pre>"},{"location":"tr/guides/plotting/basics/#suslemeler-decorations","title":"S\u00fcslemeler (Decorations)","text":"<p>\u00d6zellikleri vurgulamak i\u00e7in dikey veya yatay \u00e7izgiler ve bantlar ekleyin:</p> <ul> <li><code>vlines</code>: Dikey \u00e7izgiler (\u00f6rne\u011fin, <code>vlines=[5, (10, \"e\u015fik\")]</code>)</li> <li><code>hlines</code>: Yatay \u00e7izgiler</li> <li><code>vbands</code>: Dikey bantlar</li> <li><code>hbands</code>: Yatay bantlar</li> </ul> <p>Etiketler otomatik olarak konumland\u0131r\u0131l\u0131r ve eksen s\u0131n\u0131rlar\u0131na uyar.</p> <p>\u00d6rnek:</p> <pre><code>series.plot(x=t, y=data, vlines=[(5, \"ba\u015flang\u0131\u00e7\"), 10], hbands=[(0, 1, \"b\u00f6lge\")], ax=ax)\n</code></pre>"},{"location":"tr/guides/plotting/basics/#eksen-kontrolu","title":"Eksen Kontrol\u00fc","text":"<p><code>xlim</code>, <code>ylim</code> ve <code>zlim</code> (3D i\u00e7in) ile eksen s\u0131n\u0131rlar\u0131n\u0131 kontrol edin. Yard\u0131mc\u0131lar tutarl\u0131 etiketleri, yaz\u0131 tiplerini ve d\u00f6nd\u00fcrmeleri otomatik olarak uygular.</p>"},{"location":"tr/guides/plotting/basics/#zaman-serilerini-cizme","title":"Zaman Serilerini \u00c7izme","text":"<p>Zaman tabanl\u0131 \u00e7izimler i\u00e7in <code>series</code> yard\u0131mc\u0131lar\u0131n\u0131 kullan\u0131n:</p> <ul> <li><code>series.plot(x, y, ...)</code>: S\u00fcrekli veya ayr\u0131k veriler i\u00e7in standart \u00e7izgi grafi\u011fi.</li> <li><code>series.stem(x, y, ...)</code>: Ayr\u0131k \u00f6rnekler i\u00e7in \"stem\" (\u00e7ubuk) grafi\u011fi.</li> <li><code>series.step(x, y, ...)</code>: Par\u00e7al\u0131 sabit veriler i\u00e7in basamak grafi\u011fi.</li> <li><code>series.multi(data, ...)</code>: Ayn\u0131 anda birden fazla seriyi \u00e7izer.</li> </ul> <p>Bu yard\u0131mc\u0131lar t\u00fcm stillendirme ve s\u00fcsleme se\u00e7eneklerini destekler.</p> <p>\u00d6rnekler:</p> <pre><code># Basit zaman serisi\nseries.plot(x=t, y=x_traj, label=\"Konum\", ax=ax)\n\n# \u00c7oklu seriler\ndata = {\"x\": x_traj, \"y\": y_traj}\nseries.multi(data, styles={\"x\": \"continuous\", \"y\": \"discrete\"}, ax=ax)\n\n# \u0130mpulslar i\u00e7in stem grafi\u011fi\nseries.stem(x=k, y=impulse, ax=ax)\n</code></pre>"},{"location":"tr/guides/plotting/basics/#faz-portrelerini-cizme","title":"Faz Portrelerini \u00c7izme","text":"<p>Faz uzay\u0131 \u00e7izimleri, durum de\u011fi\u015fkenleri aras\u0131ndaki ili\u015fkileri g\u00f6rselle\u015ftirir:</p> <ul> <li><code>phase.xy(x, y, ...)</code>: 2D faz portresi.</li> <li><code>phase.xyz(x, y, z, ...)</code>: 3D faz portresi.</li> <li><code>phase.multi(x_list, y_list, ...)</code>: Tek bir \u00e7izimde birden fazla y\u00f6r\u00fcnge.</li> <li><code>phase.return_map(x, step, ...)</code>: Haritalar (maps) i\u00e7in geri d\u00f6n\u00fc\u015f haritas\u0131.</li> </ul> <p>Denge noktalar\u0131n\u0131 <code>equil</code> ile i\u015faretleyin ve etiketleri \u00f6zelle\u015ftirin.</p> <p>\u00d6rnekler:</p> <pre><code># 2D faz portresi\nphase.xy(x=x_traj, y=y_traj, equil=[(0, 0)], ax=ax)\n\n# Geri d\u00f6n\u00fc\u015f haritas\u0131 (Return map)\nphase.return_map(x=trajectory, step=1, equil=[(fixed_point,)], ax=ax)\n</code></pre>"},{"location":"tr/guides/plotting/basics/#yardmc-cizimler","title":"Yard\u0131mc\u0131 \u00c7izimler","text":"<p>Yayg\u0131n g\u00f6rselle\u015ftirmeler i\u00e7in ek yard\u0131mc\u0131lar:</p> <ul> <li><code>utils.hist(data, ...)</code>: 1D verilerin histogram\u0131.</li> <li><code>utils.image(data, ...)</code>: 2D g\u00f6r\u00fcnt\u00fc grafi\u011fi.</li> </ul> <p>Her ikisi de stillendirmeyi destekler ve renk \u00e7ubuklar\u0131 (colorbars) i\u00e7erebilir.</p> <p>\u00d6rnek:</p> <pre><code># Histogram\nutils.hist(data, bins=50, density=True, ax=ax)\n\n# Renk \u00e7ubu\u011fu ile g\u00f6r\u00fcnt\u00fc\nutils.image(matrix, extent=[0, 1, 0, 1], colorbar=True, ax=ax)\n</code></pre>"},{"location":"tr/guides/plotting/basics/#sekilleri-dsa-aktarma-ve-goruntuleme","title":"\u015eekilleri d\u0131\u015fa aktarma ve g\u00f6r\u00fcnt\u00fcleme","text":"<p>Bir \u015fekli sunman\u0131z veya kaydetmeniz gerekti\u011finde <code>dynlib.plot</code> i\u00e7inden <code>export</code> mod\u00fcl\u00fcn\u00fc i\u00e7e aktar\u0131n. Bu mod\u00fcl, Matplotlib'in <code>savefig</code> yard\u0131mc\u0131lar\u0131n\u0131 dynlib'e duyarl\u0131 varsay\u0131lanlarla yeniden d\u0131\u015fa aktar\u0131r, b\u00f6ylece ekstra kod yazmadan t\u00fcm eksen \u0131zgaralar\u0131n\u0131 veya \u015fekil tan\u0131t\u0131c\u0131lar\u0131n\u0131 (handles) iletebilirsiniz. \u00c7izim senaryonuz tamamland\u0131\u011f\u0131nda <code>export.show()</code> fonksiyonunu \u00e7a\u011f\u0131r\u0131n (not defterleri veya betikler i\u00e7in kullan\u0131\u015fl\u0131d\u0131r) veya birden fazla formatta yazmak i\u00e7in <code>export.savefig(fig_or_ax, \"plots/my-fig\", fmts=(\"png\", \"pdf\"))</code> fonksiyonunu kullan\u0131n. Format se\u00e7imi, meta veriler ve \u0131zgara kaplar\u0131 (grid containers) ile \u00e7al\u0131\u015fma hakk\u0131nda ayr\u0131nt\u0131lar i\u00e7in \u00f6zel \u00c7izimleri d\u0131\u015fa aktarma rehberi'na bak\u0131n.</p>"},{"location":"tr/guides/plotting/basics/#manifoldlar-cizme","title":"Manifoldlar\u0131 \u00c7izme","text":"<p>1D manifoldlar i\u00e7in <code>plot.manifold(segments, ...)</code> kullan\u0131n veya dallar\u0131 olan <code>result</code> nesnelerini iletin. Farkl\u0131 gruplar i\u00e7in bile\u015fenleri ve stilleri belirtin.</p> <p>\u00d6rnek:</p> <pre><code>plot.manifold(result.branches, components=(0, 1), ax=ax)\n</code></pre>"},{"location":"tr/guides/plotting/basics/#ipuclar-ve-en-iyi-uygulamalar","title":"\u0130pu\u00e7lar\u0131 ve En \u0130yi Uygulamalar","text":"<ul> <li>\u00c7izimlerin nerede g\u00f6r\u00fcnece\u011fini kontrol etmek i\u00e7in \u00e7ok panelli \u015fekiller olu\u015ftururken her zaman <code>ax=</code> kullan\u0131n.</li> <li>H\u0131zl\u0131 stillendirme i\u00e7in stil \u00f6n ayarlar\u0131ndan yararlan\u0131n, ard\u0131ndan gerekti\u011finde bunlar\u0131 ge\u00e7ersiz k\u0131l\u0131n.</li> <li>\u00c7izgiler ve bantlar gibi s\u00fcslemeler, tutarl\u0131 ek a\u00e7\u0131klamalar (annotations) i\u00e7in \u00e7o\u011fu yard\u0131mc\u0131da \u00e7al\u0131\u015f\u0131r.</li> <li>Yard\u0131mc\u0131lar veri d\u00f6n\u00fc\u015f\u00fcm\u00fcn\u00fc otomatik olarak y\u00f6netir, bu nedenle NumPy dizilerini, listeleri ve dynlib sonu\u00e7lar\u0131n\u0131 serbest\u00e7e kar\u0131\u015ft\u0131rabilirsiniz.</li> <li>Renk \u00e7ubu\u011fu olan g\u00f6r\u00fcnt\u00fclerde, daha fazla \u00f6zelle\u015ftirme i\u00e7in renk \u00e7ubu\u011funa <code>ax._last_colorbar</code> \u00fczerinden eri\u015fin.</li> </ul> <p>Bu bilgiler dynlib'in \u00e7izim ara\u00e7lar\u0131yla ba\u015flaman\u0131z\u0131 sa\u011flayacakt\u0131r. Daha geli\u015fmi\u015f \u00f6zellikler i\u00e7in API referans\u0131na bak\u0131n.</p>"},{"location":"tr/guides/plotting/basin-plot/","title":"Havza (Basin) \u00c7izimleri","text":"<p>Havza \u00e7izimleri, parametre uzay\u0131n\u0131n 2D \u0131zgaras\u0131n\u0131 renklendirerek her bir ba\u015flang\u0131\u00e7 ko\u015fulunun hangi \u00e7ekere (attractor) yerle\u015fti\u011fini ortaya koyar. <code>plot.basin_plot()</code>, \u00e7ekim havzas\u0131 analiz ara\u00e7lar\u0131 taraf\u0131ndan \u00fcretilen kategorik etiketleri bir <code>pcolormesh</code>'e d\u00f6n\u00fc\u015ft\u00fcr\u00fcr, b\u00f6ylece havzalar\u0131n yap\u0131s\u0131n\u0131, \u00f6zel sonu\u00e7lar\u0131 ve renk lejant\u0131n\u0131n her bir \u00e7ekerle nas\u0131l ili\u015fkili oldu\u011funu an\u0131nda g\u00f6rebilirsiniz.</p>"},{"location":"tr/guides/plotting/basin-plot/#cizim-ne-gosteriyor","title":"\u00c7izim ne g\u00f6steriyor","text":"<p>Her \u0131zgara h\u00fccresi, analiz s\u0131ras\u0131nda tan\u0131mlanan bir ba\u015flang\u0131\u00e7 ko\u015fuluna kar\u015f\u0131l\u0131k gelir. O h\u00fccre i\u00e7in saklanan de\u011fer bir tam say\u0131 etiketidir:</p> <ul> <li>\u00c7eker (Attractor) Kimlikleri (0, 1, \u2026), bilinen bir \u00e7ekere yak\u0131nsayan y\u00f6r\u00fcngeleri i\u015faretler.</li> <li>\u00d6zel de\u011ferler (<code>BLOWUP</code>, <code>OUTSIDE</code>, <code>UNRESOLVED</code>), \u0131raksayan y\u00f6r\u00fcngeleri, ilgi alan\u0131ndan ka\u00e7\u0131\u015flar\u0131 veya hesaplama b\u00fct\u00e7esi i\u00e7inde bir karara varamayan ba\u015flang\u0131\u00e7 ko\u015fullar\u0131n\u0131 i\u015faretler.</li> </ul> <p><code>basin_plot()</code>, bu tam say\u0131lar\u0131 renklere e\u015fler ve \u00f6nce \u00f6zel sonu\u00e7lar\u0131, ard\u0131ndan indeks s\u0131ras\u0131na g\u00f6re \u00e7ekerleri etiketleyen bir renk \u00e7ubu\u011fu (colorbar) olu\u015fturur.</p>"},{"location":"tr/guides/plotting/basin-plot/#verilerinizi-hazrlama","title":"Verilerinizi haz\u0131rlama","text":"<p><code>analysis.basin_auto()</code> (veya <code>analysis.basin_known()</code>) taraf\u0131ndan d\u00f6nd\u00fcr\u00fclen <code>BasinResult</code> nesnesini do\u011frudan <code>basin_plot()</code> fonksiyonuna iletin. Yard\u0131mc\u0131 ara\u00e7, kategorik \u0131zgara i\u00e7in <code>res.labels</code> verisini okur ve \u0131zgara boyutlar\u0131n\u0131 (<code>ic_grid</code>), s\u0131n\u0131rlar\u0131 (<code>ic_bounds</code>), g\u00f6zlemlenen de\u011fi\u015fkenleri (<code>observe_vars</code>) ve \u00e7eker meta verilerini (<code>attractor_labels</code>/<code>attractor_names</code>) \u00e7\u0131karmak i\u00e7in <code>res.meta</code> verisini kullan\u0131r.</p> <p>Etiketleri kendiniz hesaplad\u0131ysan\u0131z, bunlar\u0131 <code>labels=</code> ile iletin; 1D diziler, yard\u0131mc\u0131n\u0131n 2D'ye yeniden \u015fekillendirebilmesi i\u00e7in <code>grid=(nx, ny)</code> \u015feklini gerektirirken, \u00f6nceden \u015fekillendirilmi\u015f 2D diziler do\u011frudan sa\u011flanabilir. Alternatif olarak, etiket dizisiyle e\u015fle\u015fen a\u00e7\u0131k <code>x</code> ve <code>y</code> koordinatlar\u0131n\u0131 sa\u011flay\u0131n.</p> <pre><code>from dynlib import setup\nfrom dynlib.analysis import basin_auto\nfrom dynlib.plot import basin_plot\n\nsim = setup(\"models/henon.map\", stepper=\"map\")\nres = basin_auto(sim, ic_grid=[256, 256], ic_bounds=[(-2, 2), (-2, 2)])\nbasin_plot(res)\n</code></pre>"},{"location":"tr/guides/plotting/basin-plot/#renk-haritasn-colormap-kontrol-etme","title":"Renk haritas\u0131n\u0131 (colormap) kontrol etme","text":"<p><code>basin_plot()</code>, \u00f6zel sonu\u00e7larla (varsay\u0131lan s\u0131ra <code>[BLOWUP, OUTSIDE, UNRESOLVED]</code>) ba\u015flayan ve ard\u0131ndan \u00e7eker kimlikleri gelen tek bir renk haritas\u0131 olu\u015fturur. Varsay\u0131lanlar\u0131 \u015funlarla ge\u00e7ersiz k\u0131labilirsiniz:</p> <ul> <li><code>special_order</code>: \u00d6zel kimliklerin s\u0131ras\u0131n\u0131 de\u011fi\u015ftirin veya \u00e7\u0131kar\u0131n.</li> <li><code>special_colors</code>: Her \u00f6zel etiket i\u00e7in bir renk sa\u011flay\u0131n; daha fazla giri\u015f isterseniz varsay\u0131lanlar mevcut Matplotlib paletinden t\u00fcretilen gri tonlamal\u0131 \u00e7iftlere geri d\u00f6ner.</li> <li><code>special_labels</code>: Renk \u00e7ubu\u011funda g\u00f6r\u00fcnen \u00f6zel giri\u015fleri yeniden adland\u0131r\u0131n (\u00f6rne\u011fin, <code>{\"blowup\": \"Iraksad\u0131\"}</code>).</li> <li><code>attractor_cmap</code>: \u00c7ekerler i\u00e7in <code>\"hsv\"</code> yerine herhangi bir Matplotlib renk haritas\u0131na (veya bir <code>Colormap</code> \u00f6rne\u011fine) ge\u00e7i\u015f yap\u0131n.</li> <li><code>attractor_colors</code>: Bir renk haritas\u0131n\u0131 \u00f6rneklemek yerine a\u00e7\u0131k renkler verin.</li> <li><code>attractor_labels</code>: Renk \u00e7ubu\u011fundaki \u00e7eker adlar\u0131n\u0131 \u00f6zelle\u015ftirin; varsay\u0131lan olarak <code>meta[\"attractor_labels\"]</code>, <code>meta[\"attractor_names\"]</code> veya <code>A0</code>, <code>A1</code>, \u2026 kullan\u0131l\u0131r.</li> </ul> <pre><code>basin_plot(\n    res,\n    special_colors=[\"#1a1a1a\", \"#444444\", \"#777777\"],\n    attractor_cmap=\"viridis\",\n    attractor_labels=[\"Periyot-1\", \"Periyot-2\"],\n    colorbar_label=\"Sonu\u00e7\",\n)\n</code></pre> <p><code>basin_plot()</code>, etiketlerden daha az renk isterseniz hata verir, bu nedenle paletinizin sonu\u00e7taki \u00f6zel sonu\u00e7 ve \u00e7eker say\u0131s\u0131yla e\u015fle\u015fti\u011finden emin olun.</p>"},{"location":"tr/guides/plotting/basin-plot/#eksen-snrlar-ve-ek-acklamalar","title":"Eksen, s\u0131n\u0131rlar ve ek a\u00e7\u0131klamalar","text":"<p>Eksen s\u0131n\u0131rlar\u0131, etiketler ve tik (i\u015faret) stillendirmesi ola\u011fan <code>plot</code> yard\u0131mc\u0131lar\u0131 taraf\u0131ndan y\u00f6netilir:</p> <ul> <li><code>bounds</code> veya <code>res.meta[\"ic_bounds\"]</code>, ba\u015flang\u0131\u00e7 ko\u015fullar\u0131 olu\u015fturulurken kullan\u0131lan <code>(x_min, x_max)</code>/<code>(y_min, y_max)</code> aral\u0131klar\u0131n\u0131 belirtir. E\u011fer <code>x</code> ve <code>y</code> dizilerini sa\u011flarsan\u0131z, <code>bounds</code> yok say\u0131l\u0131r.</li> <li><code>xlabel</code>, <code>ylabel</code> ve <code>title</code>, <code>matplotlib.axes.Axes</code> etiketleri gibi davran\u0131r. Sonu\u00e7 meta verileri <code>observe_vars</code> i\u00e7eriyorsa, bunlar\u0131 ge\u00e7ersiz k\u0131lmad\u0131\u011f\u0131n\u0131z s\u00fcrece bu isimler otomatik olarak <code>xlabel</code>/<code>ylabel</code> alanlar\u0131n\u0131 doldurur.</li> <li><code>xlim</code>, <code>ylim</code>, <code>aspect</code>, <code>xlabel_fs</code>, <code>ylabel_fs</code>, <code>xtick_fs</code>, <code>ytick_fs</code>, <code>xlabel_rot</code>, <code>ylabel_rot</code>, <code>title_fs</code>, <code>titlepad</code>, <code>xpad</code> ve <code>ypad</code>, g\u00f6r\u00fcn\u00fcm\u00fc ince ayar yapman\u0131za olanak tan\u0131r.</li> <li>Yard\u0131mc\u0131, mevcut bir <code>ax=</code> parametresini kabul eder, b\u00f6ylece havza haritas\u0131n\u0131 <code>plot.fig()</code>/<code>plot.theme()</code> veya do\u011frudan Matplotlib taraf\u0131ndan \u00fcretilen \u00e7ok panelli bir \u015fekle yerle\u015ftirebilirsiniz.</li> </ul> <p>\u00c7izim <code>pcolormesh</code> kulland\u0131\u011f\u0131ndan, <code>shading</code> varsay\u0131lan olarak <code>\"auto\"</code>dur ve ba\u015fka bir veri setinden konturlar veya havzalar bindirmeyi d\u00fc\u015f\u00fcn\u00fcyorsan\u0131z \u0131zgaray\u0131 solukla\u015ft\u0131rmak i\u00e7in <code>alpha</code> kullan\u0131labilir.</p>"},{"location":"tr/guides/plotting/basin-plot/#renk-cubugu-colorbar-ayarlar","title":"Renk \u00e7ubu\u011fu (colorbar) ayarlar\u0131","text":"<p>Renk \u00e7ubu\u011funu kald\u0131rmak i\u00e7in <code>colorbar=False</code> olarak ayarlay\u0131n. Aksi takdirde, yard\u0131mc\u0131 otomatik olarak \u00f6zel giri\u015fler ve ard\u0131ndan \u00e7eker kimlikleri i\u00e7in tikleri ayarlar. \u015eunlar\u0131 kullan\u0131n:</p> <ul> <li>Eksen ba\u015fl\u0131\u011f\u0131n\u0131 ayarlamak i\u00e7in <code>colorbar_label</code>, <code>colorbar_label_rotation</code> ve <code>colorbar_labelpad</code>.</li> <li><code>plt.colorbar()</code> fonksiyonuna ekstra ayarlar (\u00f6rne\u011fin <code>{\"fraction\": 0.05}</code>) iletmek i\u00e7in <code>colorbar_kwargs</code>.</li> </ul> <p><code>plot.basin_plot()</code>, olu\u015fturulan <code>Colorbar</code> nesnesini di\u011fer \u00e7izim yard\u0131mc\u0131lar\u0131n\u0131 yans\u0131tacak \u015fekilde <code>ax._last_colorbar</code> \u00fczerinde saklar.</p>"},{"location":"tr/guides/plotting/basin-plot/#ipuclar","title":"\u0130pu\u00e7lar\u0131","text":"<ul> <li>Yaln\u0131zca d\u00fczle\u015ftirilmi\u015f etiketler iletirken <code>grid</code> parametresini sa\u011flay\u0131n; yard\u0131mc\u0131, <code>pcolormesh</code> i\u00e7in bunlar\u0131 <code>(ny, nx)</code> \u015feklinde nas\u0131l yeniden boyutland\u0131raca\u011f\u0131n\u0131 bilmelidir.</li> <li><code>res.meta[\"ic_grid\"]</code> ve <code>res.meta[\"ic_bounds\"]</code> genellikle analiz rutinleri taraf\u0131ndan doldurulur, bu nedenle \u00e7izim yaparken bunlar\u0131 nadiren tekrar etmeniz gerekir.</li> <li>\u00c7ok parametreli bir sonucun farkl\u0131 bir dilimini g\u00f6rselle\u015ftirmek i\u00e7in, <code>basin_plot()</code> \u00e7a\u011fr\u0131s\u0131ndan \u00f6nce etiket dizisini dilimleyin ve <code>bounds</code> de\u011ferini buna g\u00f6re g\u00fcncelleyin (yard\u0131mc\u0131, \u00e7ok boyutlu dilimleri otomatik olarak yeniden \u015fekillendirmez).</li> <li>Kimlikler yerine \u00e7eker adlar\u0131n\u0131 vurgulamak istiyorsan\u0131z, her zaman <code>attractor_labels</code> sa\u011flay\u0131n; b\u00f6ylece \u00e7eker kay\u0131t defterinizin s\u0131ras\u0131na bak\u0131lmaks\u0131z\u0131n renk \u00e7ubu\u011fu tikleri net bir \u015fekilde okunur.</li> </ul> <p><code>basin_plot()</code> her zaman <code>Axes</code> nesnesini d\u00f6nd\u00fcr\u00fcr, b\u00f6ylece Matplotlib komutlar\u0131 veya \u00c7izim S\u00fcslemeleri b\u00f6l\u00fcm\u00fcnde a\u00e7\u0131klanan payla\u015f\u0131lan s\u00fcsleme arg\u00fcmanlar\u0131 (<code>vlines</code>, <code>hlines</code>, <code>vbands</code>, <code>hbands</code>) ile \u015fekle ek a\u00e7\u0131klamalar yapmaya devam edebilirsiniz.</p>"},{"location":"tr/guides/plotting/bifurcation-diagrams/","title":"\u00c7atallanma (Bifurcation) Diyagramlar\u0131","text":"<p>\u00c7atallanma diyagramlar\u0131, dinamik bir sistemin uzun vadeli davran\u0131\u015f\u0131n\u0131n bir parametre de\u011fi\u015ftirildi\u011finde nas\u0131l de\u011fi\u015fti\u011fini g\u00f6rselle\u015ftirir. Dynlib, \u00e7atallanma analizi i\u00e7in tipik olan yo\u011fun nokta bulutlar\u0131 i\u00e7in optimize edilmi\u015f, sa\u00e7\u0131l\u0131m (scatter) tarz\u0131 \u00e7izimler olu\u015fturmak i\u00e7in <code>bifurcation_diagram()</code> fonksiyonunu sa\u011flar.</p>"},{"location":"tr/guides/plotting/bifurcation-diagrams/#temel-kullanm","title":"Temel Kullan\u0131m","text":"<p><code>bifurcation_diagram()</code> fonksiyonu \u00e7atallanma verilerini iki formatta kabul eder:</p> <ol> <li>Bir <code>BifurcationExtractor</code>/<code>BifurcationResult</code> (genellikle <code>SweepResult.bifurcation()</code> taraf\u0131ndan d\u00f6nd\u00fcr\u00fcl\u00fcr)</li> <li><code>(parametre_de\u011ferleri, durum_de\u011ferleri)</code> dizilerinden olu\u015fan bir demet (tuple)</li> </ol> <p>Ay\u0131klay\u0131c\u0131 yard\u0131mc\u0131lar\u0131 ve ham diziler hakk\u0131nda daha fazla bilgi i\u00e7in a\u015fa\u011f\u0131daki Girdi Veri Formatlar\u0131 b\u00f6l\u00fcm\u00fcne bak\u0131n.</p> <pre><code>from dynlib.plot import bifurcation_diagram, theme, fig, export\n\n# Analizden elde edilmi\u015f \u00e7atallanma verileriniz oldu\u011fu varsay\u0131l\u0131yor\n# result = sweep_result.bifurcation(\"x\")  # bir ay\u0131klay\u0131c\u0131 (extractor) d\u00f6nd\u00fcr\u00fcr (varsay\u0131lan .all())\n\n# \u00c7izimi olu\u015ftur\nax = fig.single(size=(10, 6))\nbifurcation_diagram(\n    result,  # BifurcationResult veya (p, y) demeti\n    xlabel=\"r\",\n    ylabel=\"x*\",\n    title=\"\u00c7atallanma Diyagram\u0131\",\n    ax=ax\n)\n\nexport.show()\n</code></pre>"},{"location":"tr/guides/plotting/bifurcation-diagrams/#girdi-veri-formatlar","title":"Girdi Veri Formatlar\u0131","text":""},{"location":"tr/guides/plotting/bifurcation-diagrams/#catallanma-ayklayclar-ve-sonuclar","title":"\u00c7atallanma ay\u0131klay\u0131c\u0131lar\u0131 ve sonu\u00e7lar\u0131","text":"<p><code>SweepResult.bifurcation(\"x\")</code> bir <code>BifurcationExtractor</code> d\u00f6nd\u00fcr\u00fcr; bu nesne <code>BifurcationResult</code> ile ayn\u0131 ince aray\u00fcz\u00fc uygular (<code>.p</code>, <code>.y</code>, <code>.param_name</code>, <code>.meta</code> ve <code>.mode</code> \u00f6zelliklerini d\u0131\u015fa a\u00e7ar). Ay\u0131klay\u0131c\u0131y\u0131 do\u011frudan <code>bifurcation_diagram()</code> fonksiyonuna iletebilir veya somut bir <code>BifurcationResult</code> elde etmek i\u00e7in <code>.all()</code>, <code>.tail()</code>, <code>.extrema()</code> veya <code>.final()</code> gibi yard\u0131mc\u0131 y\u00f6ntemleri \u00e7a\u011f\u0131rabilirsiniz.</p> <pre><code>from dynlib.analysis.sweep import traj_sweep\n\nsweep_result = traj_sweep(sim, param=\"r\", values=r_values, record_vars=[\"x\"], ...)\nresult = sweep_result.bifurcation(\"x\")             # ay\u0131klay\u0131c\u0131 varsay\u0131lan olarak \"all\" modundad\u0131r\n# result = result.tail(50)                         # iste\u011fe ba\u011fl\u0131: son 50 noktaya odaklan\n\nbifurcation_diagram(result)  # xlabel=\"r\", ylabel=\"x\", ba\u015fl\u0131k moda g\u00f6re belirlenir\n</code></pre> <p><code>bifurcation_diagram()</code> \u015funlar\u0131 otomatik olarak \u00e7eker: - <code>result.p</code> \u00fczerinden parametre de\u011ferleri - <code>result.y</code> \u00fczerinden durum de\u011ferleri - <code>result.param_name</code> ve <code>result.meta[\"var\"]</code> \u00fczerinden eksen etiketleri (meta veriler mevcut oldu\u011funda) - <code>result.mode</code> \u00fczerinden ba\u015fl\u0131k (\u00f6rne\u011fin, <code>\"all\"</code>, <code>\"tail\"</code>, <code>\"extrema\"</code>)</p>"},{"location":"tr/guides/plotting/bifurcation-diagrams/#ham-diziler","title":"Ham Diziler","text":"<p>\u00d6zel veriler veya harici \u00e7atallanma hesaplamalar\u0131 i\u00e7in:</p> <pre><code>import numpy as np\n\n# Ham parametre ve durum de\u011feri dizileri\nr_values = np.array([...])  # parametre de\u011ferleri\nx_values = np.array([...])  # kar\u015f\u0131l\u0131k gelen durum de\u011ferleri\n\nbifurcation_diagram(\n    (r_values, x_values),\n    xlabel=\"r\",\n    ylabel=\"x*\",\n    title=\"\u00d6zel \u00c7atallanma Verisi\"\n)\n</code></pre>"},{"location":"tr/guides/plotting/bifurcation-diagrams/#cizim-ozellestirme","title":"\u00c7izim \u00d6zelle\u015ftirme","text":""},{"location":"tr/guides/plotting/bifurcation-diagrams/#stillendirme-secenekleri","title":"Stillendirme Se\u00e7enekleri","text":"<p>\u00c7atallanma diyagramlar\u0131, optimize edilmi\u015f varsay\u0131lanlarla sa\u00e7\u0131l\u0131m tarz\u0131 \u00e7izimi kullan\u0131r:</p> <pre><code>bifurcation_diagram(\n    result,\n    color=\"blue\",           # \u0130\u015faret\u00e7i rengi\n    marker=\",\",             # Piksel i\u015faret\u00e7isi (varsay\u0131lan)\n    ms=0.5,                 # \u0130\u015faret\u00e7i boyutu (piksel i\u015faret\u00e7ileri i\u00e7in yok say\u0131l\u0131r)\n    alpha=0.5,              # Saydaml\u0131k (varsay\u0131lan)\n    label=\"Lojistik Harita\" # Lejant etiketi\n)\n</code></pre> <p>Farkl\u0131 g\u00f6rsel stiller i\u00e7in varsay\u0131lanlar\u0131 ge\u00e7ersiz k\u0131l\u0131n:</p> <pre><code># Daha b\u00fcy\u00fck, daha g\u00f6r\u00fcn\u00fcr i\u015faret\u00e7iler\nbifurcation_diagram(\n    result,\n    marker=\".\",\n    ms=1.0,\n    alpha=1.0,\n    color=\"darkred\"\n)\n</code></pre>"},{"location":"tr/guides/plotting/bifurcation-diagrams/#eksen-kontrolu","title":"Eksen Kontrol\u00fc","text":"<p>Eksen s\u0131n\u0131rlar\u0131n\u0131 ve etiketlerini ayarlay\u0131n:</p> <pre><code>bifurcation_diagram(\n    result,\n    xlim=(2.5, 4.0),       # Parametre aral\u0131\u011f\u0131\n    ylim=(0, 1),            # Durum aral\u0131\u011f\u0131\n    xlabel=\"r\",             # Parametre eksen etiketi\n    ylabel=\"x*\",            # Durum eksen etiketi\n    title=\"Lojistik Harita \u00c7atallanmalar\u0131\"\n)\n</code></pre>"},{"location":"tr/guides/plotting/bifurcation-diagrams/#yaz-tipi-boyutlar-ve-duzen","title":"Yaz\u0131 Tipi Boyutlar\u0131 ve D\u00fczen","text":"<p>Metin g\u00f6r\u00fcn\u00fcm\u00fcn\u00fc \u00f6zelle\u015ftirin:</p> <pre><code>bifurcation_diagram(\n    result,\n    xlabel_fs=12,           # X ekseni etiketi yaz\u0131 tipi boyutu\n    ylabel_fs=12,           # Y ekseni etiketi yaz\u0131 tipi boyutu\n    title_fs=14,            # Ba\u015fl\u0131k yaz\u0131 tipi boyutu\n    xtick_fs=10,            # X ekseni tik yaz\u0131 tipi boyutu\n    ytick_fs=10             # Y ekseni tik yaz\u0131 tipi boyutu\n)\n</code></pre>"},{"location":"tr/guides/plotting/bifurcation-diagrams/#ek-acklamalar-ve-vurgulamalar","title":"Ek A\u00e7\u0131klamalar ve Vurgulamalar","text":""},{"location":"tr/guides/plotting/bifurcation-diagrams/#dikey-cizgiler","title":"Dikey \u00c7izgiler","text":"<p>\u00d6nemli parametre de\u011ferlerini i\u015faretlemek i\u00e7in dikey \u00e7izgiler ekleyin:</p> <pre><code>bifurcation_diagram(\n    result,\n    vlines=[\n        3.0,                                    # r=3 noktas\u0131nda basit \u00e7izgi\n        (3.449, \"Periyot-4 \u00e7atallanmas\u0131\"),      # Etiketli \u00e7izgi\n        (3.5699, \"Feigenbaum noktas\u0131\")          # Ba\u015fka bir etiketli \u00e7izgi\n    ],\n    vlines_color=\"red\",\n    vlines_kwargs={\n        \"linestyle\": \"--\",\n        \"alpha\": 0.7,\n        \"linewidth\": 1\n    }\n)\n</code></pre>"},{"location":"tr/guides/plotting/bifurcation-diagrams/#gelismis-stillendirme","title":"Geli\u015fmi\u015f Stillendirme","text":"<p>Dikey \u00e7izgi g\u00f6r\u00fcn\u00fcm\u00fcn\u00fc kontrol edin:</p> <pre><code>bifurcation_diagram(\n    result,\n    vlines=[(3.0, \"r=3\"), (3.57, \"Kaos ba\u015flang\u0131c\u0131\")],\n    vlines_kwargs={\n        \"linestyle\": \":\",\n        \"alpha\": 0.5,\n        \"label_rotation\": 90,      # Etiketleri d\u00f6nd\u00fcr\n        \"label_position\": \"top\"    # Etiketleri yukar\u0131/a\u015fa\u011f\u0131 konumland\u0131r\n    }\n)\n</code></pre>"},{"location":"tr/guides/plotting/bifurcation-diagrams/#tam-ornek","title":"Tam \u00d6rnek","text":"<p>\u0130\u015fte birden fazla \u00f6zelle\u015ftirme se\u00e7ene\u011fini g\u00f6steren kapsaml\u0131 bir \u00f6rnek:</p> <pre><code>from dynlib.plot import bifurcation_diagram, theme, fig, export\n\n# Temay\u0131 yap\u0131land\u0131r\ntheme.use(\"notebook\")\ntheme.update(grid=True)\n\n# \u015eekil olu\u015ftur\nax = fig.single(size=(12, 8))\n\n# Tam \u00f6zelle\u015ftirme ile \u00e7iz\nbifurcation_diagram(\n    result,\n    color=\"black\",\n    alpha=0.8,\n    xlim=(2.5, 4.0),\n    ylim=(0, 1),\n    xlabel=\"r\",\n    ylabel=\"x*\",\n    title=\"Lojistik Harita: Periyot \u0130kiye Katlama Kaskad\u0131\",\n    xlabel_fs=14,\n    ylabel_fs=14,\n    title_fs=16,\n    vlines=[\n        (3.0, \"Periyot-2\"),\n        (3.449, \"Periyot-4\"),\n        (3.5699, \"Feigenbaum noktas\u0131\")\n    ],\n    vlines_kwargs={\n        \"color\": \"red\",\n        \"linestyle\": \"--\",\n        \"alpha\": 0.6,\n        \"linewidth\": 1.5\n    },\n    ax=ax\n)\n\nexport.show()\n</code></pre>"},{"location":"tr/guides/plotting/bifurcation-diagrams/#etkili-catallanma-cizimleri-icin-ipuclar","title":"Etkili \u00c7atallanma \u00c7izimleri \u0130\u00e7in \u0130pu\u00e7lar\u0131","text":"<ol> <li>\u00c7\u00f6z\u00fcn\u00fcrl\u00fck: P\u00fcr\u00fczs\u00fcz diyagramlar i\u00e7in y\u00fcksek \u00e7\u00f6z\u00fcn\u00fcrl\u00fckl\u00fc parametre taramalar\u0131 (10.000+ nokta) kullan\u0131n.</li> <li>Ge\u00e7ici Rejimler (Transients): \u00c7ekerlere ula\u015fmak i\u00e7in yeterli ge\u00e7ici s\u00fcrenin (transient time) tan\u0131nd\u0131\u011f\u0131ndan emin olun.</li> <li>\u0130\u015faret\u00e7iler: Piksel i\u015faret\u00e7ileri (<code>,</code>) yo\u011fun veriler i\u00e7in iyi \u00e7al\u0131\u015f\u0131r; seyrek veriler i\u00e7in daha b\u00fcy\u00fck i\u015faret\u00e7iler kullan\u0131n.</li> <li>Alfa (Alpha): D\u00fc\u015f\u00fck alfa de\u011ferleri, yo\u011fun b\u00f6lgelerdeki nokta yo\u011funlu\u011funu g\u00f6rselle\u015ftirmeye yard\u0131mc\u0131 olur.</li> <li>Ek A\u00e7\u0131klamalar: \u00c7atallanma noktalar\u0131n\u0131 ve ge\u00e7i\u015fleri vurgulamak i\u00e7in dikey \u00e7izgiler kullan\u0131n.</li> <li>Yak\u0131nla\u015ft\u0131rma (Zooming): Karma\u015f\u0131k kaskadlar i\u00e7in, yak\u0131nla\u015ft\u0131r\u0131lm\u0131\u015f b\u00f6lgeleri ayr\u0131 ayr\u0131 \u00e7izmeyi d\u00fc\u015f\u00fcn\u00fcn.</li> </ol> <p><code>bifurcation_diagram()</code> fonksiyonu, dynlib'in analiz i\u015f ak\u0131\u015f\u0131yla sorunsuz bir \u015fekilde b\u00fct\u00fcnle\u015ferek y\u00f6r\u00fcnge taramalar\u0131ndan g\u00f6rsel \u00e7atallanma diyagramlar\u0131na d\u00f6n\u00fc\u015f\u00fcm\u00fc otomatik olarak halleder.</p>"},{"location":"tr/guides/plotting/cobweb/","title":"\u00d6r\u00fcmcek A\u011f\u0131 (Cobweb) Grafikleri","text":"<p>\u00d6r\u00fcmcek a\u011f\u0131 grafikleri, bir boyutlu ayr\u0131k dinamik sistemlerin (haritalar\u0131n) davran\u0131\u015f\u0131n\u0131 analiz etmek i\u00e7in g\u00fc\u00e7l\u00fc bir g\u00f6rselle\u015ftirme arac\u0131d\u0131r. Bir fonksiyonun iterasyonlar\u0131n\u0131n zaman i\u00e7inde nas\u0131l geli\u015fti\u011fini anlamak i\u00e7in sezgisel bir yol sa\u011flarlar ve sabit noktalar, periyodik y\u00f6r\u00fcngeler ve kaotik davran\u0131\u015f gibi \u00f6nemli dinamik \u00f6zellikleri belirlemeye yard\u0131mc\u0131 olurlar.</p>"},{"location":"tr/guides/plotting/cobweb/#orumcek-ag-grafikleri-nasl-calsr","title":"\u00d6r\u00fcmcek A\u011f\u0131 Grafikleri Nas\u0131l \u00c7al\u0131\u015f\u0131r?","text":"<p>Bir \u00f6r\u00fcmcek a\u011f\u0131 grafi\u011fi, bir fonksiyonu tekrar tekrar uygulama (iterasyon) s\u00fcrecini g\u00f6rselle\u015ftirir. Bir \\(f(x)\\) fonksiyonu i\u00e7in, \\(x_0\\) ba\u015flang\u0131\u00e7 de\u011ferinden ba\u015flayarak, iterasyon \u015fu diziyi olu\u015fturur:</p> \\[x_{n+1} = f(x_n)\\] <p>\u00d6r\u00fcmcek a\u011f\u0131 grafi\u011fi bu iterasyonu geometrik olarak \u015fu \u015fekilde temsil eder:</p> <ol> <li>Fonksiyon e\u011frisi: \\(y = f(x)\\) \u00e7izilir.</li> <li>Birim (Identity) do\u011frusu: \\(y = x\\) \u00e7izilir (kesikli \u00e7izgi olarak g\u00f6sterilir).</li> <li>\u0130terasyon yolu: Her iterasyonun \\((x_n, x_n)\\) noktas\u0131ndan \\((x_n, x_{n+1})\\) noktas\u0131na, oradan da \\((x_{n+1}, x_{n+1})\\) noktas\u0131na nas\u0131l hareket etti\u011fini g\u00f6steren bir \"merdiven\" \u00e7izilir.</li> </ol> <p>Merdiven yap\u0131s\u0131 \u015fu \u015fekilde olu\u015fturulur: - \\((x_n, x_n)\\) noktas\u0131ndan \\((x_n, f(x_n))\\) noktas\u0131na dikey bir \u00e7izgi \u00e7izilir. - \\((x_n, f(x_n))\\) noktas\u0131ndan \\((f(x_n), f(x_n))\\) noktas\u0131na yatay bir \u00e7izgi \u00e7izilir.</p> <p>Bu i\u015flem, fonksiyon e\u011frisi ile birim do\u011frusu aras\u0131nda zikzak \u00e7izen ve iterasyon s\u00fcrecini g\u00f6rsel olarak temsil eden bir yol olu\u015fturur.</p>"},{"location":"tr/guides/plotting/cobweb/#temel-kullanm","title":"Temel Kullan\u0131m","text":"<pre><code>from dynlib.plot import cobweb\n\n# Basit bir fonksiyon kullanarak\ndef logistic(x, r=4.0):\n    return r * x * (1 - x)\n\ncobweb(\n    f=logistic,\n    x0=0.1,      # ba\u015flang\u0131\u00e7 ko\u015fulu\n    steps=50,     # iterasyon say\u0131s\u0131\n    xlim=(0, 1),  # x-ekseni s\u0131n\u0131rlar\u0131\n)\n</code></pre>"},{"location":"tr/guides/plotting/cobweb/#dynlib-modelleriyle-calsma","title":"Dynlib Modelleriyle \u00c7al\u0131\u015fma","text":"<p>\u00d6r\u00fcmcek a\u011f\u0131 grafikleri dynlib modelleriyle sorunsuz \u00e7al\u0131\u015f\u0131r:</p> <p><pre><code>from dynlib import setup\nfrom dynlib.plot import cobweb\n\nmodel = \"\"\"\ninline:\n[model]\ntype=\"map\"\nname=\"Logistic Map\"\n\n[states]\nx=0.1\n\n[params]\nr=4.0\n\n[equations.rhs]\nx = \"r * x * (1 - x)\"\n\"\"\"\n\nsim = setup(model, stepper=\"map\")\ncobweb(\n    f=sim.model,  # Modeli do\u011frudan iletin\n    x0=0.1,\n    xlim=(0, 1),\n    steps=50,\n)\n</code></pre> DSL'i <code>setup()</code> (veya <code>build()</code>) fonksiyonuna sat\u0131r i\u00e7i (inline) olarak iletirken, dynlib'in bunu bir dosya yolu yerine g\u00f6m\u00fcl\u00fc bir model tan\u0131m\u0131 olarak alg\u0131lamas\u0131 i\u00e7in dizenin ba\u015f\u0131na <code>inline:</code> ekleyin.</p>"},{"location":"tr/guides/plotting/cobweb/#temel-parametreler","title":"Temel Parametreler","text":""},{"location":"tr/guides/plotting/cobweb/#fonksiyon-belirtimi","title":"Fonksiyon Belirtimi","text":"<ul> <li><code>f</code>: \u0130terasyon yap\u0131lacak fonksiyon veya model. \u015eunlar olabilir:</li> <li>\u00c7a\u011fr\u0131labilir bir fonksiyon <code>f(x)</code> veya <code>f(x, r)</code></li> <li><code>map()</code> metoduna sahip bir dynlib Model nesnesi</li> <li>Bir Sim nesnesi (<code>sim.model</code> kullan\u0131l\u0131r)</li> </ul>"},{"location":"tr/guides/plotting/cobweb/#iterasyon-kontrolu","title":"\u0130terasyon Kontrol\u00fc","text":"<ul> <li><code>x0</code>: \u0130terasyon i\u00e7in ba\u015flang\u0131\u00e7 de\u011feri</li> <li><code>steps</code>: \u00c7izilecek iterasyon ad\u0131m\u0131 say\u0131s\u0131 (varsay\u0131lan: 50)</li> <li><code>t0</code>: Ba\u015flang\u0131\u00e7 zaman indeksi (varsay\u0131lan: 0.0)</li> <li><code>dt</code>: Zaman ad\u0131m\u0131 boyutu (varsay\u0131lan: 1.0)</li> </ul>"},{"location":"tr/guides/plotting/cobweb/#modele-ozgu-secenekler","title":"Modele \u00d6zg\u00fc Se\u00e7enekler","text":"<ul> <li><code>state</code>: \u00c7ok boyutlu modeller i\u00e7in, hangi durum de\u011fi\u015fkeninin kullan\u0131laca\u011f\u0131n\u0131 belirtir (isim veya indeks ile)</li> <li><code>fixed</code>: Sabit parametre/durum de\u011ferleri s\u00f6zl\u00fc\u011f\u00fc (dictionary)</li> <li><code>r</code>: 'r' parametresi i\u00e7in ge\u00e7ersiz k\u0131lma de\u011feri (\u00e7atallanma analizinde yayg\u0131nd\u0131r)</li> </ul>"},{"location":"tr/guides/plotting/cobweb/#cizim-stili","title":"\u00c7izim Stili","text":"<ul> <li><code>xlim</code>/<code>ylim</code>: Eksen s\u0131n\u0131rlar\u0131 (belirtilmezse otomatik hesaplan\u0131r)</li> <li><code>color</code>: Fonksiyon e\u011frisinin rengi</li> <li><code>identity_color</code>: Birim do\u011frusunun (y=x) rengi</li> <li><code>stair_color</code>: \u0130terasyon merdiveninin rengi</li> <li><code>lw</code>: Fonksiyon e\u011frisinin \u00e7izgi geni\u015fli\u011fi</li> <li><code>stair_lw</code>: Merdivenin \u00e7izgi geni\u015fli\u011fi</li> <li><code>alpha</code>: \u015eeffafl\u0131k</li> </ul>"},{"location":"tr/guides/plotting/cobweb/#etiketler-ve-gorunum","title":"Etiketler ve G\u00f6r\u00fcn\u00fcm","text":"<ul> <li><code>xlabel</code>/<code>ylabel</code>: Eksen etiketleri</li> <li><code>title</code>: Grafik ba\u015fl\u0131\u011f\u0131</li> <li><code>legend</code>: Lejand\u0131n g\u00f6sterilip g\u00f6sterilmeyece\u011fi (varsay\u0131lan: True)</li> </ul>"},{"location":"tr/guides/plotting/cobweb/#orumcek-ag-grafiklerini-yorumlama","title":"\u00d6r\u00fcmcek A\u011f\u0131 Grafiklerini Yorumlama","text":""},{"location":"tr/guides/plotting/cobweb/#sabit-noktalar","title":"Sabit Noktalar","text":"<p>Sabit noktalar \\(x = f(x)\\) e\u015fitli\u011finin sa\u011fland\u0131\u011f\u0131 yerlerde olu\u015fur. \u00d6r\u00fcmcek a\u011f\u0131 grafi\u011finde bunlar, fonksiyon e\u011frisi ile birim do\u011frusunun kesi\u015fim noktalar\u0131 olarak g\u00f6r\u00fcn\u00fcr.</p>"},{"location":"tr/guides/plotting/cobweb/#kararllk-stabilite","title":"Kararl\u0131l\u0131k (Stabilite)","text":"<ul> <li>Kararl\u0131 sabit noktalar: Merdiven, sabit noktaya do\u011fru i\u00e7eriye spiraller \u00e7izer.</li> <li>Karars\u0131z sabit noktalar: Merdiven, sabit noktadan d\u0131\u015far\u0131ya do\u011fru spiraller \u00e7izer.</li> </ul>"},{"location":"tr/guides/plotting/cobweb/#periyodik-yorungeler","title":"Periyodik Y\u00f6r\u00fcngeler","text":"<p>Periyodik davran\u0131\u015f, \u00f6r\u00fcmcek a\u011f\u0131 grafi\u011finde kapal\u0131 d\u00f6ng\u00fcler olarak g\u00f6r\u00fcn\u00fcr. \u00d6rne\u011fin, periyot-2 y\u00f6r\u00fcngesi, merdivenin tekrar tekrar takip etti\u011fi dikd\u00f6rtgen bir yol olu\u015fturur.</p>"},{"location":"tr/guides/plotting/cobweb/#kaos","title":"Kaos","text":"<p>Kaotik davran\u0131\u015f, merdivenin d\u00fczenli bir desene oturmamas\u0131 ve genellikle grafi\u011fin b\u00f6lgelerini yo\u011fun bir \u015fekilde doldurmas\u0131yla kendini g\u00f6sterir.</p>"},{"location":"tr/guides/plotting/cobweb/#ileri-seviye-ornekler","title":"\u0130leri Seviye \u00d6rnekler","text":""},{"location":"tr/guides/plotting/cobweb/#coklu-parametre-analizi","title":"\u00c7oklu Parametre Analizi","text":"<pre><code># Farkl\u0131 r de\u011ferlerini analiz etme\nr_values = [2.5, 3.2, 3.5, 4.0]\n\nfor r in r_values:\n    cobweb(\n        f=logistic,\n        x0=0.1,\n        r=r,  # r parametresini ge\u00e7ersiz k\u0131l\n        xlim=(0, 1),\n        title=f\"Lojistik Harita (r={r})\",\n    )\n</code></pre>"},{"location":"tr/guides/plotting/cobweb/#cok-durumlu-modeller-tek-bir-degiskeni-yineleme","title":"\u00c7ok Durumlu Modeller (tek bir de\u011fi\u015fkeni yineleme)","text":"<p>\u00d6r\u00fcmcek a\u011f\u0131 grafikleri, altta yatan harita (map) bir\u00e7ok duruma sahip olsa bile tek bir durum y\u00f6r\u00fcngesini g\u00f6rselle\u015ftirir. Takip etmek istedi\u011finiz de\u011fi\u015fkeni <code>state</code> ile ayarlay\u0131n ve geri kalan\u0131n\u0131 <code>fixed</code> arac\u0131l\u0131\u011f\u0131yla sabit tutun. Bu, di\u011fer durumlar sa\u011flanan de\u011ferlerde sabitlenirken sistemi se\u00e7ilen durum i\u00e7in etkili bir \u015fekilde 1B haritaya indirger.</p> <pre><code>from dynlib import setup\n\nmulti_state_model = \"\"\"\ninline:\n[model]\ntype = \"map\"\nname = \"Two-State Map\"\n\n[states]\nx = 0.5\ny = 1.0\n\n[params]\na = 3.0\n\n[equations.rhs]\nx = \"a * x * (1 - x) + 0.1 * y\"\ny = \"0.9 * y\"\n\"\"\"\n\nsim = setup(multi_state_model, stepper=\"map\")\ncobweb(\n    f=sim.model,\n    x0=sim.state[\"x\"],\n    state=\"x\",\n    fixed={\"y\": 1.0},\n    steps=100,\n)\n</code></pre> <p>Grafik hala yaln\u0131zca se\u00e7ilen <code>state</code> de\u011fi\u015fkenini g\u00f6sterdi\u011finden, \u00f6r\u00fcmcek a\u011f\u0131 grafikleri tek boyutlu haritalarla s\u0131n\u0131rl\u0131 kal\u0131r; \u00e7ok durumlu sistemler her seferinde bir koordinat kesiti al\u0131narak g\u00f6rselle\u015ftirilir.</p>"},{"location":"tr/guides/plotting/cobweb/#ozel-stil-tanmlama","title":"\u00d6zel Stil Tan\u0131mlama","text":"<pre><code>cobweb(\n    f=sim.model,\n    x0=0.1,\n    xlim=(0, 1),\n    color=\"blue\",\n    identity_color=\"red\",\n    stair_color=\"green\",\n    stair_lw=1.5,\n    alpha=0.8,\n    title=\"\u00d6zel Stilli \u00d6r\u00fcmcek A\u011f\u0131 Grafi\u011fi\",\n)\n</code></pre>"},{"location":"tr/guides/plotting/cobweb/#snrlamalar","title":"S\u0131n\u0131rlamalar","text":"<ul> <li>\u00d6r\u00fcmcek a\u011f\u0131 grafikleri yaln\u0131zca 1B haritalar i\u00e7in tasarlanm\u0131\u015ft\u0131r; \u00e7ok durumlu modeller <code>state</code>/<code>fixed</code> kullan\u0131larak tek bir iterasyon durumuna indirgenmelidir.</li> <li><code>lag()</code> fonksiyonlar\u0131n\u0131 kullanan modeller desteklenmez (g\u00fcvenli bir \u015fekilde de\u011ferlendirilemez).</li> <li>Ayr\u0131k harita modelleri gerektirir (<code>spec.kind == 'map'</code>).</li> </ul>"},{"location":"tr/guides/plotting/cobweb/#ilgili-fonksiyonlar","title":"\u0130lgili Fonksiyonlar","text":"<ul> <li><code>plot.return_map()</code>: D\u00f6n\u00fc\u015f haritalar\u0131n\u0131 \u00e7izer (\\(x_n\\)'e kar\u015f\u0131 \\(x_{n+1}\\))</li> <li><code>plot.series()</code>: \u0130terasyonun zaman serisini \u00e7izer</li> <li><code>plot.phase()</code>: Daha y\u00fcksek boyutlu sistemler i\u00e7in faz uzay\u0131 grafikleri</li> </ul>"},{"location":"tr/guides/plotting/decorations/","title":"Grafik S\u00fcslemeleri","text":"<p>Dynlib \u00e7izim yard\u0131mc\u0131lar\u0131, her \u00fcst d\u00fczey g\u00f6rselle\u015ftiricinin <code>src/dynlib/plot/_primitives.py</code> i\u00e7indeki <code>_apply_decor()</code> arac\u0131l\u0131\u011f\u0131yla iletti\u011fi tek bir s\u00fcsleme arg\u00fcmanlar\u0131 setini kullan\u0131ma sunar. Bu yard\u0131mc\u0131, <code>series.plot()</code>, <code>series.step()</code> ve benzeri giri\u015f noktalar\u0131ndan gelen ayn\u0131 parametreleri kabul eder, b\u00f6ylece s\u00fcslemeler her yerde ayn\u0131 \u015fekilde davran\u0131r.</p>"},{"location":"tr/guides/plotting/decorations/#dikey-cizgiler-vlines","title":"Dikey \u00c7izgiler (<code>vlines</code>)","text":"<ul> <li><code>vlines</code> parametresine ya skaler de\u011ferlerden olu\u015fan bir liste ya da <code>(x, etiket)</code> demetleri (tuples) iletin. Demetler (tuples), ayr\u0131 bir <code>text()</code> \u00e7a\u011fr\u0131s\u0131na ihtiya\u00e7 duymadan, ilgili \u00e7izginin yan\u0131nda etiketlerle birlikte olu\u015fturulur.</li> <li>G\u00f6r\u00fcn\u00fcm\u00fc ayarlamak i\u00e7in <code>vlines_kwargs</code> (veya \u00e7o\u011fu yard\u0131mc\u0131da bulunan kolayl\u0131k e\u015fle\u015fmesi <code>vlines_color</code>/<code>vlines_kwargs</code>) sa\u011flayabilirsiniz. Varsay\u0131lan kwargs de\u011ferleri \u015f\u00f6yledir: <code>color='black'</code>, <code>linestyle='--'</code>, <code>linewidth=1</code>, <code>alpha=0.7</code>.</li> <li>Etiket konumland\u0131rmas\u0131, <code>_apply_decor()</code> taraf\u0131ndan yakalan\u0131p geri kalan\u0131 <code>ax.axvline()</code> fonksiyonuna iletilmeden \u00f6nce d\u00f6rt \u00f6zel kwargs ile kontrol edilir:</li> <li><code>label_position</code>: <code>'top'</code>, <code>'bottom'</code>, <code>'center'</code> se\u00e7eneklerinden biri. Metnin ofsetler uygulanmadan \u00f6nce eksenin \u00fcst\u00fcne/alt\u0131na/ortas\u0131na m\u0131 sabitlenece\u011fini belirler.</li> <li><code>placement_pad</code>: Metin ba\u011flant\u0131 noktas\u0131n\u0131 hesaplarken eksen boyunca ek ofset ekler (<code>&lt;1</code> ise eksen y\u00fcksekli\u011finin oran\u0131, aksi takdirde veri birimi olarak).</li> <li><code>label_pad</code>: Etiketi \u00e7izgiye dik olarak (yani yatay olarak) hareket ettirir; yine <code>&lt;1</code> de\u011ferlerini eksen oran\u0131 ve <code>&gt;=1</code> de\u011ferlerini veri birimi olarak yorumlar.</li> <li><code>label_rotation</code>/<code>label_color</code>: D\u00f6nd\u00fcrme (varsay\u0131lan 90\u00b0) ve metin rengini (varsay\u0131lan olarak \u00e7izgi rengi) ge\u00e7ersiz k\u0131lar.</li> </ul> <p>\u00d6rnek: <pre><code>series.plot(\n    x=t,\n    y=x_traj,\n    vlines=[(3.0, \"period-2\"), 3.57],\n    vlines_kwargs={\n        \"label_position\": \"bottom\",\n        \"placement_pad\": 0.08,\n        \"label_pad\": 0.05,\n        \"label_rotation\": 90,\n        \"linestyle\": \":\",\n        \"color\": \"firebrick\",\n    },\n)\n</code></pre></p>"},{"location":"tr/guides/plotting/decorations/#yatay-cizgiler-hlines","title":"Yatay \u00c7izgiler (<code>hlines</code>)","text":"<ul> <li><code>vlines</code> ile ayn\u0131 \u015fekilde \u00e7al\u0131\u015f\u0131r, ancak y koordinatlar\u0131 i\u00e7indir. Etiketler <code>(y, etiket)</code> demetleri (tuples) arac\u0131l\u0131\u011f\u0131yla sa\u011flanabilir.</li> <li><code>hlines_color</code>, yaln\u0131zca rengi de\u011fi\u015ftirmenin yayg\u0131n oldu\u011fu durumlar i\u00e7in mevcuttur; <code>_apply_decor()</code> \u00e7al\u0131\u015fmadan \u00f6nce <code>hlines_kwargs</code> ile birle\u015ftirilir.</li> <li>\u00d6zel kwargs benzerdir ancak yatay geometriyi yans\u0131t\u0131r:</li> <li><code>label_position</code>: Etiketin eksenin hangi taraf\u0131na yaslanaca\u011f\u0131n\u0131 se\u00e7mek i\u00e7in <code>'left'</code>, <code>'right'</code> veya <code>'center'</code>.</li> <li><code>placement_pad</code>: Ba\u011flant\u0131 noktas\u0131n\u0131 x ekseni boyunca kayd\u0131r\u0131r (<code>&lt;1</code> = eksen oran\u0131, <code>&gt;=1</code> = veri birimi).</li> <li><code>label_pad</code>: Etiketi \u00e7izgiye dik olarak \u00f6teler (dikey olarak hareket ettirir), ayn\u0131 eksen-vs-veri-birimi yorumu ge\u00e7erlidir.</li> <li><code>label_rotation</code> yatay metin i\u00e7in varsay\u0131lan olarak <code>0</code> derecedir ve <code>label_color</code> yine varsay\u0131lan olarak \u00e7izgi rengini kullan\u0131r.</li> </ul> <p>\u00d6rnek: <pre><code>series.plot(\n    x=t,\n    y=x_traj,\n    hlines=[(0.25, \"low\"), (0.75, \"high\")],\n    hlines_kwargs={\n        \"label_position\": \"left\",\n        \"placement_pad\": 0.1,\n        \"label_pad\": 0.02,\n        \"label_color\": \"navy\",\n        \"linestyle\": \"-\",\n        \"alpha\": 0.6,\n    },\n)\n</code></pre></p>"},{"location":"tr/guides/plotting/decorations/#dikey-bantlar-vbands","title":"Dikey Bantlar (<code>vbands</code>)","text":"<ul> <li>Dikey b\u00f6lgeleri g\u00f6lgelendirmek i\u00e7in bir <code>(ba\u015flang\u0131\u00e7, biti\u015f)</code> demetleri listesi (iste\u011fe ba\u011fl\u0131 olarak renk i\u00e7in \u00fc\u00e7\u00fcnc\u00fc bir giri\u015fle) iletin: <code>(ba\u015flang\u0131\u00e7, biti\u015f)</code> varsay\u0131lan renk <code>C0</code>'\u0131 kullan\u0131r, <code>(ba\u015flang\u0131\u00e7, biti\u015f, \"teal\")</code> bunu ge\u00e7ersiz k\u0131lar.</li> <li><code>_apply_decor()</code>, <code>ba\u015flang\u0131\u00e7 &lt; biti\u015f</code> ko\u015fulunu zorunlu k\u0131lar ve <code>ax.axvspan(start, end, color=color, alpha=0.1)</code> kullanarak olu\u015fturur.</li> </ul> <p>\u00d6rnek: <pre><code>series.plot(\n    x=t,\n    y=x_traj,\n    vbands=[(2.5, 2.9, \"gold\"), (3.4, 3.6)],\n)\n</code></pre></p>"},{"location":"tr/guides/plotting/decorations/#yatay-bantlar-hbands","title":"Yatay Bantlar (<code>hbands</code>)","text":"<ul> <li><code>vbands</code> gibi davran\u0131r ancak yatay \u015feritleri doldurmak i\u00e7in <code>ax.axhspan()</code> kullan\u0131r. Demetler (tuples) iste\u011fe ba\u011fl\u0131 bir renk i\u00e7erebilir.</li> <li>Yard\u0131mc\u0131 fonksiyon \u00e7izimden \u00f6nce <code>ba\u015flang\u0131\u00e7 &lt; biti\u015f</code> kontrol\u00fc yapar ve <code>alpha=0.1</code> ile <code>color='C0'</code> varsay\u0131lan\u0131n\u0131 kullan\u0131r.</li> </ul> <p>\u00d6rnek: <pre><code>series.plot(\n    x=t,\n    y=x_traj,\n    hbands=[(0, 0.2), (0.8, 1.0, \"lightcoral\")],\n)\n</code></pre></p>"},{"location":"tr/guides/plotting/decorations/#ozel-kwargs-ozeti-tum-susleme-yardmclar","title":"\u00d6zel kwargs \u00f6zeti (t\u00fcm s\u00fcsleme yard\u0131mc\u0131lar\u0131)","text":"<ul> <li><code>vlines_kwargs</code> / <code>hlines_kwargs</code>, ola\u011fan Matplotlib \u00e7izgi arg\u00fcmanlar\u0131na ek olarak \u015fu etiket yerle\u015ftirme yard\u0131mc\u0131lar\u0131n\u0131 kabul eder: <code>label_position</code>, <code>placement_pad</code>, <code>label_pad</code>, <code>label_rotation</code>, <code>label_color</code>.</li> <li><code>placement_pad</code> ve <code>label_pad</code>, <code>&lt;1</code> de\u011ferlerini ilgili eksen aral\u0131\u011f\u0131n\u0131n kesri/oran\u0131 olarak, <code>&gt;=1</code> de\u011ferlerini ise veri birimi olarak ele al\u0131r; b\u00f6ylece g\u00f6receli ve mutlak ofsetler aras\u0131nda ge\u00e7i\u015f yapabilirsiniz.</li> <li>Demet (tuple) tabanl\u0131 \u00e7izgi tan\u0131mlar\u0131 (de\u011fer + etiket) otomatik metin olu\u015fturmay\u0131 tetikler; her etiketi global olarak \u00f6zelle\u015ftirmek i\u00e7in yine de <code>label_color</code> ve <code>label_rotation</code> sa\u011flayabilirsiniz.</li> <li>Bantlar (<code>vbands</code>, <code>hbands</code>) yaln\u0131zca <code>(ba\u015flang\u0131\u00e7, biti\u015f)</code> veya <code>(ba\u015flang\u0131\u00e7, biti\u015f, renk)</code> kabul eder ve demet uzunlu\u011fu yanl\u0131\u015f oldu\u011funda veya <code>ba\u015flang\u0131\u00e7 &gt;= biti\u015f</code> oldu\u011funda <code>ValueError</code> verir.</li> </ul> <p>Ba\u015fka eksen notasyonlar\u0131na (\u00f6rne\u011fin, manuel <code>text()</code> \u00e7a\u011fr\u0131lar\u0131 veya ekstra artistler) ihtiyac\u0131n\u0131z varsa, bunlar\u0131 bu s\u00fcslemelerle kar\u0131\u015ft\u0131rabilirsiniz; <code>_apply_decor()</code> eksen ba\u015f\u0131na yaln\u0131zca bir kez \u00e7al\u0131\u015f\u0131r ve di\u011fer artistlere dokunmaz.</p>"},{"location":"tr/guides/plotting/export/","title":"Grafikleri D\u0131\u015fa Aktarma","text":"<p><code>dynlib.plot.export</code> yard\u0131mc\u0131s\u0131, Matplotlib <code>savefig</code>/<code>show</code> i\u015f ak\u0131\u015f\u0131n\u0131 sarmalar; b\u00f6ylece tek bir panel, \u0131zgara d\u00fczeni veya daha \u00fcst d\u00fczey bir kapsay\u0131c\u0131 \u00e7iziyor olman\u0131z fark etmeksizin betikleriniz ayn\u0131 tutarl\u0131 varsay\u0131lanlar\u0131 korur.</p>"},{"location":"tr/guides/plotting/export/#cekirdek-fonksiyonlar","title":"\u00c7ekirdek Fonksiyonlar","text":""},{"location":"tr/guides/plotting/export/#exportsavefigfig_or_ax-path-fmtspng-dpi300-transparentfalse-pad001-metadatanone-bbox_inchestight","title":"<code>export.savefig(fig_or_ax, path, *, fmts=(\"png\",), dpi=300, transparent=False, pad=0.01, metadata=None, bbox_inches=\"tight\")</code>","text":"<ul> <li><code>fig_or_ax</code>, bir fig\u00fcr, eksen (axes) veya herhangi bir dynlib d\u00fczen nesnesini (<code>fig.grid</code>, <code>AxesGrid</code> vb.) kabul eder. Yard\u0131mc\u0131 fonksiyon alttaki fig\u00fcr\u00fc otomatik olarak bulur, b\u00f6ylece <code>fig.figure</code> nesnesini \u00e7a\u011f\u0131rmadan do\u011frudan \u00e7izim i\u015fleminden hemen sonra kullanabilirsiniz.</li> <li><code>path</code> bir uzant\u0131 i\u00e7erebilir (\u00f6rne\u011fin, <code>\"plots/phase.png\"</code>) veya i\u00e7ermeyebilir (\u00f6rne\u011fin, <code>\"plots/phase\"</code>). Bir uzant\u0131 iletti\u011finizde, yard\u0131mc\u0131 fonksiyon yaln\u0131zca o format\u0131 yazar; uzant\u0131y\u0131 atlay\u0131p <code>fmts</code> belirtirseniz birden fazla format\u0131 tek seferde kaydedebilirsiniz.</li> <li><code>fmts</code>, yoldan format \u00e7\u0131kar\u0131m\u0131 yap\u0131lmad\u0131\u011f\u0131 s\u00fcrece varsay\u0131lan olarak <code>(\"png\",)</code> de\u011ferini al\u0131r. Yard\u0131mc\u0131 fonksiyon, sa\u011flad\u0131\u011f\u0131n\u0131z de\u011ferleri normalize eder, kopyalar\u0131 temizler ve k\u00fc\u00e7\u00fck harfe \u00e7evirir; b\u00f6ylece ekstra ayr\u0131\u015ft\u0131rma yapmadan <code>(\".PNG\", \".pdf\")</code> ge\u00e7ebilirsiniz.</li> <li>Geri kalan anahtar kelime arg\u00fcmanlar\u0131 Matplotlib'in <code>savefig</code> fonksiyonunu yans\u0131t\u0131r. \u00c7\u00f6z\u00fcn\u00fcrl\u00fck i\u00e7in <code>dpi</code>, alfa arka planlar i\u00e7in <code>transparent</code>, bo\u015fluk eklemek i\u00e7in <code>pad</code> ve arama dostu etiketler yerle\u015ftirmek i\u00e7in <code>metadata</code> kullan\u0131n. <code>constrained_layout=True</code> ile dynlib'in <code>fig</code> yard\u0131mc\u0131lar\u0131na g\u00fcvendi\u011finizde, bu yard\u0131mc\u0131 fonksiyon s\u00fcslemeleri kesebilecek s\u0131k\u0131 (tight) bir s\u0131n\u0131rlay\u0131c\u0131 kutu uygulanmas\u0131n\u0131 otomatik olarak \u00f6nler.</li> </ul>"},{"location":"tr/guides/plotting/export/#exportshow","title":"<code>export.show()</code>","text":"<p>Matplotlib'in <code>plt.show()</code> fonksiyonunu tetiklemek i\u00e7in bir beti\u011fin, not defteri h\u00fccresinin sonunda veya herhangi bir etkile\u015fimli oturumda <code>export.show()</code> \u00e7a\u011fr\u0131s\u0131 yap\u0131n. Dynlib'in stilini takip eder, bu nedenle CLI kullan\u0131yor veya yard\u0131mc\u0131lar\u0131 bir betikte i\u00e7e aktar\u0131yor olman\u0131z fark etmeksizin fig\u00fcr numaraland\u0131rmas\u0131 ve d\u00fczenler ayn\u0131 \u015fekilde davran\u0131r.</p>"},{"location":"tr/guides/plotting/export/#en-iyi-uygulamalar","title":"En \u0130yi Uygulamalar","text":"<ul> <li><code>export</code> importlar\u0131n\u0131 \u00e7izim yard\u0131mc\u0131lar\u0131n\u0131z\u0131n yan\u0131nda tutun: <code>from dynlib.plot import fig, series, export</code>. Bu sayede her fig\u00fcr setinden sonra tutarl\u0131 bir \u015fekilde <code>export.show()</code> \u00e7a\u011f\u0131rabilirsiniz.</li> <li>Birden fazla format kaydederken, uzant\u0131y\u0131 <code>path</code>'ten \u00e7\u0131kar\u0131n ve <code>fmts</code>'ye g\u00fcvenin. \u00d6rne\u011fin, <code>export.savefig(ax, \"figures/lorenz\", fmts=(\"svg\",\"png\"))</code> \u00e7a\u011fr\u0131s\u0131, ayn\u0131 dpi/pad ayarlar\u0131yla <code>lorenz.svg</code> ve <code>lorenz.png</code> dosyalar\u0131n\u0131 yazar.</li> <li><code>axes = fig.grid(...)</code> gibi dynlib kapsay\u0131c\u0131lar\u0131n\u0131 veya <code>plot.vectorfield()</code> gibi yard\u0131mc\u0131lar\u0131n d\u00f6n\u00fc\u015f de\u011ferlerini do\u011frudan <code>savefig</code>'e iletin; <code>export</code>, fig\u00fcr\u00fc otomatik olarak bulmak i\u00e7in kapsay\u0131c\u0131y\u0131 tarar.</li> <li>Yay\u0131ma haz\u0131r g\u00f6rseller olu\u015ftururken aranabilir anahtar kelimeler veya yazar bilgisi i\u00e7in <code>metadata</code> (string anahtar/de\u011ferlerinden olu\u015fan bir s\u00f6zl\u00fck) kullan\u0131n.</li> </ul> <p>Uygulamal\u0131 bir \u00f6rnek ve daha fazla bi\u00e7imlendirme notu i\u00e7in Temel \u00e7izim rehberine d\u00f6n\u00fcn veya \u00e7izim dok\u00fcmanlar\u0131n\u0131n geri kalan\u0131n\u0131 inceleyin.</p>"},{"location":"tr/guides/plotting/manifold-plot/","title":"Manifold \u00c7izimleri","text":"<p><code>plot.manifold()</code>, 1B (bir boyutlu) manifold izlerini (kararl\u0131/karars\u0131z kollar, heteroklinik ba\u011flant\u0131lar, homoklinik d\u00f6ng\u00fcler) tutarl\u0131 bir stil ve lejant (g\u00f6sterge) y\u00f6netimi ile 2B izd\u00fc\u015f\u00fcmler olarak g\u00f6rselle\u015ftirir. Bu, manifold analizi ara\u00e7lar\u0131n\u0131n \u00e7izim arkada\u015f\u0131d\u0131r; b\u00f6ylece siz manifoldlar\u0131 \u00e7\u0131karmaya odaklanabilir ve analizlerin \u00fcretti\u011fi segmentleri g\u00f6rselle\u015ftirmek i\u00e7in bu yard\u0131mc\u0131ya g\u00fcvenebilirsiniz.</p>"},{"location":"tr/guides/plotting/manifold-plot/#yardmcnn-cizdigi-seyler","title":"Yard\u0131mc\u0131n\u0131n \u00e7izdi\u011fi \u015feyler","text":"<p><code>plot.manifold()</code>, bir manifold kolunu takip eden <code>(state_x, state_y)</code> (durum_x, durum_y) \u00f6rneklerinden olu\u015fan diziler bekler. Ham segmentleri veya daha \u00fcst seviye sonu\u00e7lar\u0131 kabul eder ve se\u00e7ilen durum bile\u015fenlerini <code>x</code>/<code>y</code> eksenlerine izd\u00fc\u015f\u00fcr\u00fcr. Sa\u011flanan her bir kol, ya bir <code>LineCollection</code> (d\u00fcz \u00e7izgiler i\u00e7in) ya da bireysel <code>plot</code> \u00e7a\u011fr\u0131lar\u0131 (i\u015faret\u00e7iler/marker istendi\u011finde) olarak g\u00f6r\u00fcn\u00fcr ve <code>None</code> olmayan bir etikete sahip herhangi bir kol otomatik olarak lejanta dahil edilir.</p>"},{"location":"tr/guides/plotting/manifold-plot/#veri-saglama-feeding-the-helper","title":"Veri sa\u011flama (Feeding the helper)","text":"<ul> <li>Segments (Segmentler): Her <code>arr</code>'in bir <code>(ad\u0131mlar, durumlar)</code> dizisi oldu\u011fu <code>segments=[arr1, arr2, \u2026]</code> yap\u0131s\u0131n\u0131 iletin. Yard\u0131mc\u0131 fonksiyon, her dizinin en az iki sat\u0131ra ve istenen <code>components</code> (bile\u015fenleri) kapsayacak kadar s\u00fctuna sahip olmas\u0131n\u0131 zorunlu k\u0131lar.</li> <li>Branches (Kollar): Pozitif/negatif kollar\u0131 kendiniz y\u00f6netiyorsan\u0131z <code>(branch_pos, branch_neg)</code> gibi bir <code>branches</code> demeti (tuple) sa\u011flay\u0131n. Her kol listesi birden fazla segment i\u00e7erebilir.</li> <li>Result objects (Sonu\u00e7 nesneleri): \u00c7o\u011fu manifold analizi sonucu, <code>plot.manifold()</code> ile uyumlu bir <code>branches</code> \u00f6zelli\u011fine (attribute) sahiptir, bu nedenle onlar\u0131 do\u011frudan iletebilirsiniz:</li> <li><code>dynlib.analysis.trace_manifold_1d_map(...)</code> / <code>trace_manifold_1d_ode(...)</code>, iki kol listesi (pozitif/negatif) i\u00e7eren <code>ManifoldTraceResult</code> d\u00f6nd\u00fcr\u00fcr.</li> <li><code>dynlib.analysis.heteroclinic_tracer(...)</code> ve <code>dynlib.analysis.homoclinic_tracer(...)</code> s\u0131ras\u0131yla <code>HeteroclinicTraceResult</code> ve <code>HomoclinicTraceResult</code> d\u00f6nd\u00fcr\u00fcr; her ikisi de <code>.branches</code> \u00f6zelli\u011fini (ikincisinin kollar\u0131 tek izlenen y\u00f6r\u00fcngeyi i\u00e7erir) ve ayr\u0131ca <code>.kind</code>/<code>.meta</code> \u00f6zelliklerini a\u00e7\u0131\u011fa \u00e7\u0131kar\u0131r, b\u00f6ylece <code>plot.manifold()</code> bunlar\u0131 otomatik olarak etiketler.</li> <li>Kendi segmentlerinizi \u00f6zel bir yap\u0131da sarmal\u0131yorsan\u0131z, <code>result=\u2026</code> olarak ge\u00e7meden \u00f6nce bu yap\u0131n\u0131n, iki demetlik (tuple) dizilere \u00e7\u00f6z\u00fcmlenen bir <code>branches</code> \u00f6zelli\u011fi sa\u011flad\u0131\u011f\u0131ndan emin olun.</li> </ul> <pre><code>from dynlib import setup\nfrom dynlib.analysis import trace_manifold_1d_map, heteroclinic_tracer\nfrom dynlib.plot import fig, manifold\n\nsim = setup(\"models/henon.map\", stepper=\"map\")\nunstable = trace_manifold_1d_map(sim, kind=\"unstable\", branch_len=500)\nhex_trace = heteroclinic_tracer(sim, source_eq=\"E0\", target_eq=\"E1\", preset=\"default\")\n\nax = fig.single()\nmanifold(result=unstable, components=(0, 1), label=\"Karars\u0131z manifold\", ax=ax)\nmanifold(result=hex_trace, components=(0, 1), style=\"discrete\", label=\"Heteroklinik y\u00f6r\u00fcnge\", ax=ax)\n</code></pre>"},{"location":"tr/guides/plotting/manifold-plot/#kollar-stillendirme","title":"Kollar\u0131 stillendirme","text":"<p><code>style</code>, <code>color</code>, <code>lw</code>, <code>ls</code>, <code>marker</code>, <code>ms</code> ve <code>alpha</code> di\u011fer <code>plot</code> yard\u0131mc\u0131lar\u0131 gibi davran\u0131r, ancak <code>style</code> ayr\u0131ca yerle\u015fik haz\u0131r ayarlar\u0131 da kabul eder:</p> <ul> <li><code>\"continuous\"</code>, <code>\"flow\"</code> / <code>\"cont\"</code>: \u0130\u015faret\u00e7isiz d\u00fcz \u00e7izgi (ODE kaynakl\u0131 kollar i\u00e7in idealdir).</li> <li><code>\"discrete\"</code>, <code>\"map\"</code>: Sadece i\u015faret\u00e7i (ayr\u0131k zamanl\u0131 manifoldlar i\u00e7in iyidir).</li> <li><code>\"mixed\"</code> / <code>\"connected\"</code>: \u00c7izgilerle birbirine ba\u011flanan i\u015faret\u00e7iler.</li> <li><code>\"line\"</code> / <code>\"scatter\"</code>: Sadece \u00e7izgiler veya sadece i\u015faret\u00e7iler i\u00e7in a\u00e7\u0131k k\u0131saltmalar.</li> </ul> <p>Kol baz\u0131nda ge\u00e7ersiz k\u0131lmalar <code>groups</code> ile y\u00f6netilir. Her grup bir e\u015fleme (<code>{\"segments\": \u2026, \"label\": \u2026, \"style\": \u2026}</code>) veya bir demettir <code>(segments, label?, style?)</code> (? iste\u011fe ba\u011fl\u0131 demektir; <code>None</code> olabilir). Yard\u0131mc\u0131 fonksiyon k\u00fcresel <code>style</code>'\u0131 devral\u0131r ancak her grup i\u00e7in haz\u0131r ayar ge\u00e7ersiz k\u0131lmalar\u0131n\u0131 veya a\u00e7\u0131k e\u015flemeleri kar\u0131\u015ft\u0131r\u0131r; bu da kararl\u0131 kolu karars\u0131z koldan veya heteroklinik izden farkl\u0131 renklendirmenize olanak tan\u0131r.</p>"},{"location":"tr/guides/plotting/manifold-plot/#izdusum-ve-eksen-secimi","title":"\u0130zd\u00fc\u015f\u00fcm ve eksen se\u00e7imi","text":"<p>Hangi durum indislerinin (<code>int</code> t\u00fcr\u00fcnde) \u00e7izilece\u011fini se\u00e7mek i\u00e7in <code>components=(i, j)</code> kullan\u0131n (\u00f6rne\u011fin, ilk iki durum i\u00e7in <code>(0, 1)</code>). Bile\u015fenler farkl\u0131 olmal\u0131 ve sa\u011flanan segmentlerin boyutsall\u0131\u011f\u0131 i\u00e7inde kalmal\u0131d\u0131r.</p> <p>Eksen etiketleri, limitler ve en boy oranlar\u0131 \u015funlarla kontrol edilir:</p> <ul> <li><code>xlabel</code>, <code>ylabel</code>, <code>title</code>, <code>xlabel_fs</code>, <code>ylabel_fs</code>, <code>title_fs</code></li> <li><code>xlim</code>, <code>ylim</code>, <code>aspect</code>, <code>xlabel_rot</code>, <code>ylabel_rot</code></li> <li><code>xpad</code>, <code>ypad</code>, <code>titlepad</code> ekstra bo\u015fluklar i\u00e7in</li> </ul> <p>Sonucunuz meta veriler sa\u011fl\u0131yorsa (\u00f6rne\u011fin, bir <code>ManifoldTraceResult</code>'tan gelen <code>result.meta</code>), <code>manifold()</code> \u00e7a\u011f\u0131rmadan \u00f6nce \u00e7izim ba\u015fl\u0131\u011f\u0131n\u0131/etiketlerini not etmek i\u00e7in bunu yeniden kullanabilirsiniz.</p> <p><code>plot.manifold()</code> bir <code>Axes</code> (eksen) nesnesi d\u00f6nd\u00fcr\u00fcr, b\u00f6ylece \u00c7izim S\u00fcslemeleri b\u00f6l\u00fcm\u00fcnde a\u00e7\u0131kland\u0131\u011f\u0131 gibi s\u00fcslemeler (dikey/yatay \u00e7izgiler, bantlar) katmanlayabilir veya manifoldu <code>fig.grid()</code>/<code>plot.fig()</code> taraf\u0131ndan olu\u015fturulan \u00e7ok panelli fig\u00fcrlere entegre edebilirsiniz.</p>"},{"location":"tr/guides/plotting/manifold-plot/#lejant-ve-gruplama-ipuclar","title":"Lejant ve gruplama ipu\u00e7lar\u0131","text":"<ul> <li>Her kolu etiketlemek i\u00e7in yard\u0131mc\u0131 \u00fczerinde veya <code>groups</code> arac\u0131l\u0131\u011f\u0131yla <code>label=</code> ayarlay\u0131n. Lejant yaln\u0131zca en az bir etiket ayarland\u0131ysa ve <code>legend=True</code> (varsay\u0131lan) ise g\u00f6r\u00fcn\u00fcr.</li> <li>Farkl\u0131 stillere veya renklere sahip kol par\u00e7alar\u0131n\u0131 \u00fcst \u00fcste bindirmek i\u00e7in <code>groups</code> kullan\u0131n (\u00f6rne\u011fin, heteroklinik bir izin ilk segmentini daha kal\u0131n bir \u00e7izgiyle vurgularken geri kalan\u0131n\u0131 ince tutmak gibi).</li> <li>Birden fazla manifoldu birlikte \u00e7izerken (\u00f6rne\u011fin, kararl\u0131 vs. karars\u0131z), yinelenen tutama\u00e7lardan ka\u00e7\u0131nmak i\u00e7in <code>legend=True</code> de\u011ferini yaln\u0131zca son \u00e7a\u011fr\u0131da iletin.</li> </ul>"},{"location":"tr/guides/plotting/manifold-plot/#ipuclar","title":"\u0130pu\u00e7lar\u0131","text":"<ul> <li>Yaln\u0131zca pencereli bir g\u00f6r\u00fcn\u00fcm istiyorsan\u0131z, \u00e7izimden \u00f6nce b\u00fcy\u00fck sonu\u00e7 dizilerini dilimleyin; yard\u0131mc\u0131 fonksiyon sa\u011flanan segmentlere tam olarak uyar.</li> <li>Ayn\u0131 <code>ax=</code> de\u011ferini ge\u00e7irerek ve <code>legend</code>'\u0131 kontrol ederek <code>plot.manifold()</code>'u di\u011fer \u00e7izim yard\u0131mc\u0131lar\u0131yla (faz portreleri, zaman serileri) birle\u015ftirin.</li> <li>\u0130\u015faret\u00e7iler istenmedi\u011finde <code>linecollection</code> kullan\u0131ld\u0131\u011f\u0131ndan, <code>alpha</code>/<code>linewidth</code> t\u00fcm segmentlere e\u015fit olarak uygulan\u0131r.</li> <li>Ayn\u0131 stili \u00e7a\u011fr\u0131lar aras\u0131nda yeniden kullanmak istiyorsan\u0131z, haz\u0131r ayar dizesini tekrarlamak yerine bir s\u00f6zl\u00fck tutun ve her grup i\u00e7in g\u00fcncelleyin (<code>style={\"color\": \"C0\"}</code>).</li> </ul> <p><code>plot.manifold()</code>, analiz ara\u00e7lar\u0131n\u0131n g\u00f6r\u00fcn\u00fcm\u00fcn\u00fc ve i\u015f ak\u0131\u015f\u0131n\u0131 yans\u0131t\u0131r, bu nedenle bir <code>ManifoldTraceResult</code>, <code>HeteroclinicTraceResult</code> veya <code>HomoclinicTraceResult</code> elde etti\u011finizde, ek veri d\u00fczenlemesi yapmadan manifoldu belgeleyebilir ve stillendirebilirsiniz.</p>"},{"location":"tr/guides/plotting/themes-and-facets/","title":"Temalar &amp; Facet'ler (B\u00f6l\u00fcmlendirme)","text":"<p>Dynlib'in \u00e7izim sistemi, tutarl\u0131 ve yay\u0131na haz\u0131r fig\u00fcrler olu\u015fturmak i\u00e7in g\u00fc\u00e7l\u00fc tema ve facet (b\u00f6l\u00fcmlendirme) yetenekleri sa\u011flar. Bu rehber, stil olu\u015fturmak i\u00e7in <code>plot.theme</code> kullan\u0131m\u0131n\u0131 ve \u00e7ok panelli d\u00fczenler i\u00e7in <code>plot.fig</code>/<code>plot.facet</code> kullan\u0131m\u0131n\u0131 kapsar.</p>"},{"location":"tr/guides/plotting/themes-and-facets/#temalara-genel-baks","title":"Temalara Genel Bak\u0131\u015f","text":"<p>Dynlib'deki temalar, t\u00fcm \u00e7izimlerin g\u00f6rsel g\u00f6r\u00fcn\u00fcm\u00fcn\u00fc kontrol ederek fig\u00fcrler aras\u0131nda tutarl\u0131l\u0131k sa\u011flar. Tema sistemi \u015funlar\u0131 y\u00f6netir:</p> <ul> <li>Yaz\u0131 tipi boyutlar\u0131 ve aileleri</li> <li>\u00c7izgi geni\u015flikleri ve i\u015faret\u00e7i (marker) stilleri</li> <li>Renk paletleri</li> <li>Izgara (grid) ve arka plan ayarlar\u0131</li> <li>Bo\u015fluklar ve kenar bo\u015fluklar\u0131</li> </ul> <p>Temalar k\u00fcresel olarak uygulan\u0131r ve de\u011fi\u015ftirilene kadar sonraki t\u00fcm \u00e7izimleri etkiler.</p>"},{"location":"tr/guides/plotting/themes-and-facets/#yerlesik-hazr-ayarlar-presets","title":"Yerle\u015fik Haz\u0131r Ayarlar (Presets)","text":"<p>Dynlib, farkl\u0131 kullan\u0131m durumlar\u0131 i\u00e7in optimize edilmi\u015f birka\u00e7 \u00f6nceden tan\u0131ml\u0131 tema i\u00e7erir:</p> <ul> <li>notebook: Dengeli stillendirme ile etkile\u015fimli Jupyter not defterleri i\u00e7in varsay\u0131lan tema.</li> <li>paper: Yay\u0131nlar i\u00e7in temiz tema; ince \u0131zgaralar devre d\u0131\u015f\u0131 b\u0131rak\u0131lm\u0131\u015f ve yaz\u0131 tipi boyutlar\u0131 optimize edilmi\u015ftir.</li> <li>talk: Sunumlar i\u00e7in y\u00fcksek kontrastl\u0131 tema; daha b\u00fcy\u00fck \u00f6\u011feler ve daha kal\u0131n \u00e7izgiler i\u00e7erir.</li> <li>dark: Daha iyi g\u00f6r\u00fcn\u00fcrl\u00fck i\u00e7in ayarlanm\u0131\u015f renklere sahip koyu arka planl\u0131 tema.</li> <li>mono: Gri tonlamal\u0131 renkler kullanan monokrom tema.</li> </ul>"},{"location":"tr/guides/plotting/themes-and-facets/#temalar-kullanma","title":"Temalar\u0131 Kullanma","text":"<p>\u00c7izim senaryonuzun ba\u015f\u0131nda bir tema ayarlay\u0131n:</p> <pre><code>from dynlib.plot import theme\n\n# Bir haz\u0131r ayar kullan\ntheme.use(\"paper\")\n\n# Veya bir haz\u0131r ayar\u0131n \u00fczerine \u00f6zelle\u015ftirme yap\ntheme.use(\"notebook\", tokens={\"scale\": 1.2, \"grid\": False})\n</code></pre>"},{"location":"tr/guides/plotting/themes-and-facets/#temalar-ozellestirme","title":"Temalar\u0131 \u00d6zelle\u015ftirme","text":"<p>Haz\u0131r ayarlar\u0131 de\u011fi\u015ftirmeden tema ayarlar\u0131n\u0131 modifiye edebilirsiniz:</p> <pre><code># Ayarlar\u0131 ge\u00e7ici olarak d\u00fczenle\ntheme.update(tokens={\"fontsize_title\": 16, \"line_w\": 2.0})\n\n# Veya kapsaml\u0131 de\u011fi\u015fiklikler i\u00e7in push/pop kullan\ntheme.push(tokens={\"palette\": \"mono\"})\n# ... \u00e7izimleri olu\u015ftur ...\ntheme.pop()  # \u00d6nceki temaya geri d\u00f6ner\n</code></pre>"},{"location":"tr/guides/plotting/themes-and-facets/#renk-paletleri","title":"Renk Paletleri","text":"<p>Dynlib birden fazla renk paletini destekler:</p> <ul> <li>classic: Standart Matplotlib renkleri</li> <li>cbf: Renk k\u00f6r\u00fc dostu palet (eri\u015filebilirlik i\u00e7in \u00f6nerilir)</li> <li>mono: Gri tonlamal\u0131 palet</li> </ul> <p>\u00d6zel paletleri kaydedin:</p> <pre><code>theme.register_palette(\"my_colors\", [\"#ff0000\", \"#00ff00\", \"#0000ff\"])\ntheme.use(\"notebook\", tokens={\"palette\": \"my_colors\"})\n</code></pre>"},{"location":"tr/guides/plotting/themes-and-facets/#tema-jetonlar-tokens","title":"Tema Jetonlar\u0131 (Tokens)","text":"<p>Temalar, bireysel stil \u00f6zelliklerini belirten jetonlar taraf\u0131ndan kontrol edilir. Temel jetonlar \u015funlard\u0131r:</p> <ul> <li>scale: Genel boyut \u00e7arpan\u0131</li> <li>fontsize_*: Farkl\u0131 \u00f6\u011feler i\u00e7in yaz\u0131 tipi boyutlar\u0131 (temel, etiket, ba\u015fl\u0131k vb.)</li> <li>line_w: \u00c7izgi geni\u015fli\u011fi</li> <li>marker_size: \u0130\u015faret\u00e7i boyutu</li> <li>grid: Izgara \u00e7izgilerinin g\u00f6sterilip g\u00f6sterilmeyece\u011fi</li> <li>palette: Renk paleti ad\u0131</li> <li>background: \"light\" (a\u00e7\u0131k) veya \"dark\" (koyu)</li> </ul> <p>Mevcut jeton de\u011ferlerine eri\u015fim:</p> <pre><code>current_scale = theme.get(\"scale\")\nfont_size = theme.get(\"fontsize_title\")\n</code></pre>"},{"location":"tr/guides/plotting/themes-and-facets/#figur-izgaralar-ve-duzenleri","title":"Fig\u00fcr Izgaralar\u0131 ve D\u00fczenleri","text":"<p>Dynlib, temalarla sorunsuz \u00e7al\u0131\u015fan fig\u00fcr d\u00fczenleri olu\u015fturmak i\u00e7in \u00fcst d\u00fczey yard\u0131mc\u0131lar sa\u011flar.</p>"},{"location":"tr/guides/plotting/themes-and-facets/#temel-figur-olusturma","title":"Temel Fig\u00fcr Olu\u015fturma","text":"<pre><code>from dynlib.plot import fig\n\n# Tek \u00e7izim\nax = fig.single(title=\"Grafi\u011fim\")\n\n# Alt \u00e7izimlerden (subplots) olu\u015fan \u0131zgara\naxes = fig.grid(rows=2, cols=3, title=\"Parametre Taramas\u0131\")\n\n# 3B \u00e7izim\nax_3d = fig.single3D(title=\"3B Y\u00f6r\u00fcnge\")\n\n# Alt \u00e7izimleri saran (wrap) esnek \u0131zgara\naxes = fig.wrap(n=7, cols=3)  # 3x3 \u0131zgara olu\u015fturur, son 2 ekseni gizler\n</code></pre> <p>T\u00fcm <code>fig</code> yard\u0131mc\u0131lar\u0131 \u00f6zelle\u015ftirme i\u00e7in parametreler kabul eder:</p> <ul> <li><code>size</code>: (geni\u015flik, y\u00fckseklik) demeti olarak fig\u00fcr boyutu</li> <li><code>scale</code>: Boyut \u00e7arpan\u0131</li> <li><code>sharex</code>/<code>sharey</code>: Eksenlerin payla\u015f\u0131l\u0131p payla\u015f\u0131lmayaca\u011f\u0131</li> <li><code>title</code>: Fig\u00fcr ba\u015fl\u0131\u011f\u0131</li> </ul>"},{"location":"tr/guides/plotting/themes-and-facets/#cizim-ile-entegrasyon","title":"\u00c7izim ile Entegrasyon","text":"<p>Olu\u015fturulan eksenleri \u00e7izim fonksiyonlar\u0131na iletin:</p> <pre><code>from dynlib.plot import fig, series\n\nax = fig.single()\nseries.plot(x=time, y=signal, ax=ax, label=\"Sinyal\")\n</code></pre>"},{"location":"tr/guides/plotting/themes-and-facets/#cok-panelli-figurler-icin-facetleme-faceting","title":"\u00c7ok Panelli Fig\u00fcrler i\u00e7in Facetleme (Faceting)","text":"<p>Facetleme, \u0131zgaralar\u0131 otomatik olarak olu\u015fturur ve veri kategorileri \u00fczerinde yineleme yapar; bu parametre taramalar\u0131 veya grupland\u0131r\u0131lm\u0131\u015f veriler i\u00e7in m\u00fckemmeldir.</p>"},{"location":"tr/guides/plotting/themes-and-facets/#temel-facetleme","title":"Temel Facetleme","text":"<pre><code>from dynlib.plot import facet, series\n\n# Farkl\u0131 parametreler i\u00e7in veriler\ndata = {\n    \"r=2.5\": trajectory_r25,\n    \"r=3.0\": trajectory_r30,\n    \"r=3.5\": trajectory_r35,\n}\n\n# Facet'lenmi\u015f \u00e7izim olu\u015ftur\nfor ax, param in facet.wrap(data.keys(), cols=2, title=\"Bifurkasyon Analizi\"):\n    traj = data[param]\n    series.plot(x=time, y=traj, ax=ax, title=param)\n</code></pre> <p><code>facet.wrap</code> fonksiyonu:</p> <ul> <li>Bir anahtar (kategoriler) yinelenebilir nesnesi al\u0131r</li> <li>Belirtilen say\u0131da s\u00fctuna sahip bir \u0131zgara olu\u015fturur</li> <li>Yineleme i\u00e7in (eksen, anahtar) \u00e7iftleri \u00fcretir</li> <li>D\u00fczeni otomatik olarak y\u00f6netir ve kullan\u0131lmayan eksenleri gizler</li> </ul>"},{"location":"tr/guides/plotting/themes-and-facets/#facetleme-parametreleri","title":"Facetleme Parametreleri","text":"<ul> <li><code>cols</code>: Izgaradaki s\u00fctun say\u0131s\u0131</li> <li><code>title</code>: Genel fig\u00fcr ba\u015fl\u0131\u011f\u0131</li> <li><code>size</code>, <code>scale</code>: Fig\u00fcr boyutland\u0131rma</li> <li><code>sharex</code>/<code>sharey</code>: Eksen payla\u015f\u0131m\u0131</li> </ul>"},{"location":"tr/guides/plotting/themes-and-facets/#ileri-seviye-facetleme-ornegi","title":"\u0130leri Seviye Facetleme \u00d6rne\u011fi","text":"<pre><code>import numpy as np\nfrom dynlib.plot import facet, series, theme\n\n# Parametre taramas\u0131\nr_values = np.linspace(2.8, 4.0, 12)\n\ntheme.use(\"paper\")\nfor ax, r in facet.wrap(r_values, cols=4, title=\"Lojistik Harita Bifurkasyonlar\u0131\"):\n    # Bu r de\u011feri i\u00e7in y\u00f6r\u00fcnge sim\u00fcle et\n    x = 0.1\n    traj = [x]\n    for _ in range(100):\n        x = r * x * (1 - x)\n        traj.append(x)\n\n    series.plot(x=range(len(traj)), y=traj, ax=ax, title=f\"r={r:.1f}\")\n</code></pre>"},{"location":"tr/guides/plotting/themes-and-facets/#en-iyi-uygulamalar","title":"En \u0130yi Uygulamalar","text":"<ol> <li> <p>Temalar\u0131 erken ayarlay\u0131n: Herhangi bir fig\u00fcr olu\u015fturmadan \u00f6nce senaryonuzun ba\u015f\u0131nda temalar\u0131 uygulay\u0131n.</p> </li> <li> <p>Tutarl\u0131 paletler kullan\u0131n: Daha iyi eri\u015filebilirlik i\u00e7in \"cbf\" gibi renk k\u00f6r\u00fc dostu paletleri tercih edin.</p> </li> <li> <p>Facetlemeden yararlan\u0131n: Parametre taramalar\u0131 veya grupland\u0131r\u0131lm\u0131\u015f veriler i\u00e7in facetleme, tekrar eden kodlar\u0131 (boilerplate) azalt\u0131r.</p> </li> <li> <p>D\u00fc\u015f\u00fcnerek \u00f6zelle\u015ftirin: Tamamen yeni temalar olu\u015fturmak yerine k\u00fc\u00e7\u00fck ayarlamalar i\u00e7in <code>theme.update()</code> kullan\u0131n.</p> </li> <li> <p>De\u011fi\u015fiklikleri kapsamland\u0131r\u0131n: Ge\u00e7ici tema modifikasyonlar\u0131 i\u00e7in <code>theme.push()</code>/<code>pop()</code> kullan\u0131n.</p> </li> <li> <p>Uygun \u015fekilde boyutland\u0131r\u0131n: Farkl\u0131 \u00e7\u0131kt\u0131lar (ekran veya bask\u0131) i\u00e7in fig\u00fcr boyutlar\u0131n\u0131 ayarlamak ad\u0131na <code>scale</code> parametresini veya tema jetonlar\u0131n\u0131 kullan\u0131n.</p> </li> </ol> <p>Temalar ve facetleme, ister ke\u015fifsel analiz ister yay\u0131n fig\u00fcrleri i\u00e7in olsun, dynlib \u00e7izimlerinizin profesyonel ve tutarl\u0131 olmas\u0131n\u0131 sa\u011flamak i\u00e7in birlikte \u00e7al\u0131\u015f\u0131r.</p>"},{"location":"tr/guides/plotting/vectorfields/","title":"Vekt\u00f6r Alanlar\u0131 ve Vekt\u00f6r Alan\u0131 Animasyonlar\u0131","text":"<p>Vekt\u00f6r alanlar\u0131, dinamik sistemlerdeki de\u011fi\u015fimin y\u00f6n\u00fcn\u00fc ve b\u00fcy\u00fckl\u00fc\u011f\u00fcn\u00fc g\u00f6rselle\u015ftirir. Dynlib'de vekt\u00f6r alanlar\u0131, sistemin sa\u011f taraf (RHS) denklemlerini 2B bir nokta \u0131zgaras\u0131 \u00fczerinde de\u011ferlendirerek ve her bir noktadan y\u00f6r\u00fcngelerin nas\u0131l evrilece\u011fini g\u00f6stererek hesaplan\u0131r.</p> <p>Bu rehberdaki \u00e7o\u011fu kod par\u00e7as\u0131 <code>from dynlib import build, plot</code> yap\u0131ld\u0131\u011f\u0131n\u0131 varsayar. Taramalar (sweeps) veya animasyonlar i\u00e7in say\u0131sal dizilere ihtiyac\u0131m\u0131z oldu\u011funda, <code>numpy</code>'\u0131n da <code>import numpy as np</code> \u015feklinde i\u00e7e aktar\u0131ld\u0131\u011f\u0131n\u0131 g\u00f6receksiniz.</p>"},{"location":"tr/guides/plotting/vectorfields/#temel-vektor-alan-cizimi","title":"Temel Vekt\u00f6r Alan\u0131 \u00c7izimi","text":"<p>Vekt\u00f6r alanlar\u0131n\u0131 \u00e7izmek i\u00e7in temel fonksiyon <code>plot.vectorfield()</code> fonksiyonudur. Modelinizin denklemlerini bir \u0131zgara \u00fczerinde de\u011ferlendirir ve ortaya \u00e7\u0131kan vekt\u00f6rleri g\u00f6r\u00fcnt\u00fcler.</p>"},{"location":"tr/guides/plotting/vectorfields/#basit-ornek","title":"Basit \u00d6rnek","text":"<pre><code>from dynlib import build, plot\n\n# Basit bir 2B sistem tan\u0131mla\nmodel_uri = \"\"\"\ninline:\n[model]\ntype = \"ode\"\n\n[states]\nx = 0.0\ny = 0.0\n\n[params]\na = 1.0\nb = -1.0\n\n[equations.rhs]\nx = \"a * x + y\"\ny = \"b * x + y\"\n\"\"\"\n\n# setup() ile olu\u015fturulan bir Sim nesnesi de ge\u00e7irebilirsiniz\nmodel = build(model_uri)\nplot.theme.use(\"notebook\")\n\n# Vekt\u00f6r alan\u0131n\u0131 \u00e7iz\nplot.vectorfield(\n    model,\n    xlim=(-2, 2),\n    ylim=(-2, 2),\n    grid=(25, 25)\n)\n\nplot.export.show()\n</code></pre> <p><code>build()</code> (veya <code>setup()</code>) fonksiyonuna sat\u0131r i\u00e7i (inline) DSL ge\u00e7irirken, dynlib'in i\u00e7eri\u011fi bir yol yerine g\u00f6m\u00fcl\u00fc model tan\u0131m\u0131 olarak ele almas\u0131 i\u00e7in dizeyi yukar\u0131da g\u00f6sterildi\u011fi gibi <code>inline:</code> ile ba\u015flat\u0131n.</p>"},{"location":"tr/guides/plotting/vectorfields/#vektor-alan-secenekleri","title":"Vekt\u00f6r Alan\u0131 Se\u00e7enekleri","text":""},{"location":"tr/guides/plotting/vectorfields/#izgara-ve-limitler","title":"Izgara ve Limitler","text":"<ul> <li><code>xlim</code>, <code>ylim</code>: \u00c7izim s\u0131n\u0131rlar\u0131n\u0131 belirten demetler (varsay\u0131lan: <code>(-1, 1)</code>)</li> <li><code>grid</code>: Izgara \u00e7\u00f6z\u00fcn\u00fcrl\u00fc\u011f\u00fcn\u00fc belirten <code>(nx, ny)</code> demeti (varsay\u0131lan: <code>(20, 20)</code>)</li> </ul> <p>Y\u00fcksek \u0131zgara de\u011ferleri daha p\u00fcr\u00fczs\u00fcz, daha detayl\u0131 \u00e7izimler sa\u011flar ancak hesaplanmas\u0131 daha uzun s\u00fcrer.</p>"},{"location":"tr/guides/plotting/vectorfields/#degisken-secimi","title":"De\u011fi\u015fken Se\u00e7imi","text":"<p>2'den fazla de\u011fi\u015fkene sahip sistemler i\u00e7in, hangilerinin \u00e7izilece\u011fini belirtin:</p> <pre><code># 3B Lorenz sistemi i\u00e7in\nplot.vectorfield(\n    model,\n    vars=(\"x\", \"y\"),  # x'e kar\u015f\u0131 y \u00e7iz\n    fixed={\"z\": 10.0},  # z'yi 10'da sabitle\n    xlim=(-20, 20),\n    ylim=(-30, 30)\n)\n</code></pre>"},{"location":"tr/guides/plotting/vectorfields/#vektor-normalizasyonu","title":"Vekt\u00f6r Normalizasyonu","text":"<ul> <li><code>normalize=True</code>: T\u00fcm vekt\u00f6rleri birim uzunlu\u011fa \u00f6l\u00e7ekler, yaln\u0131zca y\u00f6n\u00fc g\u00f6sterir.</li> <li><code>normalize=False</code> (varsay\u0131lan): Ger\u00e7ek b\u00fcy\u00fckl\u00fckleri g\u00f6sterir.</li> </ul> <pre><code># Normalle\u015ftirilmi\u015f ile b\u00fcy\u00fckl\u00fc\u011f\u00fc koruyan kar\u015f\u0131la\u015ft\u0131rmas\u0131\nplot.vectorfield(model, normalize=True)   # Ak\u0131\u015f y\u00f6nlerini g\u00f6sterir\nplot.vectorfield(model, normalize=False)  # Ak\u0131\u015f h\u0131zlar\u0131n\u0131 g\u00f6sterir\n</code></pre>"},{"location":"tr/guides/plotting/vectorfields/#renklendirme-secenekleri","title":"Renklendirme Se\u00e7enekleri","text":""},{"location":"tr/guides/plotting/vectorfields/#tek-renk","title":"Tek Renk","text":"<pre><code>plot.vectorfield(model, color=\"blue\")\n</code></pre> <p><code>color</code> arg\u00fcman\u0131 do\u011frudan Matplotlib'e akar, bu nedenle tutarl\u0131 bir palet i\u00e7in herhangi bir isimlendirilmi\u015f renk, hex dizesi veya RGBA demeti kullanabilirsiniz.</p>"},{"location":"tr/guides/plotting/vectorfields/#hza-dayal-renklendirme","title":"H\u0131za Dayal\u0131 Renklendirme","text":"<p>Vekt\u00f6rleri b\u00fcy\u00fckl\u00fcklerine g\u00f6re renklendirin:</p> <pre><code>plot.vectorfield(\n    model,\n    speed_color=True,\n    speed_cmap=\"plasma\",\n    normalize=False  # H\u0131z renklendirmesi en iyi ger\u00e7ek b\u00fcy\u00fckl\u00fcklerle \u00e7al\u0131\u015f\u0131r\n)\n</code></pre> <p>Farkl\u0131 \u00e7izimleri ayn\u0131 \u00f6l\u00e7ekte kar\u015f\u0131la\u015ft\u0131rabilmek i\u00e7in tam aral\u0131\u011f\u0131 manuel olarak sabitlemek \u00fczere <code>speed_norm</code> ge\u00e7irin (veya <code>share_speed_norm=True</code> ile bir taraman\u0131n payla\u015f\u0131lan normu hesaplamas\u0131n\u0131 sa\u011flay\u0131n).</p>"},{"location":"tr/guides/plotting/vectorfields/#cizim-modlar","title":"\u00c7izim Modlar\u0131","text":"<ul> <li><code>mode=\"quiver\"</code> (varsay\u0131lan): Ok/sadak (quiver) \u00e7izimi</li> <li><code>mode=\"stream\"</code>: Matplotlib'in streamplot'unu kullanan ak\u0131\u015f \u00e7izgisi (streamline) \u00e7izimi</li> </ul> <pre><code># Ak\u0131\u015f \u00e7izgileri, yo\u011fun ak\u0131\u015flar i\u00e7in daha p\u00fcr\u00fczs\u00fcz olabilir\nplot.vectorfield(model, mode=\"stream\", speed_color=True)\n</code></pre>"},{"location":"tr/guides/plotting/vectorfields/#nullclinelar-sfr-egrileri","title":"Nullcline'lar (S\u0131f\u0131r E\u011frileri)","text":"<p>Nullcline'lar, sistemin x veya y y\u00f6nlerinde s\u0131f\u0131r h\u0131za sahip oldu\u011fu yerleri g\u00f6sterir:</p> <pre><code>plot.vectorfield(\n    model,\n    nullclines=True,\n    nullcline_style={\"colors\": [\"red\", \"blue\"], \"linewidths\": 1.5}\n)\n</code></pre> <p>Do\u011fruluk i\u00e7in nullcline'lar varsay\u0131lan olarak daha yo\u011fun bir \u0131zgara \u00fczerinde hesaplan\u0131r.</p> <p>Daha ince konturlara veya ana \u0131zgaraya g\u00f6re yeniden boyutland\u0131rmaya ihtiyac\u0131n\u0131z oldu\u011funda <code>nullcline_grid</code> kullan\u0131n.</p>"},{"location":"tr/guides/plotting/vectorfields/#etkilesimli-ozellikler","title":"Etkile\u015fimli \u00d6zellikler","text":"<p><code>plot.vectorfield</code>, bir <code>VectorFieldHandle</code> d\u00f6nd\u00fcr\u00fcr; b\u00f6ylece oklar\u0131 \u00e7izen ayn\u0131 \u00e7a\u011fr\u0131, size g\u00fcncelleyebilece\u011finiz, sim\u00fcle edebilece\u011finiz veya temizleyebilece\u011finiz programatik bir tutama\u00e7 (handle) da verir. A\u015fa\u011f\u0131da a\u00e7\u0131klanan t\u0131klama/dokunma geri \u00e7a\u011fr\u0131mlar\u0131na (callbacks) ba\u011flanmak i\u00e7in <code>interactive=True</code> ge\u00e7irin veya \u00e7izimi yeniden olu\u015fturmadan yeni parametrelerle/sabit durumlarla yeniden \u00e7izmek i\u00e7in <code>handle.update()</code> \u00e7a\u011f\u0131r\u0131n.</p> <p>Y\u00f6r\u00fcngeleri ke\u015ffetmek i\u00e7in etkile\u015fimli \u00e7izimi etkinle\u015ftirin:</p> <pre><code>handle = plot.vectorfield(\n    model,\n    interactive=True,\n    T=10.0,  # Y\u00f6r\u00fcnge s\u00fcresi\n    trajectory_style={\"color\": \"red\", \"linewidth\": 2}\n)\n</code></pre> <p>Etkile\u015fimli Kontroller: - O noktadan bir y\u00f6r\u00fcnge ba\u015flatmak i\u00e7in \u00e7izim \u00fczerinde herhangi bir yere T\u0131klay\u0131n - Nullcline'lar\u0131 a\u00e7mak/kapatmak i\u00e7in N tu\u015funa bas\u0131n - \u00c7izilen y\u00f6r\u00fcngeleri temizlemek i\u00e7in C tu\u015funa bas\u0131n <code>handle.clear_trajectories()</code> de programatik olarak s\u0131f\u0131rlamak isterseniz toplanan yollar\u0131 kald\u0131r\u0131r.</p>"},{"location":"tr/guides/plotting/vectorfields/#parametre-taramalar-sweeps","title":"Parametre Taramalar\u0131 (Sweeps)","text":"<p>Vekt\u00f6r alanlar\u0131n\u0131 parametre de\u011ferleri aras\u0131nda kar\u015f\u0131la\u015ft\u0131rmak i\u00e7in <code>plot.vectorfield_sweep()</code> kullan\u0131n. Bu fonksiyon <code>.handles</code>, <code>.axes</code> ve <code>.colorbar</code> i\u00e7eren bir <code>VectorFieldSweep</code> d\u00f6nd\u00fcr\u00fcr; b\u00f6ylece \u00e7izimden sonra bireysel facet'leri ayarlayabilir veya renklendirme i\u00e7in kullan\u0131lan payla\u015f\u0131lan <code>speed_norm</code> de\u011ferini alabilirsiniz. Basit bir 1D tarama i\u00e7in <code>param</code>/<code>values</code> ge\u00e7irin veya parametreler ve sabit durumlar i\u00e7in \u00f6zel ge\u00e7ersiz k\u0131lmalara ihtiyac\u0131n\u0131z oldu\u011funda <code>sweep</code> e\u015flemesini sa\u011flay\u0131n; <code>target</code> arg\u00fcman\u0131 her tarama <code>value</code>sunun params (varsay\u0131lan) m\u0131 yoksa sabit durumlar\u0131 (fixed states) m\u0131 d\u00fczenleyece\u011fini se\u00e7er.</p> <pre><code>plot.vectorfield_sweep(\n    model,\n    param=\"a\",  # De\u011fi\u015ftirilecek parametre\n    values=[-1.0, 0.0, 1.0, 2.0],  # Test edilecek de\u011ferler\n    xlim=(-3, 3),\n    ylim=(-3, 3),\n    cols=2,  # Izgarada 2 s\u00fctun\n    normalize=True,\n    facet_titles=\"a = {value:.1f}\"  # \u00d6zel ba\u015fl\u0131klar\n)\n</code></pre> <p>Payla\u015f\u0131lan normalizasyon (<code>share_speed_norm=True</code>), renklendirmenin t\u00fcm facet'lerde tutarl\u0131 kalmas\u0131n\u0131 sa\u011flar ve <code>add_colorbar=True</code>, mevcut oldu\u011funda h\u0131z renklendirmesi i\u00e7in tek bir lejant \u00e7izer.</p>"},{"location":"tr/guides/plotting/vectorfields/#vektor-alan-animasyonlar","title":"Vekt\u00f6r Alan\u0131 Animasyonlar\u0131","text":"<p><code>plot.vectorfield_animate()</code> kullanarak vekt\u00f6r alanlar\u0131n\u0131n parametrelerle nas\u0131l de\u011fi\u015fti\u011fini canland\u0131r\u0131n:</p> <pre><code>import numpy as np\n\n# Parametre de\u011fi\u015fikliklerini canland\u0131r\nanim = plot.vectorfield_animate(\n    model,\n    param=\"a\",\n    values=np.linspace(-2, 2, 100),  # 100 kare\n    fps=15,\n    title_func=lambda v, idx: f\"Parametre a = {v:.2f}\",\n    normalize=True,\n    speed_color=True\n)\n\n# Animasyonu kaydet\nanim.animation.save(\"vectorfield_animation.gif\", writer=\"pillow\")\n</code></pre> <p><code>plot.vectorfield_animate()</code>, hem canl\u0131 <code>VectorFieldHandle</code>'\u0131 (eri\u015filebilir <code>.handle</code> arac\u0131l\u0131\u011f\u0131yla) hem de alttaki <code>matplotlib.animation.FuncAnimation</code> nesnesini tutan bir <code>VectorFieldAnimation</code> d\u00f6nd\u00fcr\u00fcr, b\u00f6ylece tutamac\u0131 manuel olarak g\u00fcncelleyebilir veya animasyonu daha sonra kaydedebilirsiniz. <code>frames</code>, <code>values</code> (bir <code>param</code> ile) veya <code>duration</code>/<code>fps</code> sa\u011flay\u0131n ve her kare i\u00e7in \u00f6zel ge\u00e7ersiz k\u0131lmalara ihtiyac\u0131n\u0131z oldu\u011funda <code>params_func</code>, <code>fixed_func</code> veya <code>title_func</code> kullan\u0131n.</p>"},{"location":"tr/guides/plotting/vectorfields/#animasyon-secenekleri","title":"Animasyon Se\u00e7enekleri","text":"<ul> <li><code>fps</code>: Saniyedeki kare say\u0131s\u0131 (varsay\u0131lan: 15)</li> <li><code>interval</code>: Kareler aras\u0131ndaki milisaniye (fps alternatifi)</li> <li><code>title_func</code>: Her kare i\u00e7in ba\u015fl\u0131k \u00fcretme fonksiyonu</li> <li><code>repeat</code>: Animasyonun d\u00f6ng\u00fc yap\u0131p yapmayaca\u011f\u0131 (varsay\u0131lan: True)</li> <li><code>blit</code>: Daha ak\u0131c\u0131 animasyon i\u00e7in blitting kullan (t\u00fcm arka u\u00e7larda \u00e7al\u0131\u015fmayabilir)</li> </ul>"},{"location":"tr/guides/plotting/vectorfields/#ileri-seviye-kullanm","title":"\u0130leri Seviye Kullan\u0131m","text":""},{"location":"tr/guides/plotting/vectorfields/#cizimleri-dinamik-olarak-guncelleme","title":"\u00c7izimleri Dinamik Olarak G\u00fcncelleme","text":"<p><code>vectorfield()</code> fonksiyonu, dinamik g\u00fcncellemelere izin veren bir <code>VectorFieldHandle</code> d\u00f6nd\u00fcr\u00fcr:</p> <pre><code>handle = plot.vectorfield(model, params={\"a\": 1.0})\n\n# Yeniden \u00e7izim yapmadan parametreleri g\u00fcncelle\nhandle.update(params={\"a\": 2.0})\n\n# Sabit de\u011ferleri g\u00fcncelle\nhandle.update(fixed={\"z\": 15.0})\n</code></pre>"},{"location":"tr/guides/plotting/vectorfields/#ozel-degerlendirme","title":"\u00d6zel De\u011ferlendirme","text":"<p>D\u00fc\u015f\u00fck seviyeli kontrol i\u00e7in, ham vekt\u00f6r verilerini almak \u00fczere <code>plot.eval_vectorfield()</code> kullan\u0131n:</p> <pre><code>X, Y, U, V = plot.eval_vectorfield(\n    model,\n    xlim=(-2, 2),\n    ylim=(-2, 2),\n    grid=(50, 50),\n    normalize=True\n)\n\n# Do\u011frudan matplotlib ile kullan\nimport matplotlib.pyplot as plt\nplt.quiver(X, Y, U, V)\n</code></pre> <p>B\u00fcy\u00fckl\u00fck \u0131zgaras\u0131na (\u00f6rne\u011fin, bir renk haritas\u0131 ile renklendirmek veya normalle\u015ftirilmi\u015f ile normalle\u015ftirilmemi\u015f h\u0131zlar\u0131 kar\u015f\u0131la\u015ft\u0131rmak i\u00e7in) ihtiyac\u0131n\u0131z oldu\u011funda <code>return_speed=True</code> ge\u00e7irin.</p>"},{"location":"tr/guides/plotting/vectorfields/#yuksek-boyutlu-sistemler","title":"Y\u00fcksek Boyutlu Sistemler","text":"<p>2 boyuttan fazla sisteme sahip sistemler i\u00e7in, 2B dilimlere izd\u00fc\u015f\u00fcm yap\u0131n:</p> <pre><code># Lorenz sistemi: z sabitken x-y d\u00fczlemi\nplot.vectorfield(\n    lorenz_model,\n    vars=(\"x\", \"y\"),\n    fixed={\"z\": 25.0}\n)\n\n# Ayn\u0131 sistem: x sabitken y-z d\u00fczlemi\nplot.vectorfield(\n    lorenz_model,\n    vars=(\"y\", \"z\"),\n    fixed={\"x\": 0.0}\n)\n</code></pre> <p>Y\u00fcksek boyutlu sistemleri dilimlerken, de\u011ferlendirmenin istenen d\u00fczlem i\u00e7inde kalmas\u0131 i\u00e7in di\u011fer her durumun <code>fixed</code> ile sabitlendi\u011finden emin olun.</p>"},{"location":"tr/guides/plotting/vectorfields/#performans-hususlar","title":"Performans Hususlar\u0131","text":"<ul> <li>Izgara boyutu: Daha b\u00fcy\u00fck \u0131zgaralar daha iyi \u00e7\u00f6z\u00fcn\u00fcrl\u00fck sa\u011flar ancak hesaplama daha yava\u015ft\u0131r.</li> <li>Normalizasyon: Normalle\u015ftirilmi\u015f \u00e7izimler daha h\u0131zl\u0131 hesaplan\u0131r (b\u00fcy\u00fckl\u00fck hesaplamas\u0131 yoktur).</li> <li>Nullcline'lar: Ayr\u0131 bir \u0131zgarada hesaplan\u0131r; yo\u011funlu\u011fu kontrol etmek i\u00e7in <code>nullcline_grid</code> kullan\u0131n.</li> <li>JIT derleme: Ayn\u0131 modelin tekrarlanan de\u011ferlendirmeleri i\u00e7in <code>jit=True</code> ayarlay\u0131n.</li> <li>Disk \u00f6nbellekleme: \u00c7al\u0131\u015ft\u0131rmalar aras\u0131nda derlenmi\u015f yap\u0131lar\u0131 yeniden kullanmak i\u00e7in bir URI'den olu\u015ftururken <code>disk_cache=True</code> ge\u00e7irin.</li> </ul>"},{"location":"tr/guides/plotting/vectorfields/#yaygn-desenler","title":"Yayg\u0131n Desenler","text":""},{"location":"tr/guides/plotting/vectorfields/#yorungelerle-faz-portresi","title":"Y\u00f6r\u00fcngelerle Faz Portresi","text":"<pre><code>ax = plot.fig.single()\nhandle = plot.vectorfield(\n    model,\n    ax=ax,\n    normalize=True,\n    nullclines=True\n)\n\n# Belirli y\u00f6r\u00fcngeler ekle\nfrom dynlib import Sim\nsim = Sim(model)\nsim.run(t_end=20.0, state_ic=[1.0, 0.0])\nplot.series(sim, ax=ax, vars=(\"x\", \"y\"))\n</code></pre>"},{"location":"tr/guides/plotting/vectorfields/#bifurkasyon-analizi-kurulumu","title":"Bifurkasyon Analizi Kurulumu","text":"<pre><code># Tarama aral\u0131\u011f\u0131n\u0131 numpy ile olu\u015ftur\nimport numpy as np\n\n# Parametreyi tara ve vekt\u00f6r alan\u0131 yap\u0131s\u0131ndaki nitel de\u011fi\u015fiklikleri g\u00f6zlemle\nplot.vectorfield_sweep(\n    model,\n    param=\"r\",\n    values=np.linspace(0, 1, 9),\n    normalize=True,\n    speed_color=True,\n    title=\"Vekt\u00f6r alan\u0131 yap\u0131s\u0131nda bifurkasyon\"\n)\n</code></pre>"},{"location":"tr/guides/plotting/vectorfields/#ozel-parametre-fonksiyonlar-ile-animasyon","title":"\u00d6zel Parametre Fonksiyonlar\u0131 ile Animasyon","text":"<pre><code># Parametre g\u00fcncellemeleri sal\u0131n\u0131mlar i\u00e7in NumPy'\u0131 yeniden kullanabilir\nimport numpy as np\n\n# Sal\u0131nan parametre\ndef param_func(frame_idx):\n    return {\"a\": 2.0 * np.sin(2 * np.pi * frame_idx / 50)}\n\nplot.vectorfield_animate(\n    model,\n    frames=50,\n    params_func=param_func,\n    fps=10\n)\n</code></pre>"},{"location":"tr/guides/simulation/","title":"Sim\u00fclasyon Rehberleri","text":"<ul> <li>Temeller</li> <li>Yap\u0131land\u0131rma</li> <li>Just-In-Time (JIT) Derleme</li> <li>\u00c7al\u0131\u015fma Zaman\u0131 \u00d6n Ayarlar\u0131 (Presets)</li> <li>Runner Varyantlar\u0131</li> <li>Oturum Durumu &amp; Yazd\u0131rma</li> <li>Derlenmi\u015f Kaynaklar\u0131 D\u0131\u015fa Aktarma</li> <li>Sim\u00fclasyon Stepper'lar\u0131</li> <li>Snapshot'lar &amp; Devam Etme (Resume)</li> <li>Runner &amp; Wrapper</li> </ul>"},{"location":"tr/guides/simulation/basics/","title":"Sim\u00fclasyon Temelleri","text":"<p>Bu rehber, bir dynlib sim\u00fclasyonunu \u00e7al\u0131\u015ft\u0131rman\u0131n iki temel a\u015famas\u0131n\u0131 ele al\u0131r: 1. Modelinizi bir <code>FullModel</code> olarak Derlemek (Compile). 2. Derlenen bu yap\u0131y\u0131 bir <code>Sim</code> \u00f6rne\u011fi ile Y\u00fcr\u00fctmek (Drive).</p> <p>Ayr\u0131ca, bir sim\u00fclasyonu h\u0131zl\u0131ca aya\u011fa kald\u0131rmak i\u00e7in kullan\u0131lan <code>setup()</code> k\u0131sayolunu da vurgular.</p>"},{"location":"tr/guides/simulation/basics/#1-bir-fullmodel-derleme-ve-inceleme","title":"1. Bir <code>FullModel</code> Derleme ve \u0130nceleme","text":"<p>Her dynlib sim\u00fclasyonu <code>build()</code> (veya daha fazla kontrole ihtiya\u00e7 duydu\u011funuzda alt seviye derleyici giri\u015f noktalar\u0131) ile ba\u015flar. <code>build()</code>, model spesifikasyonunu (URI, dosya yolu veya sat\u0131r i\u00e7i DSL) ve iste\u011fe ba\u011fl\u0131 stepper, mod ve JIT bayraklar\u0131n\u0131 (flags) alarak bir <code>FullModel</code> d\u00f6nd\u00fcr\u00fcr.</p> <pre><code>from dynlib import build\n\nmodel = build(\"my_model.toml\", stepper=\"rk4\", jit=True)\n</code></pre> <p>Bir <code>FullModel</code> \u015funlar\u0131 i\u00e7erir:</p> <ul> <li>Derlenmi\u015f \u00e7a\u011fr\u0131labilir nesneler (<code>rhs</code>, <code>stepper</code>, <code>runner</code>, <code>events_pre</code>, <code>events_post</code> vb.).</li> <li>Metadata (<code>spec</code>, <code>stepper_name</code>, <code>workspace_sig</code>, veri tipi, sim\u00fclasyon varsay\u0131lanlar\u0131, guard'lar).</li> <li>\u00dcretilen Python kodunu d\u0131\u015far\u0131 aktarmak i\u00e7in <code>export_sources()</code> ve durumlar\u0131 (states), parametreleri, yard\u0131mc\u0131 de\u011fi\u015fkenleri (aux) ve <code>[sim]</code> varsay\u0131lanlar\u0131n\u0131 incelemek i\u00e7in <code>full_model.spec</code> gibi yard\u0131mc\u0131 metotlar.</li> </ul> <p>Derlenen <code>model</code> standart bir Python nesnesi oldu\u011fundan, onu bir \u00e7al\u0131\u015fma zaman\u0131na (runtime) entegre etmeden \u00f6nce inceleyebilir veya yeniden kullanabilirsiniz. \u00d6rne\u011fin:</p> <ul> <li>Se\u00e7ilen entegrat\u00f6r\u00fc do\u011frulamak i\u00e7in <code>model.stepper_name</code> \u00f6zelli\u011fini kontrol edebilirsiniz.</li> <li>Neleri kaydedece\u011finizi planlamak i\u00e7in <code>model.spec.states</code>, <code>model.spec.aux</code> ve <code>model.spec.params</code> alanlar\u0131n\u0131 inceleyebilirsiniz.</li> <li>Hata ay\u0131klama (debugging) amac\u0131yla kaynak kodunu <code>model.export_sources(\"./compiled\")</code> kullanarak d\u0131\u015fa aktarabilirsiniz.</li> </ul> <p><code>FullModel</code>'i yaln\u0131zca derlenmi\u015f bile\u015fenleri incelemeniz veya yeniden kullanman\u0131z gerekti\u011finde do\u011frudan kullan\u0131n. \u00c7o\u011fu i\u015f ak\u0131\u015f\u0131nda <code>FullModel</code> do\u011frudan <code>Sim</code>'e aktar\u0131l\u0131r.</p>"},{"location":"tr/guides/simulation/basics/#2-sim-ile-simulasyon-calstrma","title":"2. <code>Sim</code> ile Sim\u00fclasyon \u00c7al\u0131\u015ft\u0131rma","text":"<p><code>Sim</code>, bir <code>FullModel</code>'i sarmalar ve devam ettirilebilir (resumable) oturum durumunu, sonu\u00e7 tamponlar\u0131n\u0131 (buffers), snapshot'lar\u0131 ve \u00f6n ayar (preset) bankalar\u0131n\u0131 y\u00f6netir.</p> <pre><code>from dynlib import Sim\n\nsim = Sim(model)\nsim.config(record_interval=5, max_steps=2000)\nsim.run(T=10.0, record=True)\nresults = sim.results()\n</code></pre> <p>Temel \u00e7al\u0131\u015fma zaman\u0131 kavramlar\u0131:</p> <ul> <li><code>run(...)</code> sim\u00fclasyonu ba\u015flat\u0131r. <code>dt</code>, <code>T</code>/<code>N</code>, <code>record</code>, <code>record_interval</code>, <code>max_steps</code> ve <code>record_vars</code> arac\u0131l\u0131\u011f\u0131yla se\u00e7ici kay\u0131t gibi <code>[sim]</code> varsay\u0131lanlar\u0131n\u0131 ge\u00e7ersiz k\u0131labilirsiniz (override).</li> <li><code>Sim.config(...)</code>, her <code>run()</code> \u00e7a\u011fr\u0131s\u0131nda ayarlar\u0131 tekrarlamamak i\u00e7in kal\u0131c\u0131 varsay\u0131lanlar belirler.</li> <li><code>Sim.assign(...)</code>, \u00e7al\u0131\u015ft\u0131rmadan \u00f6nce durumlar\u0131/parametreleri g\u00fcnceller veya ge\u00e7mi\u015fi temizler.</li> <li><code>Sim.results()</code>, isimlendirilmi\u015f eri\u015fim i\u00e7in bir <code>ResultsView</code> sa\u011flarken, <code>Sim.raw_results()</code> d\u00fc\u015f\u00fck seviyeli <code>Results</code> tamponu arac\u0131l\u0131\u011f\u0131yla do\u011frudan dizi g\u00f6r\u00fcn\u00fcmleri (array views) sunar.</li> <li><code>Sim.reset()</code>, isimlendirilmi\u015f bir snapshot'a geri d\u00f6ner (ilk \u00e7al\u0131\u015ft\u0131rmada otomatik olarak bir <code>\"initial\"</code> snapshot olu\u015fturulur) ve kaydedilen ge\u00e7mi\u015fi temizler.</li> <li><code>Sim.create_snapshot(...)</code>, <code>list_snapshots()</code> ve <code>name_segment()</code>, birden fazla senaryo i\u00e7in tekrarlanabilir segmentler \u00fczerinde kontrol sa\u011flar.</li> <li><code>run(resume=True)</code>, mevcut durumdan devam ederek sim\u00fclasyon segmentlerinin kesintisiz birle\u015ftirilmesine olanak tan\u0131r.</li> </ul> <p><code>Sim</code>, DSL i\u00e7indeki <code>[sim]</code> tablosuna sayg\u0131 duyar, bu nedenle sim\u00fclasyon parametreleri mant\u0131kl\u0131 varsay\u0131lanlara sahiptir. <code>run()</code> yaln\u0131zca belirtti\u011finiz \u015feyleri de\u011fi\u015ftirir.</p>"},{"location":"tr/guides/simulation/basics/#3-setup-ile-hzl-kurulum","title":"3. <code>setup()</code> ile H\u0131zl\u0131 Kurulum","text":"<p>Derlemek ve \u00e7al\u0131\u015ft\u0131rmak i\u00e7in h\u0131zl\u0131 bir yol ar\u0131yorsan\u0131z <code>setup()</code> yard\u0131mc\u0131s\u0131n\u0131 kullan\u0131n. Bu, <code>build()</code> ve <code>Sim()</code> i\u015flemlerini tek bir \u00e7a\u011fr\u0131da birle\u015ftirir, ayn\u0131 varsay\u0131lanlar\u0131 uygular ve derlenmi\u015f modele <code>sim.model</code> \u00fczerinden eri\u015fim sa\u011flar.</p> <pre><code>from dynlib import setup\n\nsim = setup(\"my_model.toml\", stepper=\"rk4\", jit=True)\nsim.run(T=10.0)\nprint(sim.results().t)\n</code></pre> <p><code>setup()</code> size \u00e7al\u0131\u015fmaya haz\u0131r bir <code>Sim</code> verdi\u011finden, sim\u00fclasyonlara ba\u015flaman\u0131n en h\u0131zl\u0131 yoludur. A\u00e7\u0131k <code>build()</code> + <code>Sim()</code> yakla\u015f\u0131m\u0131n\u0131, \u00f6nce <code>FullModel</code> \u00fczerinde i\u015flem yapman\u0131z gereken durumlar (\u00f6rne\u011fin; guard'lar\u0131 incelemek, kaynaklar\u0131 d\u0131\u015fa aktarmak veya yeniden kullan\u0131m i\u00e7in \u00f6nbelle\u011fe almak) i\u00e7in saklay\u0131n.</p>"},{"location":"tr/guides/simulation/basics/#is-aks-ipuclar","title":"\u0130\u015f Ak\u0131\u015f\u0131 \u0130pu\u00e7lar\u0131","text":"<ul> <li>Bir kez derleyin (build) ve <code>FullModel</code>'i farkl\u0131 senaryolar veya veri \u015fekilleri i\u00e7in yeniden kullan\u0131n.</li> <li>Snapshot'lar, \u00f6n ayarlar (presets) veya tekrarlanan yap\u0131land\u0131rmalar i\u00e7in bir <code>Sim</code> \u00f6rne\u011fini canl\u0131 tutun; s\u0131f\u0131rlay\u0131p yeniden kullanmak, yeniden derlemekten daha verimlidir.</li> <li>\u00c7o\u011fu ayar i\u00e7in <code>[sim]</code> varsay\u0131lanlar\u0131na g\u00fcvenin, gerekti\u011finde <code>Sim.config()</code> ve hedefli <code>run()</code> ge\u00e7ersiz k\u0131lmalar\u0131n\u0131 kullan\u0131n.</li> <li>H\u0131zl\u0131 prototipleme, test etme veya demolar i\u00e7in <code>setup()</code> kullan\u0131n.</li> <li><code>jit=True</code> se\u00e7ene\u011fini yaln\u0131zca numba y\u00fckl\u00fcyse ve sim\u00fclasyonlar derleme maliyetini hakl\u0131 \u00e7\u0131karacak kadar uzunsa etkinle\u015ftirin. K\u0131sa \u00e7al\u0131\u015ft\u0131rmalar i\u00e7in, yorumlay\u0131c\u0131da (interpreter) kalmak \u00fczere <code>jit=False</code> kullan\u0131n.</li> </ul>"},{"location":"tr/guides/simulation/configuration/","title":"Sim\u00fclasyon Yap\u0131land\u0131rmas\u0131","text":"<p>Bu rehber, \u00e7al\u0131\u015fma zaman\u0131 varsay\u0131lanlar\u0131n\u0131n nas\u0131l ayarlanaca\u011f\u0131n\u0131, model durumu/parametre bankas\u0131n\u0131n nas\u0131l d\u00fczenlenece\u011fini ve <code>Sim</code> ile \u00e7al\u0131\u015f\u0131rken kay\u0131t (recording) ve kapasite s\u0131n\u0131rlar\u0131n\u0131n (caps) nas\u0131l kontrol edilece\u011fini a\u00e7\u0131klar.</p>"},{"location":"tr/guides/simulation/configuration/#simconfig-ile-varsaylanlar-kalc-hale-getirme","title":"<code>Sim.config()</code> ile varsay\u0131lanlar\u0131 kal\u0131c\u0131 hale getirme","text":"<p><code>Sim.config()</code>, belirli bir arg\u00fcman belirtilmedi\u011finde <code>run()</code> komutunun kullanaca\u011f\u0131 kal\u0131c\u0131 varsay\u0131lanlar ayarlaman\u0131za olanak tan\u0131r. En yayg\u0131n sim\u00fclasyon d\u00fc\u011fmelerini ve stepper'a \u00f6zg\u00fc <code>Config</code> alanlar\u0131n\u0131 kapsar.</p> <pre><code>sim.config(\n    dt=0.01,\n    max_steps=5000,\n    record=True,\n    record_interval=10,\n    cap_rec=2048,\n    cap_evt=4,\n    tol=1e-6,          # aktif stepper yap\u0131land\u0131rmas\u0131na iletilir\n)\n</code></pre> <p>\u00d6ne \u00c7\u0131kanlar:</p> <ul> <li><code>dt</code>, nominal zaman ad\u0131m\u0131n\u0131 (veya ayr\u0131k modeller i\u00e7in etiket aral\u0131\u011f\u0131n\u0131) ayarlar ve sim\u00fclasyon durumunda <code>_nominal_dt</code> olarak saklan\u0131r. Pozitif olmal\u0131d\u0131r.</li> <li><code>max_steps</code>, <code>N</code>/<code>T</code> atland\u0131\u011f\u0131nda varsay\u0131lan g\u00fcvenlik s\u0131n\u0131r\u0131 (s\u00fcrekli) veya hedef iterasyon say\u0131s\u0131 (ayr\u0131k) olur.</li> <li><code>record</code> ve <code>record_interval</code>, varsay\u0131lan g\u00fcnl\u00fck kayd\u0131 davran\u0131\u015f\u0131n\u0131 tan\u0131mlar ve ge\u00e7ersiz k\u0131l\u0131nmad\u0131k\u00e7a sonraki <code>run()</code> \u00e7a\u011fr\u0131lar\u0131 taraf\u0131ndan devral\u0131n\u0131r.</li> <li><code>cap_rec</code>/<code>cap_evt</code>, y\u00f6r\u00fcnge/olay tamponlar\u0131n\u0131n ba\u015flang\u0131\u00e7 boyutlar\u0131n\u0131 kontrol eder. Gerekirse otomatik olarak b\u00fcy\u00fcrler, ancak daha b\u00fcy\u00fck ba\u015flang\u0131\u00e7 kapasiteleri yeniden tahsis i\u015flemlerini (reallocations) azaltabilir.</li> <li>Ekstra anahtar kelime arg\u00fcmanlar\u0131 <code>Sim.stepper_config()</code>'e iletilir, b\u00f6ylece <code>tol</code>, <code>max_iter</code> veya di\u011fer stepper d\u00fc\u011fmelerini global olarak yap\u0131land\u0131rabilirsiniz.</li> </ul> <p><code>run()</code>'a verilen a\u00e7\u0131k arg\u00fcmanlar\u0131n bu varsay\u0131lanlar\u0131 her zaman ge\u00e7ersiz k\u0131ld\u0131\u011f\u0131n\u0131 unutmay\u0131n; tekrarlanabilir scriptler i\u00e7in <code>config()</code> ile <code>run(...)</code> ge\u00e7ersiz k\u0131lmalar\u0131n\u0131 birlikte kullan\u0131n.</p>"},{"location":"tr/guides/simulation/configuration/#simassign-ile-durum-ve-parametreleri-ayarlama","title":"<code>Sim.assign()</code> ile durum ve parametreleri ayarlama","text":"<p><code>Sim.assign()</code>, hi\u00e7bir \u015feyi yeniden derlemeden oturumun mevcut durum ve parametre vekt\u00f6rlerini isme g\u00f6re g\u00fcnceller.</p> <pre><code>sim.assign({\"v\": -65.0, \"I\": 5.0})\nsim.assign(I=8.0, clear_history=True)\n</code></pre> <p>Temel davran\u0131\u015flar:</p> <ul> <li>Bir e\u015fleme (mapping) ve/veya anahtar kelime arg\u00fcmanlar\u0131 kabul eder; anahtar kelimeler harita girdilerini ge\u00e7ersiz k\u0131lar.</li> <li>\u0130simleri \u00f6nce <code>states</code>, sonra <code>params</code> i\u00e7inde arar; bilinmeyen isimler \"bunu mu demek istediniz?\" \u00f6nerileriyle net bir <code>ValueError</code> verir.</li> <li>Girdileri model veri tipine d\u00f6n\u00fc\u015ft\u00fcr\u00fcr, hassasiyet kayb\u0131 olacaksa bir uyar\u0131 verir.</li> <li><code>clear_history=True</code>, zaman\u0131, \u00e7al\u0131\u015fma alan\u0131n\u0131 (workspace), snapshot'lar\u0131 veya stepper yap\u0131land\u0131rmas\u0131n\u0131 de\u011fi\u015ftirmeden birikmi\u015f <code>Results</code> verisini, segmentleri ve bekleyen etiketleri temizler.</li> <li>De\u011fi\u015fiklikler, <code>run()</code> komutuna a\u00e7\u0131k <code>ic</code>/<code>params</code> arg\u00fcmanlar\u0131 ge\u00e7medi\u011finiz s\u00fcrece bir sonraki <code>run()</code> i\u00e7in hemen ge\u00e7erli olur.</li> </ul> <p><code>Sim</code>'i yeni ko\u015fullarla yeniden kullanmak, deneyler aras\u0131nda parametreleri de\u011fi\u015ftirmek veya devam etmeden (resume) \u00f6nce sistemi haz\u0131rlamak istedi\u011finizde <code>assign()</code> kullan\u0131n.</p>"},{"location":"tr/guides/simulation/configuration/#kayt-recording-secenekleri","title":"Kay\u0131t (Recording) se\u00e7enekleri","text":"<p><code>Sim.run()</code>, <code>config()</code> veya <code>[sim]</code> tablosu arac\u0131l\u0131\u011f\u0131yla belirledi\u011finiz varsay\u0131lanlar\u0131n yan\u0131 s\u0131ra g\u00fcnl\u00fck kayd\u0131 \u00fczerinde hassas kontrol sunar.</p> <ul> <li><code>record</code> (bool): kayd\u0131 a\u00e7/kapa. <code>False</code> oldu\u011funda, yaln\u0131zca global zaman ekseni g\u00fcncellenir; durum/aux tamponlar\u0131 b\u00fcy\u00fcmez.</li> <li><code>record_interval</code> (int): her N'inci ad\u0131m\u0131 yakalar (varsay\u0131lan <code>1</code>). \u00d6rnekleme s\u0131kl\u0131\u011f\u0131n\u0131 d\u00fc\u015f\u00fcrmek (downsampling) veya h\u0131zl\u0131 sim\u00fclasyonlar\u0131 ucuza yakalamak i\u00e7in kullan\u0131\u015fl\u0131d\u0131r.</li> <li><code>record_vars</code>: se\u00e7ici kay\u0131t listesi. Kabul edilebilir giri\u015fler:</li> <li><code>None</code> (varsay\u0131lan) : Mevcut t\u00fcm durum de\u011fi\u015fkenleri.</li> <li>\u00d6nek (prefix) olmayan isimler durumlara (states) at\u0131fta bulunur.</li> <li><code>\"aux.&lt;isim&gt;\"</code> a\u00e7\u0131k\u00e7a yard\u0131mc\u0131 de\u011fi\u015fkenleri hedefler, ancak <code>aux</code> isimlerini \u00f6nek olmadan g\u00f6ndermek de kabul edilir ve ay\u0131rt edilir.</li> <li>Bo\u015f bir liste (<code>[]</code>), zaman damgalar\u0131n\u0131, ad\u0131mlar\u0131 ve bayraklar\u0131 kaydetmeye devam ederken durum/aux kayd\u0131n\u0131 devre d\u0131\u015f\u0131 b\u0131rak\u0131r.</li> </ul> <p>Se\u00e7ici kay\u0131t, ayn\u0131 <code>Results</code> tampon d\u00fczenini korur ancak yaln\u0131zca istenen alt k\u00fcmeleri doldurur, bu da b\u00fcy\u00fck durum vekt\u00f6rleri i\u00e7in bellek/zaman tasarrufu sa\u011flar.</p> <p>Ayr\u0131ca, bir \u00e7al\u0131\u015ft\u0131rmadan \u00f6nce <code>cap_rec</code> ve <code>cap_evt</code> ile kay\u0131t kapasitesini ayarlayabilir veya <code>record_interval</code>/<code>record_vars</code> neyin yakalanaca\u011f\u0131na karar verirken dynlib'in tamponlar\u0131 otomatik olarak b\u00fcy\u00fctmesine izin verebilirsiniz.</p>"},{"location":"tr/guides/simulation/configuration/#simulasyon-ufuklarn-horizons-yonetme","title":"Sim\u00fclasyon ufuklar\u0131n\u0131 (horizons) y\u00f6netme","text":"<ul> <li><code>dt</code> nominal ad\u0131m boyutunu kaydeder. Kal\u0131c\u0131 bir varsay\u0131lan i\u00e7in <code>config(dt=\u2026)</code> kullan\u0131n veya \u00e7al\u0131\u015ft\u0131rma ba\u015f\u0131na ge\u00e7ersiz k\u0131l\u0131n.</li> <li><code>T</code> (s\u00fcrekli) veya <code>N</code> (ayr\u0131k), runner'\u0131n ne kadar ilerleyece\u011fini tan\u0131mlar; her ikisi de atlan\u0131rsa <code>max_steps</code> devreye girer (varsay\u0131lan yine de <code>[sim].max_steps</code>'e sayg\u0131 duyar).</li> <li>Haritalarla (<code>kind=\"map\"</code>) \u00e7al\u0131\u015f\u0131rken, <code>N</code> iterasyonlar\u0131 belirler ve <code>T</code> t\u00fcretilir; ODE'ler i\u00e7in <code>T</code> biti\u015f zaman\u0131d\u0131r ve <code>N</code> \u00e7\u0131kar\u0131m yoluyla bulunur.</li> <li><code>max_steps</code>, s\u00fcrekli modellerde bir g\u00fcvenlik \u00f6nlemi olarak uygulan\u0131r ve ayr\u0131k modellerde <code>N</code> atland\u0131\u011f\u0131nda varsay\u0131lan iterasyon say\u0131s\u0131 olarak i\u015flev g\u00f6r\u00fcr. Ufuk b\u00fcy\u00fcd\u00fc\u011f\u00fcnde bunu art\u0131r\u0131n veya kontrols\u00fcz d\u00f6ng\u00fclerden ka\u00e7\u0131nmak i\u00e7in k\u00fc\u00e7\u00fclt\u00fcn. Bir runner <code>max_steps</code>'e ula\u015f\u0131rsa, sessiz ve beklenmedik davran\u0131\u015flardan ka\u00e7\u0131nmak i\u00e7in bir uyar\u0131 verilir.</li> <li><code>transient</code>, saklanan <code>Results</code> verisini etkilemeden ba\u015flang\u0131\u00e7taki \u0131s\u0131nma periyodunu (zaman veya iterasyon olarak) atlayabilir. <code>transient</code> periyodu boyunca hi\u00e7bir \u015fey kaydedilmez. Zaman\u0131n <code>transient</code> periyodundan sonra <code>t0</code>'dan ba\u015flad\u0131\u011f\u0131n\u0131 unutmay\u0131n; bu, baz\u0131 kullan\u0131c\u0131lar i\u00e7in sezgisel olmayabilir.</li> <li><code>resume=True</code>, son <code>SessionState</code>'den yeniden ba\u015flatmaya izin verir; devam etme (resume) modunda <code>ic</code>, <code>params</code>, <code>t0</code> ve <code>dt</code>'nin ge\u00e7ersiz k\u0131l\u0131namayaca\u011f\u0131n\u0131 unutmay\u0131n.</li> </ul> <p>\u00c7ok a\u015famal\u0131 deneyleri y\u00f6netirken bu se\u00e7enekleri <code>Sim.reset()</code>/<code>Sim.create_snapshot()</code> ile e\u015fle\u015ftirin, b\u00f6ylece ufuklar\u0131 de\u011fi\u015ftirseniz bile segmentler ve kaydedilen ge\u00e7mi\u015f \u00fczerinde kontrol\u00fc elinizde tutars\u0131n\u0131z.</p>"},{"location":"tr/guides/simulation/configuration/#ozet","title":"\u00d6zet","text":"<ul> <li><code>dt</code>, <code>max_steps</code>, kay\u0131t, kapasiteler ve stepper ayarlar\u0131 i\u00e7in uzun \u00f6m\u00fcrl\u00fc varsay\u0131lanlar\u0131 bildirmek \u00fczere <code>Sim.config()</code> kullan\u0131n.</li> <li>Modeli yeniden olu\u015fturmadan durum/parametre de\u011ferlerini g\u00fcncellemeniz gerekti\u011finde <code>Sim.assign()</code> \u00e7a\u011f\u0131r\u0131n.</li> <li>Do\u011fruluk ve bellek aras\u0131nda denge kurmak i\u00e7in <code>run(record_vars=\u2026)</code>, <code>record_interval</code> ve tampon s\u0131n\u0131rlar\u0131n\u0131 (caps) kullan\u0131n.</li> <li>Harita veya s\u00fcrekli sistem sim\u00fclasyonu yap\u0131p yapmad\u0131\u011f\u0131n\u0131za ba\u011fl\u0131 olarak <code>T</code>, <code>N</code> ve <code>max_steps</code> de\u011ferlerini ayarlay\u0131n ve a\u015famaland\u0131rmay\u0131 kontrol etmek i\u00e7in <code>transient</code>/<code>resume</code> kullan\u0131n.</li> <li>Hem tekrarlanabilirlik hem de h\u0131za ihtiya\u00e7 duydu\u011funuzda yap\u0131land\u0131rma se\u00e7eneklerini snapshot'lar, segmentler ve <code>setup()</code> ile birle\u015ftirin.</li> </ul>"},{"location":"tr/guides/simulation/export-sources/","title":"Derlenmi\u015f Kaynaklar\u0131 D\u0131\u015fa Aktarma","text":"<p>dynlib'in neler \u00fcretti\u011fine g\u00f6z atman\u0131z gerekti\u011finde, <code>FullModel.export_sources()</code> (ve karde\u015f yard\u0131mc\u0131s\u0131 <code>dynlib.compiler.build.export_model_sources</code>), mevcut her \u00e7a\u011fr\u0131labilir nesneyi bir dizine yazar. B\u00f6ylece bunlar\u0131 edit\u00f6r\u00fcn\u00fczde a\u00e7abilir, linting \u00e7al\u0131\u015ft\u0131rabilir veya bir sim\u00fclasyon derlemesinin kayd\u0131n\u0131 tutabilirsiniz.</p> <p>Kaynaklar\u0131 d\u0131\u015fa aktarmak \u015fu durumlarda faydal\u0131d\u0131r:</p> <ul> <li>DSL denklemlerinin Python fonksiyonlar\u0131na (rhs, steppers, events vb.) nas\u0131l d\u00f6n\u00fc\u015ft\u00fc\u011f\u00fcn\u00fc anlamak istedi\u011finizde</li> <li>Stepper'lar, olaylar veya \u00e7\u00f6z\u00fcc\u00fc se\u00e7enekleri aras\u0131nda neyin de\u011fi\u015fti\u011fini denetlemeniz (audit) gerekti\u011finde</li> <li>Regresyon testleri, demolar veya ekip arkada\u015flar\u0131n\u0131zla payla\u015fmak i\u00e7in \u00e7\u0131kt\u0131lar (artifacts) haz\u0131rlad\u0131\u011f\u0131n\u0131zda</li> </ul>"},{"location":"tr/guides/simulation/export-sources/#adm-adm-dsa-aktarma-is-aks","title":"Ad\u0131m ad\u0131m d\u0131\u015fa aktarma i\u015f ak\u0131\u015f\u0131","text":"<pre><code>from dynlib import build\n\nmodel = build(\"decay.toml\", stepper=\"euler\", jit=True)\nfiles = model.export_sources(\"compiled_sources\")\nprint(files[\"rhs\"])\n</code></pre> <ol> <li>Bir <code>FullModel</code> elde etmek i\u00e7in <code>build(...)</code> veya <code>setup(...)</code> \u00e7a\u011f\u0131r\u0131n. Zaten bir <code>Sim</code>'iniz varsa, derlenmi\u015f yap\u0131ya ula\u015fmak i\u00e7in <code>sim.model</code> kullan\u0131n.</li> <li>Yaz\u0131labilir bir <code>output_dir</code> (\u00e7\u0131kt\u0131 dizini) iletin. Dizin otomatik olarak olu\u015fturulur (<code>mkdir -p</code> mant\u0131\u011f\u0131yla).</li> <li>D\u00f6n\u00fc\u015f de\u011feri, bile\u015fen isimlerini yaz\u0131lan dosyan\u0131n <code>Path</code> nesnesine e\u015fleyen bir s\u00f6zl\u00fckt\u00fcr.</li> <li>Farkl\u0131 se\u00e7eneklerle her yeniden derleme (rebuild) yapt\u0131\u011f\u0131n\u0131zda, kaynak farklar\u0131n\u0131 kar\u015f\u0131la\u015ft\u0131rmak i\u00e7in yeni bir dizine tekrar d\u0131\u015fa aktar\u0131m yapabilirsiniz.</li> </ol> <p>Ba\u011f\u0131ms\u0131z bir yard\u0131mc\u0131 tercih ederseniz, <code>dynlib.compiler.build</code> mod\u00fcl\u00fcnden <code>export_model_sources</code>'\u0131 i\u00e7e aktar\u0131n ve <code>FullModel</code> \u00f6rne\u011fini iletin.</p>"},{"location":"tr/guides/simulation/export-sources/#neler-yazlr","title":"Neler yaz\u0131l\u0131r","text":"<p>D\u0131\u015fa aktarma i\u015flemi, model nesnesi \u00fczerindeki kaynak metnini ta\u015f\u0131yan her derlenmi\u015f bile\u015fen i\u00e7in bir <code>.py</code> dosyas\u0131 yazar:</p> <ul> <li><code>rhs.py</code>, <code>events_pre.py</code>, <code>events_post.py</code>, <code>update_aux.py</code></li> <li><code>stepper.py</code> ve (mevcut oldu\u011funda) <code>jvp.py</code>, <code>jacobian.py</code>, <code>inv_rhs.py</code></li> </ul> <p>Ek olarak, <code>model_info.txt</code> spesifikasyonu \u00f6zetler: spec hash, t\u00fcr (kind), stepper ad\u0131, veri tipi (dtype), listelenen durumlar/parametreler, RHS denklemleri ve herhangi bir olay\u0131n k\u0131sa bir \u00f6nizlemesi (faz, guard ve eylem blo\u011funun ilk ~50 karakteri). Kodun yan\u0131nda bu metadatan\u0131n olmas\u0131, derlenmi\u015f bir snapshot'\u0131 DSL girdisiyle ili\u015fkilendirmeyi kolayla\u015ft\u0131r\u0131r.</p> <p><code>FullModel</code> kaynaklar\u0131 <code>disk_cache</code> veya se\u00e7ti\u011finiz stepper'dan ba\u011f\u0131ms\u0131z olarak tuttu\u011fu i\u00e7in, derleyici \u00f6nbelle\u011fe al\u0131nm\u0131\u015f yap\u0131lar\u0131 yeniden kullansa veya <code>euler</code>, <code>rk4</code> ya da \u00f6zel stepper'lar aras\u0131nda ge\u00e7i\u015f yapsan\u0131z bile d\u0131\u015fa aktarma \u00e7al\u0131\u015f\u0131r. Dosyalar UTF-8 kodlamas\u0131yla yaz\u0131l\u0131r, b\u00f6ylece herhangi bir standart edit\u00f6rde a\u00e7abilirsiniz.</p>"},{"location":"tr/guides/simulation/export-sources/#ipuclar","title":"\u0130pu\u00e7lar\u0131","text":"<ul> <li>Hata ay\u0131klama i\u00e7in olu\u015fturulan runner/stepper'\u0131n bir kayd\u0131na ihtiyac\u0131n\u0131z varsa, derledikten sonra ve uzun sim\u00fclasyonlar\u0131 \u00e7al\u0131\u015ft\u0131rmadan \u00f6nce d\u0131\u015fa aktar\u0131n.</li> <li>Her d\u0131\u015fa aktarma dizinini bir snapshot olarak de\u011ferlendirin: Regresyonlar\u0131 izlemek veya belirli bir se\u00e7ene\u011fin (\u00f6rne\u011fin; <code>jit=True</code> vs <code>jit=False</code>) \u00fcretilen kodu nas\u0131l etkiledi\u011fini belgelemek i\u00e7in saklay\u0131n.</li> <li>Yard\u0131mc\u0131 metot <code>Path</code> nesneleri d\u00f6nd\u00fcr\u00fcr, b\u00f6ylece i\u00e7erikleri hemen okuyabilirsiniz (\u00f6rne\u011fin; <code>files[\"stepper\"].read_text()</code>).</li> </ul>"},{"location":"tr/guides/simulation/jit/","title":"Sim\u00fclasyonlarda JIT Derlemesi","text":"<p>dynlib \u015fu anda tek just-in-time (JIT) arka ucu (backend) olarak Numba'ya dayanmaktad\u0131r. <code>build()</code> ve <code>setup()</code> varsay\u0131lan olarak <code>jit=False</code> ve <code>disk_cache=False</code> ayarlar\u0131na sahip oldu\u011fundan, JIT'i a\u00e7mak bilin\u00e7li bir tercihtir: derlenmi\u015f \u00e7ekirdeklere (kernels) ihtiyac\u0131n\u0131z oldu\u011funda <code>jit=True</code> parametresini ge\u00e7in. E\u011fer Numba y\u00fckl\u00fc de\u011filse, bu bayrak <code>JITUnavailableError</code> hatas\u0131 verir, bu y\u00fczden \u00f6nce numba'y\u0131 y\u00fckleyin. Runtime tasar\u0131m\u0131, derlenmi\u015f \u00e7ekirde\u011fin GIL-free (Global Interpreter Lock'tan ba\u011f\u0131ms\u0131z) oldu\u011funu varsayar, bu nedenle di\u011fer JIT motorlar\u0131 (PyPy, Cython, LLVM sarmalay\u0131c\u0131lar\u0131 vb.) desteklenmez.</p>"},{"location":"tr/guides/simulation/jit/#jiti-acma","title":"JIT'i A\u00e7ma","text":"<ul> <li>D\u00fcz bir <code>build(model)</code> veya <code>setup(model)</code> \u00e7a\u011fr\u0131s\u0131, sim\u00fclasyonu tamamen Python i\u00e7inde \u00e7al\u0131\u015ft\u0131r\u0131r.</li> <li>dynlib'i RHS, events, auxiliary updater, stepper, runner ve guard'lar\u0131 Numba ile derlemeye zorlamak i\u00e7in <code>jit=True</code> parametresini kullan\u0131n.</li> <li><code>jit=False</code> h\u0131zl\u0131 deneyler veya k\u0131sa partiler (batches) i\u00e7in g\u00fcvenliyken, <code>jit=True</code>, \u00f6n derleme maliyetinin amorti edildi\u011fi uzun s\u00fcreli sim\u00fclasyonlar i\u00e7in avantajl\u0131d\u0131r.</li> <li>Derlenmi\u015f \u00e7\u0131kt\u0131lar\u0131 i\u015flemler (processes) aras\u0131nda kal\u0131c\u0131 hale getirmek i\u00e7in <code>jit=True</code> ile birlikte <code>disk_cache=True</code> kullan\u0131n; <code>disk_cache=False</code> b\u0131rakmak her \u015feyi bellekte tutar ve \u00f6nbellek k\u00f6k dizinine (cache root) yaz\u0131lmas\u0131n\u0131 engeller.</li> </ul> <pre><code>from dynlib import setup\n\nsim = setup(\"builtin://ode/vanderpol\", stepper=\"rk4\", jit=True, disk_cache=True)\nsim.run(T=20.0)\n</code></pre> <p><code>FullModel</code>'i incelemeniz gerekti\u011finde do\u011frudan <code>build()</code> fonksiyonunu da \u00e7a\u011f\u0131rabilirsiniz. Derlenmi\u015f nitelikleri (<code>model.rhs</code>, <code>model.stepper</code>, <code>model.runner</code> vb.), JIT i\u015fleminden sonra ola\u011fan Numba <code>signatures</code> \u00f6zelliklerini a\u00e7\u0131\u011fa \u00e7\u0131kar\u0131r.</p>"},{"location":"tr/guides/simulation/jit/#neler-derlenir","title":"Neler derlenir","text":"<p>JIT yolu, say\u0131sal olarak yo\u011fun d\u00f6ng\u00fc (hot loop) i\u00e7inde \u00e7al\u0131\u015fan par\u00e7alar\u0131 kapsar:</p> <ul> <li>Triplet fonksiyonlar\u0131: <code>rhs</code>, <code>events_pre</code>, <code>events_post</code> ve <code>update_aux</code>, stepper/runner taraf\u0131ndan \u00e7a\u011fr\u0131ld\u0131klar\u0131nda performansl\u0131 kalmalar\u0131 i\u00e7in birlikte derlenir.</li> <li>Stepper: <code>stepper.emit()</code>, entegrasyon \u00e7ekirde\u011fini \u00fcretir; bu da stepper JIT uyumlu olarak i\u015faretlendi\u011finde JIT ile derlenir.</li> <li>Runner: Runner \u015fablonu (ordinary, fast-path veya analysis varyant\u0131), t\u00fcm wrapper \u2192 runner y\u0131\u011f\u0131n\u0131n\u0131n Python'a geri d\u00f6nmeden \u00e7al\u0131\u015fmas\u0131 i\u00e7in ayn\u0131 <code>jit</code> bayra\u011f\u0131yla derlenir.</li> <li>Guard'lar: JIT etkinle\u015ftirildi\u011finde, durumlar\u0131/parametreleri do\u011frulayan guard yard\u0131mc\u0131lar\u0131 bir kez derlenir ve <code>nopython</code> s\u00f6zle\u015fmesini sa\u011flam tutmak i\u00e7in yeniden kullan\u0131l\u0131r.</li> </ul>"},{"location":"tr/guides/simulation/jit/#jit-cktlarn-onbellege-alma-caching","title":"JIT \u00e7\u0131kt\u0131lar\u0131n\u0131 \u00f6nbelle\u011fe alma (Caching)","text":"<p>\u00d6nbelle\u011fe alma, ayn\u0131 modeli yeniden \u00e7al\u0131\u015ft\u0131rd\u0131\u011f\u0131n\u0131zda veya ba\u015fka bir i\u015flemde (process) yeniden olu\u015fturdu\u011funuzda gereksiz derlemeyi ortadan kald\u0131r\u0131r.</p> <ul> <li> <p><code>disk_cache=True</code>: Derlenmi\u015f triplet'leri, stepper'lar\u0131 ve runner'lar\u0131 \u015fu yollarda kal\u0131c\u0131 hale getirir:</p> <ul> <li><code>~/.cache/dynlib/jit/...</code> (Linux),</li> <li><code>~/Library/Caches/dynlib/jit/...</code> (macOS),</li> <li><code>%LOCALAPPDATA%/dynlib/Cache/jit/...</code> (Windows).</li> </ul> </li> <li> <p><code>disk_cache=False</code>: Her \u015feyi bellekte tutar; \u00f6nbellek k\u00f6k dizinine yazamad\u0131\u011f\u0131n\u0131zda veya her \u00e7al\u0131\u015ft\u0131rma i\u00e7in \u00f6zellikle temiz bir derleme istedi\u011finizde kullan\u0131\u015fl\u0131d\u0131r.</p> </li> <li> <p>Kaynak g\u00f6r\u00fcn\u00fcrl\u00fc\u011f\u00fc: \u00dcretilen kaynak kodu, <code>disk_cache</code> durumuna bak\u0131lmaks\u0131z\u0131n <code>model</code> nesnesi \u00fczerinde (<code>model.rhs_source</code>, <code>model.stepper_source</code>, \u2026) eri\u015filebilir kal\u0131r.</p> </li> </ul>"},{"location":"tr/guides/simulation/jit/#onbellek-anahtar-cache-key-nasl-olusturulur","title":"\u00d6nbellek anahtar\u0131 (cache key) nas\u0131l olu\u015fturulur","text":"<ul> <li><code>runner_variants.get_runner</code> ve triplet/stepper \u00f6nbellek olu\u015fturucular\u0131, \u00f6nbellek anahtarlar\u0131n\u0131 deterministik girdilerden t\u00fcretir: model hash'i, stepper ad\u0131, dtype, guard yap\u0131 imzas\u0131, runner varyant\u0131, analiz imzas\u0131, <code>cache_token</code>, JIT bayra\u011f\u0131 ve \u015fablon s\u00fcr\u00fcm\u00fc.</li> <li>Triplet/stepper \u00f6nbellekleri, derlenmi\u015f mod\u00fclleri <code>cache_root/jit/triplets|steppers/.../&lt;digest&gt;</code> alt\u0131nda saklar, b\u00f6ylece ayn\u0131 hash'e sahip iki \u00e7al\u0131\u015ft\u0131rma derlenmi\u015f \u00e7\u0131kt\u0131y\u0131 hemen yeniden kullan\u0131r.</li> <li>Runner'lar <code>analysis</code> kancalar\u0131n\u0131 (hooks) enjekte eder ve bu nedenle yaln\u0131zca analiz d\u0131\u015f\u0131 varyantlar\u0131 \u00f6nbelle\u011fe al\u0131r (analiz uyumlu runner'lar i\u00e7in <code>njit(cache=True)</code> bayraklar\u0131 atlan\u0131r \u00e7\u00fcnk\u00fc kancalar \u00e7al\u0131\u015fma zaman\u0131nda \u00e7\u00f6z\u00fcmlenir). Varyantlar yine de i\u015flem i\u00e7inde (in-process) ve disk \u00fczerinde <code>runner_cache</code> arac\u0131l\u0131\u011f\u0131yla \u00f6nbelle\u011fe al\u0131n\u0131r ve <code>cache_token</code> (yap\u0131land\u0131r\u0131lm\u0131\u015f \u00f6nbellek ba\u011flam\u0131na dayal\u0131 olarak), \u00e7al\u0131\u015fma alan\u0131 d\u00fczeni veya dtype de\u011fi\u015fti\u011finde \u00f6nbelleklerin ge\u00e7ersiz k\u0131l\u0131nmas\u0131n\u0131 sa\u011flar.</li> </ul>"},{"location":"tr/guides/simulation/jit/#onbellek-kok-dizinini-yaplandrma","title":"\u00d6nbellek k\u00f6k dizinini yap\u0131land\u0131rma","text":"<p>\u00d6nbellek k\u00f6k dizinini yap\u0131land\u0131rma dosyalar\u0131 veya ortam de\u011fi\u015fkenleri arac\u0131l\u0131\u011f\u0131yla ge\u00e7ersiz k\u0131labilirsiniz:</p> <ol> <li><code>DYNLIB_CONFIG</code>, <code>cache_root = \"/ozel/kok\"</code> veya <code>root = \"/ozel/kok\"</code> i\u00e7eren bir <code>[cache]</code> tablosu bulundurabilen bir TOML dosyas\u0131na i\u015faret eder.</li> <li><code>load_config()</code> ayr\u0131ca <code>DYN_MODEL_PATH</code>'i de dikkate al\u0131r, b\u00f6ylece <code>cache_root</code> ge\u00e7ersiz k\u0131lmalar\u0131n\u0131 \u00f6zel TAG k\u00f6kleriyle birle\u015ftirebilirsiniz.</li> <li>Yap\u0131land\u0131r\u0131lan k\u00f6k yaz\u0131labilir de\u011filse, dynlib <code>/tmp/dynlib-cache</code> yoluna geri d\u00f6ner (ve bir kez uyar\u0131r). Bu da ba\u015far\u0131s\u0131z olursa, runtime uyar\u0131r ve JIT \u00f6nbelle\u011fini tamamen bellekte tutar (dosya yaz\u0131lmaz).</li> </ol>"},{"location":"tr/guides/simulation/jit/#onbellek-dayankllg","title":"\u00d6nbellek dayan\u0131kl\u0131l\u0131\u011f\u0131","text":"<ul> <li>Disk \u00fczerindeki \u00f6nbellek, bozulma tespit etti\u011finde kendini yeniden olu\u015fturur: bozuk mod\u00fcl\u00fc siler, olu\u015fturulan kayna\u011f\u0131 yeniden i\u015fler (re-render) ve derlemeyi yeniden dener.</li> <li><code>CacheLock</code> korumalar\u0131, birden fazla i\u015flem ayn\u0131 \u00f6zeti (digest) ayn\u0131 anda doldurmaya \u00e7al\u0131\u015ft\u0131\u011f\u0131nda yar\u0131\u015f durumlar\u0131n\u0131 (races) \u00f6nler.</li> <li>\u00d6nbellekler ayr\u0131ca <code>cache_token</code>'a dokunarak manuel bir ge\u00e7ersiz k\u0131lma yolunu da destekler (runner olu\u015fturucu mevcut yap\u0131 imzas\u0131n\u0131 ve dtype'\u0131 al\u0131r), b\u00f6ylece ABI'yi etkileyen de\u011fi\u015fiklikler otomatik olarak yeni giri\u015fler olu\u015fturur.</li> <li>Runner veya stepper kaynak kodundaki de\u011fi\u015fiklikler izlenmez veya hash'lenmez. Kaynak kodundaki herhangi bir de\u011fi\u015fiklik \u00f6nbelle\u011fi bozabilir veya \u00f6nbelle\u011fe al\u0131nm\u0131\u015f \u00e7\u0131kt\u0131lar nedeniyle eski davran\u0131\u015flarla kar\u015f\u0131la\u015fabilirsiniz. Bu gibi durumlarda \u00f6nbelle\u011fi silin. \u00d6nbelle\u011fi silmek i\u00e7in CLI kullan\u0131labilir (\u00f6rne\u011fin: <code>dynlib cache clear --all</code>).</li> </ul>"},{"location":"tr/guides/simulation/jit/#derleme-durumunu-kontrol-etme","title":"Derleme durumunu kontrol etme","text":"<p>Bir \u00e7a\u011fr\u0131labilirin (callable) ger\u00e7ekten JIT ile derlenip derlenmedi\u011fini bilmek istiyorsan\u0131z:</p> <pre><code>from dynlib import build\n\ndef is_jitted(fn):\n    return hasattr(fn, \"signatures\") and bool(fn.signatures)\n\nmodel = build(\"model.toml\", stepper=\"euler\", jit=True)\nprint(\"RHS jitted\", is_jitted(model.rhs))\nprint(\"Runner jitted\", is_jitted(model.runner))\n</code></pre> <p><code>model.export_sources(...)</code> fonksiyonu <code>disk_cache=True</code> oldu\u011funda bile \u00e7al\u0131\u015f\u0131r; d\u0131\u015fa aktar\u0131lan dizin, dynlib'in arka planda ne derledi\u011fini incelemeyi kolayla\u015ft\u0131ran her derlenmi\u015f bile\u015feni (<code>rhs.py</code>, <code>stepper.py</code>, <code>runner.py</code> vb.) i\u00e7erir.</p>"},{"location":"tr/guides/simulation/jit/#en-iyi-uygulamalar","title":"En iyi uygulamalar","text":"<ul> <li><code>jit=True</code> se\u00e7ene\u011fini, \u00f6n derleme maliyetini amorti edecek kadar uzun \u00e7al\u0131\u015fan sim\u00fclasyonlar i\u00e7in saklay\u0131n.</li> <li>Ayn\u0131 modelleri tekrar tekrar olu\u015fturdu\u011funuz geli\u015ftirme d\u00f6ng\u00fcleri i\u00e7in <code>disk_cache=True</code> kullan\u0131n; temiz bir ba\u015flang\u0131ca ihtiya\u00e7 duydu\u011funuzda (\u00f6rne\u011fin, taze bir derleme sa\u011flayan CI veya testlerde) bunu kapat\u0131n.</li> <li>Bir \u00e7al\u0131\u015ft\u0131rma Numba hatas\u0131yla ba\u015far\u0131s\u0131z olursa, traceback'i inceleyin, desteklenmeyen Python yap\u0131lar\u0131n\u0131 d\u00fczeltin ve yeniden \u00e7al\u0131\u015ft\u0131r\u0131n - dynlib, <code>jit=True</code> oldu\u011funda sessizce Python'a geri d\u00f6nmez.</li> <li>Yeni observer kancalar\u0131 ekledi\u011finizde veya dtype/stepper de\u011fi\u015ftirdi\u011finizde, \u00f6nbellek anahtar\u0131 otomatik olarak de\u011fi\u015fir, bu nedenle \u00f6nbellek dizinlerini manuel olarak silmenize gerek yoktur.</li> </ul> <p>Bu ayarlarla, kal\u0131c\u0131 \u00f6nbellekler arac\u0131l\u0131\u011f\u0131yla izlenebilirli\u011fi ve tekrarlanabilirli\u011fi korurken neredeyse yerel (native) performans elde edebilirsiniz.</p>"},{"location":"tr/guides/simulation/presets/","title":"Runtime Preset'leri","text":"<p>Bu rehber, bir sim\u00fclasyon \u00e7al\u0131\u015f\u0131rken preset (haz\u0131r ayar) bankas\u0131yla nas\u0131l \u00e7al\u0131\u015f\u0131laca\u011f\u0131na odaklan\u0131r. Preset tan\u0131mlar\u0131n\u0131n DSL taraf\u0131 <code>docs/guides/modeling/presets.md</code> i\u00e7inde yer al\u0131r, ancak bir <code>FullModel</code> derlendi\u011finde, <code>Sim</code> \u00f6rne\u011fi bu preset'lerin kendi bellek i\u00e7i \u00f6nbelle\u011fini, art\u0131 sonradan ekledi\u011finiz veya i\u00e7e aktard\u0131\u011f\u0131n\u0131z her \u015feyi tutar.</p>"},{"location":"tr/guides/simulation/presets/#sim-icindeki-preset-bankas","title":"<code>Sim</code> i\u00e7indeki Preset bankas\u0131","text":"<p>Her <code>Sim</code>, model spesifikasyonundaki sat\u0131r i\u00e7i <code>[presets.&lt;isim&gt;]</code> tablolar\u0131 ile ba\u015flatma s\u0131ras\u0131nda doldurulan bir preset bankas\u0131 tutar. \u015eu anda nelerin mevcut oldu\u011funu incelemek i\u00e7in <code>list_presets(pattern=\"*\")</code> kullan\u0131n; bu, alfabetik olarak s\u0131ralanm\u0131\u015f isimleri d\u00f6nd\u00fcr\u00fcr ve <code>glob</code> tarz\u0131 filtreleri (<code>*</code>, <code>?</code>, <code>[]</code>) destekler.</p> <pre><code>sim = Sim(model)\nprint(sim.list_presets())  # ['bursting', 'regular_spiking', ...]\n</code></pre> <p>Banka; \u00e7al\u0131\u015ft\u0131rmalar (runs), snapshot'lar ve resume segmentleri aras\u0131nda payla\u015f\u0131l\u0131r, b\u00f6ylece modeli yeniden olu\u015fturmadan preset'ler aras\u0131nda ge\u00e7i\u015f yapabilirsiniz.</p>"},{"location":"tr/guides/simulation/presets/#calstrma-oncesi-bir-preset-uygulama","title":"\u00c7al\u0131\u015ft\u0131rma \u00f6ncesi bir preset uygulama","text":"<p>Bir preset'in durumlar\u0131n\u0131 (states) ve/veya parametrelerini mevcut oturuma g\u00f6ndermek i\u00e7in <code>sim.apply_preset(isim)</code> \u00e7a\u011fr\u0131s\u0131 yap\u0131n. Yaln\u0131zca preset i\u00e7inde listelenen anahtarlar g\u00fcncellenir\u2014di\u011fer her \u015fey (zaman, <code>dt</code>, stepper \u00e7al\u0131\u015fma alan\u0131, kaydedilen ge\u00e7mi\u015f) dokunulmadan b\u0131rak\u0131l\u0131r\u2014bu nedenle bu, <code>run()</code> \u00f6ncesinde veya segmentler aras\u0131nda oturumu yeniden yap\u0131land\u0131rman\u0131n g\u00fcvenli ve art\u0131ml\u0131 bir yoludur.</p> <pre><code>sim.apply_preset(\"bursting\")\nsim.run(T=2.0, record=True)\n</code></pre> <p>Preset'in par\u00e7as\u0131 olmayan bir parametreyi de\u011fi\u015ftirmeniz gerekirse, preset'i uygulad\u0131ktan sonra <code>sim.assign(...)</code> kullan\u0131n veya ek anahtar\u0131 i\u00e7eren yeni bir preset olu\u015fturun. Bir preset uygulamak <code>reset()</code>/<code>import_snapshot()</code> sonras\u0131nda da \u00e7al\u0131\u015f\u0131r, b\u00f6ylece kaydedilmi\u015f bir durumdan yeni bir de\u011fer kombinasyonuyla dallanabilirsiniz.</p>"},{"location":"tr/guides/simulation/presets/#annda-yeni-presetler-yakalama","title":"An\u0131nda yeni preset'ler yakalama","text":"<p><code>sim.add_preset(isim, *, states=None, params=None, overwrite=False)</code>, preset bankas\u0131na yeni bir giri\u015f kaydeder.</p> <ul> <li>Hem <code>states</code> hem de <code>params</code> atland\u0131\u011f\u0131nda, y\u00f6ntem mevcut oturum de\u011ferlerinin anl\u0131k g\u00f6r\u00fcnt\u00fcs\u00fcn\u00fc (snapshot) al\u0131r. Aksi takdirde, saklamak istedi\u011finiz de\u011fi\u015fkenler i\u00e7in e\u015flemeler (mappings) veya 1-D NumPy dizileri sa\u011flay\u0131n.</li> <li>Mevcut bir preset'i de\u011fi\u015ftirmek i\u00e7in <code>overwrite=True</code> ge\u00e7in, aksi takdirde \u00e7ak\u0131\u015fmay\u0131 \u00f6nlemek i\u00e7in bir <code>ValueError</code> y\u00fckseltilir.</li> </ul> <pre><code>sim.assign(I=15.0)\nsim.run(T=1.0)\nsim.add_preset(\"after_stim\", overwrite=True)  # en son durumlar\u0131 ve parametreleri yakalar\n</code></pre> <p>Ayr\u0131ca anahtar kelime arg\u00fcmanlar\u0131ndan birini ge\u00e7irerek k\u0131smi preset'ler (\u00f6rne\u011fin, durumlar\u0131n sadece bir alt k\u00fcmesini saklayan) olu\u015fturabilirsiniz.</p>"},{"location":"tr/guides/simulation/presets/#presetleri-ice-ve-dsa-aktarma","title":"Preset'leri i\u00e7e ve d\u0131\u015fa aktarma","text":"<p><code>dynlib-presets-v1</code> \u015femas\u0131n\u0131 (<code>[__presets__].schema = \"dynlib-presets-v1\"</code>) izleyen bir TOML dosyas\u0131ndan preset okumak i\u00e7in <code>sim.load_preset(isim_veya_desen, yol, *, on_conflict=\"error\")</code> kullan\u0131n. Tek bir preset ismini e\u015fle\u015ftirebilir veya <code>\"fast_*\"</code> gibi bir glob deseni ge\u00e7ebilirsiniz. Y\u00fckleyici dosyay\u0131 do\u011frular, say\u0131sal tablolar\u0131 zorunlu k\u0131lar ve referans verilen her durumun/parametrenin aktif modelde mevcut oldu\u011fundan emin olur.</p> <ul> <li><code>on_conflict=\"error\"</code> (varsay\u0131lan), banka zaten preset'i i\u00e7eriyorsa hata verir.</li> <li><code>\"keep\"</code>, dosya preset'ini atlar ve bankay\u0131 dokunmadan b\u0131rak\u0131r (uyar\u0131 verilir).</li> <li><code>\"replace\"</code>, banka giri\u015fini dosya s\u00fcr\u00fcm\u00fcyle \u00fczerine yazar (uyar\u0131 verilir).</li> </ul> <pre><code>sim.load_preset(\"fast_*\", \"presets.toml\", on_conflict=\"replace\")\nsim.apply_preset(\"fast_spiking\")\nsim.run(T=5.0)\n</code></pre> <p>Tersine, <code>sim.save_preset(isim, yol, *, overwrite=False)</code> bir banka giri\u015fini diske geri yazar. Yard\u0131mc\u0131, bir <code>[__presets__]</code> ba\u015fl\u0131\u011f\u0131n\u0131n var oldu\u011fundan emin olur, dosyadaki ilgisiz preset'leri dokunmadan b\u0131rak\u0131r ve ya yeni bir <code>[presets.&lt;isim&gt;]</code> tablosu ekler ya da zaten varsa (e\u011fer <code>overwrite=True</code> ise) g\u00fcnceller.</p> <pre><code>sim.save_preset(\"after_stim\", \"presets.toml\", overwrite=True)\n</code></pre> <p>Preset'leri kal\u0131c\u0131 hale getirmek; deney m\u00fcfredatlar\u0131 olu\u015fturman\u0131za, yap\u0131land\u0131rmalar\u0131 i\u015f arkada\u015flar\u0131n\u0131zla payla\u015fman\u0131za veya bir sonu\u00e7 \u00fcreten tam durumlar\u0131/parametre setlerini s\u00fcr\u00fcm kontrol\u00fcne alman\u0131za olanak tan\u0131r.</p>"},{"location":"tr/guides/simulation/presets/#runtime-presetleri-ile-calsma-ipuclar","title":"Runtime preset'leri ile \u00e7al\u0131\u015fma ipu\u00e7lar\u0131","text":"<ul> <li>Tek bir i\u015f ak\u0131\u015f\u0131 i\u00e7inde preset'ler aras\u0131nda ge\u00e7i\u015f yaparken, oturumu yeniden yap\u0131land\u0131rmak i\u00e7in genellikle <code>apply_preset()</code> yeterlidir; yaln\u0131zca zaman\u0131 geri sarmak veya kaydediciyi temizlemek istiyorsan\u0131z <code>reset()</code> veya snapshot'lara ihtiya\u00e7 duyars\u0131n\u0131z.</li> <li>Tekrar oynat\u0131labilir bir durumu yakalamak ve di\u011fer projeler i\u00e7in d\u0131\u015fa aktarmak amac\u0131yla <code>add_preset()</code> ve <code>save_preset()</code> komutlar\u0131n\u0131 birle\u015ftirin.</li> <li>Preset'lerin yaln\u0131zca listeledikleri de\u011fi\u015fkenlere dokundu\u011funu unutmay\u0131n\u2014her parametreyi ge\u00e7ersiz k\u0131lman\u0131z veya sabit bir zaman hikayesi tutman\u0131z gerekiyorsa, \u00e7al\u0131\u015ft\u0131rmadan \u00f6nce bunlar\u0131 snapshot'lar veya <code>assign()</code> \u00e7a\u011fr\u0131lar\u0131 ile e\u015fle\u015ftirin.</li> </ul>"},{"location":"tr/guides/simulation/results/","title":"Sim\u00fclasyon Sonu\u00e7lar\u0131","text":"<p>Bu rehber, dynlib'in ne kaydetti\u011fini, sonu\u00e7lar\u0131 nas\u0131l dilimleyece\u011finizi/filtreleyece\u011finizi/d\u0131\u015fa aktaraca\u011f\u0131n\u0131z\u0131 ve b\u00fcy\u00fck sim\u00fclasyonlar\u0131 nas\u0131l y\u00f6netilebilir tutaca\u011f\u0131n\u0131z\u0131 anlaman\u0131z i\u00e7in <code>Sim.results()</code> / <code>Sim.raw_results()</code> konular\u0131na derinlemesine iner.</p>"},{"location":"tr/guides/simulation/results/#1-resultsview-ile-isimlendirilmis-erisim","title":"1. <code>ResultsView</code> ile isimlendirilmi\u015f eri\u015fim","text":"<p><code>Sim.results()</code>, model spesifikasyonundan t\u00fcretilen isimlerle sim\u00fclasyon sonu\u00e7lar\u0131na ergonomik eri\u015fim sa\u011flayan bir <code>ResultsView</code> d\u00f6nd\u00fcr\u00fcr:</p> <ul> <li><code>res.t</code>, <code>res.step</code>, <code>res.flags</code>; zaman eksenini, ad\u0131m indekslerini ve durum bayraklar\u0131n\u0131 NumPy g\u00f6r\u00fcn\u00fcmleri (views) olarak verir.</li> <li><code>res[\"x\"]</code>, <code>res[\"aux.energy\"]</code> veya <code>res[[\"x\",\"y\"]]</code>; durumlar ve aux de\u011fi\u015fkenleri i\u00e7in kaydedilen serileri d\u00f6nd\u00fcr\u00fcr ve \u00e7oklu de\u011fi\u015fken isteklerinde gerekti\u011finde bunlar\u0131 kompakt kopyalar halinde y\u0131\u011far.</li> <li><code>res.analyze(...)</code> h\u0131zl\u0131 istatistikler (maks/min/kesi\u015fmeler) i\u00e7in bir <code>TrajectoryAnalyzer</code> / <code>MultiVarAnalyzer</code> olu\u015fturur ve <code>res.observers</code>, \u00e7al\u0131\u015fma zaman\u0131 observer \u00e7\u0131kt\u0131lar\u0131n\u0131 ergonomik <code>ObserverResult</code> sarmalay\u0131c\u0131s\u0131 arac\u0131l\u0131\u011f\u0131yla y\u00fczeye \u00e7\u0131kar\u0131r.</li> <li><code>res.segment</code>, ana API'yi yans\u0131t\u0131rken tek bir \u00e7al\u0131\u015ft\u0131rmaya (otomatik <code>run#N</code> isimleri veya manuel etiketler) odaklanman\u0131z\u0131 sa\u011flar. Her <code>SegmentView</code>, kopyalama yapmadan o par\u00e7aya ait <code>t</code>, <code>step</code>, <code>flags</code> ve hatta <code>events()</code> verilerini dilimler.</li> </ul>"},{"location":"tr/guides/simulation/results/#2-sununla-ham-erisim-results","title":"2. \u015eununla ham eri\u015fim: <code>Results</code>","text":"<p>Alttaki tamponlara (buffers) do\u011frudan eri\u015fmesi gereken ileri d\u00fczey kullan\u0131c\u0131lar i\u00e7in <code>Sim.raw_results()</code>, kopyalama yapmadan runner tamponlar\u0131n\u0131 yans\u0131tan bir <code>Results</code> veri s\u0131n\u0131f\u0131 (dataclass) sunar. Temel alanlar \u015funlard\u0131r: destekleyici diziler (zaman <code>T</code>, durumlar <code>Y</code>, iste\u011fe ba\u011fl\u0131 aux <code>AUX</code>, <code>STEP</code>, <code>FLAGS</code>), olay g\u00fcnl\u00fc\u011f\u00fc (<code>EVT_CODE</code>, <code>EVT_INDEX</code>, <code>EVT_LOG_DATA</code>), dolu say\u0131lar <code>n</code>/<code>m</code>, \u00e7\u0131k\u0131\u015f <code>status</code> ve son durum/parametreler/\u00e7al\u0131\u015fma alanlar\u0131n\u0131n snapshot'lar\u0131. Her eri\u015fimci (accessor), dolu b\u00f6lgeyle s\u0131n\u0131rl\u0131 bir g\u00f6r\u00fcn\u00fcm sa\u011flar, b\u00f6ylece her zaman biti\u015fik kay\u0131tlar\u0131 g\u00f6r\u00fcrs\u00fcn\u00fcz ve <code>Results.to_pandas()</code>, s\u00fctunlar\u0131 sonraki NumPy/Pandas i\u015f ak\u0131\u015flar\u0131 i\u00e7in d\u00fczenli (tidy) bir <code>DataFrame</code> olarak somutla\u015ft\u0131rabilir.</p> <p>Tamponun tamam\u0131na ihtiyac\u0131n\u0131z oldu\u011funda <code>Sim.raw_results()</code> kullan\u0131n. \u00c7o\u011fu kullan\u0131c\u0131 i\u00e7in <code>Sim.results()</code>, bu d\u00fc\u015f\u00fck seviyeli nesneyi isimler, yard\u0131mc\u0131lar ve segmentlerle sarar.</p>"},{"location":"tr/guides/simulation/results/#3-dilimleme-filtreleme-ve-dsa-aktarma","title":"3. Dilimleme, filtreleme ve d\u0131\u015fa aktarma","text":"<ul> <li><code>res[\"var\"]</code>'\u0131 birincil dilimleme kancan\u0131z olarak kullan\u0131n; birden fazla seriyi y\u0131\u011fmak ve do\u011fal s\u0131ralamay\u0131 korumak i\u00e7in <code>res[[\"x\",\"y\"]]</code> kullan\u0131n.</li> <li>Segment ba\u015f\u0131na y\u00f6r\u00fcnge (trajectory) dilimleri i\u00e7in <code>res.segment[0]</code> veya <code>res.segment[\"run#1\"]</code> indekslemesi yap\u0131n. Her segment kendi kay\u0131t penceresine sayg\u0131 duyar ve sar\u0131lm\u0131\u015f k\u0131s\u0131m i\u00e7in <code>events()</code> i\u015flevini a\u00e7ar.</li> <li>Tablo \u015feklinde d\u0131\u015fa aktarmalar\u0131 tercih etti\u011finizde, <code>Results.to_pandas()</code> size <code>t</code>, <code>step</code>, <code>flag</code>, her durum s\u00fctunu ve \u00f6nekli aux s\u00fctunlar\u0131n\u0131 verir, b\u00f6ylece \u00e7er\u00e7eveyi do\u011frudan Pandas/NumPy'ye verebilirsiniz.</li> </ul>"},{"location":"tr/guides/simulation/results/#olay-event-gunlugu-sonuclarna-erisim","title":"Olay (Event) g\u00fcnl\u00fc\u011f\u00fc sonu\u00e7lar\u0131na eri\u015fim","text":"<p>Olaylar y\u00f6r\u00fcngeyle birlikte saklan\u0131r ve her olay sat\u0131r\u0131 bir kod, sahip kay\u0131t indeksi ve g\u00fcnl\u00fc\u011fe kaydedilmi\u015f veri blo\u011fu ta\u015f\u0131r. <code>ResultsView</code>, DSL tan\u0131ml\u0131 isimleri/etiketleri \u00e7\u00f6zer, b\u00f6ylece <code>res.event(\"threshold\")</code> hangi kodun, alanlar\u0131n ve etiketlerin kullan\u0131laca\u011f\u0131n\u0131 bilir. NumPy'nin keyfi sat\u0131r g\u00f6r\u00fcn\u00fcmleri \u00fczerindeki s\u0131n\u0131rlamalar\u0131 nedeniyle, filtreleme (zaman aral\u0131klar\u0131, ba\u015f/kuyruk, s\u0131ralama) kompakt diziler ay\u0131r\u0131r (allocate), ancak API ay\u0131rmalar\u0131 izole tutar, b\u00f6ylece sonu\u00e7lar\u0131n geri kalan\u0131 salt okunur (view-only) kal\u0131r.</p> <ul> <li>Bir <code>EventView</code> almak i\u00e7in <code>res.event(\"spike\")</code> \u00e7a\u011f\u0131r\u0131n, ard\u0131ndan <code>.time(t0, t1)</code>, <code>.head(k)</code>, <code>.tail(k)</code> veya <code>.sort(by=\"t\")</code> zincirleyin ve <code>ev[\"id\"]</code> veya <code>ev[[\"t\",\"id\"]]</code> ile bireysel alanlar\u0131 al\u0131n. <code>ev.table()</code> kaydedilen t\u00fcm s\u00fctunlar\u0131 s\u0131rayla somutla\u015ft\u0131r\u0131r.</li> <li>Birden fazla olay t\u00fcr\u00fc \u00fczerinde grupland\u0131r\u0131lm\u0131\u015f bir g\u00f6r\u00fcn\u00fcm i\u00e7in <code>res.event(tag=\"group\")</code> kullan\u0131n; <code>group.select(...)</code> alanlar\u0131 birle\u015ftirmenize veya kesi\u015ftirmenize izin verirken, <code>group.table(...)</code> birle\u015ftirilmi\u015f sat\u0131rlar\u0131 s\u0131ralayabilir.</li> <li><code>res.event.summary()</code> olay t\u00fcr\u00fc ba\u015f\u0131na h\u0131zl\u0131 say\u0131mlar verir ve <code>res.event.names()/fields()/tags()</code> neyin kaydedildi\u011fini ke\u015ffetmenize yard\u0131mc\u0131 olur.</li> </ul>"},{"location":"tr/guides/simulation/results/#4-buyuk-veri-setleri-ve-harici-araclarla-calsma","title":"4. B\u00fcy\u00fck veri setleri ve harici ara\u00e7larla \u00e7al\u0131\u015fma","text":"<ul> <li><code>Sim.config()</code> ve <code>run()</code> kancalar\u0131 arac\u0131l\u0131\u011f\u0131yla g\u00fcnl\u00fc\u011fe kaydetmeyi (logging) kontrol edin: <code>record</code> \u00f6zelli\u011fini a\u00e7\u0131p kapat\u0131n, her <code>record_interval</code> ad\u0131mda bir atlay\u0131n veya sadece ihtiyac\u0131n\u0131z olan\u0131 yakalamak i\u00e7in <code>record_vars</code>/<code>[]</code> ge\u00e7in.</li> <li>Tamponlar\u0131 \u00f6nceden ay\u0131rmak i\u00e7in <code>cap_rec</code>/<code>cap_evt</code> de\u011ferlerini art\u0131r\u0131n, alt \u00f6rnekleme (downsampling) i\u00e7in <code>record_interval</code> de\u011ferini d\u00fc\u015f\u00fcr\u00fcn veya zaman/ad\u0131m/bayraklar\u0131 kaydederken durum/aux kayd\u0131n\u0131 tamamen devre d\u0131\u015f\u0131 b\u0131rak\u0131n.</li> <li>Tamponlar\u0131 a\u015f\u0131r\u0131 y\u00fcklemeden a\u015famal\u0131 deneyleri y\u00f6netmek i\u00e7in <code>transient</code>, <code>resume</code> ve snapshot'lar\u0131 (<code>Sim.reset()</code>, <code>Sim.create_snapshot()</code>) kullan\u0131n.</li> <li>Halihaz\u0131rda a\u00e7\u0131\u011fa \u00e7\u0131kar\u0131lm\u0131\u015f diziler (<code>res.t</code>, <code>res[\"x\"]</code>, <code>.events()</code>, <code>.table()</code>) arac\u0131l\u0131\u011f\u0131yla veya tutarl\u0131 s\u00fctun isimlerine sahip bir <code>DataFrame</code>'e ihtiya\u00e7 duydu\u011funuzda <code>Results.to_pandas()</code> ile NumPy/Pandas'a d\u0131\u015fa aktar\u0131n.</li> <li><code>res.segment[...]</code>, <code>res.event(...)</code> ve <code>res.observers</code>, ilgilendi\u011finiz dilimleri tamponun geri kalan\u0131ndan ba\u011f\u0131ms\u0131z tutar, b\u00f6ylece bunlar\u0131 gere\u011finden fazla kopyalamadan sonraki analiz\u00f6rlere aktarabilirsiniz.</li> </ul>"},{"location":"tr/guides/simulation/results/#ozet","title":"\u00d6zet","text":"<ul> <li>Ergonomik isimler ve yard\u0131mc\u0131lar istedi\u011finizde <code>Sim.results()</code> kullan\u0131n, ham tampona ihtiyac\u0131n\u0131z oldu\u011funda <code>Sim.raw_results()</code>'a geri d\u00f6n\u00fcn.</li> <li>Segmentleri, olaylar\u0131 ve observer'lar\u0131 dilimler \u00e7\u0131karmak i\u00e7in <code>ResultsView</code> arac\u0131l\u0131\u011f\u0131yla ke\u015ffedin ve y\u00f6r\u00fcngeleri NumPy/Pandas'a vermek i\u00e7in <code>Results.to_pandas()</code> veya <code>res[[\"x\",\"y\"]]</code> ile y\u0131\u011fmay\u0131 kullan\u0131n.</li> <li>Bellek kullan\u0131m\u0131n\u0131 kararl\u0131 tutmak i\u00e7in uzun \u00e7al\u0131\u015ft\u0131rmalardan \u00f6nce <code>record</code>, <code>record_interval</code>, <code>record_vars</code> ve tampon s\u0131n\u0131rlar\u0131n\u0131 (buffer caps) ayarlay\u0131n, ard\u0131ndan ilgilendi\u011finiz olaylar\u0131/segmentleri tekrar oynat\u0131n veya d\u0131\u015fa aktar\u0131n.</li> </ul>"},{"location":"tr/guides/simulation/runner-variants/","title":"Runner T\u00fcrleri","text":"<p>Runner katman\u0131n\u0131n nas\u0131l yap\u0131land\u0131\u011f\u0131n\u0131 anlamak; performans dengelerini, observer (g\u00f6zlemci) deste\u011fini ve fast-path API\u2019nin normal wrapper d\u00f6ng\u00fcs\u00fcnden nas\u0131l ayr\u0131ld\u0131\u011f\u0131n\u0131 daha kolay anlaman\u0131 sa\u011flar.</p>"},{"location":"tr/guides/simulation/runner-variants/#normal-runnerlar","title":"Normal runner\u2019lar","text":"<p><code>run_with_wrapper</code> (bkz. <code>src/dynlib/runtime/wrapper.py</code>) varsay\u0131lan \u00e7al\u0131\u015ft\u0131rma yolunu y\u00f6netir. \u015eunlar\u0131 yapar:</p> <ul> <li><code>Sim</code> ayarlar\u0131n\u0131 (t0/tend, adaptive bayraklar, discrete ufuklar, stop phase\u2019ler, se\u00e7meli kay\u0131t se\u00e7enekleri, observer\u2019lar vb.) dondurulmu\u015f runner ABI\u2019si ile uyumlu tamponlara ve skaler girdilere \u00e7evirir.</li> <li>kay\u0131t/event dizilerini ve workspace\u2019leri bir kez ay\u0131r\u0131r, sonra <code>runner_variants.get_runner</code> \u00fczerinden <code>RunnerVariant.BASE</code> veya <code>RunnerVariant.ANALYSIS</code> runner\u2019\u0131n\u0131 \u00e7a\u011f\u0131r\u0131r.</li> <li><code>GROW_REC</code>, <code>GROW_EVT</code>, <code>DONE</code>, <code>EARLY_EXIT</code>, <code>USER_BREAK</code>, <code>NAN_DETECTED</code> gibi runner sinyallerini y\u00f6netir; gerekirse tamponlar\u0131 b\u00fcy\u00fct\u00fcr veya duraklat\u0131p devam ettirir. B\u00f6ylece derlenmi\u015f kernel hi\u00e7 bir zaman bellek yeniden ay\u0131rmak zorunda kalmaz.</li> <li>d\u00f6n\u00fc\u015fte son state/dt, trace\u2019ler ve observer metadatas\u0131n\u0131 <code>Results</code> nesnesine kopyalar. Bu y\u00fczden wrapper s\u0131cak d\u00f6ng\u00fcy\u00fc yal\u0131n tutar; derlenmi\u015f runner ise say\u0131sal stepping\u2019e odaklan\u0131r.</li> </ul> <p>Bu yol event\u2019leri, de\u011fi\u015fken kay\u0131t uzunluklar\u0131n\u0131, stop phase\u2019leri ve b\u00fcy\u00fcme kodlar\u0131n\u0131 takip etti\u011fi i\u00e7in buna normal runner diyoruz. En esnek runner budur ve <code>fastpath</code> a\u00e7\u0131k\u00e7a istenmedik\u00e7e <code>Sim.run</code> taraf\u0131ndan kullan\u0131l\u0131r. Hem continuous (ODE) hem de discrete (map) stepper\u2019lar ayn\u0131 normal runner \u015fablonlar\u0131n\u0131 payla\u015f\u0131r (<code>RunnerVariant.BASE</code> veya <code>RunnerVariant.ANALYSIS</code>, <code>discrete</code> bayra\u011f\u0131 ile). B\u00f6ylece wrapper, zaman\u0131 baz alan ufuklar\u0131 ve iterasyon b\u00fct\u00e7esi bazl\u0131 ufuklar\u0131 ayn\u0131 ABI ile y\u00f6netebilir.</p>"},{"location":"tr/guides/simulation/runner-variants/#fast-path-runnerlar","title":"Fast-path runner\u2019lar","text":"<p><code>runtime/fastpath/executor.py</code> \u00f6zel, sabit-ad\u0131m (fixed-step) yolunu s\u00fcrer. Executor her \u015feyi en ba\u015fta ay\u0131r\u0131r (workspace\u2019ler, se\u00e7meli kay\u0131t tamponlar\u0131, stop bayraklar\u0131, variational hook\u2019lar) ve sonra <code>runner_variants.get_runner</code> ile <code>RunnerVariant.FASTPATH</code> veya <code>RunnerVariant.FASTPATH_ANALYSIS</code> ister.</p> <p>Fast-path runner\u2019lar sadele\u015ftirilmi\u015ftir:</p> <ul> <li>event-log b\u00fcy\u00fctme veya \u201csticky\u201d tampon yeniden boyutland\u0131rma yoktur \u2014 her \u015fey ilk \u00e7a\u011fr\u0131dan \u00f6nce se\u00e7ilen <code>RecordingPlan</code>\u2019a g\u00f6re ( <code>RecordingPlan.capacity</code> \u00fczerinden) boyutland\u0131r\u0131l\u0131r.</li> <li><code>GROW_*</code> durumlar\u0131 yoktur; runner ald\u0131\u011f\u0131 tamponlar\u0131n yeterli oldu\u011funu varsayar. Bu da d\u00f6ng\u00fcy\u00fc s\u0131k\u0131 tutar.</li> <li>runner \u015fablonunun i\u00e7inde event/kesinti d\u00f6ng\u00fcs\u00fc yoktur; haz\u0131rl\u0131k i\u00e7in ge\u00e7ici warm-up, son k\u0131rpma (trimming) ve metadata \u00fcretimi executor\u2019un sorumlulu\u011fundad\u0131r.</li> </ul> <p>Bu y\u00fczden fast-path runner\u2019lar; tekrarl\u0131 toplu \u00e7al\u0131\u015ft\u0131rmalar (<code>run_batch_fastpath</code>), throughput benchmark\u2019lar\u0131 veya sabit ad\u0131m boyu ve bellek limitlerini garanti edebildi\u011fin senaryolar i\u00e7in idealdir. Executor yine de observer trace\u2019lerini, variational hook\u2019lar\u0131 ve runtime workspace\u2019lerini haz\u0131rlar; ama bunu say\u0131sal olarak \u201cs\u0131cak\u201d d\u00f6ng\u00fcn\u00fcn d\u0131\u015f\u0131nda yapar.</p>"},{"location":"tr/guides/simulation/runner-variants/#analysis-runnerlar","title":"Analysis runner\u2019lar","text":"<p>Observer eklendi\u011finde, hem normal hem de fast-path runner\u2019lar analysis varyant\u0131na ge\u00e7er:</p> <ul> <li><code>RunnerVariant.ANALYSIS</code> (wrapper yolu) ve <code>RunnerVariant.FASTPATH_ANALYSIS</code> (fast-path yolu) observer hook\u2019lar\u0131n\u0131 global olarak (<code>ANALYSIS_PRE</code> ve <code>ANALYSIS_POST</code>) enjekte eder; b\u00f6ylece wrapper/executor runner ABI \u00fczerinden fonksiyon handle ta\u015f\u0131mak zorunda kalmaz.</li> <li><code>runner_variants.compile_analysis_hooks</code>, <code>ObserverModule.resolve_hooks</code> \u00e7\u0131kt\u0131s\u0131n\u0131 \u00e7\u00f6zer, iki hook\u2019u da \u00f6nceden derler (ya da no-op yede\u011fini kullan\u0131r) ve bunlar\u0131 <code>analysis_signature_hash</code> i\u00e7eren runner cache anahtar\u0131na dahil eder.</li> <li>Analysis runner\u2019lar ayr\u0131ca <code>analysis_ws</code>, <code>analysis_out</code> ve trace tamponlar\u0131n\u0131 ba\u011flar; <code>analysis.trace.record_interval()</code> ve <code>analysis_kind</code> gibi metadata\u2019ya uyar. B\u00f6ylece kullan\u0131c\u0131lar ana simulation ad\u0131mlar\u0131n\u0131n yan\u0131nda \u201cyan kanal\u201d verisi de toplayabilir.</li> <li>Variational observer\u2019lar, runner\u2019\u0131n varsay\u0131lan stepper yerine \u00e7a\u011f\u0131raca\u011f\u0131 bir <code>runner_variational_step</code> callback\u2019i sa\u011flayabilir; bu sayede hook\u2019lar JIT uyumlulu\u011funu bozmadan \u00f6nerileri (proposals) ayarlayabilir.</li> </ul> <p>Analysis runner\u2019lar, hangi varyant se\u00e7ildiyse ona g\u00f6re ya normal runner \u00f6zelliklerini (kay\u0131t, durdurma, b\u00fcy\u00fcme) miras al\u0131r ya da fast-path sadele\u015ftirmelerini uygular.</p>"},{"location":"tr/guides/simulation/runner-variants/#mimari-referans","title":"Mimari Referans","text":"<p><code>runner_variants.py</code> t\u00fcm runner \u015fablonlar\u0131 i\u00e7in tek referans noktas\u0131d\u0131r. <code>Sim.run()</code> observer yoksa base runner\u2019\u0131 kullan\u0131r; <code>runtime/fastpath/executor.py</code> ise observer varsa analysis-aware fast-path runner ister. Her executor/normal runner varyant\u0131 ayr\u0131 ayr\u0131 cache\u2019lenir; b\u00f6ylece fast-path batch\u2019leri ve wrapper \u00e7a\u011fr\u0131lar\u0131 kendi derlenmi\u015f kernel\u2019lar\u0131n\u0131 kullan\u0131r.</p>"},{"location":"tr/guides/simulation/runner-variants/#runner_variantspy","title":"<code>runner_variants.py</code>","text":"<ul> <li>T\u00fcm runner varyantlar\u0131 (<code>BASE</code>, <code>ANALYSIS</code>, <code>FASTPATH</code>, <code>FASTPATH_ANALYSIS</code>) i\u00e7in \u015fablonlar\u0131 ve derleme mant\u0131\u011f\u0131n\u0131 tan\u0131mlar; hem continuous hem discrete modelleri kapsar.</li> <li><code>get_runner(variant, ...)</code> fonksiyonunu sunar: cache anahtar\u0131 \u00fcretir, observer hook\u2019lar\u0131n\u0131 global olarak enjekte eder, iste\u011fe ba\u011fl\u0131 olarak Numba ile JIT derler ve hem LRU (bellek i\u00e7i) hem de disk \u00fcst\u00fc runner cache\u2019lerini kullan\u0131r.</li> <li>Python source \u00fcretiminden, analysis hook\u2019lar\u0131n\u0131 haz\u0131rlamaktan ve ayn\u0131 runner \u015fablonlar\u0131n\u0131n hem <code>wrapper.py</code> hem <code>executor.py</code> taraf\u0131ndan kullan\u0131lmas\u0131n\u0131 sa\u011flamaktan sorumludur.</li> </ul>"},{"location":"tr/guides/simulation/runner-variants/#executorpy-fast-path","title":"<code>executor.py</code> (fast-path)","text":"<ul> <li>Sabit-ad\u0131m fast-path \u00e7al\u0131\u015ft\u0131rmay\u0131 y\u00f6netir: tamponlar, workspace\u2019ler, opsiyonel ge\u00e7ici warm-up ve sonu\u00e7lar\u0131n toplanmas\u0131 (result marshalling).</li> <li>Observer varl\u0131\u011f\u0131na g\u00f6re <code>get_runner(RunnerVariant.FASTPATH, ...)</code> veya <code>RunnerVariant.FASTPATH_ANALYSIS</code> se\u00e7er.</li> <li>Tekli ve batch \u00e7al\u0131\u015ft\u0131rmay\u0131 (opsiyonel paralelle\u015ftirme ile) destekler; trajectory mant\u0131\u011f\u0131n\u0131 ortak runner \u015fablonlar\u0131n\u0131n i\u00e7inde b\u0131rak\u0131r.</li> <li>Observer trace/metadata\u2019y\u0131 sonland\u0131r\u0131r; b\u00f6ylece \u00e7a\u011f\u0131ran taraf normal wrapper yoluyla ayn\u0131 analysis payload\u2019lar\u0131n\u0131 al\u0131r.</li> </ul>"},{"location":"tr/guides/simulation/runner-variants/#runner_variantspy-ile-runner-uretimi","title":"runner_variants.py ile runner \u00fcretimi","text":"<p><code>src/dynlib/compiler/codegen/runner_variants.py</code> her runner \u015fablonu i\u00e7in tek kaynakt\u0131r.</p> <ul> <li><code>RunnerVariant</code> d\u00f6rt desteklenen t\u00fcr\u00fc sayar: <code>BASE</code>, <code>ANALYSIS</code>, <code>FASTPATH</code>, <code>FASTPATH_ANALYSIS</code>.</li> <li><code>_RUNNER_TEMPLATE_MAP</code>, her varyant\u0131 ve continuous/discrete bayra\u011f\u0131n\u0131 do\u011fru \u015fablon metni ve fonksiyon ad\u0131yla e\u015fle\u015ftirir.</li> <li><code>get_runner</code>, <code>(model_hash, stepper_name, analysis_sig, variant, runner_kind, dtype, cache_token, jit flag, template version)</code> bile\u015fenlerinden olu\u015fan bir cache anahtar\u0131 kurar ve <code>_variant_cache_continuous</code> veya <code>_variant_cache_discrete</code> i\u00e7inde arar.</li> <li>Runner yoksa: source \u00fcretir, iste\u011fe ba\u011fl\u0131 Numba ile JIT derler, <code>ANALYSIS_PRE</code>/<code>ANALYSIS_POST</code> hook global\u2019lerini enjekte eder ve \u00e7a\u011fr\u0131labilir nesneyi hem yerel LRU\u2019ya hem de disk \u00fcst\u00fc <code>runner_cache</code>\u2019e yazar.</li> <li><code>analysis_signature_hash</code>, her observer set\u2019ini stabil 16 karakterlik bir hash\u2019e indirger; b\u00f6ylece observer hook\u2019lar\u0131 dinamik \u00fcretilse bile runner\u2019lar cache\u2019lenebilir.</li> </ul> <p>Hem wrapper hem de fast-path executor <code>get_runner</code> \u00e7a\u011f\u0131rd\u0131\u011f\u0131 i\u00e7in, yeni bir runner varyant\u0131 (\u00f6r. her zaman \u00f6zel bir log\u2019a yazan ya da ekstra tan\u0131lar\u0131 birle\u015ftiren bir varyant) eklemek; yeni bir \u015fablon metni eklemek, <code>_RUNNER_TEMPLATE_MAP</code>\u2019e kaydetmek ve ilgili \u00e7al\u0131\u015ft\u0131rma yolundan \u00e7a\u011f\u0131rmak demektir.</p>"},{"location":"tr/guides/simulation/runner-variants/#fast-path-executor-sorumluluklar","title":"Fast-path executor sorumluluklar\u0131","text":"<p><code>executor.py</code> sadece runner \u00e7a\u011f\u0131rmaz:</p> <ul> <li><code>_RunContext</code>, <code>_WorkspaceBundle</code> ve <code>_call_runner</code> yap\u0131lar\u0131n\u0131 uygular; do\u011fru tamponlar\u0131 ay\u0131r\u0131r, cursor reset\u2019lerini y\u00f6netir ve <code>run_single_fastpath</code>, <code>run_batch_fastpath</code> ve optimize batch yard\u0131mc\u0131lar\u0131 aras\u0131nda \u00e7a\u011fr\u0131 noktas\u0131n\u0131 birle\u015ftirir.</li> <li>Observer verilmi\u015fse fast-path runner varyant\u0131n\u0131 se\u00e7er ve wrapper\u2019a benzer \u015fekilde <code>analysis=None</code> veya ger\u00e7ek observer mod\u00fcl\u00fcn\u00fc <code>get_runner</code>\u2019a ge\u00e7irir; ancak daha k\u0131s\u0131tl\u0131 bir ortamda.</li> <li>Observer varsa yine de trace tamponlar\u0131n\u0131, metadata\u2019y\u0131 (<code>build_observer_metadata</code>) ve opsiyonel variational step callback\u2019lerini toplar; b\u00f6ylece runner analysis \u00e7\u0131kt\u0131s\u0131 \u00fcretebilir.</li> <li>Batch yard\u0131mc\u0131lar\u0131 opsiyonel olarak thread pool kullanarak ayn\u0131 runner\u2019\u0131 birden fazla IC/parametre seti \u00fczerinde \u00e7al\u0131\u015ft\u0131r\u0131r; derlenmi\u015f runner\u2019\u0131n jit-safe ve GIL-free olmas\u0131na g\u00fcvenir.</li> </ul> <p>Bu ayr\u0131m; fast-path executor ile normal wrapper\u2019\u0131n ayn\u0131 \u015fablonlar\u0131 ve ayn\u0131 cache altyap\u0131s\u0131n\u0131 payla\u015f\u0131p, i\u00e7 d\u00f6ng\u00fc \u00e7evresindeki \u201cdefter tutma\u201d (bookkeeping) miktar\u0131nda ayr\u0131\u015fmas\u0131n\u0131 sa\u011flar.</p>"},{"location":"tr/guides/simulation/session-introspection/","title":"Session state &amp; yazd\u0131rma","text":"<p><code>Sim</code>, derlenmi\u015f modeli kapat\u0131p yeniden kurmadan \u00e7al\u0131\u015fan oturumu inceleyebilmen veya de\u011fi\u015ftirebilmen i\u00e7in canl\u0131 bir <code>SessionState</code> tutar. Bu rehber; \u201coturumda \u015fu an ne var?\u201d, bunu g\u00fcvenli \u015fekilde nas\u0131l de\u011fi\u015ftirirsin ve ihtiya\u00e7 oldu\u011funda alttaki DSL denklemlerini nas\u0131l yazd\u0131r\u0131rs\u0131n gibi konulardaki yard\u0131mc\u0131lar\u0131 anlat\u0131r. Daha detayl\u0131 introspection i\u00e7in <code>export_sources()</code> kullan\u0131m\u0131na bak.</p>"},{"location":"tr/guides/simulation/session-introspection/#session-state-inceleme","title":"Session state inceleme","text":"<ul> <li><code>session_state_summary()</code> mevcut zaman\u0131 (<code>t</code>), ad\u0131m say\u0131s\u0131n\u0131, nominal <code>dt</code>\u2019yi, stepper ad\u0131n\u0131, durumu ve <code>resume=True</code>\u2019\u0131n h\u00e2l\u00e2 m\u00fcmk\u00fcn olup olmad\u0131\u011f\u0131n\u0131 (<code>can_resume</code>/<code>reason</code>) d\u00f6nd\u00fcr\u00fcr. Ayr\u0131ca saklanan stepper config \u00f6zetini (digest) i\u00e7erir; b\u00f6ylece gelecekteki bir <code>run()</code> \u00e7a\u011fr\u0131s\u0131n\u0131n ayn\u0131 konfig\u00fcrasyonu kullan\u0131p kullanmayaca\u011f\u0131n\u0131 anlayabilirsin.</li> <li><code>can_resume()</code> ve <code>compat_check()</code> \u00e7al\u0131\u015fma zaman\u0131 pin\u2019lerinin (spec hash, stepper, workspace imzas\u0131, dtype, dynlib s\u00fcr\u00fcm\u00fc) aktif model ile e\u015fle\u015fip e\u015fle\u015fmedi\u011fini kontrol eder; b\u00f6ylece bir oturumu devam ettirmeden \u00f6nce do\u011frulayabilirsin.</li> <li>Bu \u00f6zet, <code>run()</code> bittikten hemen sonra veya bir <code>Snapshot</code> olu\u015fturmadan \u00f6nce dashboard/log \u00fcretmek i\u00e7in \u00e7ok kullan\u0131\u015fl\u0131d\u0131r.</li> </ul>"},{"location":"tr/guides/simulation/session-introspection/#ornek","title":"\u00d6rnek","text":"<pre><code>summary = sim.session_state_summary()\nprint(f\"Current time {summary['t']} (step {summary['step']})\")\nif not summary[\"can_resume\"]:\n    print(\"Resume unavailable:\", summary[\"reason\"])\n</code></pre>"},{"location":"tr/guides/simulation/session-introspection/#calsma-srasnda-session-degerlerini-degistirme","title":"\u00c7al\u0131\u015fma s\u0131ras\u0131nda session de\u011ferlerini de\u011fi\u015ftirme","text":"<p><code>Sim.assign(...)</code> state ve parametreleri isme g\u00f6re g\u00fcnceller; zaman\u0131, workspace\u2019i veya sonu\u00e7 ge\u00e7mi\u015fini de\u011fi\u015ftirmez (sen a\u00e7\u0131k\u00e7a temizlemezsen). Metot; isimleri modelden \u00e7\u0131kar\u0131r, \u201cbunu mu demek istedin?\u201d \u00f6nerileri verir, de\u011ferleri model dtype\u2019\u0131na \u00e7evirir ve bilinmeyen de\u011fi\u015fkenleri de\u011fi\u015ftirmeye \u00e7al\u0131\u015f\u0131rsan hata verir.</p> <ul> <li>Bir mapping veya keyword ver: <code>sim.assign(v=-65.0, I=12.0)</code> ayn\u0131 session zaman\u0131n\u0131 korur ama bir sonraki run\u2019\u0131n ba\u015flang\u0131\u00e7 de\u011ferlerini de\u011fi\u015ftirir.</li> <li><code>clear_history=True</code> ile birikmi\u015f results/segment ge\u00e7mi\u015fini d\u00fc\u015f\u00fcr\u00fcrs\u00fcn, ama <code>SessionState</code> korunur. Bu, daha \u00f6nceki snapshot\u2019a d\u00f6nmeden yeni bir kay\u0131t ba\u015flatmak istedi\u011finde i\u015fe yarar.</li> </ul> <pre><code>sim.assign({\"v\": -70.0, \"I\": 10.0}, clear_history=True)\nsim.run(T=1.0, record=True)\n</code></pre>"},{"location":"tr/guides/simulation/session-introspection/#saysal-degerleri-dsa-aktarma-ve-yazdrma","title":"Say\u0131sal de\u011ferleri d\u0131\u015fa aktarma ve yazd\u0131rma","text":"<p>Session\u2019dan, model spec\u2019inden veya isimli bir snapshot\u2019tan state/parametre vekt\u00f6rlerini ya da s\u00f6zl\u00fcklerini okumak i\u00e7in birka\u00e7 yard\u0131mc\u0131 var:</p> <ul> <li><code>state_vector(source='session', copy=True)</code> / <code>param_vector(...)</code> DSL\u2019deki tan\u0131m s\u0131ras\u0131na g\u00f6re 1-boyutlu NumPy dizileri d\u00f6nd\u00fcr\u00fcr. <code>source</code> <code>\"session\"</code>, <code>\"model\"</code> veya <code>\"snapshot\"</code> olabilir. <code>copy=False</code> verirsen alttaki saklama alan\u0131na bir view al\u0131rs\u0131n; de\u011ferleri do\u011frudan de\u011fi\u015ftirmek istiyorsan kullan\u0131\u015fl\u0131d\u0131r.</li> <li><code>state_dict(...)</code> / <code>param_dict(...)</code> yukar\u0131daki dizileri <code>isim -&gt; float</code> s\u00f6zl\u00fc\u011f\u00fcne \u00e7evirir; h\u0131zl\u0131 log veya JSON \u00e7\u0131kt\u0131s\u0131 i\u00e7in pratik.</li> <li><code>state(name)</code> / <code>param(name)</code> mevcut session\u2019dan tek bir skalar okur; ismi yanl\u0131\u015f yazarsan yard\u0131mc\u0131 \u00f6neriler verir.</li> </ul> <pre><code>print(sim.state_dict())  # session de\u011ferleri dict olarak\nprint(sim.param_vector(source=\"model\"))  # model varsay\u0131lanlar\u0131 ndarray olarak\nsnapshot_states = sim.state_vector(source=\"snapshot\", snapshot=\"initial\")\n\nprint(sim.state(\"v\"))  # tek de\u011fer okuma\n</code></pre> <p>Bu yard\u0131mc\u0131lar; run ortas\u0131nda debug yazd\u0131rma, UI paneli \u00fcretme veya snapshot/preset yan\u0131na checkpoint metadatas\u0131 koyma gibi i\u015flerde \u00e7ok i\u015fe yarar.</p>"},{"location":"tr/guides/simulation/session-introspection/#dsl-denklemlerini-yazdrma","title":"DSL denklemlerini yazd\u0131rma","text":"<p><code>FullModel.print_equations()</code> \u00fcretilmi\u015f runner\u2019\u0131 de\u011fil, orijinal DSL tan\u0131m\u0131n\u0131 yans\u0131t\u0131r. B\u00f6ylece dok\u00fcmana veya log\u2019a \u201cg\u00fczel yazd\u0131r\u0131lm\u0131\u015f\u201d denklemler ekleyebilirsin.</p> <ul> <li><code>tables</code> hangi TOML table\u2019lar\u0131n\u0131n yazd\u0131r\u0131laca\u011f\u0131n\u0131 se\u00e7er: varsay\u0131lan <code>\"equations\"</code> ana dinamikleri g\u00f6sterir; ama di\u011fer kay\u0131tl\u0131 table\u2019lar\u0131 da isteyebilirsin (<code>\"equations.inverse\"</code>, <code>\"equations.jacobian\"</code> vb.) veya <code>tables=\"all\"</code> ile hepsini yazd\u0131rabilirsin.</li> <li><code>include_headers</code> b\u00f6l\u00fcm ba\u015fl\u0131klar\u0131n\u0131n yazd\u0131r\u0131l\u0131p yazd\u0131r\u0131lmayaca\u011f\u0131n\u0131 kontrol eder; <code>file=</code> ise \u00e7\u0131kt\u0131y\u0131 yaz\u0131labilir herhangi bir stream\u2019e y\u00f6nlendirmeni sa\u011flar.</li> <li><code>FullModel.available_equation_tables()</code> t\u00fcm kay\u0131tl\u0131 anahtarlar\u0131 listeler; ne isteyebilece\u011fini kontrol edersin.</li> </ul> <pre><code>model.print_equations()  # ana denklemleri ba\u015fl\u0131klarla yazd\u0131r\u0131r\n\nwith open(\"equations.txt\", \"w\") as out:\n    model.print_equations(tables=\"all\", include_headers=False, file=out)\n\nprint(FullModel.available_equation_tables())\n</code></pre> <p><code>print_equations()</code> ile <code>session_state_summary()</code> veya <code>state_dict()</code>\u2019i birlikte kullanmak, say\u0131sal state\u2019i onu \u00fcreten denklemlerle ba\u011flayan tekrarlanabilir raporlar \u00fcretmeni kolayla\u015ft\u0131r\u0131r.</p>"},{"location":"tr/guides/simulation/snapshots-and-resume/","title":"Snapshots &amp; Resume","text":"<p><code>Sim</code>, zaman\u0131, state\u2019leri, parametreleri, stepper workspace\u2019ini ve runtime metadatas\u0131n\u0131 kapsayan canl\u0131 bir <code>SessionState</code> tutar. Snapshot\u2019lar bu state\u2019i belirli bir anda yakalar; b\u00f6ylece geri sarabilir, dallanabilir (branch) veya bir simulation\u2019\u0131 serialize edebilirsin. <code>run(resume=True)</code> ise modeli ba\u015ftan kurmadan kaydedilmi\u015f segment\u2019leri uzatman\u0131 sa\u011flar.</p>"},{"location":"tr/guides/simulation/snapshots-and-resume/#snapshot-temelleri","title":"Snapshot temelleri","text":"<ul> <li>Ba\u015flang\u0131\u00e7 snapshot\u2019\u0131: <code>\"initial\"</code> snapshot\u2019\u0131 ilk <code>run()</code> \u00f6ncesinde otomatik olu\u015fturulur; b\u00f6ylece her zaman geri d\u00f6nebilece\u011fin bilinen bir ba\u015flang\u0131\u00e7 noktas\u0131 vard\u0131r.</li> <li><code>create_snapshot(name, description=\"\u2026\")</code>: Mevcut <code>SessionState</code>\u2019i kopyalar, mevcut <code>time_shift</code>/<code>dt</code> de\u011ferlerini kaydeder, snapshot\u2019a <code>name</code>/<code>description</code> yazar ve tam workspace + stepper config\u2019i saklar. Ayn\u0131 isim ikinci kez verilirse hata verir; a\u00e7\u0131klay\u0131c\u0131 isimler se\u00e7.</li> <li><code>list_snapshots()</code> <code>name</code>, simulation zaman\u0131 <code>t</code>, step say\u0131s\u0131, olu\u015fturma zaman\u0131 ve verdiysen a\u00e7\u0131klamay\u0131 d\u00f6nd\u00fcr\u00fcr.</li> <li><code>compat_check(snapshot)</code> <code>SessionPins</code> (spec hash, stepper, workspace imzas\u0131, dtype, dynlib s\u00fcr\u00fcm\u00fc) kar\u015f\u0131la\u015ft\u0131rmas\u0131 yapar ve snapshot\u2019\u0131n uyumlu bir build\u2019den geldi\u011fini garanti eder. <code>reset()</code> ayn\u0131 kontrol\u00fc kullan\u0131r; model, stepper veya dtype de\u011fi\u015ftiyse h\u0131zl\u0131ca ba\u015far\u0131s\u0131z olur.</li> </ul> <p>Snapshot olu\u015fturmak hafiftir ve saklamak ucuzdur; bu y\u00fczden bir d\u00f6n\u00fcm noktas\u0131na geldi\u011finde bir tane al (\u00f6r. uyar\u0131/stimulus uygulad\u0131ktan sonra, bir parametre sweep\u2019ini bitirince vb.).</p>"},{"location":"tr/guides/simulation/snapshots-and-resume/#resetleme-ve-yeniden-baslatma","title":"Resetleme ve yeniden ba\u015flatma","text":"<ul> <li><code>reset(name=\"initial\")</code> oturumu isimli snapshot\u2019a geri al\u0131r ve kaydedilmi\u015f ge\u00e7mi\u015fi, segment\u2019leri, bekleyen run tag\u2019lerini ve resume state\u2019ini temizler. Snapshot\u2019tan <code>_time_shift</code> ve <code>_nominal_dt</code> de\u011ferlerini geri y\u00fckler; b\u00f6ylece sonraki <code>run()</code> \u00e7a\u011fr\u0131lar\u0131 tam o andan ba\u015flar.</li> <li><code>reset</code> sonras\u0131 recorder temizlenir; bu ayn\u0131 zamanda saklanan <code>record_vars</code> se\u00e7imini de s\u0131f\u0131rlar. Sonraki run\u2019dan \u00f6nce farkl\u0131 bir de\u011fi\u015fken alt k\u00fcmesi se\u00e7ebilirsin.</li> <li><code>session_state_summary()</code> <code>can_resume</code>/<code>reason</code> raporlar; b\u00f6ylece <code>resume=True</code> m\u00fcmk\u00fcn m\u00fc diye, run mant\u0131\u011f\u0131n\u0131 tetiklemeden bakabilirsin.</li> </ul>"},{"location":"tr/guides/simulation/snapshots-and-resume/#calstrma-ve-devam-ettirme-resume","title":"\u00c7al\u0131\u015ft\u0131rma ve devam ettirme (resume)","text":"<p><code>Sim.run(resume=True)</code>, <code>t0</code>\u2019dan yeniden ba\u015flamak yerine en g\u00fcncel <code>SessionState</code>\u2019ten devam eder. Ana davran\u0131\u015flar:</p> <ol> <li>Session s\u00fcreklili\u011fi: \u00d6nceki run\u2019daki workspace, stepper konfig\u00fcrasyonu ve <code>time_shift</code> korunur. B\u00f6ylece sonraki segment hem deterministic hem de adaptive stepper\u2019larda kesintisiz bir uzant\u0131 gibi davran\u0131r.</li> <li>Kay\u0131t k\u0131s\u0131tlar\u0131: <code>ic</code>, <code>params</code>, <code>t0</code> veya <code>dt</code> override edemezsin; <code>resume</code> her zaman oturumun kald\u0131\u011f\u0131 yerden ba\u015flar. <code>transient &gt; 0</code> (warm-up) yasakt\u0131r; \u00e7\u00fcnk\u00fc resume segment\u2019i an\u0131nda devam etmelidir. <code>record_vars</code> da yeniden verilemez; <code>reset</code> sonras\u0131 ilk recorded run de\u011fi\u015fken listesini sabitler ve sonraki t\u00fcm <code>resume</code> run\u2019lar\u0131 bu listeyi otomatik yeniden kullan\u0131r.</li> <li>Segment takibi: Her recorded run bir <code>Segment</code> girdisi ekler: <code>t_start</code>, <code>t_end</code>, <code>step_start</code>, <code>step_end</code> ve par\u00e7an\u0131n resume ile \u00fcretilip \u00fcretilmedi\u011fi. <code>run()</code> \u00e7a\u011fr\u0131s\u0131na <code>tag=\"label\"</code> verirsen okunur bir isim olur; aksi halde <code>run#0</code>, <code>run#1</code> gibi isimler \u00fcretilir. <code>ResultsView</code> i\u00e7in okunur etiketler gerekti\u011finde <code>name_segment()</code> veya <code>name_last_segment()</code> ile yeniden adland\u0131r.</li> <li>Sonu\u00e7lar\u0131n birle\u015ftirilmesi: Resume ayn\u0131 <code>_ResultAccumulator</code>\u2019\u0131 kullan\u0131r; bu y\u00fczden <code>raw_results()</code>/<code>results()</code> t\u00fcm segment\u2019leri kapsayan tek par\u00e7a bir time-series g\u00f6r\u00fcr. <code>run(resume=True)</code>, istenen ufuk mevcut zaman\u0131n ilerisinde de\u011filse hata verir; b\u00f6ylece \u00fcst \u00fcste binme (overlap) olmaz.</li> <li>Uyumluluk kontrol\u00fc: Resume\u2019den \u00f6nce <code>can_resume()</code>, mevcut pin\u2019leri <code>SessionState</code> i\u00e7inde yakalanm\u0131\u015f pin\u2019lerle kar\u015f\u0131la\u015ft\u0131r\u0131r. <code>(False, reason)</code> d\u00f6nerse <code>reset()</code> ile yeniden ba\u015flat veya uyumlu bir <code>FullModel</code> ile yeniden kur.</li> <li>Resume i\u00e7inde parametre override yok: Resume segment\u2019inde yeni <code>ic</code>, <code>params</code>, <code>t0</code> veya <code>dt</code> veremezsin. Run; \u00f6nceki segmentin parametrelerini, stepper workspace\u2019ini ve zamanlamas\u0131n\u0131 korur. De\u011fer de\u011fi\u015ftirmek i\u00e7in reset/snapshot kullanman veya <code>resume=True</code> olmadan ayr\u0131 bir <code>run()</code> yapman gerekir.</li> </ol> <p>Tipik kullan\u0131m:</p> <pre><code>sim.run(T=2.0, record=True, tag=\"phase-1\")\nsim.create_snapshot(\"phase-1\", \"after the first stimulus\")\n\n# Yeniden kurmadan devam et; ikinci run eklenir\nsim.run(T=5.0, resume=True, tag=\"phase-2\")\n\n# Kaydedilmi\u015f snapshot\u2019a resetleyerek farkl\u0131 bir dal ba\u015flat\nsim.reset(\"phase-1\")\nsim.run(T=3.0, record=True, tag=\"phase-1-replay\")\n</code></pre> <p>Segment\u2019ler aras\u0131nda parametre de\u011fi\u015ftirmek gerekiyorsa, resumed run\u2019dan \u00f6nce yap: daha erken bir snapshot\u2019a resetle, yeni parametre/state de\u011ferlerini <code>assign()</code> ile ver (ya da zaten o de\u011ferleri i\u00e7eren bir snapshot i\u00e7e aktar), sonra <code>resume</code> olmadan run et veya yeni de\u011ferler haz\u0131r olduktan sonra <code>run(resume=True)</code> \u00e7a\u011f\u0131r. Resume hi\u00e7bir zaman <code>ic</code>, <code>params</code>, <code>t0</code> veya <code>dt</code> override kabul etmez; yeni konfig\u00fcrasyon mutlaka resumed segment ba\u015flamadan \u00f6nce snapshot/assignment ile ayarlanmal\u0131d\u0131r.</p>"},{"location":"tr/guides/simulation/snapshots-and-resume/#segmentler-arasnda-parametre-degistirme-ornekleri","title":"Segment\u2019ler aras\u0131nda parametre de\u011fi\u015ftirme \u00f6rnekleri","text":"<p>\u00d6rnek 1: Parametre de\u011fi\u015ftirerek dallanma (resume yok)</p> <pre><code># \u0130lk segmenti \u00e7al\u0131\u015ft\u0131r\nsim.run(T=2.0, record=True, tag=\"baseline\")\n\n# \u0130lk segment sonunda snapshot olu\u015ftur\nsim.create_snapshot(\"after-baseline\", \"End of baseline run\")\n\n# Snapshot\u2019a d\u00f6n ve bir parametre de\u011fi\u015ftir\nsim.reset(\"after-baseline\")\nsim.assign(I=15.0)  # Input current parametresini de\u011fi\u015ftir\n\n# De\u011fi\u015fmi\u015f parametreyle yeni segment \u00e7al\u0131\u015ft\u0131r (kay\u0131t yeniden ba\u015flar)\nsim.run(T=3.0, record=True, tag=\"modified-current\")\n</code></pre> <p>\u00d6rnek 2: Parametre de\u011fi\u015ftirerek devam etme (resume kullanarak)</p> <pre><code># \u0130lk segment\nsim.run(T=2.0, record=True, tag=\"phase-1\")\n\n# Snapshot olu\u015ftur\nsim.create_snapshot(\"phase-1-end\", \"End of phase 1\")\n\n# Resetle ve parametreleri de\u011fi\u015ftir\nsim.reset(\"phase-1-end\")\nsim.assign(a=0.02, b=0.25)  # Izhikevich parametrelerini de\u011fi\u015ftir\n\n# Reset noktas\u0131ndan yeni parametrelerle devam et\nsim.run(T=5.0, resume=True, tag=\"phase-2-modified\")\n</code></pre> <p>\u00d6rnek 3: <code>assign()</code> + <code>clear_history=True</code> ile yeni kay\u0131t ba\u015flatma</p> <p><code>assign()</code> metodunun <code>clear_history</code> ad\u0131nda opsiyonel bir parametresi vard\u0131r. <code>clear_history=True</code> olunca, yeni atanan de\u011ferlerle mevcut session state (zaman, workspace vb.) korunur ama \u00f6nceki sonu\u00e7lar ve segment\u2019ler temizlenir. Bu, snapshot\u2019a d\u00f6nmeden yeni bir segment ba\u015flatmana imk\u00e2n verir:</p> <pre><code># \u0130lk segment\nsim.run(T=2.0, record=True, tag=\"initial\")\n\n# Yeni parametreleri ata ve ge\u00e7mi\u015fi temizle\nsim.assign(I=20.0, clear_history=True)\n\n# Bu run yeni bir segment \u00fcretir (\u00e7\u00fcnk\u00fc ge\u00e7mi\u015f temizlendi)\nsim.run(T=3.0, record=True, tag=\"new-segment\")\n</code></pre> <p>Not: <code>clear_history=True</code> simulation zaman\u0131n\u0131 veya workspace state\u2019ini de\u011fi\u015ftirmez \u2014 sadece kaydedilmi\u015f sonu\u00e7lar\u0131 temizler ve sonraki <code>run()</code> \u00e7a\u011fr\u0131s\u0131n\u0131n mevcut session state\u2019ten yeni bir kay\u0131t ba\u015flatmas\u0131n\u0131 sa\u011flar.</p>"},{"location":"tr/guides/simulation/snapshots-and-resume/#kalclk-ve-tasnabilirlik","title":"Kal\u0131c\u0131l\u0131k ve ta\u015f\u0131nabilirlik","text":"<ul> <li><code>export_snapshot(path, source=\"current\" | \"snapshot\", name=...)</code> bir <code>.npz</code> dosyas\u0131na \u015funlar\u0131 yazar:</li> <li><code>meta.json</code> (\u015fema s\u00fcr\u00fcm\u00fc, pin\u2019ler, isimler, zaman/ad\u0131m saya\u00e7lar\u0131, <code>time_shift</code>, <code>nominal_dt</code>, stepper config isim/de\u011ferleri)</li> <li><code>y</code> ve <code>params</code> vekt\u00f6rleri</li> <li>Workspace klas\u00f6rleri (<code>workspace/runtime/&lt;name&gt;</code>, <code>workspace/stepper/&lt;name&gt;</code>) ve varsa <code>stepper_config</code></li> <li>Yazma i\u015flemi ge\u00e7ici dosya \u00fczerinden atomik yap\u0131l\u0131r; b\u00f6ylece yar\u0131m yazmalar mevcut snapshot\u2019lar\u0131 bozmaz.</li> <li><code>inspect_snapshot(path)</code> session\u2019\u0131 de\u011fi\u015ftirmeden <code>meta.json</code> okur; i\u00e7e aktarmadan \u00f6nce uyumluluk kontrol\u00fc yapmak i\u00e7in idealdir.</li> <li><code>import_snapshot(path)</code> session state\u2019i dosyadaki snapshot ile de\u011fi\u015ftirir, results/segment\u2019leri temizler, <code>_time_shift</code>/<code>_nominal_dt</code> de\u011ferlerini resetler ve pin\u2019leri aktif modelle uyu\u015fmayan dosyalar\u0131 reddeder.</li> </ul> <p>Uzun bir hesaplamay\u0131 checkpoint almak, bir resume noktas\u0131n\u0131 ekip arkada\u015f\u0131nla payla\u015fmak veya CI run\u2019lar\u0131 aras\u0131nda workflow state\u2019i saklamak i\u00e7in export/import kullan.</p>"},{"location":"tr/guides/simulation/snapshots-and-resume/#segment-adlandrma-ve-resume-metadatas","title":"Segment adland\u0131rma ve resume metadatas\u0131","text":"<ul> <li>Her <code>Segment</code>, bir <code>cfg_hash</code> (stepper config \u00f6zeti) ve <code>resume</code> bayra\u011f\u0131 ta\u015f\u0131r; b\u00f6ylece a\u015fa\u011f\u0131 ak\u0131\u015f ara\u00e7lar\u0131 bir par\u00e7an\u0131n taze bir run ile mi yoksa <code>resume</code> ile mi \u00fcretildi\u011fini anlayabilir.</li> <li><code>run()</code> \u00e7a\u011fr\u0131s\u0131nda <code>tag</code> kullan veya sonradan <code>name_segment()</code> ile de\u011fi\u015ftir; <code>segments</code> listesini okunur tutar. <code>ResultsView</code> bu isimleri g\u00f6sterir; b\u00f6ylece istedi\u011fin k\u0131sm\u0131 h\u0131zl\u0131ca se\u00e7ebilirsin.</li> <li>Resetledi\u011finde segment listesi bo\u015fal\u0131r, ama snapshot\u2019lar kal\u0131r. Segment eklemeyi yaln\u0131zca <code>resume=True</code> ile s\u00fcrd\u00fcr \u2014 aksi halde <code>run()</code> accumulator\u2019\u0131 temizler ve yeni bir kay\u0131t turu ba\u015flat\u0131r.</li> </ul> <p>Snapshot ve resume kontrolleri deneylerini tekrarlanabilir tutar: dallanma noktalar\u0131nda snapshot al, varyasyonlar\u0131 denemek i\u00e7in onlara resetle ve uzun trajectory\u2019leri ge\u00e7mi\u015fi kaybetmeden b\u00fcy\u00fctmek i\u00e7in resume kullan.</p>"},{"location":"tr/guides/simulation/steppers/","title":"Stepper'lar","text":"<p><code>dynlib</code>, sim\u00fclasyonu bir ad\u0131m ilerletmek i\u00e7in stepper'lar\u0131 kullan\u0131r. Bunlar \u00e7o\u011funlukla integrat\u00f6rlerdir; ancak ayr\u0131k haritalar\u0131 (discrete maps) ilerletmek i\u00e7in de kullan\u0131ld\u0131klar\u0131ndan, sadece \"integrat\u00f6r\" veya \"\u00e7\u00f6z\u00fcc\u00fc\" (solver) olarak adland\u0131r\u0131lmazlar. Ayr\u0131ca, ODE integrat\u00f6rleri gelecekteki farkl\u0131 dinamik sistem t\u00fcrleri i\u00e7in uygun olmayabilir. Probleminizin s\u0131n\u0131f\u0131na (ODE vs map), zaman kontrol stratejisine (sabit vs uyarlamal\u0131) ve say\u0131sal \u015femas\u0131na (a\u00e7\u0131k, kapal\u0131, ayr\u0131\u015ft\u0131rma) uygun olan stepper'\u0131 se\u00e7in. Model varsay\u0131lan\u0131n\u0131 <code>build(..., stepper=\"rk4\")</code> \u00fczerinden veya uygulama kodundaki h\u0131zl\u0131 yol i\u00e7in <code>setup(..., stepper=\"rk4\")</code> ile ge\u00e7ersiz k\u0131labilirsiniz. Derlenmi\u015f her <code>Model</code> veya <code>Sim</code> y\u00fczeyi <code>model.stepper_name</code> de\u011ferini d\u0131\u015fa a\u00e7ar; b\u00f6ylece derlemeden sonra hangi integrat\u00f6r\u00fcn se\u00e7ildi\u011fini teyit edebilirsiniz.</p>"},{"location":"tr/guides/simulation/steppers/#bir-stepper-secmek","title":"Bir Stepper Se\u00e7mek","text":"<p>Bir sim\u00fclasyonu \u00e7al\u0131\u015ft\u0131rmadan \u00f6nce her zaman kontrol etmeniz gereken \u00fc\u00e7 ana eksen vard\u0131r:</p> <ul> <li>T\u00fcr (<code>Kind = \"ode\" | \"map\"</code>): Stepper'\u0131n matematiksel do\u011fas\u0131n\u0131 tan\u0131mlar. ODE stepper'lar\u0131 bir RHS (sa\u011f taraf) <code>f(t, y)</code> bekler ve bunu <code>dt</code> ile \u00e7arpar; <code>map</code> stepper'\u0131 ise derlenmi\u015f fonksiyonu, do\u011frudan bir sonraki durumu d\u00f6nd\u00fcren ayr\u0131k bir g\u00fcncelleme olarak ele al\u0131r (<code>dt</code> burada sadece bir etikettir).</li> <li>Zaman Kontrol\u00fc (<code>TimeCtrl = \"fixed\" | \"adaptive\"</code>): Integrat\u00f6r\u00fcn sabit bir <code>dt</code> ile mi ilerleyece\u011fini, yoksa ad\u0131m\u0131 dahili olarak yeniden deneyip boyutland\u0131raca\u011f\u0131n\u0131 m\u0131 belirler. Uyarlamal\u0131 (adaptive) stepper'lar (RK45, BDF2a, TR-BDF2a) <code>atol/rtol</code> tolerans kontrollerini sunarken, sabit ad\u0131ml\u0131 (fixed) stepper'lar s\u00fcr\u00fcc\u00fc <code>Sim.run()</code> arg\u00fcmanlar\u0131na g\u00fcvenir.</li> <li>\u015eema (<code>Scheme = \"explicit\" | \"implicit\" | \"splitting\"</code>): Y\u00f6ntemin cebirsel yap\u0131s\u0131d\u0131r. A\u00e7\u0131k (explicit) stepper'larda do\u011frusal olmayan \u00e7\u00f6z\u00fcmler (nonlinear solves) yoktur; oysa kapal\u0131 (implicit) stepper'lar (SDIRK2, BDF2, BDF2a, TR-BDF2a) Newton iterasyonlar\u0131n\u0131 \u00e7a\u011f\u0131r\u0131r ve genellikle iste\u011fe ba\u011fl\u0131 analitik Jakobiyenleri destekler. Ayr\u0131\u015ft\u0131rma (splitting) \u015femalar\u0131 gelecekte eklenecektir.</li> </ul> <p>Bu eksenlerin kombinasyonu ve her <code>StepperMeta</code> i\u00e7indeki <code>family</code>/<code>order</code> (aile/mertebe) \u00fcst verileri, size fiziksel olarak ne olup bitti\u011fine dair \u00f6zl\u00fc bir g\u00f6r\u00fcn\u00fcm sunar. Jakobiyenlere, yo\u011fun \u00e7\u0131kt\u0131ya (dense output) veya Lyapunov analizi i\u00e7in varyasyonel ad\u0131mlamaya ihtiyac\u0131n\u0131z varsa, <code>StepperCaps</code> blo\u011funa bak\u0131n (dok\u00fcmanlarda <code>dense_output</code>, <code>jacobian</code>, <code>jit_capable</code>, <code>requires_scipy</code> ve <code>variational_stepping</code> bayraklar\u0131n\u0131 sunuyoruz).</p>"},{"location":"tr/guides/simulation/steppers/#mevcut-stepperlar","title":"Mevcut Stepper'lar","text":"\u0130sim T\u00fcr Zaman Kontrol\u00fc \u015eema Mertebe \u00d6nemli Notlar <code>map</code> map sabit (fixed) a\u00e7\u0131k 1 Ayr\u0131k yinelemeler (<code>F(t, y)</code> sonraki durumu d\u00f6ner). <code>dt</code> sadece zaman\u0131 etiketler. <code>euler</code> ode sabit (fixed) a\u00e7\u0131k 1 \u0130leri Euler, minimum \u00e7al\u0131\u015fma alan\u0131, varyasyonel stepping uyumlu. <code>rk2</code> ode sabit (fixed) a\u00e7\u0131k 2 Basit 2 a\u015famal\u0131 g\u00fcncelleme ve varyasyonel destekli a\u00e7\u0131k orta nokta (RK2). <code>rk4</code> ode sabit (fixed) a\u00e7\u0131k 4 Klasik Runge\u2013Kutta 4. mertebe; takma adlar\u0131: <code>rk4_classic</code>, <code>classical_rk4</code>. <code>rk45</code> ode uyarlamal\u0131 a\u00e7\u0131k 5\u00b9 4. mertebe hata tahminli Dormand\u2013Prince RK45. <code>ab2</code> ode sabit (fixed) a\u00e7\u0131k 2 Heun ba\u015flang\u0131\u00e7l\u0131 Adams\u2013Bashforth 2 \u00e7ok ad\u0131ml\u0131 y\u00f6ntemi; t\u00fcrev ge\u00e7mi\u015fini tutar. <code>ab3</code> ode sabit (fixed) a\u00e7\u0131k 3 \u0130ki ad\u0131ml\u0131 ba\u015flang\u0131ca sahip Adams\u2013Bashforth 3. <code>sdirk2</code> ode sabit (fixed) kapal\u0131 2 Alexander SDIRK2 (\u03b3 = (2\u2212\u221a2)/2), sert (stiff) problemlerde hassas ama Jakobiyen gerektirir. <code>bdf2</code> ode sabit (fixed) kapal\u0131 2 Newton \u00e7\u00f6z\u00fcc\u00fcl\u00fc kapal\u0131 BDF2; iste\u011fe ba\u011fl\u0131 harici Jakobiyenleri kabul eder. <code>bdf2a</code> ode uyarlamal\u0131 kapal\u0131 2 Hata tahminli de\u011fi\u015fken ad\u0131ml\u0131 BDF2. <code>tr-bdf2a</code> ode uyarlamal\u0131 kapal\u0131 2 <code>bdf2a</code> ile ayn\u0131 ayarlara sahip TR-BDF2 uyarlamal\u0131 integrat\u00f6r (L-kararl\u0131). <p>\u00b9 G\u00f6m\u00fcl\u00fc mertebe: 4 (hata tahmini). Uyarlamal\u0131 stepper'lar <code>dt</code> de\u011ferini dahili olarak ge\u00e7ersiz k\u0131lar ancak \u00e7al\u0131\u015ft\u0131r\u0131c\u0131 i\u00e7in yine de <code>dt_next</code> rapor eder.</p> <p>Her temel stepper ismi bir kez kaydedilir; <code>forward_euler</code>, <code>rk4_classic</code>, <code>trbdf2a</code> ve <code>sdirk2_jit</code> gibi takma adlar (aliases) otomatik olarak ayn\u0131 spesifikasyona e\u015flenir. Yap\u0131land\u0131rmalar\u0131 payla\u015f\u0131rken s\u00fcrprizlerle kar\u015f\u0131la\u015fmamak i\u00e7in temel (canonical) ismi kullan\u0131n.</p> <p>Haritalar (maps) i\u00e7in <code>stepper=map</code> tan\u0131mlaman\u0131z gerekmez. ODE modelleri i\u00e7in varsay\u0131lan stepper <code>rk4</code>'t\u00fcr.</p>"},{"location":"tr/guides/simulation/steppers/#stepper-kayd-ve-kesfi","title":"Stepper Kayd\u0131 ve Ke\u015ffi","text":"<p>Stepper kay\u0131t defteri hem kullan\u0131c\u0131 hem de geli\u015ftirici odakl\u0131d\u0131r. Stepper mod\u00fclleri i\u00e7e aktar\u0131ld\u0131\u011f\u0131nda otomatik olarak doldurulur, ancak \u00f6zel bir y\u00f6nteme ihtiyac\u0131n\u0131z varsa <code>dynlib.register()</code> ile kendi tan\u0131mlar\u0131n\u0131z\u0131 da kaydedebilirsiniz.</p> <pre><code>from dynlib import list_steppers, select_steppers, get_stepper\n\nprint(list_steppers(kind=\"ode\"))\ninfos = select_steppers(scheme=\"implicit\", stiff=True, jit_capable=True)\nprint([info.name for info in infos])\nspec = get_stepper(\"rk45\")\nprint(spec.meta.order, spec.meta.aliases)\n</code></pre> <p><code>list_steppers()</code> s\u0131ralanm\u0131\u015f temel isimleri d\u00f6nd\u00fcr\u00fcr ve <code>select_steppers()</code> ile ayn\u0131 anahtar kelime filtrelerini (kind, scheme, stiff, jit_capable vb.) kabul eder. <code>select_steppers()</code> fonksiyonu <code>StepperInfo</code> \u00f6rneklerini d\u00f6nd\u00fcr\u00fcr. Ayr\u0131ca ince ayarl\u0131 ke\u015fif i\u00e7in <code>name_pattern</code> veya \u00f6zel bir <code>predicate</code> (ko\u015ful) ge\u00e7ebilirsiniz (\u00f6rne\u011fin varyasyonel stepping veya yo\u011fun \u00e7\u0131kt\u0131 destekleyen se\u00e7enekleri aramak i\u00e7in).</p> <p>CLI, Python API'sini yans\u0131t\u0131r: <code>dynlib steppers list</code> komutu ayn\u0131 temel isimleri yazd\u0131r\u0131r ve mevcut bayraklar yukar\u0131daki filtreleri yans\u0131tarak \u00e7\u0131kt\u0131y\u0131 daraltman\u0131za olanak tan\u0131r.</p>"},{"location":"tr/guides/simulation/steppers/#stepper-ust-veri-metadata-alanlar","title":"Stepper \u00dcst Veri (Metadata) Alanlar\u0131","text":"<ul> <li><code>name</code>: Temel stepper ismi.</li> <li><code>kind</code>: <code>ode</code> veya <code>map</code>.</li> <li><code>time_control</code>: <code>fixed</code> (sabit) veya <code>adaptive</code> (uyarlamal\u0131).</li> <li><code>scheme</code>: <code>explicit</code> (a\u00e7\u0131k), <code>implicit</code> (kapal\u0131) veya <code>splitting</code> (ayr\u0131\u015ft\u0131rma).</li> <li><code>geometry</code>: Geometri duyarl\u0131 y\u00f6ntemler i\u00e7in ayr\u0131lm\u0131\u015f set (\u015fu an yerle\u015fik stepper'larda bo\u015ftur).</li> <li><code>family</code>: <code>runge-kutta</code>, <code>adams-bashforth</code>, <code>bdf</code>, <code>dirk</code>, <code>tr-bdf2</code> veya <code>iter</code> gibi s\u0131n\u0131fland\u0131rmalar.</li> <li><code>order</code>, <code>embedded_order</code>: Birincil ve g\u00f6m\u00fcl\u00fc do\u011frulu\u011fu tan\u0131mlar.</li> <li><code>stiff</code>: Y\u00f6ntemin sert (stiff) problemler i\u00e7in uygun olup olmad\u0131\u011f\u0131n\u0131 belirtir.</li> <li><code>aliases</code>: Ayn\u0131 spesifikasyona e\u015flenen di\u011fer isimler.</li> <li><code>caps</code>: A\u015fa\u011f\u0131daki yetenek bayraklar\u0131.</li> </ul>"},{"location":"tr/guides/simulation/steppers/#stepper-yetenek-bayraklar-steppercaps","title":"Stepper Yetenek Bayraklar\u0131 (<code>StepperCaps</code>)","text":"<ul> <li><code>dense_output</code>: S\u00fcrekli interpolasyon / yo\u011fun \u00e7\u0131kt\u0131 deste\u011fi.</li> <li><code>jacobian</code>: Stepper'\u0131n harici Jakobiyenleri nas\u0131l t\u00fcketti\u011fini a\u00e7\u0131klar (<code>none</code>, <code>internal</code>, <code>optional</code>, <code>required</code>).</li> <li><code>jit_capable</code>: T\u00fcm yerle\u015fik stepper'lar i\u00e7in do\u011frudur; y\u00f6ntem d\u0131\u015f ba\u011f\u0131ml\u0131l\u0131klara dayan\u0131yorsa yanl\u0131\u015ft\u0131r.</li> <li><code>requires_scipy</code>: SciPy gerekliyse do\u011frudur.</li> <li><code>variational_stepping</code>: <code>emit_step_with_variational()</code> deste\u011fini belirtir (Lyapunov analizinde kullan\u0131l\u0131r).</li> </ul>"},{"location":"tr/guides/simulation/steppers/#stepper-workspace","title":"Stepper Workspace","text":"<p>Stepper workspace'i, \u00e7al\u0131\u015fma zaman\u0131 \u00fcst verilerinin yan\u0131nda ya\u015fayan, stepper'a \u00f6zel bir karalama alan\u0131d\u0131r. Her stepper, tek bir ad\u0131m s\u0131ras\u0131nda ihtiya\u00e7 duydu\u011fu dizileri tan\u0131mlayan bir <code>NamedTuple</code> belirler. Workspace, her sim\u00fclasyon i\u00e7in bir kez stepper'\u0131n <code>make_workspace(n_state, dtype)</code> kancas\u0131 \u00fczerinden tahsis edilir ve her ad\u0131mda yeniden kullan\u0131l\u0131r.</p>"},{"location":"tr/guides/simulation/steppers/#temel-ozellikler","title":"Temel \u00d6zellikler","text":"<ul> <li>Sahiplik: Her stepper spesifikasyonuna \u00f6zeldir ve ABI'ye <code>stepper_ws</code> olarak aktar\u0131l\u0131r.</li> <li>\u00d6m\u00fcr: <code>Sim</code> yok edilene veya workspace belle\u011fi a\u00e7\u0131k\u00e7a serbest b\u0131rak\u0131lana kadar kal\u0131c\u0131d\u0131r.</li> <li>\u0130\u00e7erik: NumPy dizileri (a\u015fama tamponlar\u0131, t\u00fcrev ge\u00e7mi\u015fleri, Jakobiyen karalama alan\u0131 vb.).</li> <li>Tahsis: Stepper'\u0131n <code>workspace_type()</code> ve <code>make_workspace()</code> metodlar\u0131 taraf\u0131ndan y\u00f6netilir.</li> <li>T\u00fcr: Alanlara dizin yerine isimle eri\u015filmesi i\u00e7in bir <code>NamedTuple</code>'d\u0131r.</li> </ul>"},{"location":"tr/guides/simulation/steppers/#ornek-workspace-duzenleri","title":"\u00d6rnek Workspace D\u00fczenleri","text":""},{"location":"tr/guides/simulation/steppers/#euler-workspace","title":"Euler Workspace","text":"<pre><code>class Workspace(NamedTuple):\n    dy: np.ndarray\n    kv: np.ndarray\n</code></pre>"},{"location":"tr/guides/simulation/steppers/#rk4-workspace","title":"RK4 Workspace","text":"<pre><code>class Workspace(NamedTuple):\n    y_stage: np.ndarray\n    k1: np.ndarray\n    k2: np.ndarray\n    k3: np.ndarray\n    k4: np.ndarray\n    v_stage: np.ndarray\n    kv1: np.ndarray\n    kv2: np.ndarray\n    kv3: np.ndarray\n    kv4: np.ndarray\n</code></pre>"},{"location":"tr/guides/simulation/steppers/#neden-her-stepper-rhs-dizilerine-ihtiyac-duyar","title":"Neden Her Stepper RHS Dizilerine \u0130htiya\u00e7 Duyar?","text":"<p>\u015eema ne olursa olsun, stepper bir teklif olu\u015fturabilmek i\u00e7in <code>f(t, y)</code>'nin bir veya daha fazla de\u011ferlendirmesini saklamal\u0131d\u0131r. Workspace bu RHS tamponlar\u0131n\u0131 tutar. Her y\u00f6ntem t\u00fcrev vekt\u00f6rlerini kendi yuvalar\u0131na yazar, ard\u0131ndan <code>y_prop</code>, <code>t_prop</code>, <code>dt_next</code> ve <code>err_est</code> de\u011ferlerini birle\u015ftirir.</p>"},{"location":"tr/guides/simulation/steppers/#runtime-workspace","title":"Runtime Workspace","text":"<p>Runtime workspace'i, stepper'\u0131n karalama alan\u0131ndan ayr\u0131 olarak, gecikme tamponlar\u0131n\u0131 (lag buffers) ve di\u011fer DSL makinelerinin durumunu y\u00f6netir.</p>"},{"location":"tr/guides/simulation/steppers/#stepper-abi","title":"Stepper ABI","text":"<p>Derlenmi\u015f stepper \u00e7a\u011fr\u0131labilir yap\u0131s\u0131 (callable), runner ve sonu\u00e7 altyap\u0131s\u0131n\u0131n genel kalabilmesi i\u00e7in sabit bir ABI izler. \u0130mzas\u0131 \u015f\u00f6yledir:</p> <pre><code>status = stepper(\n    t: float,\n    dt: float,\n    y_curr: float[:],\n    rhs,\n    params: float[:] | int[:],\n    runtime_ws,\n    stepper_ws,\n    stepper_config: float64[:],\n    y_prop: float[:],\n    t_prop: float[:],\n    dt_next: float[:],\n    err_est: float[:],\n) -&gt; int32\n</code></pre> <ul> <li><code>rhs</code>: Stepper'\u0131n tekrar tekrar \u00e7a\u011f\u0131rd\u0131\u011f\u0131 derlenmi\u015f RHS fonksiyonu.</li> <li><code>runtime_ws</code>: Gecikme tamponlar\u0131 ve \u00fcst veriler i\u00e7in payla\u015f\u0131lan \u00e7al\u0131\u015fma zaman\u0131 alan\u0131.</li> <li><code>stepper_ws</code>: Yukar\u0131da a\u00e7\u0131klanan aktif stepper workspace'i.</li> <li><code>stepper_config</code>: Stepper'\u0131n dataclass'\u0131ndan paketlenmi\u015f ayar dizisi.</li> <li><code>y_prop</code>, <code>t_prop</code>, <code>dt_next</code>, <code>err_est</code>: Runner'\u0131n her \u00e7a\u011fr\u0131dan sonra t\u00fcketti\u011fi \u00e7\u0131kt\u0131 tamponlar\u0131.</li> </ul>"},{"location":"tr/guides/simulation/steppers/#varyasyonel-stepping-genel-baks","title":"Varyasyonel Stepping Genel Bak\u0131\u015f","text":"<p>Baz\u0131 stepper'lar, Lyapunov, duyarl\u0131l\u0131k veya varyasyonel analizler i\u00e7in yararl\u0131 olan birle\u015fik bir \"durum + te\u011fet\" (state + tangent) entegrasyon yolunu destekler. <code>StepperCaps(variational_stepping=True)</code> ayar\u0131na sahip <code>StepperSpec</code> uygulamalar\u0131na bak\u0131n. Bu tesisler, te\u011fet tamponlar\u0131n\u0131 durum workspace'inin yan\u0131nda tutar ve te\u011fet durumunun <code>y_prop</code> ile senkronize kalmas\u0131n\u0131 sa\u011flar.</p>"},{"location":"tr/guides/simulation/steppers/#stepperlar-genisletme-gelistirici-rehberi","title":"Stepper'lar\u0131 Geni\u015fletme (Geli\u015ftirici Rehberi)","text":"<p>\u00d6zel bir integrat\u00f6r veya haritaya (map) ihtiya\u00e7 duyan katk\u0131c\u0131lar i\u00e7in <code>dynlib</code> stepper yap\u0131s\u0131 mod\u00fcler tasarlanm\u0131\u015ft\u0131r. Yeni bir stepper spesifikasyonu sadece <code>StepperSpec</code> protokol\u00fcn\u00fc uygular, kendini kaydeder ve iste\u011fe ba\u011fl\u0131 olarak <code>ConfigMixin</code> arac\u0131l\u0131\u011f\u0131yla \u00e7al\u0131\u015fma zaman\u0131 ayarlar\u0131n\u0131 d\u0131\u015fa a\u00e7ar.</p> <ol> <li>\u00dcst verileri ve yetenekleri tan\u0131mlay\u0131n: Yeni y\u00f6ntemi a\u00e7\u0131klayan bir <code>StepperMeta</code> ve <code>StepperCaps</code> olu\u015fturun.</li> <li>Spesifikasyonu uygulay\u0131n: <code>emit</code> i\u00e7inde, <code>stepper_config</code> (paketlenmi\u015f float dizisi) \u00fczerinden \u00e7al\u0131\u015fma zaman\u0131 ge\u00e7ersiz k\u0131lmalar\u0131n\u0131 uygulay\u0131n.</li> <li>Workspace yard\u0131mc\u0131lar\u0131n\u0131 haz\u0131rlay\u0131n: Workspace d\u00fczenini NumPy dizileri i\u00e7eren bir <code>NamedTuple</code> olarak tan\u0131mlay\u0131n.</li> <li>Spec'i kaydedin: Stepper'\u0131 genel kay\u0131t defterine <code>dynlib.register()</code> ile ekleyin.</li> </ol>"},{"location":"tr/guides/simulation/wrapper-and-runner/","title":"Wrapper ve Runner Etkile\u015fimi","text":"<p>Ana sim\u00fclasyon \u015femas\u0131 \u015fu \u015fekilde organize edilmi\u015ftir: wrapper \u2283 runner \u2283 stepper. Runner ve stepper, JIT ile derlenebilir bir sim\u00fclasyon \u00e7ekirde\u011fi (kernel) olu\u015fturur. Bu \u00e7ekirdek numba uyumlulu\u011fu i\u00e7in tasarlanm\u0131\u015ft\u0131r, bu nedenle karma\u015f\u0131k Python i\u015flemleri olmadan s\u0131k\u0131 bir d\u00f6ng\u00fc i\u00e7inde \u00e7al\u0131\u015f\u0131r. Stepper'\u0131n <code>emit()</code> metodu, bu \u00e7ekirde\u011fin stepper taraf\u0131ndaki hesaplay\u0131c\u0131s\u0131n\u0131 sa\u011flar ve JIT uyumlu bir fonksiyon d\u00f6nd\u00fcr\u00fcr. Her sim\u00fclasyon ad\u0131m\u0131nda runner bu fonksiyonu \u00e7a\u011f\u0131r\u0131r. Stepper fonksiyonunun kendi i\u00e7 d\u00f6ng\u00fcs\u00fc vard\u0131r; ba\u015far\u0131l\u0131 bir sonraki ad\u0131m de\u011feri elde edilene kadar yeniden deneyebilir. Her ad\u0131mda runner; stepper sonucunun durumunu, tamponlar\u0131, kay\u0131tlar\u0131 vb. kontrol eder. Sim\u00fclasyon bitmeden ola\u011fand\u0131\u015f\u0131 bir olay ger\u00e7ekle\u015firse, sim\u00fclasyonu duraklatabilir ve t\u00fcm sorumlulu\u011fu bir durum koduyla wrapper'a iade edebilir. Wrapper durum kodunu inceler ve JIT'lenebilir bir \u00e7ekirdek ile ger\u00e7ekle\u015ftirilemeyecek gerekli eylemi (tamponun yeniden tahsis edilmesi gibi) ger\u00e7ekle\u015ftirir. Gerekli eylemden sonra wrapper, runner'\u0131 (durum terminal de\u011filse) yeniden ba\u015flat\u0131r.</p> <p>A\u015fa\u011f\u0131da bu \u015feman\u0131n detaylar\u0131 a\u00e7\u0131klanm\u0131\u015ft\u0131r.</p>"},{"location":"tr/guides/simulation/wrapper-and-runner/#ygndaki-stack-sorumluluklar","title":"Y\u0131\u011f\u0131ndaki (Stack) Sorumluluklar","text":"<ul> <li><code>Sim._execute_run</code>, <code>run_with_wrapper</code>'\u0131 \u00e7a\u011f\u0131rmadan \u00f6nce tohumlar\u0131 (seeds), kay\u0131t se\u00e7imlerini, durdurma a\u015famas\u0131 maskelerini ve workspace ipu\u00e7lar\u0131n\u0131 haz\u0131rlar. Bu sayede wrapper, y\u00fcr\u00fctmeyi s\u00fcrmek i\u00e7in ihtiya\u00e7 duydu\u011fu derlenmi\u015f \u00e7a\u011fr\u0131labilirleri ve varsay\u0131lanlar\u0131 g\u00f6r\u00fcr.</li> <li><code>run_with_wrapper</code> iletken g\u00f6revi g\u00f6r\u00fcr: her runner \u00e7a\u011fr\u0131s\u0131ndan \u00f6nce kay\u0131t/olay tamponlar\u0131n\u0131, workspace'leri, g\u00f6zlemci kancalar\u0131n\u0131 ve stepping parametrelerini rezerve eder. Bu, s\u0131cak (hot) runner d\u00f6ng\u00fcs\u00fcn\u00fcn yal\u0131n ve ad\u0131mlamaya odaklanm\u0131\u015f kalmas\u0131n\u0131 sa\u011flarken; kurulum, b\u00fcy\u00fcme ve son i\u015flem ad\u0131mlar\u0131n\u0131 wrapper'\u0131n y\u00f6netmesini sa\u011flar.</li> </ul>"},{"location":"tr/guides/simulation/wrapper-and-runner/#wrapper-ne-yapar","title":"Wrapper Ne Yapar?","text":"<ol> <li>Her workspace'i tahsis eder ve tohumlar. \u00c7al\u0131\u015fma zaman\u0131 ve stepper workspace'leri bir kez olu\u015fturulur ve devam etme senaryolar\u0131n\u0131 etkinle\u015ftirmek i\u00e7in iste\u011fe ba\u011fl\u0131 olarak <code>seed.workspace</code> ile tohumlanabilir.</li> <li>Kay\u0131t ve olay havuzlar\u0131n\u0131 y\u00f6netir. Wrapper, kay\u0131t dizilerini sadece se\u00e7ilen durum/yard\u0131mc\u0131 dizinler i\u00e7in dilimler, olay g\u00fcnl\u00fc\u011f\u00fc tamponlar\u0131n\u0131 tahsis eder ve runner sonu\u00e7lar\u0131 i\u00e7in imle\u00e7leri (cursors) tutar.</li> <li>Y\u00fcr\u00fctme yap\u0131land\u0131rmas\u0131n\u0131 ay\u0131r\u0131r. <code>Sim</code> ayarlar\u0131n\u0131 (dt, uyarlamal\u0131 bayraklar, durdurma a\u015famalar\u0131 vb.) runner'\u0131n ihtiya\u00e7 duydu\u011fu girdilere \u00e7evirir.</li> <li>Analiz ve g\u00f6zlemcileri ba\u011flar. G\u00f6zlemciler kay\u0131tl\u0131ysa, wrapper onlar\u0131n workspace'lerini ve izleme tamponlar\u0131n\u0131 tahsis eder.</li> <li>Runner d\u00f6ng\u00fcs\u00fcn\u00fc s\u00fcrer. Bir <code>while True</code> d\u00f6ng\u00fcs\u00fc i\u00e7inde, derlenmi\u015f runner'\u0131 tekrar tekrar \u00e7a\u011f\u0131r\u0131r, sahip oldu\u011fu tamponlar\u0131 aktar\u0131r ve runner'dan d\u00f6nen durum kodlar\u0131na yan\u0131t verir.</li> </ol>"},{"location":"tr/guides/simulation/wrapper-and-runner/#runner-abi-sozlesmesi","title":"Runner ABI S\u00f6zle\u015fmesi","text":"<p>Runner, kay\u0131tlar veya g\u00f6zlemciler hakk\u0131nda hi\u00e7bir \u015fey bilmeyen JIT dostu bir \u00e7a\u011fr\u0131labilir yap\u0131d\u0131r; sadece <code>runner_api.py</code> i\u00e7inde tan\u0131mlanan donmu\u015f ABI'ye uyar. Her \u00e7a\u011fr\u0131 \u015funlar\u0131 al\u0131r: <code>(t0, t_end, dt_init, max_steps)</code> gibi skalerler, model depolamas\u0131 (<code>y_curr</code>, <code>params</code>), workspace'ler, kay\u0131t tamponlar\u0131, olay g\u00fcnl\u00fckleri ve d\u00fc\u015f\u00fck seviyeli imle\u00e7ler. Tek bir ad\u0131mlama d\u00f6nemini (epoch) y\u00f6netir ve yaln\u0131zca iyi tan\u0131mlanm\u0131\u015f durumlar \u00fczerinden \u00e7\u0131k\u0131\u015f yapabilir.</p> <p>\u00d6nemli Durumlar: - <code>DONE</code> / <code>EARLY_EXIT</code>: Ufka ula\u015f\u0131ld\u0131\u011f\u0131n\u0131 veya bir durdurma ko\u015fulunun tetiklendi\u011fini wrapper'a bildirir. Wrapper daha sonra son durumu kopyalar ve bir <code>Results</code> nesnesi olu\u015fturur. - <code>GROW_REC</code> / <code>GROW_EVT</code>: Wrapper'a kay\u0131t veya olay tamponlar\u0131n\u0131 yeniden boyutland\u0131rmas\u0131 gerekti\u011fini bildirir. Wrapper b\u00fcy\u00fctme i\u015flemini yapar ve runner'\u0131n kald\u0131\u011f\u0131 yerden devam edebilmesi i\u00e7in imle\u00e7leri g\u00fcncelleyerek runner'a yeniden girer. - <code>STEPFAIL</code>, <code>NAN_DETECTED</code>, <code>USER_BREAK</code>: Uyar\u0131 olarak geri d\u00f6ner; wrapper yine de k\u0131smi \u00e7\u0131kt\u0131lar\u0131n incelenebilmesi i\u00e7in bir <code>Results</code> anl\u0131k g\u00f6r\u00fcnt\u00fcs\u00fc olu\u015fturur. - <code>OK</code>: Dahili kal\u0131r; wrapper, \u00e7\u0131k\u0131\u015f durumlar\u0131ndan biri g\u00f6r\u00fclene kadar runner'\u0131 yeniden \u00e7a\u011f\u0131rmaya devam eder.</p>"},{"location":"tr/guides/simulation/wrapper-and-runner/#dongu-ve-yeniden-giris-re-entry","title":"D\u00f6ng\u00fc ve Yeniden Giri\u015f (Re-entry)","text":"<p>Runner b\u00fcy\u00fcme rapor etti\u011finde wrapper: - Mevcut verileri kopyalarken uygun tamponu b\u00fcy\u00fct\u00fcr, kapasiteyi g\u00fcnceller, - Ba\u015flang\u0131\u00e7 imle\u00e7lerini geri sarar ve - Runner'\u0131n s\u00fcreklili\u011fi kaybetmeden bir sonraki par\u00e7aya devam edebilmesi i\u00e7in son i\u015flenen zaman\u0131/dt'yi kullan\u0131r.</p>"},{"location":"tr/guides/simulation/wrapper-and-runner/#veri-aks-ozeti","title":"Veri Ak\u0131\u015f\u0131 \u00d6zeti","text":"<ol> <li><code>Sim._execute_run</code>, ayarlar\u0131 paketler ve <code>run_with_wrapper</code>'a iletir.</li> <li>Wrapper tamponlar\u0131 ve analiz \u00fcst verilerini haz\u0131rlar, ard\u0131ndan derlenmi\u015f runner'\u0131 \u00e7a\u011f\u0131r\u0131r.</li> <li>Runner bir durum d\u00f6nd\u00fcr\u00fcr; wrapper bunu yorumlar, gerekiyorsa tamponlar\u0131 b\u00fcy\u00fct\u00fcr ve sim\u00fclasyon tamamlanana veya iptal edilene kadar d\u00f6ng\u00fcye girer.</li> <li>Son olarak wrapper; kay\u0131tl\u0131 diziler, olay g\u00fcnl\u00fckleri ve son durum ile bir <code>Results</code> \u00f6rne\u011fi olu\u015fturur.</li> </ol> <p>Bu ayr\u0131m, Python taraf\u0131ndaki defter tutma i\u015flemlerinden el yaz\u0131m\u0131 wrapper'\u0131n sorumlu olmas\u0131n\u0131 sa\u011flarken, derlenmi\u015f runner'\u0131n say\u0131sal olarak yo\u011fun ad\u0131mlama d\u00f6ng\u00fcs\u00fcne odaklanmas\u0131na izin verir.</p>"},{"location":"tr/reference/","title":"Referans","text":"<p>Referans b\u00f6l\u00fcm\u00fc, dynlib i\u00e7erisinde tan\u0131ml\u0131 yerle\u015fik modelleri listeler. Kaynak kodlar\u0131na sahipseniz bu referans\u0131 <code>tools/gen_model_docs.py</code> beti\u011fini \u00e7al\u0131\u015ft\u0131rarak yerel olarak \u00fcretebilirsiniz.</p>"},{"location":"tr/reference/#yerlesik-modeller","title":"Yerle\u015fik modeller","text":"<p>Yerle\u015fik modeller kaynak kodlar\u0131nda <code>src/dynlib/models/{map,ode}</code> kals\u00f6rleri i\u00e7erisinde tan\u0131ml\u0131 olup <code>builtin</code> URI etiketi ile kullan\u0131labilir. Hangi yerle\u015fik modelin hangi e\u015fitliklere sahip oldu\u011funu <code>print_equations()</code> metodu yard\u0131m\u0131yla \u00e7al\u0131\u015fma an\u0131nda da \u00f6\u011frenebilirsiniz.</p> <ul> <li>Yerle\u015fik model genel bak\u0131\u015f\u0131 \u2014 yerle\u015fik map ve ODE modellerinin TOML DSL dosyalar\u0131n\u0131 inceleyin.</li> </ul>"},{"location":"tr/reference/#dokumantasyonu-lokal-olarak-uretme","title":"D\u00f6k\u00fcmantasyonu lokal olarak \u00fcretme","text":"<ul> <li> <p>Dmk\u00fcmantasyon i\u00e7in <code>mkdocs</code> kullan\u0131lm\u0131\u015ft\u0131r. E\u011fer lokal olarak bu d\u00f6k\u00fcmasnyonu kendiniz olu\u015fturmak isterseniz a\u015fa\u011f\u0131daki ad\u0131mlar\u0131 takip edin:</p> </li> <li> <p>MkDocs ve eklentilerini kurun (sanal ortam ile):    <pre><code>pip install mkdocs mkdocs-material mkdocs-literate-nav \"mkdocstrings[python]\" mkdocs-static-i18n\n</code></pre></p> </li> <li> <p>\u0130lave Markdown eklentilerini kurun:    <pre><code>pip install pymdown-extensions\n</code></pre></p> </li> <li> <p>Proje klas\u00f6r\u00fc \u00fczerinden a\u015fa\u011f\u0131daki komutlar\u0131 \u00e7al\u0131\u015ft\u0131r\u0131n:    <pre><code>mkdocs serve\n</code></pre>    Or build them:    <pre><code>mkdocs build\n</code></pre></p> </li> <li> <p>Otomatik olarak \u00fcretilen d\u00f6k\u00fcmantasyonu \u00fcretmek i\u00e7in a\u015fa\u011f\u0131daki komutu \u00e7al\u0131\u015ft\u0131r\u0131n:    <pre><code>python tools/gen_model_docs.py\n</code></pre></p> </li> </ul> <p>\u00dcretilecek olan d\u00f6k\u00fcmantasyon <code>site/</code> klas\u00f6r\u00fc i\u00e7inde olacakt\u0131r.</p>"},{"location":"tr/reference/models/","title":"Yerle\u015fik model k\u00fct\u00fcphanesi","text":"<ul> <li>Harita modelleri</li> <li>ODE modelleri</li> </ul>"},{"location":"tr/reference/models/map/","title":"Harita modelleri","text":"<ul> <li>henon</li> <li>henon2</li> <li>ikeda</li> <li>logistic</li> <li>lozi</li> <li>sine</li> <li>standard</li> </ul>"},{"location":"tr/reference/models/map/henon/","title":"<code>henon.toml</code>","text":"<p>Kaynak: <code>src/dynlib/models/map/henon.toml</code> <pre><code>[model]\ntype = \"map\"\nname = \"Henon Map\"\ndtype = \"float64\"\n\n[states]\nx = 0.0\ny = 0.0\n\n[params]\na = 1.4\nb = 0.3\n\n[equations.rhs]\nx = \"1.0 - a * x**2 + y\"\ny = \"b * x\"\n\n[equations.jacobian]\nexpr = [\n    [\"-2.0 * a * x\", \"1.0\"],\n    [\"b\", \"0.0\"]\n]\n</code></pre></p>"},{"location":"tr/reference/models/map/henon2/","title":"<code>henon2.toml</code>","text":"<p>Kaynak: <code>src/dynlib/models/map/henon2.toml</code> <pre><code># Henon map version used in Kathleen Alligood's book\n[model]\ntype = \"map\"\nname = \"Henon Map 2\"\ndtype = \"float64\"\n\n[states]\nx = 0.0\ny = 0.0\n\n[params]\na = 1.4\nb = 0.3\n\n[equations.rhs]\nx = \"a - x**2 + b*y\"\ny = \"x\"\n\n[equations.inverse.rhs]\nx = \"y\"\ny = \"(x - a + y**2) / b\"\n\n[equations.jacobian]\nexpr = [\n    [\"-2.0 * x\", \"b\"],\n    [\"1.0\", \"0.0\"]\n]\n</code></pre></p>"},{"location":"tr/reference/models/map/ikeda/","title":"<code>ikeda.toml</code>","text":"<p>Kaynak: <code>src/dynlib/models/map/ikeda.toml</code> <pre><code>[model]\ntype = \"map\"\nname = \"Ikeda Map\"\ndtype = \"float64\"\n\n[states]\nx = 0.1\ny = 0.0\n\n[params]\nu = 0.9\na = 0.4\nb = 6.0\n\n[aux]\nr2     = \"x**2 + y**2\"\ntheta  = \"a - b / (1.0 + r2)\"\n\n[equations.rhs]\nx = \"1.0 + u * (x * cos(theta) - y * sin(theta))\"\ny = \"u * (x * sin(theta) + y * cos(theta))\"\n</code></pre></p>"},{"location":"tr/reference/models/map/logistic/","title":"<code>logistic.toml</code>","text":"<p>Kaynak: <code>src/dynlib/models/map/logistic.toml</code> <pre><code>[model]\ntype=\"map\"\nname=\"Logistic Map\"\n\n[states]\nx=0.1\n\n[params]\nr=4.0\n\n[equations.rhs]\nx = \"r * x * (1 - x)\"\n\n[equations.jacobian]\nexpr = [\n    [\"r - 2 * r * x\"]\n]\n</code></pre></p>"},{"location":"tr/reference/models/map/lozi/","title":"<code>lozi.toml</code>","text":"<p>Kaynak: <code>src/dynlib/models/map/lozi.toml</code> <pre><code>[model]\ntype = \"map\"\nname = \"Lozi Map\"\ndtype = \"float64\"\n\n[states]\nx = 0.0\ny = 0.0\n\n[params]\na = 1.7\nb = 0.5\n\n[equations.rhs]\nx = \"1.0 - a * abs(x) + b * y\"\ny = \"x\"\n</code></pre></p>"},{"location":"tr/reference/models/map/sine/","title":"<code>sine.toml</code>","text":"<p>Kaynak: <code>src/dynlib/models/map/sine.toml</code> <pre><code>[model]\ntype = \"map\"\nname = \"Sine Map\"\ndtype = \"float64\"\n\n[states]\nx = 0.5\n\n[params]\nr  = 0.9\npi = 3.141592653589793\n\n[equations.rhs]\nx = \"r * sin(pi * x)\"\n\n[equations.jacobian]\nexpr = [\n    [\"r * pi * cos(pi * x)\"]\n]\n</code></pre></p>"},{"location":"tr/reference/models/map/standard/","title":"<code>standard.toml</code>","text":"<p>Kaynak: <code>src/dynlib/models/map/standard.toml</code> <pre><code>[model]\ntype = \"map\"\nname = \"Standard Map\"\ndtype = \"float64\"\n\n[states]\np     = 0.0\ntheta = 0.1\n\n[params]\nK  = 0.971635\n\n[equations.rhs]\np     = \"((p + K * sin(theta)) + pi) % (2*pi) - pi\"\ntheta = \"(theta + p + K * sin(theta)) % (2*pi)\"\n\n[equations.jacobian]\nexpr = [\n    [\"1.0\", \"K * cos(theta)\"],\n    [\"1.0\", \"1.0 + K * cos(theta)\"]\n]\n</code></pre></p>"},{"location":"tr/reference/models/ode/","title":"ODE modelleri","text":"<ul> <li>duffing</li> <li>eto-circular</li> <li>exp-if</li> <li>expdecay</li> <li>fitzhugh-nagumo</li> <li>hodgkin-huxley</li> <li>izhikevich</li> <li>leaky-if</li> <li>lorenz</li> <li>quadratic-if</li> <li>resonate-if</li> <li>vanderpol</li> </ul>"},{"location":"tr/reference/models/ode/duffing/","title":"<code>duffing.toml</code>","text":"<p>Kaynak: <code>src/dynlib/models/ode/duffing.toml</code> <pre><code>[model]\ntype = \"ode\"\nname = \"Duffing Oscillator\"\ndtype = \"float64\"\n\n[states]\nx = 0.1\ny = 0.1\n\n[params]\ndelta = 0.2\nalpha = -1.0\nbeta  = 1.0\ngamma = 0.3\nomega = 1.2\n\n[equations.rhs]\nx = \"y\"\ny = \"-delta*y - alpha*x - beta*x**3 + gamma*cos(omega*t)\"\n\n[equations.jacobian]\nexpr = [\n    [\"0\", \"1\"],\n    [\"-alpha - 3*beta*x**2\", \"-delta\"]\n]\n</code></pre></p>"},{"location":"tr/reference/models/ode/eto-circular/","title":"<code>eto-circular.toml</code>","text":"<p>Kaynak: <code>src/dynlib/models/ode/eto-circular.toml</code> <pre><code># ETO (Energy Template Oscillator) with Circular L Curve\n# See https://doi.org/10.28948/ngumuh.1458253 (\u00d6zt\u00fcrk, 2024)\n\n[model]\ntype = \"ode\"\nname = \"ETO-Circular\"\ndtype = \"float64\"\n\n[states]\nx = 0.1\ny = 0.1\n\n[params]\n# These defaults are for limit cycle\na  = 2.0\nmu = 0.8\n\n[equations.rhs]\nx = \"-x*(x**2+y**2-a) + mu*(x+y)*(x**2+y**2-a) + a*y\"\ny = \"-y*(x**2+y**2-a) + mu*(y-x)*(x**2+y**2-a) - a*x\"\n\n[equations.jacobian]\nexpr = [\n    [\"(mu-1)*(x**2 + y**2 - a) + 2*x*((mu-1)*x + mu*y)\", \"mu*(x**2 + y**2 - a) + 2*y*((mu-1)*x + mu*y) + a\"],\n    [\"-mu*(x**2 + y**2 - a) + 2*x*(-mu*x + (mu-1)*y) - a\", \"(mu-1)*(x**2 + y**2 - a) + 2*y*(-mu*x + (mu-1)*y)\"]\n]\n</code></pre></p>"},{"location":"tr/reference/models/ode/exp-if/","title":"<code>exp-if.toml</code>","text":"<p>Kaynak: <code>src/dynlib/models/ode/exp-if.toml</code> <pre><code>[model]\ntype = \"ode\"\nname = \"Exponential Integrate-and-Fire Neuron Model\"\n\n[states]\nv = -70.0\n\n[params]\ntau = 15.0       \nv_rest = -72.0   \nv_th = -45.0     \nv_reset = -75.0 \nvt = -55.0\nD = 2.0\nI = 0.0          \n\n[equations.rhs]\nv = \"(-(v-v_rest)+D*exp((v-vt)/D)+I)/tau\"\n\n[events.reset]\ncond = \"v &gt;= v_th\"\naction = \"v = v_reset\"\n</code></pre></p>"},{"location":"tr/reference/models/ode/expdecay/","title":"<code>expdecay.toml</code>","text":"<p>Kaynak: <code>src/dynlib/models/ode/expdecay.toml</code> <pre><code># Simple exponential decay model: dx/dt = -a*x\n# Analytic solution: x(t) = x0 * exp(-a*t)\n\n[model]\ntype = \"ode\"\nname = \"Exponential Decay\"\n\n[states]\nx = 1.0\n\n[params]\na = 1.0\n\n[equations.rhs]\nx = \"-a * x\"\n\n[equations.jacobian]\nexpr = [\n    [\"-a\"]\n]\n</code></pre></p>"},{"location":"tr/reference/models/ode/fitzhugh-nagumo/","title":"<code>fitzhugh-nagumo.toml</code>","text":"<p>Kaynak: <code>src/dynlib/models/ode/fitzhugh-nagumo.toml</code> <pre><code>[model]\ntype = \"ode\"\nname = \"FitzHugh-Nagumo Neuron\"\ndtype = \"float64\"\n\n[states]\n# Resting equilibrium for I = 0 with a = b = 0.7, R = 0.1, tau = 12.5\n# (computed from the original calc_equilibrium)\nV = -1.74\nw = -1.48\n\n[params]\na   = 0.7\nb   = 0.7\nR   = 0.1\nI   = 0.0\ntau = 12.5\n\n[equations.rhs]\nV = \"V - V**3/3 - w + R*I\"\nw = \"(V + a - b*w) / tau\"\n\n[equations.jacobian]\nexpr = [\n    [\"1 - V**2\", \"-1.0\"],\n    [\"1 / tau\", \"-b / tau\"]\n]\n</code></pre></p>"},{"location":"tr/reference/models/ode/hodgkin-huxley/","title":"<code>hodgkin-huxley.toml</code>","text":"<p>Kaynak: <code>src/dynlib/models/ode/hodgkin-huxley.toml</code> <pre><code>[model]\ntype = \"ode\"\nname = \"Hodgkin-Huxley Neuron (activation-function form)\"\ndtype = \"float64\"\n\n[states]\n# Resting equilibrium for I = 0 (from old resting_ic())\nV = -65.0\nn = 0.31\nm = 0.06\nh = 0.61\n\n[params]\n# Membrane / channels\nC   = 1.0\nEK  = -77.0\nENa = 55.0\nEL  = -54.0\ngK  = 36.0\ngNa = 120.0\ngL  = 0.3\nI   = 0.0\n\n# Na activation (m)\nVmid_m  = -40.0\nk_m     = 9.0\nVmax_m  = -38.0\nsigma_m = 30.0\nCamp_m  = 0.46\nCbase_m = 0.04\n\n# Na inactivation (h)\nVmid_h  = -62.0\nk_h     = -7.0\nVmax_h  = -67.0\nsigma_h = 20.0\nCamp_h  = 7.4\nCbase_h = 1.2\n\n# K activation (n)\nVmid_n  = -53.0\nk_n     = 15.0\nVmax_n  = -79.0\nsigma_n = 50.0\nCamp_n  = 4.7\nCbase_n = 1.1\n\n[functions.boltzmann]\nargs = [\"Vmid\", \"k\", \"V\"]\nexpr = \"1.0 / (1.0 + exp((Vmid - V) / k))\"\n\n[functions.gaussian]\nargs = [\"Vmax\", \"sigma\", \"Camp\", \"Cbase\", \"V\"]\nexpr = \"Cbase + Camp * exp(-((Vmax - V)**2) / (sigma**2))\"\n\n[aux]\n# Steady-state activation / inactivation\nm_inf = \"boltzmann(Vmid_m, k_m, V)\"\nh_inf = \"boltzmann(Vmid_h, k_h, V)\"\nn_inf = \"boltzmann(Vmid_n, k_n, V)\"\n\n# Time constants\ntau_m = \"gaussian(Vmax_m, sigma_m, Camp_m, Cbase_m, V)\"\ntau_h = \"gaussian(Vmax_h, sigma_h, Camp_h, Cbase_h, V)\"\ntau_n = \"gaussian(Vmax_n, sigma_n, Camp_n, Cbase_n, V)\"\n\n[equations.rhs]\nV = \"(I - gK*n**4*(V - EK) - gNa*m**3*h*(V - ENa) - gL*(V - EL)) / C\"\nn = \"(n_inf - n) / tau_n\"\nm = \"(m_inf - m) / tau_m\"\nh = \"(h_inf - h) / tau_h\"\n</code></pre></p>"},{"location":"tr/reference/models/ode/izhikevich/","title":"<code>izhikevich.toml</code>","text":"<p>Kaynak: <code>src/dynlib/models/ode/izhikevich.toml</code> <pre><code>[model]\ntype = \"ode\"\n\n[states]\nv = -65.0\nu = -13.0\n\n[params]\na = 0.02\nb = 0.2\nc = -65.0\nd = 8.0\nI = 10.0\nv_th = 30.0\n\n[equations]\nexpr = \"\"\"\ndv = 0.04 * v * v + 5.0 * v + 140.0 - u + I\ndu = a * (b * v - u)\n\"\"\"\n\n[events.reset]\ncond = \"v &gt;= v_th\"\nphase = \"post\"\naction = \"\"\"\nv = c\nu = u + d\n\"\"\"\n\n# PRESETS:\n[presets.regular_spiking.params]\na = 0.02\nb = 0.2\nc = -65.0\nd = 8.0\n\n[presets.intrinsic_bursting.params]\na = 0.02\nb = 0.2\nc = -55.0\nd = 4.0\n\n[presets.bursting.params]\na = 0.02\nb = 0.2\nc = -50\nd = 2\n\n[presets.fast_spiking.params]\na = 0.1\nb = 0.2\nc = -65\nd = 2\n\n[presets.low_threshold.params]\na = 0.02\nb = 0.25\nc = -65\nd = 2\n\n[presets.resonator.params]\na = 0.1\nb = 0.26\nc = -65\nd = 2\n</code></pre></p>"},{"location":"tr/reference/models/ode/leaky-if/","title":"<code>leaky-if.toml</code>","text":"<p>Kaynak: <code>src/dynlib/models/ode/leaky-if.toml</code> <pre><code>[model]\ntype = \"ode\"\nname = \"Leaky Integrate-and-Fire Neuron Model\"\n\n[states]\nv = -65.0  # Membrane potential in mV\n\n[params]\ntau = 10.0       # Membrane time constant in ms\nv_rest = -65.0   # Resting potential in mV\nv_th = -50.0     # Spike threshold in mV\nv_reset = -65.0  # Reset potential after spike in mV\nI = 0.0          # Input current in nA\n\n[equations.rhs]\nv = \"(v_rest - v + I) / tau\"\n\n[events.reset]\ncond = \"v &gt;= v_th\"\naction = \"v = v_reset\"\n</code></pre></p>"},{"location":"tr/reference/models/ode/lorenz/","title":"<code>lorenz.toml</code>","text":"<p>Kaynak: <code>src/dynlib/models/ode/lorenz.toml</code> <pre><code>[model]\ntype = \"ode\"\nname = \"Lorenz System\"\n\n[states]\nx = 1.0\ny = 1.0\nz = 1.0\n\n[params]\nsigma = 10.0\nrho = 28.0\nbeta = \"8.0/3.0\"\n\n[equations.rhs]\nx = \"sigma * (y - x)\"\ny = \"x * (rho - z) - y\"\nz = \"x * y - beta * z\"\n\n[equations.jacobian]\nexpr = [\n    [\"-sigma\", \"sigma\", \"0\"],\n    [\"rho - z\", \"-1\", \"-x\"],\n    [\"y\", \"x\", \"-beta\"]\n]\n</code></pre></p>"},{"location":"tr/reference/models/ode/quadratic-if/","title":"<code>quadratic-if.toml</code>","text":"<p>Kaynak: <code>src/dynlib/models/ode/quadratic-if.toml</code> <pre><code>[model]\ntype = \"ode\"\nname = \"Quadratic Integrate-and-Fire Neuron Model\"\n\n[states]\nv = -65.0 \n\n[params]\ntau = 15.0\nv_rest = -65.0   \nv_th = 5.0     \nv_reset = -70.0  \nI = 0.0\nvt = -50.0\nR = 10.0 # for lower currents   \n\n[equations.rhs]\nv = \"((v-v_rest)*(v-vt)+R*I) / tau\"\n\n[events.reset]\ncond = \"v &gt;= v_th\"\naction = \"v = v_reset\"\n</code></pre></p>"},{"location":"tr/reference/models/ode/resonate-if/","title":"<code>resonate-if.toml</code>","text":"<p>Kaynak: <code>src/dynlib/models/ode/resonate-if.toml</code> <pre><code># Resonate integrate and fire (Izhikevich's book)\n# Threshold y=1 line reset (0,1)\n# dx/dt = b*x-w*y+I\n# dy/dt = b*y+w*x\n# Complex expression:\n# dz/dt = (b+iw)*z+I\n# If I&gt;0 y increases until y=1, then it is reset\n# Reset is considered a spike (even though there is no spike)\n# After reset orbit focus into origin\n\n[model]\ntype = \"ode\"\nname = \"Resonate Integrate-and-Fire Neuron Model\"\n\n[states]\nx = 0.0  \ny = 0.0 \n\n[params]\nI = 0.0\nb = -0.05\nw = 0.25\ny_th = 1.0\nx_reset = 0.0\ny_reset = 1.0\n\n[equations]\nexpr = \"\"\"\ndx = b*x-w*y+I\ndy = b*y+w*x\n\"\"\"\n\n[events.reset]\ncond = \"y &gt;= y_th\"\naction = \"\"\"\nx=x_reset\ny=y_reset\n\"\"\"\n</code></pre></p>"},{"location":"tr/reference/models/ode/vanderpol/","title":"<code>vanderpol.toml</code>","text":"<p>Kaynak: <code>src/dynlib/models/ode/vanderpol.toml</code> <pre><code>[model]\ntype = \"ode\"\n\n[states]\nx = 2.0\ny = 0.0\n\n[params]\nmu = 1.0\n\n[equations]\nexpr = \"\"\"\ndx = y\ndy = mu*(1-x**2)*y-x\n\"\"\"\n\n[equations.jacobian]\nexpr = [\n    [\"0.0\", \"1.0\"],\n    [\"-2.0 * mu * x * y - 1.0\", \"mu * (1 - x**2)\"]\n]\n</code></pre></p>"}]}